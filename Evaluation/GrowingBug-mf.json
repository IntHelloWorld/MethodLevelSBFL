{
  "AaltoXml-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/aalto/out/ByteXmlWriter.java",
        "start_loc": 905,
        "end_loc": 1009,
        "buggy_function": "    @Override\n    public final void writeCharacters(char[] cbuf, int offset, int len)\n        throws IOException, XMLStreamException\n    {\n        if (_surrogate != 0) {\n            outputSurrogates(_surrogate, cbuf[offset]);\n            ++offset;\n            --len;\n        }\n\n        /* Ok, let's offline (what's sure to be) slow case first:\n         * (with multi-byte chars, others may be, too).\n         */\n        int ptr = _outputPtr;\n        if ((ptr + len) > _outputBufferLen) {\n            writeSplitCharacters(cbuf, offset, len);\n            return;\n        }\n\n        len += offset; // now marks the end\n\n        main_loop:\n        while (offset < len) {\n            final int[] charTypes = _charTypes.TEXT_CHARS;\n\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= OutputCharTypes.MAIN_TABLE_SIZE) {\n                    break inner_loop;\n                }\n                if (charTypes[ch] != XmlCharTypes.CT_OK) {\n                    /* This may look weird, but profiling showed that\n                     * handling of lfs for indentation has measurable\n                     * effect; plus, that checking it here will not\n                     * slow down inner loop either\n                     */\n                    if (ch != '\\n') {\n                        break inner_loop;\n                    }\n                    ++_locRowNr;\n                }\n                _outputBuffer[ptr++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            // Ok, so what did we hit?\n            int ch = (int) cbuf[offset++];\n            if (ch < OutputCharTypes.MAIN_TABLE_SIZE) {\n                switch (charTypes[ch]) {\n                case CT_INVALID:\n                    reportInvalidChar(ch);\n                case CT_WS_CR:\n                    // !!! TBI: line count\n                    // Also, CR to be quoted?\n                    if (_config.willEscapeCR()) {\n                        _outputPtr = ptr;\n                        break;\n                    }\n                    _outputBuffer[ptr++] = (byte)ch;\n                    ++_locRowNr;\n                    continue main_loop;\n                case CT_WS_LF: // never occurs (handled in loop), but don't want to leave gaps\n                    break;\n                case CT_OUTPUT_MUST_QUOTE: // == MULTIBYTE_N value\n                case CT_LT:\n                case CT_AMP:\n                    _outputPtr = ptr;\n                    writeAsEntity(ch);\n                    break;\n                case CT_MULTIBYTE_2:\n                    // To off-line or not?\n                    _outputPtr = ptr;\n                    output2ByteChar(ch);\n                    break;\n                case CT_RBRACKET: // may need to quote as well...\n                    // Let's not quote if known not to be followed by '>'\n                    if (offset >= len || cbuf[offset] == '>') {\n                        _outputPtr = ptr;\n                        writeAsEntity(ch);\n                        break;\n                    }\n                    //  fall through\n                default:\n                    _outputBuffer[ptr++] = (byte)ch;\n                    continue main_loop;\n                }\n            } else { // beyond 2-byte encodables; 3-byte, surrogates?\n                _outputPtr = ptr;\n                offset = outputMultiByteChar(ch, cbuf, offset, len);\n            }\n\n            /* At this point, it's not guaranteed any more that we'll\n             * be able to fit all output into buffer without checks.\n             * Let's verify: in the worst case, we'll just flush\n             * whatever we had, to gain more room.\n             */\n            if ((len - offset) >= (_outputBufferLen - _outputPtr)) {\n                flushBuffer();\n            }\n            ptr = _outputPtr;\n        }\n        _outputPtr = ptr;\n    }",
        "fixed_function": "    @Override\n    public final void writeCharacters(char[] cbuf, int offset, int len)\n        throws IOException, XMLStreamException\n    {\n        if (_surrogate != 0) {\n            outputSurrogates(_surrogate, cbuf[offset]);\n            ++offset;\n            --len;\n        }\n\n        /* Ok, let's offline (what's sure to be) slow case first:\n         * (with multi-byte chars, others may be, too).\n         */\n        int ptr = _outputPtr;\n        if ((ptr + len) > _outputBufferLen) {\n            writeSplitCharacters(cbuf, offset, len);\n            return;\n        }\n\n        len += offset; // now marks the end\n\n        main_loop:\n        while (offset < len) {\n            final int[] charTypes = _charTypes.TEXT_CHARS;\n\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= OutputCharTypes.MAIN_TABLE_SIZE) {\n                    break inner_loop;\n                }\n                if (charTypes[ch] != XmlCharTypes.CT_OK) {\n                    /* This may look weird, but profiling showed that\n                     * handling of lfs for indentation has measurable\n                     * effect; plus, that checking it here will not\n                     * slow down inner loop either\n                     */\n                    if (ch != '\\n') {\n                        break inner_loop;\n                    }\n                    ++_locRowNr;\n                }\n                _outputBuffer[ptr++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            // Ok, so what did we hit?\n            int ch = (int) cbuf[offset++];\n            if (ch < OutputCharTypes.MAIN_TABLE_SIZE) {\n                switch (charTypes[ch]) {\n                case CT_INVALID:\n                    reportInvalidChar(ch);\n                case CT_WS_CR:\n                    // !!! TBI: line count\n                    // Also, CR to be quoted?\n                    if (_config.willEscapeCR()) {\n                        _outputPtr = ptr;\n                        writeAsEntity(ch);\n                        break;\n                    }\n                    _outputBuffer[ptr++] = (byte)ch;\n                    ++_locRowNr;\n                    continue main_loop;\n                case CT_WS_LF: // never occurs (handled in loop), but don't want to leave gaps\n                    break;\n                case CT_OUTPUT_MUST_QUOTE: // == MULTIBYTE_N value\n                case CT_LT:\n                case CT_AMP:\n                    _outputPtr = ptr;\n                    writeAsEntity(ch);\n                    break;\n                case CT_MULTIBYTE_2:\n                    // To off-line or not?\n                    _outputPtr = ptr;\n                    output2ByteChar(ch);\n                    break;\n                case CT_RBRACKET: // may need to quote as well...\n                    // Let's not quote if known not to be followed by '>'\n                    if (offset >= len || cbuf[offset] == '>') {\n                        _outputPtr = ptr;\n                        writeAsEntity(ch);\n                        break;\n                    }\n                    //  fall through\n                default:\n                    _outputBuffer[ptr++] = (byte)ch;\n                    continue main_loop;\n                }\n            } else { // beyond 2-byte encodables; 3-byte, surrogates?\n                _outputPtr = ptr;\n                offset = outputMultiByteChar(ch, cbuf, offset, len);\n            }\n\n            /* At this point, it's not guaranteed any more that we'll\n             * be able to fit all output into buffer without checks.\n             * Let's verify: in the worst case, we'll just flush\n             * whatever we had, to gain more room.\n             */\n            if ((len - offset) >= (_outputBufferLen - _outputPtr)) {\n                flushBuffer();\n            }\n            ptr = _outputPtr;\n        }\n        _outputPtr = ptr;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/out/StreamWriterBase.java",
        "start_loc": 1136,
        "end_loc": 1142,
        "buggy_function": "    @Override\n    public XMLStreamLocation2 getLocation()\n    {\n        return new LocationImpl(null, null, // pub/sys ids not yet known\n                                _xmlWriter.getAbsOffset(),\n                                _xmlWriter.getRow(), _xmlWriter.getColumn());\n    }",
        "fixed_function": "    @Override\n    public XMLStreamLocation2 getLocation()\n    {\n        return new LocationImpl(null, null, // pub/sys ids not yet known\n                _xmlWriter.getAbsOffset(), _xmlWriter.getRow(), _xmlWriter.getColumn());\n    }",
        "comment": "/*\n    /**********************************************************************\n    /* Stax2, other accessors, mutators\n    /**********************************************************************\n     */"
      }
    ],
    "trigger_test": {
      "stax2.wstream.TestEscaping::testLinefeedQuoting": {
        "path": "stax2/wstream/TestEscaping.java",
        "function_name": "testLinefeedQuoting",
        "src": "public void testLinefeedQuoting() throws Exception\n    {\n        final String EXP = \"<root>a\\nb&#xd;c</root>\";\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        XMLStreamWriter2 w = getNonRepairingWriter(bos, \"US-ASCII\", true);\n        w.writeStartElement(\"root\");\n        w.writeCharacters(\"a\\nb\\rc\");\n        w.writeEndElement();\n        w.writeEndDocument();\n        w.close();\n\n        assertEquals(EXP, bos.toString(\"UTF-8\"));\n\n        StringWriter strw = new StringWriter();\n        w = getNonRepairingWriter(strw, \"US-ASCII\", true);\n        w.writeStartElement(\"root\");\n        w.writeCharacters(\"a\\nb\\rc\");\n        w.writeEndElement();\n        w.writeEndDocument();\n        w.close();\n\n        assertEquals(EXP, strw.toString());\n    }",
        "error_msg": "stax2.wstream.TestEscaping::testLinefeedQuoting --> junit.framework.ComparisonFailure: expected:<<root>a",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<<root>a"
      }
    }
  },
  "AaltoXml-6": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java",
        "start_loc": 2341,
        "end_loc": 2402,
        "buggy_function": "    protected int handleEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer[ptr++];\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer[ptr] == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer[ptr++];\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_p\n                            && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2;\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_o\n                            && _inputBuffer[ptr+1] == BYTE_s\n                            && _inputBuffer[ptr+2] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer[ptr] == BYTE_u\n                        && _inputBuffer[ptr+1] == BYTE_o\n                        && _inputBuffer[ptr+2] == BYTE_t\n                        && _inputBuffer[ptr+3] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_APOS;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "fixed_function": "    protected int handleEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer[ptr++];\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer[ptr] == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer[ptr++];\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_p\n                            && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2;\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_o\n                            && _inputBuffer[ptr+1] == BYTE_s\n                            && _inputBuffer[ptr+2] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer[ptr] == BYTE_u\n                        && _inputBuffer[ptr+1] == BYTE_o\n                        && _inputBuffer[ptr+2] == BYTE_t\n                        && _inputBuffer[ptr+3] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_QUOTE;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "comment": "/**\n     * Method called to handle entity encountered inside\n     * CHARACTERS segment, when trying to complete a non-coalescing text segment.\n     *<p>\n     * NOTE: unlike with generic parsing of named entities, where trailing semicolon\n     * needs to be left in place, here we should just process it right away.\n     * \n     * @return Expanded (character) entity, if positive number; 0 if incomplete.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java",
        "start_loc": 2897,
        "end_loc": 2958,
        "buggy_function": "    private int skipEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer[ptr++];\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer[ptr] == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer[ptr++];\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_p\n                            && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2; // NOTE: do skip semicolon as well\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_o\n                            && _inputBuffer[ptr+1] == BYTE_s\n                            && _inputBuffer[ptr+2] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer[ptr] == BYTE_u\n                        && _inputBuffer[ptr+1] == BYTE_o\n                        && _inputBuffer[ptr+2] == BYTE_t\n                        && _inputBuffer[ptr+3] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_APOS;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "fixed_function": "    private int skipEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer[ptr++];\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer[ptr] == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer[ptr++];\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_p\n                            && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2; // NOTE: do skip semicolon as well\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer[ptr] == BYTE_o\n                            && _inputBuffer[ptr+1] == BYTE_s\n                            && _inputBuffer[ptr+2] == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer[ptr] == BYTE_t\n                        && _inputBuffer[ptr+1] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer[ptr] == BYTE_u\n                        && _inputBuffer[ptr+1] == BYTE_o\n                        && _inputBuffer[ptr+2] == BYTE_t\n                        && _inputBuffer[ptr+3] == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_QUOTE;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "comment": "/**\n     * Method called to handle entity encountered inside\n     * CHARACTERS segment, when trying to complete a non-coalescing text segment.\n     * \n     * @return Expanded (character) entity, if positive number; 0 if incomplete.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java",
        "start_loc": 2346,
        "end_loc": 2407,
        "buggy_function": "    protected int handleEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer.get(ptr++);\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer.get(ptr) == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer.get(ptr++);\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_p\n                            && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2;\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_o\n                            && _inputBuffer.get(ptr+1) == BYTE_s\n                            && _inputBuffer.get(ptr+2) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer.get(ptr)== BYTE_u\n                        && _inputBuffer.get(ptr+1) == BYTE_o\n                        && _inputBuffer.get(ptr+2) == BYTE_t\n                        && _inputBuffer.get(ptr+3) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_APOS;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "fixed_function": "    protected int handleEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer.get(ptr++);\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer.get(ptr) == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer.get(ptr++);\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_p\n                            && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2;\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_o\n                            && _inputBuffer.get(ptr+1) == BYTE_s\n                            && _inputBuffer.get(ptr+2) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer.get(ptr)== BYTE_u\n                        && _inputBuffer.get(ptr+1) == BYTE_o\n                        && _inputBuffer.get(ptr+2) == BYTE_t\n                        && _inputBuffer.get(ptr+3) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_QUOTE;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "comment": "/**\n     * Method called to handle entity encountered inside\n     * CHARACTERS segment, when trying to complete a non-coalescing text segment.\n     *<p>\n     * NOTE: unlike with generic parsing of named entities, where trailing semicolon\n     * needs to be left in place, here we should just process it right away.\n     * \n     * @return Expanded (character) entity, if positive number; 0 if incomplete.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java",
        "start_loc": 2902,
        "end_loc": 2963,
        "buggy_function": "    private int skipEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer.get(ptr++);\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer.get(ptr) == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer.get(ptr++);\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_p\n                            && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2; // NOTE: do skip semicolon as well\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_o\n                            && _inputBuffer.get(ptr+1) == BYTE_s\n                            && _inputBuffer.get(ptr+2) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer.get(ptr) == BYTE_u\n                        && _inputBuffer.get(ptr+1) == BYTE_o\n                        && _inputBuffer.get(ptr+2) == BYTE_t\n                        && _inputBuffer.get(ptr+3) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_APOS;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "fixed_function": "    private int skipEntityInCharacters() throws XMLStreamException\n    {\n        /* Thing that simplifies processing here is that handling\n         * is pretty much optional: if there isn't enough data, we\n         * just return 0 and are done with it.\n         * \n         * Also: we need at least 3 more characters for any character entity\n         */\n        int ptr = _inputPtr;\n        if ((ptr  + 3) <= _inputEnd) {\n            byte b = _inputBuffer.get(ptr++);\n            if (b == BYTE_HASH) { // numeric character entity\n                if (_inputBuffer.get(ptr) == BYTE_x) {\n                    return handleHexEntityInCharacters(ptr+1);\n                }\n                return handleDecEntityInCharacters(ptr);\n            }\n            // general entity; maybe one of pre-defined ones\n            if (b == BYTE_a) { // amp or apos?\n                b = _inputBuffer.get(ptr++);\n                if (b == BYTE_m) {\n                    if ((ptr + 1) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_p\n                            && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 2; // NOTE: do skip semicolon as well\n                        return INT_AMP;\n                    }\n                } else if (b == BYTE_p) {\n                    if ((ptr + 2) < _inputEnd\n                            && _inputBuffer.get(ptr) == BYTE_o\n                            && _inputBuffer.get(ptr+1) == BYTE_s\n                            && _inputBuffer.get(ptr+2) == BYTE_SEMICOLON) {\n                        _inputPtr = ptr + 3;\n                        return INT_APOS;\n                    }\n                }\n            } else if (b == BYTE_g) { // gt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_GT;\n                }\n            } else if (b == BYTE_l) { // lt?\n                if (_inputBuffer.get(ptr) == BYTE_t\n                        && _inputBuffer.get(ptr+1) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 2;\n                    return INT_LT;\n                }\n            } else if (b == BYTE_q) { // quot?\n                if ((ptr + 3) < _inputEnd\n                        && _inputBuffer.get(ptr) == BYTE_u\n                        && _inputBuffer.get(ptr+1) == BYTE_o\n                        && _inputBuffer.get(ptr+2) == BYTE_t\n                        && _inputBuffer.get(ptr+3) == BYTE_SEMICOLON) {\n                    _inputPtr = ptr + 4;\n                    return INT_QUOTE;\n                }\n            }\n        }\n        // couldn't handle:\n        return 0;\n    }",
        "comment": "/**\n     * Method called to handle entity encountered inside\n     * CHARACTERS segment, when trying to complete a non-coalescing text segment.\n     * \n     * @return Expanded (character) entity, if positive number; 0 if incomplete.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteScanner.java",
        "start_loc": 371,
        "end_loc": 378,
        "buggy_function": "    @Override\n    protected void _releaseBuffers()\n    {\n        super._releaseBuffers();\n        if (_symbols.maybeDirty()) {\n            _config.updateBBSymbols(_symbols);\n        }\n    }",
        "fixed_function": "    @Override\n    protected void _releaseBuffers()\n    {\n        super._releaseBuffers();\n        if ((_symbols != null) && _symbols.maybeDirty()) {\n            _config.updateBBSymbols(_symbols);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "async.TestCharactersParsing::testTextWithEntities": {
        "path": "async/TestCharactersParsing.java",
        "function_name": "testTextWithEntities",
        "src": "public void testTextWithEntities() throws Exception\n    {\n        // let's try with different chunking, addition (or not) of space\n        for (int spaces = 0; spaces < 3; ++spaces) {\n            _testTextWithEntities(1, true, spaces(spaces));\n            _testTextWithEntities(2, true, spaces(spaces));\n            _testTextWithEntities(3, true, spaces(spaces));\n            _testTextWithEntities(5, true, spaces(spaces));\n            _testTextWithEntities(11, true, spaces(spaces));\n            _testTextWithEntities(999, true, spaces(spaces));\n        }\n    }",
        "error_msg": "async.TestCharactersParsing::testTextWithEntities --> junit.framework.ComparisonFailure: expected:<a[]b",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<a[]b"
      }
    }
  },
  "AaltoXml-8": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java",
        "start_loc": 954,
        "end_loc": 1092,
        "buggy_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        // Had fully complete event? Need to reset state etc:\n        if (_currToken != EVENT_INCOMPLETE) {\n            // First: keep track of where event started\n            setStartLocation();\n            \n            // yet one more special case: after START_DOCUMENT need to check things...\n            if (_currToken == START_DOCUMENT) {\n                _currToken = EVENT_INCOMPLETE;\n                if (_tokenName != null) {\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_PI_AFTER_TARGET;\n                    checkPITargetName(_tokenName);\n                    return handlePI();\n                }\n            } else {\n                _currToken = _nextEvent = EVENT_INCOMPLETE;\n                _state = STATE_DEFAULT;\n            }\n        }\n        // Ok, do we know which event it will be?\n        if (_nextEvent == EVENT_INCOMPLETE) { // nope\n            // The very first thing: XML declaration handling\n            if (_state == STATE_PROLOG_INITIAL) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                // Ok: see if we have what looks like XML declaration; process:\n                if (_pendingInput != 0) { // already parsing (potential) XML declaration\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) { // not yet known; bail out\n                        return EVENT_INCOMPLETE;\n                    }\n                    // no real XML declaration; syntesize one:\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                if (_inputBuffer[_inputPtr] == BYTE_LT) { // first byte, see if it could be XML declaration\n                    ++_inputPtr;\n                    _pendingInput = PENDING_STATE_XMLDECL_LT;\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) {\n                        return EVENT_INCOMPLETE;\n                    }\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                // can't be XML declaration\n                _state = STATE_DEFAULT;\n                _currToken = START_DOCUMENT;\n                return START_DOCUMENT;\n            }\n\n            // First: did we have a lone CR at the end of the buffer?\n            if (_pendingInput != 0) { // yup\n                if (!handlePartialCR()) {\n                    return _currToken;\n                }\n            }\n            while (_state == STATE_DEFAULT) {\n                if (_inputPtr >= _inputEnd) { // no more input available\n                    if (_endOfInput) { // for good? That may be fine\n                        setStartLocation();\n                        return TOKEN_EOI;\n                    }\n                    return _currToken;\n                }\n                byte b = _inputBuffer[_inputPtr++];\n\n                /* Really should get white space or '<'... anything else is\n                 * pretty much an error.\n                 */\n                if (b == BYTE_LT) { // root element, comment, proc instr?\n                    _state = STATE_PROLOG_SEEN_LT;\n                    break;\n                }\n                if (b == BYTE_SPACE || b == BYTE_CR\n                    || b == BYTE_LF || b == BYTE_TAB) {\n                    // Prolog/epilog ws is to be skipped, not part of Infoset\n                    if (!asyncSkipSpace()) { // ran out of input?\n                        if (_endOfInput) { // for good? That may be fine\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                        return _currToken;\n                    }\n                } else {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), null);\n                }\n            }\n            if (_state == STATE_PROLOG_SEEN_LT) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                byte b = _inputBuffer[_inputPtr++];\n                if (b == BYTE_EXCL) { // comment or DOCTYPE declaration?\n                    _state = STATE_PROLOG_DECL;\n                    return handlePrologDeclStart(isProlog);\n                }\n                if (b == BYTE_QMARK) { // PI\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_DEFAULT;\n                    return handlePI();\n                }\n                if (!isProlog || (b == BYTE_SLASH)) {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), \" (unbalanced start/end tags?)\");\n                }\n                return handleStartElementStart(b);\n            }\n            if (_state == STATE_PROLOG_DECL) {\n                return handlePrologDeclStart(isProlog);\n            }\n            // should never have anything else...\n            return throwInternal();\n        }\n        \n        // At this point, we do know the event type\n        switch (_nextEvent) {\n        case START_ELEMENT:\n            return handleStartElement();\n        case START_DOCUMENT:\n            return handleXmlDeclaration();\n        case PROCESSING_INSTRUCTION:\n            return handlePI();\n        case COMMENT:\n            return handleComment();\n        case DTD:\n            return handleDTD();\n        }\n        return throwInternal(); // should never get here\n    }",
        "fixed_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        // Had fully complete event? Need to reset state etc:\n        if (_currToken != EVENT_INCOMPLETE) {\n            // First: keep track of where event started\n            setStartLocation();\n            \n            // yet one more special case: after START_DOCUMENT need to check things...\n            if (_currToken == START_DOCUMENT) {\n                _currToken = EVENT_INCOMPLETE;\n                if (_tokenName != null) {\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_PI_AFTER_TARGET;\n                    checkPITargetName(_tokenName);\n                    return handlePI();\n                }\n            } else {\n                _currToken = _nextEvent = EVENT_INCOMPLETE;\n                _state = STATE_DEFAULT;\n            }\n        }\n        // Ok, do we know which event it will be?\n        if (_nextEvent == EVENT_INCOMPLETE) { // nope\n            // The very first thing: XML declaration handling\n            if (_state == STATE_PROLOG_INITIAL) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                // Ok: see if we have what looks like XML declaration; process:\n                if (_pendingInput != 0) { // already parsing (potential) XML declaration\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) { // not yet known; bail out\n                        return EVENT_INCOMPLETE;\n                    }\n                    // no real XML declaration; syntesize one:\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                if (_inputBuffer[_inputPtr] == BYTE_LT) { // first byte, see if it could be XML declaration\n                    ++_inputPtr;\n                    _pendingInput = PENDING_STATE_XMLDECL_LT;\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) {\n                        return EVENT_INCOMPLETE;\n                    }\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                // can't be XML declaration\n                _state = STATE_DEFAULT;\n                _currToken = START_DOCUMENT;\n                return START_DOCUMENT;\n            }\n\n            // First: did we have a lone CR at the end of the buffer?\n            if (_pendingInput != 0) { // yup\n                if (!handlePartialCR()) {\n                    return _currToken;\n                }\n            }\n            while (_state == STATE_DEFAULT) {\n                if (_inputPtr >= _inputEnd) { // no more input available\n                    if (_endOfInput) { // for good? That may be fine\n                        setStartLocation();\n                        return TOKEN_EOI;\n                    }\n                    return _currToken;\n                }\n                byte b = _inputBuffer[_inputPtr++];\n\n                /* Really should get white space or '<'... anything else is\n                 * pretty much an error.\n                 */\n                if (b == BYTE_LT) { // root element, comment, proc instr?\n                    _state = STATE_PROLOG_SEEN_LT;\n                    break;\n                }\n                if (b == BYTE_SPACE || b == BYTE_CR\n                    || b == BYTE_LF || b == BYTE_TAB) {\n                    // Prolog/epilog ws is to be skipped, not part of Infoset\n                    if (!asyncSkipSpace()) { // ran out of input?\n                        if (_endOfInput) { // for good? That may be fine\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                        return _currToken;\n                    }\n                } else {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), null);\n                }\n            }\n            if (_state == STATE_PROLOG_SEEN_LT) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                byte b = _inputBuffer[_inputPtr++];\n                if (b == BYTE_EXCL) { // comment or DOCTYPE declaration?\n                    _state = STATE_PROLOG_DECL;\n                    return handlePrologDeclStart(isProlog);\n                }\n                if (b == BYTE_QMARK) { // PI\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_DEFAULT;\n                    return handlePI();\n                }\n                if (!isProlog || (b == BYTE_SLASH)) {\n                    reportPrologUnexpElement(isProlog, b);\n                }\n                return handleStartElementStart(b);\n            }\n            if (_state == STATE_PROLOG_DECL) {\n                return handlePrologDeclStart(isProlog);\n            }\n            // should never have anything else...\n            return throwInternal();\n        }\n        \n        // At this point, we do know the event type\n        switch (_nextEvent) {\n        case START_ELEMENT:\n            return handleStartElement();\n        case START_DOCUMENT:\n            return handleXmlDeclaration();\n        case PROCESSING_INSTRUCTION:\n            return handlePI();\n        case COMMENT:\n            return handleComment();\n        case DTD:\n            return handleDTD();\n        }\n        return throwInternal(); // should never get here\n    }",
        "comment": "/*\n    /**********************************************************************\n    /* Implementation of parsing API\n    /**********************************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java",
        "start_loc": 962,
        "end_loc": 1100,
        "buggy_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        // Had fully complete event? Need to reset state etc:\n        if (_currToken != EVENT_INCOMPLETE) {\n            // First: keep track of where event started\n            setStartLocation();\n            \n            // yet one more special case: after START_DOCUMENT need to check things...\n            if (_currToken == START_DOCUMENT) {\n                _currToken = EVENT_INCOMPLETE;\n                if (_tokenName != null) {\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_PI_AFTER_TARGET;\n                    checkPITargetName(_tokenName);\n                    return handlePI();\n                }\n            } else {\n                _currToken = _nextEvent = EVENT_INCOMPLETE;\n                _state = STATE_DEFAULT;\n            }\n        }\n        // Ok, do we know which event it will be?\n        if (_nextEvent == EVENT_INCOMPLETE) { // nope\n            // The very first thing: XML declaration handling\n            if (_state == STATE_PROLOG_INITIAL) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                // Ok: see if we have what looks like XML declaration; process:\n                if (_pendingInput != 0) { // already parsing (potential) XML declaration\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) { // not yet known; bail out\n                        return EVENT_INCOMPLETE;\n                    }\n                    // no real XML declaration; syntesize one:\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                if (_inputBuffer.get(_inputPtr) == BYTE_LT) { // first byte, see if it could be XML declaration\n                    ++_inputPtr;\n                    _pendingInput = PENDING_STATE_XMLDECL_LT;\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) {\n                        return EVENT_INCOMPLETE;\n                    }\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                // can't be XML declaration\n                _state = STATE_DEFAULT;\n                _currToken = START_DOCUMENT;\n                return START_DOCUMENT;\n            }\n\n            // First: did we have a lone CR at the end of the buffer?\n            if (_pendingInput != 0) { // yup\n                if (!handlePartialCR()) {\n                    return _currToken;\n                }\n            }\n            while (_state == STATE_DEFAULT) {\n                if (_inputPtr >= _inputEnd) { // no more input available\n                    if (_endOfInput) { // for good? That may be fine\n                        setStartLocation();\n                        return TOKEN_EOI;\n                    }\n                    return _currToken;\n                }\n                byte b = _inputBuffer.get(_inputPtr++);\n\n                /* Really should get white space or '<'... anything else is\n                 * pretty much an error.\n                 */\n                if (b == BYTE_LT) { // root element, comment, proc instr?\n                    _state = STATE_PROLOG_SEEN_LT;\n                    break;\n                }\n                if (b == BYTE_SPACE || b == BYTE_CR\n                    || b == BYTE_LF || b == BYTE_TAB) {\n                    // Prolog/epilog ws is to be skipped, not part of Infoset\n                    if (!asyncSkipSpace()) { // ran out of input?\n                        if (_endOfInput) { // for good? That may be fine\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                        return _currToken;\n                    }\n                } else {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), null);\n                }\n            }\n            if (_state == STATE_PROLOG_SEEN_LT) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                byte b = _inputBuffer.get(_inputPtr++);\n                if (b == BYTE_EXCL) { // comment or DOCTYPE declaration?\n                    _state = STATE_PROLOG_DECL;\n                    return handlePrologDeclStart(isProlog);\n                }\n                if (b == BYTE_QMARK) { // PI\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_DEFAULT;\n                    return handlePI();\n                }\n                if (b == BYTE_SLASH || !isProlog) {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), \" (unbalanced start/end tags?)\");\n                }\n                return handleStartElementStart(b);\n            }\n            if (_state == STATE_PROLOG_DECL) {\n                return handlePrologDeclStart(isProlog);\n            }\n            // should never have anything else...\n            return throwInternal();\n        }\n        \n        // At this point, we do know the event type\n        switch (_nextEvent) {\n        case START_ELEMENT:\n            return handleStartElement();\n        case START_DOCUMENT:\n            return handleXmlDeclaration();\n        case PROCESSING_INSTRUCTION:\n            return handlePI();\n        case COMMENT:\n            return handleComment();\n        case DTD:\n            return handleDTD();\n        }\n        return throwInternal(); // should never get here\n    }",
        "fixed_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        // Had fully complete event? Need to reset state etc:\n        if (_currToken != EVENT_INCOMPLETE) {\n            // First: keep track of where event started\n            setStartLocation();\n            \n            // yet one more special case: after START_DOCUMENT need to check things...\n            if (_currToken == START_DOCUMENT) {\n                _currToken = EVENT_INCOMPLETE;\n                if (_tokenName != null) {\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_PI_AFTER_TARGET;\n                    checkPITargetName(_tokenName);\n                    return handlePI();\n                }\n            } else {\n                _currToken = _nextEvent = EVENT_INCOMPLETE;\n                _state = STATE_DEFAULT;\n            }\n        }\n        // Ok, do we know which event it will be?\n        if (_nextEvent == EVENT_INCOMPLETE) { // nope\n            // The very first thing: XML declaration handling\n            if (_state == STATE_PROLOG_INITIAL) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                // Ok: see if we have what looks like XML declaration; process:\n                if (_pendingInput != 0) { // already parsing (potential) XML declaration\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) { // not yet known; bail out\n                        return EVENT_INCOMPLETE;\n                    }\n                    // no real XML declaration; syntesize one:\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                if (_inputBuffer.get(_inputPtr) == BYTE_LT) { // first byte, see if it could be XML declaration\n                    ++_inputPtr;\n                    _pendingInput = PENDING_STATE_XMLDECL_LT;\n                    Boolean b = startXmlDeclaration(); // is or may be XML declaration, so:\n                    if (b == null) {\n                        return EVENT_INCOMPLETE;\n                    }\n                    if (b == Boolean.FALSE) {\n                        _currToken = START_DOCUMENT;\n                        return START_DOCUMENT;\n                    }\n                    return handleXmlDeclaration();\n                }\n                // can't be XML declaration\n                _state = STATE_DEFAULT;\n                _currToken = START_DOCUMENT;\n                return START_DOCUMENT;\n            }\n\n            // First: did we have a lone CR at the end of the buffer?\n            if (_pendingInput != 0) { // yup\n                if (!handlePartialCR()) {\n                    return _currToken;\n                }\n            }\n            while (_state == STATE_DEFAULT) {\n                if (_inputPtr >= _inputEnd) { // no more input available\n                    if (_endOfInput) { // for good? That may be fine\n                        setStartLocation();\n                        return TOKEN_EOI;\n                    }\n                    return _currToken;\n                }\n                byte b = _inputBuffer.get(_inputPtr++);\n\n                /* Really should get white space or '<'... anything else is\n                 * pretty much an error.\n                 */\n                if (b == BYTE_LT) { // root element, comment, proc instr?\n                    _state = STATE_PROLOG_SEEN_LT;\n                    break;\n                }\n                if (b == BYTE_SPACE || b == BYTE_CR\n                    || b == BYTE_LF || b == BYTE_TAB) {\n                    // Prolog/epilog ws is to be skipped, not part of Infoset\n                    if (!asyncSkipSpace()) { // ran out of input?\n                        if (_endOfInput) { // for good? That may be fine\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                        return _currToken;\n                    }\n                } else {\n                    reportPrologUnexpChar(isProlog, decodeCharForError(b), null);\n                }\n            }\n            if (_state == STATE_PROLOG_SEEN_LT) {\n                if (_inputPtr >= _inputEnd) {\n                    return _currToken;\n                }\n                byte b = _inputBuffer.get(_inputPtr++);\n                if (b == BYTE_EXCL) { // comment or DOCTYPE declaration?\n                    _state = STATE_PROLOG_DECL;\n                    return handlePrologDeclStart(isProlog);\n                }\n                if (b == BYTE_QMARK) { // PI\n                    _nextEvent = PROCESSING_INSTRUCTION;\n                    _state = STATE_DEFAULT;\n                    return handlePI();\n                }\n                if (b == BYTE_SLASH || !isProlog) {\n                    reportPrologUnexpElement(isProlog, b);\n                }\n                return handleStartElementStart(b);\n            }\n            if (_state == STATE_PROLOG_DECL) {\n                return handlePrologDeclStart(isProlog);\n            }\n            // should never have anything else...\n            return throwInternal();\n        }\n        \n        // At this point, we do know the event type\n        switch (_nextEvent) {\n        case START_ELEMENT:\n            return handleStartElement();\n        case START_DOCUMENT:\n            return handleXmlDeclaration();\n        case PROCESSING_INSTRUCTION:\n            return handlePI();\n        case COMMENT:\n            return handleComment();\n        case DTD:\n            return handleDTD();\n        }\n        return throwInternal(); // should never get here\n    }",
        "comment": "/*\n    /**********************************************************************\n    /* Implementation of parsing API\n    /**********************************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/in/ReaderScanner.java",
        "start_loc": 173,
        "end_loc": 237,
        "buggy_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        if (_tokenIncomplete) { // left-overs from last thingy?\n            skipToken();\n        }\n\n        // First: keep track of where event started\n        setStartLocation();\n\n        // Ok: we should get a WS or '<'. So, let's skip through WS\n        while (true) {\n            // Any more data? Just need a single byte\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    setStartLocation();\n                    return TOKEN_EOI;\n                }\n            }\n            int c = _inputBuffer[_inputPtr++] & 0xFF;\n\n            // Really should get white space or '<'...\n            if (c == '<') {\n                break;\n            }\n            if (c != ' ') {\n                if (c == '\\n') {\n                    markLF();\n                } else if (c == '\\r') {\n                    if (_inputPtr >= _inputEnd) {\n                        if (!loadMore()) {\n                            markLF();\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                    }\n                    if (_inputBuffer[_inputPtr] == '\\n') {\n                        ++_inputPtr;\n                    }\n                    markLF();\n                } else if (c != '\\t') {\n                    reportPrologUnexpChar(isProlog, c, null);\n                }\n            }\n        }\n\n        // Ok, got LT:\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed(COMMENT);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '!') { // comment/DOCTYPE? (CDATA not legal)\n            return handlePrologDeclStart(isProlog);\n        }\n        if (c == '?') {\n            return handlePIStart();\n        }\n        /* End tag not allowed if no open tree; and only one root\n         * element (one root-level start tag)\n         */\n        if (c == '/' || !isProlog) {\n            reportPrologUnexpChar(isProlog, c, \" (unbalanced start/end tags?)\");\n        }\n        return handleStartElement(c);\n    }",
        "fixed_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        if (_tokenIncomplete) { // left-overs from last thingy?\n            skipToken();\n        }\n\n        // First: keep track of where event started\n        setStartLocation();\n\n        // Ok: we should get a WS or '<'. So, let's skip through WS\n        while (true) {\n            // Any more data? Just need a single byte\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    setStartLocation();\n                    return TOKEN_EOI;\n                }\n            }\n            int c = _inputBuffer[_inputPtr++] & 0xFF;\n\n            // Really should get white space or '<'...\n            if (c == '<') {\n                break;\n            }\n            if (c != ' ') {\n                if (c == '\\n') {\n                    markLF();\n                } else if (c == '\\r') {\n                    if (_inputPtr >= _inputEnd) {\n                        if (!loadMore()) {\n                            markLF();\n                            setStartLocation();\n                            return TOKEN_EOI;\n                        }\n                    }\n                    if (_inputBuffer[_inputPtr] == '\\n') {\n                        ++_inputPtr;\n                    }\n                    markLF();\n                } else if (c != '\\t') {\n                    reportPrologUnexpChar(isProlog, c, null);\n                }\n            }\n        }\n\n        // Ok, got LT:\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed(COMMENT);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '!') { // comment/DOCTYPE? (CDATA not legal)\n            return handlePrologDeclStart(isProlog);\n        }\n        if (c == '?') {\n            return handlePIStart();\n        }\n        /* End tag not allowed if no open tree; and only one root\n         * element (one root-level start tag)\n         */\n        if (c == '/' || !isProlog) {\n            reportPrologUnexpElement(isProlog, c);\n        }\n        return handleStartElement(c);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/aalto/in/StreamScanner.java",
        "start_loc": 116,
        "end_loc": 183,
        "buggy_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        if (_tokenIncomplete) { // left-overs from last thingy?\n            skipToken();\n        }\n\n        // First: keep track of where event started\n        setStartLocation();        \n        // Ok: we should get a WS or '<'. So, let's skip through WS\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    setStartLocation();        \n                    return TOKEN_EOI;\n                }\n            }\n            int c = _inputBuffer[_inputPtr++] & 0xFF;\n\n            // Really should get white space or '<'...\n            if (c == INT_LT) {\n                break;\n            }\n            /* 26-Mar-2008, tatus: White space in prolog/epilog is\n             *   not to be reported at all (by default at least), as\n             *   it is not part of XML Infoset content. So let's\n             *   just actively skip it here\n             */\n            if (c != INT_SPACE) {\n                if (c == INT_LF) {\n                    markLF();\n                } else if (c == INT_CR) {\n                    if (_inputPtr >= _inputEnd) {\n                        if (!loadMore()) {\n                            markLF();\n                            setStartLocation();        \n                            return TOKEN_EOI;\n                        }\n                    }\n                    if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                        ++_inputPtr;\n                    }\n                    markLF();\n                } else if (c != INT_TAB) {\n                    reportPrologUnexpChar(isProlog, decodeCharForError((byte)c), null);\n                }\n            }\n        }\n\n        // Ok, got LT:\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed(COMMENT); // not necessarily a comment of course\n        }\n        byte b = _inputBuffer[_inputPtr++];\n        if (b == BYTE_EXCL) { // comment/DOCTYPE? (CDATA not legal)\n            return handlePrologDeclStart(isProlog);\n        }\n        if (b == BYTE_QMARK) {\n            return handlePIStart();\n        }\n        /* End tag not allowed if no open tree; and only one root\n         * element (one root-level start tag)\n         */\n        if (b == BYTE_SLASH || !isProlog) {\n            reportPrologUnexpChar(isProlog, decodeCharForError(b), \" (unbalanced start/end tags?)\");\n        }\n        return handleStartElement(b);\n    }",
        "fixed_function": "    @Override\n    public final int nextFromProlog(boolean isProlog) throws XMLStreamException\n    {\n        if (_tokenIncomplete) { // left-overs from last thingy?\n            skipToken();\n        }\n\n        // First: keep track of where event started\n        setStartLocation();        \n        // Ok: we should get a WS or '<'. So, let's skip through WS\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    setStartLocation();        \n                    return TOKEN_EOI;\n                }\n            }\n            int c = _inputBuffer[_inputPtr++] & 0xFF;\n\n            // Really should get white space or '<'...\n            if (c == INT_LT) {\n                break;\n            }\n            /* 26-Mar-2008, tatus: White space in prolog/epilog is\n             *   not to be reported at all (by default at least), as\n             *   it is not part of XML Infoset content. So let's\n             *   just actively skip it here\n             */\n            if (c != INT_SPACE) {\n                if (c == INT_LF) {\n                    markLF();\n                } else if (c == INT_CR) {\n                    if (_inputPtr >= _inputEnd) {\n                        if (!loadMore()) {\n                            markLF();\n                            setStartLocation();        \n                            return TOKEN_EOI;\n                        }\n                    }\n                    if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                        ++_inputPtr;\n                    }\n                    markLF();\n                } else if (c != INT_TAB) {\n                    reportPrologUnexpChar(isProlog, decodeCharForError((byte)c), null);\n                }\n            }\n        }\n\n        // Ok, got LT:\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed(COMMENT); // not necessarily a comment of course\n        }\n        byte b = _inputBuffer[_inputPtr++];\n        if (b == BYTE_EXCL) { // comment/DOCTYPE? (CDATA not legal)\n            return handlePrologDeclStart(isProlog);\n        }\n        if (b == BYTE_QMARK) {\n            return handlePIStart();\n        }\n        /* End tag not allowed if no open tree; and only one root\n         * element (one root-level start tag)\n         */\n        if (b == BYTE_SLASH || !isProlog) {\n            reportPrologUnexpElement(isProlog, b);\n        }\n        return handleStartElement(b);\n    }",
        "comment": "/*\n    /**********************************************************************\n    /* Implementation of parsing API\n    /**********************************************************************\n     */"
      }
    ],
    "trigger_test": {
      "async.TestAsyncErrorHandling::testSimpleByteArray": {
        "path": "async/TestAsyncErrorHandling.java",
        "function_name": "testSimpleByteArray",
        "src": "public void testSimpleByteArray() throws Exception\n    {\n        final AsyncXMLInputFactory f = newAsyncInputFactory();\n\n        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr = f.createAsyncForByteArray();\n        final AsyncReaderWrapperForByteArray asyncR = new AsyncReaderWrapperForByteArray(sr,\n                1000, \"<root>a</root><second>x>/second>\");\n\n        int t = verifyStart(asyncR);\n        assertTokenType(START_ELEMENT, t);\n        assertEquals(\"root\", sr.getLocalName());\n        assertEquals(0, sr.getAttributeCount());\n\n        assertTokenType(CHARACTERS, sr.next());\n        assertTokenType(END_ELEMENT, sr.next());\n\n        // and now expect problems\n        try {\n            sr.next();\n            fail(\"Should not pass\");\n        } catch (XMLStreamException e) {\n            verifyException(e, \"Second root element in content\");\n        }\n    }",
        "error_msg": "async.TestAsyncErrorHandling::testSimpleByteArray --> junit.framework.AssertionFailedError: Expected an exception with sub-string Second root element in content: got one with message Unexpected character 's' (code 115) in epilog (unbalanced start/end tags?)",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected an exception with sub-string Second root element in content: got one with message Unexpected character 's' (code 115) in epilog (unbalanced start/end tags?)"
      }
    }
  },
  "Bcel-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/bcel/generic/MethodGen.java",
        "start_loc": 337,
        "end_loc": 339,
        "buggy_function": "    public void removeLocalVariable( LocalVariableGen l ) {\n        variable_vec.remove(l);\n    }",
        "fixed_function": "    public void removeLocalVariable( LocalVariableGen l ) {\n        l.dispose();\n        variable_vec.remove(l);\n    }",
        "comment": "/**\n     * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable\n     * with an explicit index argument.\n     */"
      },
      {
        "path": "src/main/java/org/apache/bcel/generic/MethodGen.java",
        "start_loc": 345,
        "end_loc": 347,
        "buggy_function": "    public void removeLocalVariables() {\n        variable_vec.clear();\n    }",
        "fixed_function": "    public void removeLocalVariables() {\n        for (LocalVariableGen lv : variable_vec) {\n            lv.dispose();\n        }\n        variable_vec.clear();\n    }",
        "comment": "/**\n     * Remove all local variables.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.bcel.generic.MethodGenTestCase::testRemoveLocalVariable": {
        "path": "org/apache/bcel/generic/MethodGenTestCase.java",
        "function_name": "testRemoveLocalVariable",
        "src": "public void testRemoveLocalVariable() throws Exception {\n        MethodGen mg = getMethod(Foo.class, \"bar\");\n\n        LocalVariableGen lv = mg.getLocalVariables()[1];\n        assertEquals(\"variable name\", \"a\", lv.getName());\n        InstructionHandle start = lv.getStart();\n        InstructionHandle end = lv.getEnd();\n        assertNotNull(\"scope start\", start);\n        assertNotNull(\"scope end\", end);\n        assertTrue(\"scope start not targeted by the local variable\", Arrays.asList(start.getTargeters()).contains(lv));\n        assertTrue(\"scope end not targeted by the local variable\", Arrays.asList(end.getTargeters()).contains(lv));\n\n        // now let's remove the local variable\n        mg.removeLocalVariable(lv);\n\n        assertFalse(\"scope start still targeted by the removed variable\", Arrays.asList(start.getTargeters()).contains(lv));\n        assertFalse(\"scope end still targeted by the removed variable\", Arrays.asList(end.getTargeters()).contains(lv));\n        assertNull(\"scope start\", lv.getStart());\n        assertNull(\"scope end\", lv.getEnd());\n    }",
        "error_msg": "org.apache.bcel.generic.MethodGenTestCase::testRemoveLocalVariable --> junit.framework.AssertionFailedError: scope start still targeted by the removed variable",
        "clean_error_msg": "junit.framework.AssertionFailedError: scope start still targeted by the removed variable"
      },
      "org.apache.bcel.generic.MethodGenTestCase::testRemoveLocalVariables": {
        "path": "org/apache/bcel/generic/MethodGenTestCase.java",
        "function_name": "testRemoveLocalVariables",
        "src": "public void testRemoveLocalVariables() throws Exception {\n        MethodGen mg = getMethod(Foo.class, \"bar\");\n\n        LocalVariableGen lv = mg.getLocalVariables()[1];\n        assertEquals(\"variable name\", \"a\", lv.getName());\n        InstructionHandle start = lv.getStart();\n        InstructionHandle end = lv.getEnd();\n        assertNotNull(\"scope start\", start);\n        assertNotNull(\"scope end\", end);\n        assertTrue(\"scope start not targeted by the local variable\", Arrays.asList(start.getTargeters()).contains(lv));\n        assertTrue(\"scope end not targeted by the local variable\", Arrays.asList(end.getTargeters()).contains(lv));\n\n        // now let's remove the local variables\n        mg.removeLocalVariables();\n\n        assertFalse(\"scope start still targeted by the removed variable\", Arrays.asList(start.getTargeters()).contains(lv));\n        assertFalse(\"scope end still targeted by the removed variable\", Arrays.asList(end.getTargeters()).contains(lv));\n        assertNull(\"scope start\", lv.getStart());\n        assertNull(\"scope end\", lv.getEnd());\n    }",
        "error_msg": "org.apache.bcel.generic.MethodGenTestCase::testRemoveLocalVariables --> junit.framework.AssertionFailedError: scope start still targeted by the removed variable",
        "clean_error_msg": "junit.framework.AssertionFailedError: scope start still targeted by the removed variable"
      }
    }
  },
  "Canvas_api-3": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/edu/ksu/canvas/oauth/RefreshableOauthToken.java",
        "start_loc": 55,
        "end_loc": 60,
        "buggy_function": "        TokenExpiration(Long timeToLive) {\n            this.lastRefreshed = new Date();\n            if (timeToLive != null) {\n                this.timeToLive = timeToLive * 1000;\n            }\n        }",
        "fixed_function": "        TokenExpiration(Long timeToLive) {\n            this.lastRefreshed = new Date();\n            if (timeToLive != null) {\n                this.timeToLive = timeToLive - expireWindowMS;\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/edu/ksu/canvas/oauth/TokenRefreshResponse.java",
        "start_loc": 29,
        "end_loc": 34,
        "buggy_function": "    public Long getExpiresIn() {\n        if (expiresIn == null || expiresIn == 0) {\n            return null;\n        }\n        return expiresIn;\n    }",
        "fixed_function": "    public Long getExpiresIn() {\n        return expiresIn;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "edu.ksu.canvas.oauth.RefreshableTokenUTest::tokenIsNotRefreshedWhenNotExpired": {
        "path": "edu/ksu/canvas/oauth/RefreshableTokenUTest.java",
        "function_name": "tokenIsNotRefreshedWhenNotExpired",
        "src": "@Test\n    public void tokenIsNotRefreshedWhenNotExpired() throws Exception {\n        when(tokenRefresher.getNewToken(refreshToken))\n                .thenReturn(firstToken)\n                .thenReturn(secondToken);\n        token = new RefreshableOauthToken(tokenRefresher, refreshToken);\n\n        String accessToken = token.getAccessToken();\n\n        assertEquals(\"Expected token to not be refreshed when not expired\", secondToken.getAccessToken(), accessToken);\n    }",
        "error_msg": "edu.ksu.canvas.oauth.RefreshableTokenUTest::tokenIsNotRefreshedWhenNotExpired --> junit.framework.AssertionFailedError: Expected token to not be refreshed when not expired expected:<[second]Token> but was:<[first]Token>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected token to not be refreshed when not expired expected:<[second]Token> but was:<[first]Token>"
      },
      "edu.ksu.canvas.oauth.RefreshableTokenUTest::tokenIsRefreshedWhenExpireTimeReached": {
        "path": "edu/ksu/canvas/oauth/RefreshableTokenUTest.java",
        "function_name": "tokenIsRefreshedWhenExpireTimeReached",
        "src": "@Test\n    public void tokenIsRefreshedWhenExpireTimeReached() throws Exception {\n        firstToken.setExpiresIn(0l);\n        when(tokenRefresher.getNewToken(refreshToken))\n                .thenReturn(firstToken)\n                .thenReturn(secondToken);\n        token = new RefreshableOauthToken(tokenRefresher, refreshToken);\n\n        String accessToken = token.getAccessToken();\n\n        assertEquals(\"Expected token to be refreshed when expire time is reached\", secondToken.getAccessToken(), accessToken);\n    }",
        "error_msg": "edu.ksu.canvas.oauth.RefreshableTokenUTest::tokenIsRefreshedWhenExpireTimeReached --> junit.framework.AssertionFailedError: Expected token to be refreshed when expire time is reached expected:<[second]Token> but was:<[first]Token>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected token to be refreshed when expire time is reached expected:<[second]Token> but was:<[first]Token>"
      }
    }
  },
  "Chart-14": {
    "function_num": 4,
    "functions": [
      {
        "path": "source/org/jfree/chart/plot/CategoryPlot.java",
        "start_loc": 2155,
        "end_loc": 2171,
        "buggy_function": "    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "fixed_function": "    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "comment": "/**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */"
      },
      {
        "path": "source/org/jfree/chart/plot/CategoryPlot.java",
        "start_loc": 2434,
        "end_loc": 2453,
        "buggy_function": "    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "fixed_function": "    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "comment": "/**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     * \n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */"
      },
      {
        "path": "source/org/jfree/chart/plot/XYPlot.java",
        "start_loc": 2282,
        "end_loc": 2298,
        "buggy_function": "    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "fixed_function": "    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "comment": "/**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */"
      },
      {
        "path": "source/org/jfree/chart/plot/XYPlot.java",
        "start_loc": 2515,
        "end_loc": 2534,
        "buggy_function": "    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "fixed_function": "    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }",
        "comment": "/**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */"
      }
    ],
    "trigger_test": {
      "org.jfree.chart.plot.junit.CategoryPlotTests::testRemoveRangeMarker": {
        "path": "org/jfree/chart/plot/junit/CategoryPlotTests.java",
        "function_name": "testRemoveRangeMarker",
        "src": "public void testRemoveRangeMarker() {\n    \tCategoryPlot plot = new CategoryPlot();\n    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n    }",
        "error_msg": "org.jfree.chart.plot.junit.CategoryPlotTests::testRemoveRangeMarker --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.jfree.chart.plot.junit.CategoryPlotTests::testRemoveDomainMarker": {
        "path": "org/jfree/chart/plot/junit/CategoryPlotTests.java",
        "function_name": "testRemoveDomainMarker",
        "src": "public void testRemoveDomainMarker() {\n    \tCategoryPlot plot = new CategoryPlot();\n    \tassertFalse(plot.removeDomainMarker(new CategoryMarker(\"Category 1\")));\n    }",
        "error_msg": "org.jfree.chart.plot.junit.CategoryPlotTests::testRemoveDomainMarker --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.jfree.chart.plot.junit.XYPlotTests::testRemoveRangeMarker": {
        "path": "org/jfree/chart/plot/junit/XYPlotTests.java",
        "function_name": "testRemoveRangeMarker",
        "src": "public void testRemoveRangeMarker() {\n    \tXYPlot plot = new XYPlot();\n    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n    }",
        "error_msg": "org.jfree.chart.plot.junit.XYPlotTests::testRemoveRangeMarker --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.jfree.chart.plot.junit.XYPlotTests::testRemoveDomainMarker": {
        "path": "org/jfree/chart/plot/junit/XYPlotTests.java",
        "function_name": "testRemoveDomainMarker",
        "src": "public void testRemoveDomainMarker() {\n    \tXYPlot plot = new XYPlot();\n    \tassertFalse(plot.removeDomainMarker(new ValueMarker(0.5)));\n    }",
        "error_msg": "org.jfree.chart.plot.junit.XYPlotTests::testRemoveDomainMarker --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Chart-18": {
    "function_num": 3,
    "functions": [
      {
        "path": "source/org/jfree/data/DefaultKeyedValues.java",
        "start_loc": 315,
        "end_loc": 321,
        "buggy_function": "    public void removeValue(int index) {\n        this.keys.remove(index);\n        this.values.remove(index);\n        if (index < this.keys.size()) {\n        rebuildIndex();\n        }\n    }",
        "fixed_function": "    public void removeValue(int index) {\n        this.keys.remove(index);\n        this.values.remove(index);\n        rebuildIndex();\n    }",
        "comment": "/**\n     * Removes a value from the collection.\n     *\n     * @param index  the index of the item to remove (in the range \n     *     <code>0</code> to <code>getItemCount() - 1</code>).\n     *     \n     * @throws IndexOutOfBoundsException if <code>index</code> is not within\n     *     the specified range.\n     */"
      },
      {
        "path": "source/org/jfree/data/DefaultKeyedValues.java",
        "start_loc": 332,
        "end_loc": 338,
        "buggy_function": "    public void removeValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n\t\t\treturn;\n        }\n        removeValue(index);\n    }",
        "fixed_function": "    public void removeValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n        }\n        removeValue(index);\n    }",
        "comment": "/**\n     * Removes a value from the collection.\n     *\n     * @param key  the item key (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * @throws UnknownKeyException if <code>key</code> is not recognised.\n     */"
      },
      {
        "path": "source/org/jfree/data/DefaultKeyedValues2D.java",
        "start_loc": 454,
        "end_loc": 461,
        "buggy_function": "    public void removeColumn(Comparable columnKey) {\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n                rowData.removeValue(columnKey);\n        }\n        this.columnKeys.remove(columnKey);\n    }",
        "fixed_function": "    public void removeColumn(Comparable columnKey) {\n    \tif (columnKey == null) {\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\n    \t}\n    \tif (!this.columnKeys.contains(columnKey)) {\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\n    \t}\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                rowData.removeValue(columnKey);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }",
        "comment": "/**\n     * Removes a column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if the table does not contain a column with\n     *     the specified key.\n     * @throws IllegalArgumentException if <code>columnKey</code> is \n     *     <code>null</code>.\n     * \n     * @see #removeColumn(int)\n     * @see #removeRow(Comparable)\n     */"
      }
    ],
    "trigger_test": {
      "org.jfree.data.category.junit.DefaultCategoryDatasetTests::testBug1835955": {
        "path": "org/jfree/data/category/junit/DefaultCategoryDatasetTests.java",
        "function_name": "testBug1835955",
        "src": "public void testBug1835955() {\n    \tDefaultCategoryDataset d = new DefaultCategoryDataset();\n    \td.addValue(1.0, \"R1\", \"C1\");\n    \td.addValue(2.0, \"R2\", \"C2\");\n    \td.removeColumn(\"C2\");\n    \td.addValue(3.0, \"R2\", \"C2\");\n    \tassertEquals(3.0, d.getValue(\"R2\", \"C2\").doubleValue(), EPSILON);\n    }",
        "error_msg": "org.jfree.data.category.junit.DefaultCategoryDatasetTests::testBug1835955 --> java.lang.IndexOutOfBoundsException: Index: 0, Size: 0",
        "clean_error_msg": "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0"
      },
      "org.jfree.data.junit.DefaultKeyedValues2DTests::testRemoveColumnByKey": {
        "path": "org/jfree/data/junit/DefaultKeyedValues2DTests.java",
        "function_name": "testRemoveColumnByKey",
        "src": "public void testRemoveColumnByKey() {\n    \tDefaultKeyedValues2D d = new DefaultKeyedValues2D();\n    \td.addValue(new Double(1.0), \"R1\", \"C1\");\n    \td.addValue(new Double(2.0), \"R2\", \"C2\");\n    \td.removeColumn(\"C2\");\n    \td.addValue(new Double(3.0), \"R2\", \"C2\");\n    \tassertEquals(3.0, d.getValue(\"R2\", \"C2\").doubleValue(), EPSILON);\n    \t\n    \t// check for unknown column\n    \tboolean pass = false;\n    \ttry {\n    \t\td.removeColumn(\"XXX\");\n    \t}\n    \tcatch (UnknownKeyException e) {\n    \t\tpass = true;\n    \t}\n    \tassertTrue(pass);\n    }",
        "error_msg": "org.jfree.data.junit.DefaultKeyedValues2DTests::testRemoveColumnByKey --> java.lang.IndexOutOfBoundsException: Index: 0, Size: 0",
        "clean_error_msg": "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0"
      },
      "org.jfree.data.junit.DefaultKeyedValuesTests::testRemoveValue": {
        "path": "org/jfree/data/junit/DefaultKeyedValuesTests.java",
        "function_name": "testRemoveValue",
        "src": "public void testRemoveValue() {\n        DefaultKeyedValues data = new DefaultKeyedValues();\n        data.addValue(\"A\", new Double(1.0));\n        data.addValue(\"B\", null);\n        data.addValue(\"C\", new Double(3.0));\n        data.addValue(\"D\", new Double(2.0));\n        assertEquals(1, data.getIndex(\"B\"));\n        data.removeValue(\"B\");\n        assertEquals(-1, data.getIndex(\"B\"));\n        \n        boolean pass = false;\n        try {\n            data.removeValue(\"XXX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;   \n        }\n        assertTrue(pass);\n    }",
        "error_msg": "org.jfree.data.junit.DefaultKeyedValuesTests::testRemoveValue --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.jfree.data.junit.DefaultKeyedValuesTests::testGetIndex2": {
        "path": "org/jfree/data/junit/DefaultKeyedValuesTests.java",
        "function_name": "testGetIndex2",
        "src": "public void testGetIndex2() {\n    \tDefaultKeyedValues v = new DefaultKeyedValues();\n    \tassertEquals(-1, v.getIndex(\"K1\"));\n    \tv.addValue(\"K1\", 1.0);\n    \tassertEquals(0, v.getIndex(\"K1\"));\n    \tv.removeValue(\"K1\");\n    \tassertEquals(-1, v.getIndex(\"K1\"));\n    }",
        "error_msg": "org.jfree.data.junit.DefaultKeyedValuesTests::testGetIndex2 --> junit.framework.AssertionFailedError: expected:<-1> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-1> but was:<0>"
      }
    }
  },
  "Cli-13": {
    "function_num": 2,
    "functions": [
      {
        "path": "./src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
        "start_loc": 109,
        "end_loc": 130,
        "buggy_function": "    public List getValues(final Option option,\n                          final List defaultValues) {\n        // First grab the command line values\n        List valueList = (List) values.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // Thirdly try the option's default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        // Finally use an empty list\n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }",
        "fixed_function": "    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }",
        "comment": ""
      },
      {
        "path": "./src/java/org/apache/commons/cli2/option/ArgumentImpl.java",
        "start_loc": 139,
        "end_loc": 189,
        "buggy_function": "    public void processValues(final WriteableCommandLine commandLine,\n                              final ListIterator arguments,\n                              final Option option)\n        throws OptionException {\n        // count of arguments processed for this option.\n        int argumentCount = 0;\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            // should we ignore things that look like options?\n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            // does it look like an option?\n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            // should we split the string up?\n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            // it must be a value as it is\n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }",
        "fixed_function": "    public void processValues(final WriteableCommandLine commandLine,\n                              final ListIterator arguments,\n                              final Option option)\n        throws OptionException {\n        // count of arguments processed for this option.\n        int argumentCount = commandLine.getUndefaultedValues(option).size();\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            // should we ignore things that look like options?\n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            // does it look like an option?\n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            // should we split the string up?\n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            // it must be a value as it is\n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.commons.cli2.bug.BugLoopingOptionLookAlikeTest::testLoopingOptionLookAlike2": {
        "path": "org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java",
        "function_name": "testLoopingOptionLookAlike2",
        "src": "public void testLoopingOptionLookAlike2() {\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n        final Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();\n        final Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\n        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);\n        final Group options = gbuilder.withOption(targets).create();\n        final Parser parser = new Parser();\n        parser.setGroup(options);\n        try {\n            parser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });\n            fail(\"OptionException\");\n        } catch (OptionException e) {\n            assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());\n        }\n    }",
        "error_msg": "org.apache.commons.cli2.bug.BugLoopingOptionLookAlikeTest::testLoopingOptionLookAlike2 --> junit.framework.ComparisonFailure: expected:<Unexpected [testfile.txt while processing ]> but was:<Unexpected [value testfile.txt found while processing  input]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<Unexpected [testfile.txt while processing ]> but was:<Unexpected [value testfile.txt found while processing  input]>"
      }
    }
  },
  "Cli-16": {
    "function_num": 3,
    "functions": [
      {
        "path": "./src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
        "start_loc": 65,
        "end_loc": 74,
        "buggy_function": "    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n    }",
        "fixed_function": "    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n        Option parent = option.getParent();\n        while (parent != null && !options.contains(parent)) {\n            options.add(parent);\n            parent = parent.getParent();\n        }\n    }",
        "comment": ""
      },
      {
        "path": "./src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "start_loc": 64,
        "end_loc": 111,
        "buggy_function": "    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }",
        "fixed_function": "    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.setParent(this);\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }",
        "comment": "/**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */"
      },
      {
        "path": "./src/java/org/apache/commons/cli2/option/OptionImpl.java",
        "start_loc": 124,
        "end_loc": 126,
        "buggy_function": "    public void defaults(final WriteableCommandLine commandLine) {\n        // nothing to do normally\n    }",
        "fixed_function": "    public Option getParent() {\n        return parent;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.commons.cli2.bug.BugCLI123Test::testMultipleChildOptions": {
        "path": "org/apache/commons/cli2/bug/BugCLI123Test.java",
        "function_name": "testMultipleChildOptions",
        "src": "public void testMultipleChildOptions() throws OptionException {\n        CommandLine cl = parser.parse(new String[] { \"--child\", \"test\",\n                \"--sub\", \"anotherTest\" });\n        assertTrue(\"Child option not found\", cl.hasOption(childOption1));\n        assertEquals(\"Wrong value for option\", \"test\", cl\n                .getValue(childOption1));\n        assertTrue(\"Sub option not found\", cl.hasOption(childOption2));\n        assertEquals(\"Wrong value for sub option\", \"anotherTest\", cl\n                .getValue(childOption2));\n        assertTrue(\"Child group not found\", cl.hasOption(childGroup));\n    }",
        "error_msg": "org.apache.commons.cli2.bug.BugCLI123Test::testMultipleChildOptions --> org.apache.commons.cli2.OptionException: Missing option parentOptions",
        "clean_error_msg": "org.apache.commons.cli2.OptionException: Missing option parentOptions"
      },
      "org.apache.commons.cli2.bug.BugCLI123Test::testParentOptionAndChildOption": {
        "path": "org/apache/commons/cli2/bug/BugCLI123Test.java",
        "function_name": "testParentOptionAndChildOption",
        "src": "public void testParentOptionAndChildOption() throws OptionException {\n        try {\n            parser.parse(new String[] { \"--parent\", \"error\", \"--child\",\n                    \"exception\" });\n            fail(\"Maximum restriction for parent not verified!\");\n        } catch (OptionException oex) {\n            // ok\n        }\n    }",
        "error_msg": "org.apache.commons.cli2.bug.BugCLI123Test::testParentOptionAndChildOption --> junit.framework.AssertionFailedError: Maximum restriction for parent not verified!",
        "clean_error_msg": "junit.framework.AssertionFailedError: Maximum restriction for parent not verified!"
      },
      "org.apache.commons.cli2.bug.BugCLI123Test::testSingleChildOption": {
        "path": "org/apache/commons/cli2/bug/BugCLI123Test.java",
        "function_name": "testSingleChildOption",
        "src": "public void testSingleChildOption() throws OptionException {\n        CommandLine cl = parser.parse(new String[] { \"--child\", \"test\" });\n        assertTrue(\"Child option not found\", cl.hasOption(childOption1));\n        assertEquals(\"Wrong value for option\", \"test\", cl\n                .getValue(childOption1));\n        assertTrue(\"Child group not found\", cl.hasOption(childGroup));\n    }",
        "error_msg": "org.apache.commons.cli2.bug.BugCLI123Test::testSingleChildOption --> org.apache.commons.cli2.OptionException: Missing option parentOptions",
        "clean_error_msg": "org.apache.commons.cli2.OptionException: Missing option parentOptions"
      },
      "org.apache.commons.cli2.commandline.DefaultingCommandLineTest::testGetOptions_Order": {
        "path": "org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java",
        "function_name": "testGetOptions_Order",
        "src": "",
        "error_msg": "org.apache.commons.cli2.commandline.DefaultingCommandLineTest::testGetOptions_Order --> junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>"
      },
      "org.apache.commons.cli2.commandline.PreferencesCommandLineTest::testGetOptions_Order": {
        "path": "org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java",
        "function_name": "testGetOptions_Order",
        "src": "",
        "error_msg": "org.apache.commons.cli2.commandline.PreferencesCommandLineTest::testGetOptions_Order --> junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>"
      },
      "org.apache.commons.cli2.commandline.PropertiesCommandLineTest::testGetOptions_Order": {
        "path": "org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java",
        "function_name": "testGetOptions_Order",
        "src": "",
        "error_msg": "org.apache.commons.cli2.commandline.PropertiesCommandLineTest::testGetOptions_Order --> junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>"
      },
      "org.apache.commons.cli2.commandline.WriteableCommandLineImplTest::testGetOptions_Order": {
        "path": "org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java",
        "function_name": "testGetOptions_Order",
        "src": "",
        "error_msg": "org.apache.commons.cli2.commandline.WriteableCommandLineImplTest::testGetOptions_Order --> junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected same:<[--help (-?,-h)|login <username>] [<target1> [<target2> ...]]> was not:<[--help (-?,-h)]>"
      }
    }
  },
  "Cli-21": {
    "function_num": 3,
    "functions": [
      {
        "path": "./src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
        "start_loc": 59,
        "end_loc": 63,
        "buggy_function": "    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }",
        "fixed_function": "    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n        setCurrentOption(rootOption);\n    }",
        "comment": "/**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */"
      },
      {
        "path": "./src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java",
        "start_loc": 232,
        "end_loc": 246,
        "buggy_function": "    public boolean looksLikeOption(final String trigger)\n    {\n            // this is a reentrant call\n\n            for (final Iterator i = prefixes.iterator(); i.hasNext();)\n            {\n                final String prefix = (String) i.next();\n\n                if (trigger.startsWith(prefix))\n                {\n                        return true;\n                }\n            }\n            return false;\n    }",
        "fixed_function": "    public void setCurrentOption(Option currentOption) {\n        this.currentOption = currentOption;\n    }",
        "comment": ""
      },
      {
        "path": "./src/java/org/apache/commons/cli2/option/GroupImpl.java",
        "start_loc": 511,
        "end_loc": 514,
        "buggy_function": "    private boolean looksLikeOption(final WriteableCommandLine commandLine,\n            final String trigger) {\n            return commandLine.looksLikeOption(trigger);\n    }",
        "fixed_function": "    private boolean looksLikeOption(final WriteableCommandLine commandLine,\n            final String trigger) {\n        Option oldOption = commandLine.getCurrentOption();\n        try {\n            commandLine.setCurrentOption(this);\n            return commandLine.looksLikeOption(trigger);\n        } finally {\n            commandLine.setCurrentOption(oldOption);\n        }\n    }",
        "comment": "/**\n     * Helper method for testing whether an element of the command line looks\n     * like an option. This method queries the command line, but sets the\n     * current option first.\n     *\n     * @param commandLine the command line\n     * @param trigger the trigger to be checked\n     * @return a flag whether this element looks like an option\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.cli2.bug.BugCLI150Test::testNegativeNumber": {
        "path": "org/apache/commons/cli2/bug/BugCLI150Test.java",
        "function_name": "testNegativeNumber",
        "src": "public void testNegativeNumber() throws OptionException\n    {\n        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n        final GroupBuilder gBuilder = new GroupBuilder();\n\n        final Argument numArg = aBuilder.withValidator(\n                NumberValidator.getNumberInstance()).withMinimum(1)\n                .withMaximum(1).create();\n        final Option numOpt = oBuilder.withLongName(\"num\").withArgument(numArg)\n                .create();\n        final Group options = gBuilder.withOption(numOpt).create();\n\n        final Parser parser = new Parser();\n        parser.setGroup(options);\n\n        CommandLine cl = parser.parse(new String[] {\n                \"--num\", \"-42\"\n        });\n        Number num = (Number) cl.getValue(numOpt);\n        assertEquals(\"Wrong option value\", -42, num.intValue());\n    }",
        "error_msg": "org.apache.commons.cli2.bug.BugCLI150Test::testNegativeNumber --> org.apache.commons.cli2.OptionException: Unexpected -42 while processing --num",
        "clean_error_msg": "org.apache.commons.cli2.OptionException: Unexpected -42 while processing --num"
      }
    }
  },
  "Cli-30": {
    "function_num": 2,
    "functions": [
      {
        "path": "./src/main/java/org/apache/commons/cli/DefaultParser.java",
        "start_loc": 139,
        "end_loc": 178,
        "buggy_function": "    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            \n                // get the value from the properties\n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }",
        "fixed_function": "    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }",
        "comment": "/**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */"
      },
      {
        "path": "./src/main/java/org/apache/commons/cli/Parser.java",
        "start_loc": 252,
        "end_loc": 299,
        "buggy_function": "    protected void processProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            \n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }",
        "fixed_function": "    protected void processProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }",
        "comment": "/**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.cli.BasicParserTest::testPropertyOptionGroup": {
        "path": "org/apache/commons/cli/BasicParserTest.java",
        "function_name": "testPropertyOptionGroup",
        "src": "",
        "error_msg": "org.apache.commons.cli.BasicParserTest::testPropertyOptionGroup --> org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'",
        "clean_error_msg": "org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'"
      },
      "org.apache.commons.cli.BasicParserTest::testPropertyOptionUnexpected": {
        "path": "org/apache/commons/cli/BasicParserTest.java",
        "function_name": "testPropertyOptionUnexpected",
        "src": "",
        "error_msg": "org.apache.commons.cli.BasicParserTest::testPropertyOptionUnexpected --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.commons.cli.DefaultParserTest::testPropertyOptionGroup": {
        "path": "org/apache/commons/cli/DefaultParserTest.java",
        "function_name": "testPropertyOptionGroup",
        "src": "",
        "error_msg": "org.apache.commons.cli.DefaultParserTest::testPropertyOptionGroup --> org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'",
        "clean_error_msg": "org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'"
      },
      "org.apache.commons.cli.DefaultParserTest::testPropertyOptionUnexpected": {
        "path": "org/apache/commons/cli/DefaultParserTest.java",
        "function_name": "testPropertyOptionUnexpected",
        "src": "",
        "error_msg": "org.apache.commons.cli.DefaultParserTest::testPropertyOptionUnexpected --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.commons.cli.GnuParserTest::testPropertyOptionGroup": {
        "path": "org/apache/commons/cli/GnuParserTest.java",
        "function_name": "testPropertyOptionGroup",
        "src": "",
        "error_msg": "org.apache.commons.cli.GnuParserTest::testPropertyOptionGroup --> org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'",
        "clean_error_msg": "org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'"
      },
      "org.apache.commons.cli.GnuParserTest::testPropertyOptionUnexpected": {
        "path": "org/apache/commons/cli/GnuParserTest.java",
        "function_name": "testPropertyOptionUnexpected",
        "src": "",
        "error_msg": "org.apache.commons.cli.GnuParserTest::testPropertyOptionUnexpected --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.commons.cli.OptionGroupTest::testTwoOptionsFromGroupWithProperties": {
        "path": "org/apache/commons/cli/OptionGroupTest.java",
        "function_name": "testTwoOptionsFromGroupWithProperties",
        "src": "public void testTwoOptionsFromGroupWithProperties() throws Exception\n    {\n        String[] args = new String[] { \"-f\" };\n        \n        Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n        \n        CommandLine cl = parser.parse( _options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertTrue(!cl.hasOption(\"d\"));\n    }",
        "error_msg": "org.apache.commons.cli.OptionGroupTest::testTwoOptionsFromGroupWithProperties --> org.apache.commons.cli.AlreadySelectedException: The option 'd' was specified but an option from this group has already been selected: 'f'",
        "clean_error_msg": "org.apache.commons.cli.AlreadySelectedException: The option 'd' was specified but an option from this group has already been selected: 'f'"
      },
      "org.apache.commons.cli.PosixParserTest::testPropertyOptionGroup": {
        "path": "org/apache/commons/cli/PosixParserTest.java",
        "function_name": "testPropertyOptionGroup",
        "src": "",
        "error_msg": "org.apache.commons.cli.PosixParserTest::testPropertyOptionGroup --> org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'",
        "clean_error_msg": "org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'"
      },
      "org.apache.commons.cli.PosixParserTest::testPropertyOptionUnexpected": {
        "path": "org/apache/commons/cli/PosixParserTest.java",
        "function_name": "testPropertyOptionUnexpected",
        "src": "",
        "error_msg": "org.apache.commons.cli.PosixParserTest::testPropertyOptionUnexpected --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Cli-31": {
    "function_num": 2,
    "functions": [
      {
        "path": "./src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "start_loc": 636,
        "end_loc": 664,
        "buggy_function": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }",
        "fixed_function": "    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }",
        "comment": "/**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */"
      },
      {
        "path": "./src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "start_loc": 77,
        "end_loc": 87,
        "buggy_function": "    private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }",
        "fixed_function": "    private static void reset()\n    {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }",
        "comment": "/**\n     * Resets the member variables to their default values.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.cli.HelpFormatterTest::testDefaultArgName": {
        "path": "org/apache/commons/cli/HelpFormatterTest.java",
        "function_name": "testDefaultArgName",
        "src": "public void testDefaultArgName()\n    {\n        Option option = OptionBuilder.hasArg().isRequired().create(\"f\");\n        \n        Options options = new Options();\n        options.addOption(option);\n        \n        StringWriter out = new StringWriter();\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }",
        "error_msg": "org.apache.commons.cli.HelpFormatterTest::testDefaultArgName --> junit.framework.ComparisonFailure: expected:<usage: app -f <arg[ument]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<usage: app -f <arg[ument]>"
      }
    }
  },
  "Closure-30": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "start_loc": 155,
        "end_loc": 158,
        "buggy_function": "  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n  }",
        "fixed_function": "  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "start_loc": 391,
        "end_loc": 402,
        "buggy_function": "  private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue,\n        new AbstractCfgNodeTraversalCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n          Var dep = jsScope.getVar(n.getString());\n            def.depends.add(dep);\n        }\n      }\n    });\n  }",
        "fixed_function": "  private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue,\n        new AbstractCfgNodeTraversalCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName()) {\n          Var dep = jsScope.getVar(n.getString());\n          if (dep == null) {\n            def.unknownDependencies = true;\n          } else {\n            def.depends.add(dep);\n          }\n        }\n      }\n    });\n  }",
        "comment": "/**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "start_loc": 425,
        "end_loc": 437,
        "buggy_function": "  boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n\n    for (Var s : def.depends) {\n      if (s.scope != jsScope) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "fixed_function": "  boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    if (def.unknownDependencies) {\n      return true;\n    }\n\n    for (Var s : def.depends) {\n      if (s.scope != jsScope) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testInlineAcrossSideEffect1": {
        "path": "com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
        "function_name": "testInlineAcrossSideEffect1",
        "src": "public void testInlineAcrossSideEffect1() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX.\n    //\n    // noSFX must be both const and pure in order to inline it.\n    noInline(\"var y; var x = noSFX(y); print(x)\");\n    //inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n  }",
        "error_msg": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testInlineAcrossSideEffect1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testCanInlineAcrossNoSideEffect": {
        "path": "com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
        "function_name": "testCanInlineAcrossNoSideEffect",
        "src": "public void testCanInlineAcrossNoSideEffect() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX. We should be able to mark noSFX as const\n    // in some way.\n    noInline(\n        \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\");\n    //inline(\n    //    \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\",\n    //    \"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))\");\n  }",
        "error_msg": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testCanInlineAcrossNoSideEffect --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testIssue698": {
        "path": "com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
        "function_name": "testIssue698",
        "src": "public void testIssue698() {\n    // Most of the flow algorithms operate on Vars. We want to make\n    // sure the algorithm bails out appropriately if it sees\n    // a var that it doesn't know about.\n    inline(\n        \"var x = ''; \"\n        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"return x;\",\n        \"var x; \"\n        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n        + \"x = '' + unknown; \"\n        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"return x;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testIssue698 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-34": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "start_loc": 85,
        "end_loc": 732,
        "buggy_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "fixed_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "start_loc": 741,
        "end_loc": 757,
        "buggy_function": "  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }",
        "fixed_function": "  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.addOp(opStr, true);\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }",
        "comment": "/**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "start_loc": 331,
        "end_loc": 342,
        "buggy_function": "    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }",
        "fixed_function": "    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CodePrinterTest::testManyAdds": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testManyAdds",
        "src": "public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testManyAdds --> java.lang.StackOverflowError",
        "clean_error_msg": "java.lang.StackOverflowError"
      }
    }
  },
  "Closure-37": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "start_loc": 510,
        "end_loc": 545,
        "buggy_function": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n    traverseBranch(body, n);\n\n    popScope();\n  }",
        "fixed_function": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
        "comment": "/**\n   * Traverses a function.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "start_loc": 609,
        "end_loc": 673,
        "buggy_function": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
        "fixed_function": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.IntegrationTest::testIncompleteFunction": {
        "path": "com/google/javascript/jscomp/IntegrationTest.java",
        "function_name": "testIncompleteFunction",
        "src": "public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }",
        "error_msg": "com.google.javascript.jscomp.IntegrationTest::testIncompleteFunction --> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      }
    }
  },
  "Closure-47": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/debugging/sourcemap/SourceMapConsumerV3.java",
        "start_loc": 482,
        "end_loc": 496,
        "buggy_function": "  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }",
        "fixed_function": "  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine() + 1)\n        .setColumnPosition(entry.getSourceColumn() + 1);\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }",
        "comment": "/**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 117,
        "end_loc": 143,
        "buggy_function": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }",
        "fixed_function": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n    int lineBaseOffset = 1;\n    if (generator instanceof SourceMapGeneratorV1\n        || generator instanceof SourceMapGeneratorV2) {\n      lineBaseOffset = 0;\n    }\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testParseSourceMetaMap": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testParseSourceMetaMap",
        "src": "public void testParseSourceMetaMap() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    final String MAP1 = \"map1\";\n    final String MAP2 = \"map2\";\n    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n    maps.put(MAP1, result1.sourceMapFileContent);\n    maps.put(MAP2, result2.sourceMapFileContent);\n\n    List<SourceMapSection> sections = Lists.newArrayList();\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    sections.add(SourceMapSection.forURL(MAP1, 0, 0));\n    output.append(result2.generatedSource);\n    sections.add(\n        SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn()));\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n\n    check(inputs, output.toString(), mapContents.toString(),\n      new SourceMapSupplier() {\n        @Override\n        public String getSourceMap(String url){\n          return maps.get(url);\n      }});\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testParseSourceMetaMap --> junit.framework.AssertionFailedError: expected:<5> but was:<4>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<5> but was:<4>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput0a": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput0a",
        "src": "public void testGoldenOutput0a() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"a;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"a\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput0a --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultilineMapping": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testMultilineMapping",
        "src": "public void testMultilineMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultilineMapping --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultiFunctionMapping": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testMultiFunctionMapping",
        "src": "public void testMultiFunctionMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\\n\" +\n\n                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n                    \"var __VAR2__ = '__STR2__';\\n\" +\n                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n                    \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultiFunctionMapping --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testLiteralMappingsGoldenOutput": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testLiteralMappingsGoldenOutput",
        "src": "public void testLiteralMappingsGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                   \"var __VAR__ = '__STR__'; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,CAACC,UAAD,CAAaC,UAAb,\" +\n                       \"CAAyB,CAAE,IAAIC,QAAU,SAAhB;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\",\\\"__PARAM1__\\\",\\\"__PARAM2__\\\",\" +\n                       \"\\\"__VAR__\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testLiteralMappingsGoldenOutput --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultilineMapping2": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testMultilineMapping2",
        "src": "public void testMultilineMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = 1;\\n\" +\n                    \"var __ANO__ = 2;\\n\" +\n                    \"}\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testMultilineMapping2 --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMappingGoldenOutput": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testBasicMappingGoldenOutput",
        "src": "public void testBasicMappingGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__() { }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,EAAG;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMappingGoldenOutput --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testSourceMapMerging": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testSourceMapMerging",
        "src": "public void testSourceMapMerging() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    output.append(result2.generatedSource);\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n\n    generator.mergeMapSection(0, 0, result1.sourceMapFileContent);\n    generator.mergeMapSection(offset.getLine(), offset.getColumn(),\n        result2.sourceMapFileContent);\n\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendTo(mapContents, \"out.js\");\n\n    check(inputs, output.toString(), mapContents.toString());\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testSourceMapMerging --> junit.framework.AssertionFailedError: expected:<5> but was:<4>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<5> but was:<4>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testLiteralMappings": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testLiteralMappings",
        "src": "public void testLiteralMappings() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                    \"var __VAR__ = '__STR__'; }\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testLiteralMappings --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMapping1": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testBasicMapping1",
        "src": "public void testBasicMapping1() throws Exception {\n    compileAndCheck(\"function __BASIC__() { }\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMapping1 --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMapping2": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testBasicMapping2",
        "src": "public void testBasicMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__) {}\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testBasicMapping2 --> junit.framework.AssertionFailedError: expected:<10> but was:<9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<10> but was:<9>"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput1": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput1",
        "src": "public void testGoldenOutput1() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAAED,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkB,CAAG,\" +\n                       \"OAAOD,IAA9B;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAATA,CAAWC,GAAXD,CAAgBE,\" +\n                       \"GAAhBF,EAAuBC,GAAvBD,CAA6BC,GAA7BD,CAAmCE,GAAnCF,\" +\n                       \"SAAmDC,IAAnDD;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput1 --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput2": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput2",
        "src": "public void testGoldenOutput2() throws Exception {\n    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                   \"\\nreturn foo;\\n}\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAIrBD,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkBD,\" +\n                       \"GAClB,OAAOA,IALc;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput2 --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput3": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput3",
        "src": "public void testGoldenOutput3() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput3 --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput4": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput4",
        "src": "public void testGoldenOutput4() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;   boo;   goo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,GAAOC,IAAOC;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\",\\\"boo\\\",\\\"goo\\\"]\\n\" +\n                   \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput4 --> junit.framework.ComparisonFailure: expected:<...t:1,",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...t:1,"
      },
      "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput5": {
        "path": "com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java",
        "function_name": "testGoldenOutput5",
        "src": "public void testGoldenOutput5() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\n        \"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;AAGA,IAAIA,IAAIC,CAAJD,CAAQ,mxCAARA;AAA8xCE,\" +\n            \"CAA9xCF,CAAkyCG,CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;IAGIA,IAAIC,CAAJD;AAA8xCE,CAA9xCF,CAAkyCG,\" +\n            \"CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n  }",
        "error_msg": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testGoldenOutput5 --> junit.framework.ComparisonFailure: expected:<...",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<..."
      }
    }
  },
  "Closure-54": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "start_loc": 1373,
        "end_loc": 1489,
        "buggy_function": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
        "fixed_function": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
        "comment": "/**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 322,
        "end_loc": 350,
        "buggy_function": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }",
        "fixed_function": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }",
        "comment": "/**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 357,
        "end_loc": 395,
        "buggy_function": "  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
        "fixed_function": "  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    PrototypeObjectType oldPrototype = this.prototype;\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
        "comment": "/**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue537a": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue537a",
        "src": "public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue537a --> junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testIssue537b": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue537b",
        "src": "public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue537b --> junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertyOnUnknownSuperClass2": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testPropertyOnUnknownSuperClass2",
        "src": "public void testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertyOnUnknownSuperClass2 --> junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>"
      }
    }
  },
  "Closure-72": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
        "start_loc": 142,
        "end_loc": 152,
        "buggy_function": "  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n  }",
        "fixed_function": "  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n        .process(null, fnNode);\n  }",
        "comment": "/**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "start_loc": 209,
        "end_loc": 235,
        "buggy_function": "    private void visitLabel(Node node, Node parent) {\n      Node nameNode = node.getFirstChild();\n      Preconditions.checkState(nameNode != null);\n      String name = nameNode.getString();\n      LabelInfo li = getLabelInfo(name);\n      // This is a label...\n      if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n          // ... and it is used, give it the short name.\n          nameNode.setString(newName);\n          compiler.reportCodeChange();\n        }\n      } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n          NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n      }\n\n      // Remove the label from the current stack of labels.\n      namespaceStack.peek().renameMap.remove(name);\n    }",
        "fixed_function": "    private void visitLabel(Node node, Node parent) {\n      Node nameNode = node.getFirstChild();\n      Preconditions.checkState(nameNode != null);\n      String name = nameNode.getString();\n      LabelInfo li = getLabelInfo(name);\n      // This is a label...\n      if (li.referenced || !removeUnused) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n          // ... and it is used, give it the short name.\n          nameNode.setString(newName);\n          compiler.reportCodeChange();\n        }\n      } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n          NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n      }\n\n      // Remove the label from the current stack of labels.\n      namespaceStack.peek().renameMap.remove(name);\n    }",
        "comment": "/**\n     * Rename or remove labels.\n     * @param node  The label node.\n     * @param parent The parent of the label node.\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.InlineFunctionsTest::testInlineFunctions31": {
        "path": "com/google/javascript/jscomp/InlineFunctionsTest.java",
        "function_name": "testInlineFunctions31",
        "src": "public void testInlineFunctions31() {\n    // Don't introduce a duplicate label in the same scope\n    test(\"function foo(){ lab:{4;} }\" +\n        \"lab:{foo();}\",\n        \"lab:{{JSCompiler_inline_label_0:{4}}}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineFunctionsTest::testInlineFunctions31 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-79": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/Normalize.java",
        "start_loc": 118,
        "end_loc": 149,
        "buggy_function": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
        "fixed_function": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/VarCheck.java",
        "start_loc": 205,
        "end_loc": 221,
        "buggy_function": "  private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n\n    getSynthesizedExternsRoot().addChildToBack(\n        new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n  }",
        "fixed_function": "  private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n\n    getSynthesizedExternsRoot().addChildToBack(\n        new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n  }",
        "comment": "/**\n   * Create a new variable in a synthetic script. This will prevent\n   * subsequent compiler passes from crashing.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.NormalizeTest::testIssue": {
        "path": "com/google/javascript/jscomp/NormalizeTest.java",
        "function_name": "testIssue",
        "src": "public void testIssue166a() {\n    test(\"try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }\",\n         \"try { throw 1 } catch(e) { var e=2 }\",\n         Normalize.CATCH_BLOCK_VAR_ERROR);\n  }",
        "error_msg": "com.google.javascript.jscomp.NormalizeTest::testIssue --> java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      },
      "com.google.javascript.jscomp.VarCheckTest::testPropReferenceInExterns1": {
        "path": "com/google/javascript/jscomp/VarCheckTest.java",
        "function_name": "testPropReferenceInExterns1",
        "src": "public void testPropReferenceInExterns1() {\n    testSame(\"asdf.foo;\", \"var asdf;\",\n        VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n  }",
        "error_msg": "com.google.javascript.jscomp.VarCheckTest::testPropReferenceInExterns1 --> junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called",
        "clean_error_msg": "junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called"
      },
      "com.google.javascript.jscomp.VarCheckTest::testPropReferenceInExterns3": {
        "path": "com/google/javascript/jscomp/VarCheckTest.java",
        "function_name": "testPropReferenceInExterns3",
        "src": "public void testPropReferenceInExterns3() {\n    testSame(\"asdf.foo;\", \"var asdf;\",\n        VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n\n    externValidationErrorLevel = CheckLevel.ERROR;\n    test(\n        \"asdf.foo;\", \"var asdf;\", \"\",\n         VarCheck.UNDEFINED_EXTERN_VAR_ERROR, null);\n\n    externValidationErrorLevel = CheckLevel.OFF;\n    test(\"asdf.foo;\", \"var asdf;\", \"var asdf;\", null, null);\n  }",
        "error_msg": "com.google.javascript.jscomp.VarCheckTest::testPropReferenceInExterns3 --> junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called",
        "clean_error_msg": "junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called"
      },
      "com.google.javascript.jscomp.VarCheckTest::testVarReferenceInExterns": {
        "path": "com/google/javascript/jscomp/VarCheckTest.java",
        "function_name": "testVarReferenceInExterns",
        "src": "public void testVarReferenceInExterns() {\n    testSame(\"asdf;\", \"var asdf;\",\n        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n  }",
        "error_msg": "com.google.javascript.jscomp.VarCheckTest::testVarReferenceInExterns --> junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called",
        "clean_error_msg": "junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called"
      },
      "com.google.javascript.jscomp.VarCheckTest::testCallInExterns": {
        "path": "com/google/javascript/jscomp/VarCheckTest.java",
        "function_name": "testCallInExterns",
        "src": "public void testCallInExterns() {\n    testSame(\"yz();\", \"function yz() {}\",\n        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n  }",
        "error_msg": "com.google.javascript.jscomp.VarCheckTest::testCallInExterns --> junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called",
        "clean_error_msg": "junit.framework.AssertionFailedError: compiler.reportCodeChange() should have been called"
      }
    }
  },
  "Closure-89": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CollapseProperties.java",
        "start_loc": 477,
        "end_loc": 540,
        "buggy_function": "  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }",
        "fixed_function": "  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }",
        "comment": "/**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "start_loc": 896,
        "end_loc": 925,
        "buggy_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }",
        "fixed_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToChildOfUncollapsibleFunctionInLocalScope": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAddPropertyToChildOfUncollapsibleFunctionInLocalScope",
        "src": "public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToChildOfUncollapsibleFunctionInLocalScope --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_1": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAliasCreatedForFunctionDepth1_1",
        "src": "public void testAliasCreatedForFunctionDepth1_1() {\n    testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_2": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAliasCreatedForFunctionDepth1_2",
        "src": "public void testAliasCreatedForFunctionDepth1_2() {\n    testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_3": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAliasCreatedForFunctionDepth1_3",
        "src": "public void testAliasCreatedForFunctionDepth1_3() {\n    testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_3 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1",
        "src": "public void testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1() {\n    // This technically should be collapsed, according to the rules.\n    // We don't collapse named constructors for legacy reasons\n    // (this pass has been around too long, and we don't know who's\n    // depending on this behavior).\n    testSame(\n          \"/** @constructor */ function a() {} var c = a; \" +\n          \"(function() {a.b = 0;})(); a.b;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1",
        "src": "public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1() {\n    testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2",
        "src": "public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2() {\n    test(\"var a = {}; a.b = function (){}; var d = a.b;\" +\n         \"(function() {a.b.c = 0;})(); a.b.c;\",\n         \"var a$b = function (){}; var d = a$b;\" +\n         \"(function() {a$b.c = 0;})(); a$b.c;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth2": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testAliasCreatedForFunctionDepth2",
        "src": "public void testAliasCreatedForFunctionDepth2() {\n    test(\n        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +\n        \"a.b.c != d.c;\",\n        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +\n        \"a$b.c != d.c;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-90": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "start_loc": 176,
        "end_loc": 190,
        "buggy_function": "    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }",
        "fixed_function": "    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.restrictByNotNullOrUndefined().isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 861,
        "end_loc": 903,
        "buggy_function": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
        "fixed_function": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testBackwardsTypedefUse8",
        "src": "public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8 --> junit.framework.AssertionFailedError: unexpected warnings(s):",
        "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse9": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testBackwardsTypedefUse9",
        "src": "public void testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse9 --> junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter"
      }
    }
  },
  "Closure-103": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "start_loc": 884,
        "end_loc": 904,
        "buggy_function": "  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "fixed_function": "  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "comment": "/**\n   * Determines if the subtree might throw an exception.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/DisambiguateProperties.java",
        "start_loc": 736,
        "end_loc": 767,
        "buggy_function": "    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n      if (!(type instanceof ObjectType)) {\n        if (type.autoboxesTo() != null) {\n          type = type.autoboxesTo();\n        } else {\n          return null;\n        }\n      }\n\n      // Ignore the prototype itself at all times.\n      if (\"prototype\".equals(field)) {\n        return null;\n      }\n\n      // We look up the prototype chain to find the highest place (if any) that\n      // this appears.  This will make references to overriden properties look\n      // like references to the initial property, so they are renamed alike.\n      ObjectType foundType = null;\n      ObjectType objType = ObjectType.cast(type);\n      while (objType != null && objType.getImplicitPrototype() != objType) {\n        if (objType.hasOwnProperty(field)) {\n          foundType = objType;\n        }\n        objType = objType.getImplicitPrototype();\n      }\n      // If the property does not exist on the referenced type but the original\n      // type is an object type, see if any subtype has the property.\n        // getGreatestSubtypeWithProperty does not guarantee that the property\n        // is defined on the returned type, it just indicates that it might be,\n        // so we have to double check.\n      return foundType;\n    }",
        "fixed_function": "    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n      if (!(type instanceof ObjectType)) {\n        if (type.autoboxesTo() != null) {\n          type = type.autoboxesTo();\n        } else {\n          return null;\n        }\n      }\n\n      // Ignore the prototype itself at all times.\n      if (\"prototype\".equals(field)) {\n        return null;\n      }\n\n      // We look up the prototype chain to find the highest place (if any) that\n      // this appears.  This will make references to overriden properties look\n      // like references to the initial property, so they are renamed alike.\n      ObjectType foundType = null;\n      ObjectType objType = ObjectType.cast(type);\n      while (objType != null && objType.getImplicitPrototype() != objType) {\n        if (objType.hasOwnProperty(field)) {\n          foundType = objType;\n        }\n        objType = objType.getImplicitPrototype();\n      }\n      // If the property does not exist on the referenced type but the original\n      // type is an object type, see if any subtype has the property.\n      if (foundType == null) {\n        ObjectType maybeType = ObjectType.cast(\n            registry.getGreatestSubtypeWithProperty(type, field));\n        // getGreatestSubtypeWithProperty does not guarantee that the property\n        // is defined on the returned type, it just indicates that it might be,\n        // so we have to double check.\n        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n          foundType = maybeType;\n        }\n      }\n      return foundType;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CheckUnreachableCodeTest::testInstanceOfThrowsException": {
        "path": "com/google/javascript/jscomp/CheckUnreachableCodeTest.java",
        "function_name": "testInstanceOfThrowsException",
        "src": "public void testInstanceOfThrowsException() {\n    testSame(\"function f() {try { if (value instanceof type) return true; } \" +\n             \"catch (e) { }}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CheckUnreachableCodeTest::testInstanceOfThrowsException --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_UNREACHABLE_CODE. unreachable code at testcode line 1 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_UNREACHABLE_CODE. unreachable code at testcode line 1 expected:<0> but was:<1>"
      },
      "com.google.javascript.jscomp.ControlFlowAnalysisTest::testInstanceOf": {
        "path": "com/google/javascript/jscomp/ControlFlowAnalysisTest.java",
        "function_name": "testInstanceOf",
        "src": "public void testInstanceOf() {\n    String src = \"try { x instanceof 'x' } catch (e) { }\";\n    ControlFlowGraph<Node> cfg = createCfg(src, true);\n    assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX);\n  }",
        "error_msg": "com.google.javascript.jscomp.ControlFlowAnalysisTest::testInstanceOf --> junit.framework.AssertionFailedError: No cross edges found",
        "clean_error_msg": "junit.framework.AssertionFailedError: No cross edges found"
      },
      "com.google.javascript.jscomp.DisambiguatePropertiesTest::testSupertypeReferenceOfSubtypeProperty": {
        "path": "com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
        "function_name": "testSupertypeReferenceOfSubtypeProperty",
        "src": "public void testSupertypeReferenceOfSubtypeProperty() {\n    String externs = \"\"\n        + \"/** @constructor */ function Ext() {}\"\n        + \"Ext.prototype.a;\";\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"/** @constructor \\n@extends Foo*/ function Bar() {}\\n\"\n        + \"Bar.prototype.a;\\n\"\n        + \"/** @param {Foo} foo */\"\n        + \"function foo(foo) {\\n\"\n        + \"  var x = foo.a;\\n\"\n        + \"}\\n\";\n    String result = \"\"\n        + \"function Foo() {}\\n\"\n        + \"function Bar() {}\\n\"\n        + \"Bar.prototype.Bar_prototype$a;\\n\"\n        + \"function foo(foo) {\\n\"\n        + \"  var x = foo.Bar_prototype$a;\\n\"\n        + \"}\\n\";\n    testSets(false, externs, js, result, \"{a=[[Bar.prototype]]}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.DisambiguatePropertiesTest::testSupertypeReferenceOfSubtypeProperty --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-106": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "start_loc": 899,
        "end_loc": 913,
        "buggy_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n\n      if (isClassOrEnum) {\n        return true;\n      }\n      return (type == Type.FUNCTION || aliasingGets == 0) &&\n          (parent == null || parent.canCollapseUnannotatedChildNames());\n    }",
        "fixed_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n      return (type == Type.FUNCTION || aliasingGets == 0) &&\n          (parent == null || parent.canCollapseUnannotatedChildNames());\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "start_loc": 188,
        "end_loc": 193,
        "buggy_function": "  public boolean recordBlockDescription(String description) {\n    if (parseDocumentation) {\n    populated = true;\n    }\n    return currentInfo.documentBlock(description);\n  }",
        "fixed_function": "  public boolean recordBlockDescription(String description) {\n    populated = true;\n    return currentInfo.documentBlock(description);\n  }",
        "comment": "/**\n   * Records a block-level description.\n   *\n   * @return {@code true} if the description was recorded.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CheckSideEffectsTest::testJSDocComments": {
        "path": "com/google/javascript/jscomp/CheckSideEffectsTest.java",
        "function_name": "testJSDocComments",
        "src": "public void testJSDocComments() {\n    test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n    test(\"function A() { /* This is a normal comment */ this.foo; }\", e);\n  }",
        "error_msg": "com.google.javascript.jscomp.CheckSideEffectsTest::testJSDocComments --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE. Suspicious code. This code lacks side-effects. Is there a bug? at testcode line 1 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE. Suspicious code. This code lacks side-effects. Is there a bug? at testcode line 1 expected:<0> but was:<1>"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testTwinReferenceCancelsChildCollapsing": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testTwinReferenceCancelsChildCollapsing",
        "src": "public void testTwinReferenceCancelsChildCollapsing() {\n    test(\"var a = {}; if (a.b = function() {}) { a.b.c = 3; a.b(a.b.c); }\",\n         \"var a$b; if (a$b = function() {}) { a$b.c = 3; a$b(a$b.c); }\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testTwinReferenceCancelsChildCollapsing --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testCrashInNestedAssign": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testCrashInNestedAssign",
        "src": "public void testCrashInNestedAssign() {\n    test(\"var a = {}; if (a.b = function() {}) a.b();\",\n         \"var a$b; if (a$b=function() {}) { a$b(); }\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testCrashInNestedAssign --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CollapsePropertiesTest::testCrashInCommaOperator": {
        "path": "com/google/javascript/jscomp/CollapsePropertiesTest.java",
        "function_name": "testCrashInCommaOperator",
        "src": "public void testCrashInCommaOperator() {\n    test(\"var a = {}; a.b = function() {},a.b();\",\n         \"var a$b; a$b=function() {},a$b();\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CollapsePropertiesTest::testCrashInCommaOperator --> java.lang.IllegalArgumentException",
        "clean_error_msg": "java.lang.IllegalArgumentException"
      }
    }
  },
  "Closure-110": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "start_loc": 352,
        "end_loc": 422,
        "buggy_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "fixed_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/Node.java",
        "start_loc": 549,
        "end_loc": 562,
        "buggy_function": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
        "fixed_function": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    if (n == null) {\n      throw new RuntimeException(\"node is not a child\");\n    }\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.ScopedAliasesTest::testHoistedFunctionDeclaration": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testHoistedFunctionDeclaration",
        "src": "public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testHoistedFunctionDeclaration --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>"
      },
      "com.google.javascript.jscomp.ScopedAliasesTest::testFunctionDeclaration": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testFunctionDeclaration",
        "src": "public void testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testFunctionDeclaration --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>"
      }
    }
  },
  "Closure-134": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/AmbiguateProperties.java",
        "start_loc": 195,
        "end_loc": 249,
        "buggy_function": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n\n    Set<String> reservedNames =\n        new HashSet<String>(externedNames.size() + quotedNames.size());\n    reservedNames.addAll(externedNames);\n    reservedNames.addAll(quotedNames);\n\n    int numRenamedPropertyNames = 0;\n    int numSkippedPropertyNames = 0;\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n    for (Property p : propertyMap.values()) {\n      if (!p.skipAmbiguating) {\n        ++numRenamedPropertyNames;\n        computeRelatedTypes(p.type);\n        propsByFreq.add(p);\n      } else {\n        ++numSkippedPropertyNames;\n        reservedNames.add(p.oldName);\n      }\n    }\n\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n    GraphColoring<Property, Void> coloring =\n        new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n    int numNewPropertyNames = coloring.color();\n\n    NameGenerator nameGen = new NameGenerator(\n        reservedNames, \"\", reservedCharacters);\n    for (int i = 0; i < numNewPropertyNames; ++i) {\n      colorMap.put(i, nameGen.generateNextName());\n    }\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\n      node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n      renamingMap.put(node.getValue().oldName, node.getValue().newName);\n    }\n\n    // Update the string nodes.\n    for (Node n : stringNodesToRename) {\n      String oldName = n.getString();\n      Property p = propertyMap.get(oldName);\n      if (p != null && p.newName != null) {\n        Preconditions.checkState(oldName.equals(p.oldName));\n        if (!p.newName.equals(oldName)) {\n          n.setString(p.newName);\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \"\n                + numNewPropertyNames + \" and skipped renaming \"\n                + numSkippedPropertyNames + \" properties.\");\n  }",
        "fixed_function": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n\n    Set<String> reservedNames =\n        new HashSet<String>(externedNames.size() + quotedNames.size());\n    reservedNames.addAll(externedNames);\n    reservedNames.addAll(quotedNames);\n\n    int numRenamedPropertyNames = 0;\n    int numSkippedPropertyNames = 0;\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n    for (Property p : propertyMap.values()) {\n      if (!p.skipAmbiguating) {\n        ++numRenamedPropertyNames;\n        propsByFreq.add(p);\n      } else {\n        ++numSkippedPropertyNames;\n        reservedNames.add(p.oldName);\n      }\n    }\n\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n    GraphColoring<Property, Void> coloring =\n        new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n    int numNewPropertyNames = coloring.color();\n\n    NameGenerator nameGen = new NameGenerator(\n        reservedNames, \"\", reservedCharacters);\n    for (int i = 0; i < numNewPropertyNames; ++i) {\n      colorMap.put(i, nameGen.generateNextName());\n    }\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\n      node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n      renamingMap.put(node.getValue().oldName, node.getValue().newName);\n    }\n\n    // Update the string nodes.\n    for (Node n : stringNodesToRename) {\n      String oldName = n.getString();\n      Property p = propertyMap.get(oldName);\n      if (p != null && p.newName != null) {\n        Preconditions.checkState(oldName.equals(p.oldName));\n        if (!p.newName.equals(oldName)) {\n          n.setString(p.newName);\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \"\n                + numNewPropertyNames + \" and skipped renaming \"\n                + numSkippedPropertyNames + \" properties.\");\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AmbiguateProperties.java",
        "start_loc": 352,
        "end_loc": 357,
        "buggy_function": "    public boolean isIndependentOf(Property prop) {\n      if (typesRelatedToSet.intersects(prop.typesSet)) {\n        return false;\n      }\n      return !getRelated(prop.type).intersects(typesInSet);\n    }",
        "fixed_function": "    public boolean isIndependentOf(Property prop) {\n      if (typesRelatedToSet.intersects(prop.typesSet)) {\n        return false;\n      }\n      return !prop.relatedTypesSet.intersects(typesInSet);\n    }",
        "comment": "/**\n     * Returns true if prop is in an independent set from all properties in\n     * this sub graph.  That is, if none of its types is contained in the\n     * related types for this sub graph and if none if its related types is one\n     * of the types in the sub graph.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AmbiguateProperties.java",
        "start_loc": 364,
        "end_loc": 367,
        "buggy_function": "    public void addNode(Property prop) {\n      typesInSet.or(prop.typesSet);\n      typesRelatedToSet.or(getRelated(prop.type));\n    }",
        "fixed_function": "    public void addNode(Property prop) {\n      typesInSet.or(prop.typesSet);\n      typesRelatedToSet.or(prop.relatedTypesSet);\n    }",
        "comment": "/**\n     * Adds the node to the sub graph, adding all of its types to the set of\n     * types in the sub graph and all of its related types to the related types\n     * for the sub graph.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AmbiguateProperties.java",
        "start_loc": 588,
        "end_loc": 600,
        "buggy_function": "    private void addNonUnionType(JSType newType) {\n      if (skipAmbiguating || isInvalidatingType(newType)) {\n        skipAmbiguating = true;\n        return;\n      }\n\n      if (type == null) {\n        type = newType;\n      } else {\n        type = type.getLeastSupertype(newType);\n      }\n      typesSet.set(getIntForType(newType));\n    }",
        "fixed_function": "    private void addNonUnionType(JSType newType) {\n      if (skipAmbiguating || isInvalidatingType(newType)) {\n        skipAmbiguating = true;\n        return;\n      }\n\n      int typeInt = getIntForType(newType);\n      if (!typesSet.get(typeInt)) {\n        computeRelatedTypes(newType);\n        typesSet.set(typeInt);\n        relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "start_loc": 553,
        "end_loc": 565,
        "buggy_function": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      }\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n\n      return null;\n    }",
        "fixed_function": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType instanceof FunctionType) {\n            return (FunctionType) propType;\n          }\n        }\n      }\n\n      return null;\n    }",
        "comment": "/**\n     * Find the function that's being overridden on this type, if any.\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.AmbiguatePropertiesTest::testImplementsAndExtends": {
        "path": "com/google/javascript/jscomp/AmbiguatePropertiesTest.java",
        "function_name": "testImplementsAndExtends",
        "src": "public void testImplementsAndExtends() {\n    String js = \"\"\n        + \"/** @interface */ function Foo() {}\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" */\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.y = function() { return 3; };\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" * @extends {Bar}\\n\"\n        + \" * @implements {Foo}\\n\"\n        + \" */\\n\"\n        + \"function SubBar(){ }\\n\"\n        + \"/** @param {Foo} x */ function f(x) { x.z = 3; }\\n\"\n        + \"/** @param {SubBar} x */ function g(x) { x.z = 3; }\";\n    String output = \"\"\n        + \"function Foo(){}\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.b = function() { return 3; };\\n\"\n        + \"function SubBar(){}\\n\"\n        + \"function f(x) { x.a = 3; }\\n\"\n        + \"function g(x) { x.a = 3; }\";\n    test(js, output);\n  }",
        "error_msg": "com.google.javascript.jscomp.AmbiguatePropertiesTest::testImplementsAndExtends --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testIssue86": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue86",
        "src": "public void testIssue86() throws Exception {\n    testTypes(\n        \"/** @interface */ function I() {}\" +\n        \"/** @return {number} */ I.prototype.get = function(){};\" +\n        \"/** @constructor \\n * @implements {I} */ function F() {}\" +\n        \"/** @override */ F.prototype.get = function() { return true; };\",\n        \"inconsistent return type\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue86 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      }
    }
  },
  "Closure-135": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java",
        "start_loc": 354,
        "end_loc": 367,
        "buggy_function": "  private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n      return;\n    }\n\n    for (Node child : node.children()) {\n      if (NodeUtil.isThis(child)) {\n        Node newName = Node.newString(Token.NAME, name);\n        node.replaceChild(child, newName);\n      } else {\n        replaceReferencesToThis(child, name);\n      }\n    }\n  }",
        "fixed_function": "  private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n      return;\n    }\n\n    for (Node child : node.children()) {\n      if (NodeUtil.isThis(child)) {\n        Node newName = Node.newString(Token.NAME, name);\n        newName.setJSType(child.getJSType());\n        node.replaceChild(child, newName);\n      } else {\n        replaceReferencesToThis(child, name);\n      }\n    }\n  }",
        "comment": "/**\n   * Replaces references to \"this\" with references to name.  Do not\n   * traverse function boundaries.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 407,
        "end_loc": 410,
        "buggy_function": "  @Override\n  public boolean hasProperty(String name) {\n    return super.hasProperty(name) || \"prototype\".equals(name);\n  }",
        "fixed_function": "  @Override\n  public boolean hasOwnProperty(String name) {\n    return super.hasOwnProperty(name) || \"prototype\".equals(name);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 466,
        "end_loc": 480,
        "buggy_function": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
        "fixed_function": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.equals(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest::testRewritePrototypeMethods2": {
        "path": "com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java",
        "function_name": "testRewritePrototypeMethods2",
        "src": "public void testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON);\n  }",
        "error_msg": "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest::testRewritePrototypeMethods2 --> junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = null, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = null, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = null, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = null, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testGoodExtends9": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testGoodExtends9",
        "src": "public void testGoodExtends9() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Super() {}\" +\n        \"Super.prototype.foo = function() {};\" +\n        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n        \"Sub.prototype = new Super();\" +\n        \"/** @override */ Sub.prototype.foo = function() {};\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testGoodExtends9 --> junit.framework.AssertionFailedError: unexpected warnings(s):",
        "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      }
    }
  },
  "Closure-136": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/MethodCompilerPass.java",
        "start_loc": 101,
        "end_loc": 128,
        "buggy_function": "  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }",
        "fixed_function": "  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n    } else {\n      nonMethodProperties.add(name);\n    }\n  }",
        "comment": "/**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/RenameVars.java",
        "start_loc": 170,
        "end_loc": 226,
        "buggy_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }",
        "fixed_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n        if (local) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n          String newName =\n            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n                name);\n          if (!newName.equals(name)) {\n            n.setString(newName);\n          }\n        }\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_1": {
        "path": "com/google/javascript/jscomp/InlineGettersTest.java",
        "function_name": "testIssue2508576_1",
        "src": "public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_1 --> junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(a)]> but was:<[]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(a)]> but was:<[]>"
      },
      "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_3": {
        "path": "com/google/javascript/jscomp/InlineGettersTest.java",
        "function_name": "testIssue2508576_3",
        "src": "public void testIssue2508576_3() {\n    // Anonymous object definition without side-effect should be removed.\n    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_3 --> java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      },
      "com.google.javascript.jscomp.MethodCheckTest::testSeparateMethods": {
        "path": "com/google/javascript/jscomp/MethodCheckTest.java",
        "function_name": "testSeparateMethods",
        "src": "public void testSeparateMethods() {\n    testSame(\"var f = new Foo();f.oneOrTwoArg2(1);\");\n    testSame(\"var f = new Baz();f.oneOrTwoArg2(1, 2);\");\n    testSame(\"Boz.staticMethod1(1);\");\n    testSame(\"Boz.staticMethod2(1, 2);\");\n\n    // Can't detect these incorrect usuages as they are defined indirectly.\n    testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n    testSame(\"Boz.staticMethod1(1, 2);\");\n    testSame(\"Boz.staticMethod2(1);\");\n  }",
        "error_msg": "com.google.javascript.jscomp.MethodCheckTest::testSeparateMethods --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>"
      },
      "com.google.javascript.jscomp.RenameVarsTest::testDollarSignSuperExport2": {
        "path": "com/google/javascript/jscomp/RenameVarsTest.java",
        "function_name": "testDollarSignSuperExport2",
        "src": "public void testDollarSignSuperExport2() {\n    boolean normalizedExpectedJs = false;\n    super.enableNormalize(false);\n\n    useGoogleCodingConvention = false;\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var c = function($super,    a,         b){};\" +\n            \"var d = function($super,    a){};\");\n\n    localRenamingOnly = false;\n    test(\"var $super = 1\", \"var a = 1\");\n\n    useGoogleCodingConvention = true;\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var d = function(a,     b,    c         ){};\" +\n            \"var e = function(     a,    b){};\");\n\n    super.disableNormalize();\n  }",
        "error_msg": "com.google.javascript.jscomp.RenameVarsTest::testDollarSignSuperExport2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-137": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "start_loc": 266,
        "end_loc": 268,
        "buggy_function": "    private static String getOrginalNameInternal(String name, int index) {\n      return name.substring(0, index);\n    }",
        "fixed_function": "    private boolean containsSeparator(String name) {\n      return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "start_loc": 274,
        "end_loc": 278,
        "buggy_function": "    private static String getNameSuffix(String name, int index) {\n      return name.substring(\n          index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),\n          name.length());\n    }",
        "fixed_function": "    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      referenceStack.push(referencedNames);\n      referencedNames = Sets.newHashSet();\n    }",
        "comment": "/**\n     * Prepare a set for the new scope.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "start_loc": 284,
        "end_loc": 344,
        "buggy_function": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n          Scope scope = t.getScope();\n          Var var = t.getScope().getVar(oldName);\n          if (var == null || var.isGlobal()) {\n        return;\n      }\n\n          if (nameMap.containsKey(var)) {\n            node.setString(nameMap.get(var));\n          } else {\n            int index = indexOfSeparator(oldName);\n            String newName = getOrginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n\n      // Merge any names that were referenced but not declared in the current\n      // scope.\n      // If there isn't anything left in the stack we will be going into the\n      // global scope: don't try to build a set of referenced names for the\n      // global scope.\n            boolean recurseScopes = false;\n            if (!suffix.matches(\"\\\\d+\")) {\n              recurseScopes = true;\n            }\n\n    /**\n     * For the Var declared in the current scope determine if it is possible\n     * to revert the name to its orginal form without conflicting with other\n     * values.\n     */\n        // Check if the new name is valid and if it would cause conflicts.\n            if (var.scope.isDeclared(newName, recurseScopes) ||\n                !TokenStream.isJSIdentifier(newName)) {\n              newName = oldName;\n            } else {\n              var.scope.declare(newName, var.nameNode, null, null);\n          // Adding a reference to the new name to prevent either the parent\n          // scopes or the current scope renaming another var to this new name.\n              Node parentNode = var.getParentNode();\n              if (parentNode.getType() == Token.FUNCTION &&\n                  parentNode == var.scope.getRootNode()) {\n                var.getNameNode().setString(newName);\n              }\n\n              node.setString(newName);\n          compiler.reportCodeChange();\n        }\n\n            nameMap.put(var, newName);\n\n      }\n\n        // Add all referenced names to the set so it is possible to check for\n        // conflicts.\n        // Store only references to candidate names in the node map.\n        }\n      }\n    }",
        "fixed_function": "    public void exitScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        handleScopeVar(v);\n      }\n\n      // Merge any names that were referenced but not declared in the current\n      // scope.\n      Set<String> current = referencedNames;\n      referencedNames = referenceStack.pop();\n      // If there isn't anything left in the stack we will be going into the\n      // global scope: don't try to build a set of referenced names for the\n      // global scope.\n      if (!referenceStack.isEmpty()) {\n        referencedNames.addAll(current);\n      }\n    }",
        "comment": "/**\n     * Rename vars for the current scope, and merge any referenced \n     * names into the parent scope reference set.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "start_loc": 390,
        "end_loc": 405,
        "buggy_function": "    @Override\n    public void addDeclaredName(String name) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n          }\n          declarations.put(name, newName);\n        }\n      }\n    }",
        "fixed_function": "    void handleScopeVar(Var v) {\n      String name  = v.getName();\n      if (containsSeparator(name)) {\n        String newName = getOrginalName(name);\n        // Check if the new name is valid and if it would cause conflicts.\n        if (TokenStream.isJSIdentifier(newName) &&\n            !referencedNames.contains(newName) && \n            !newName.equals(ARGUMENTS)) {\n          referencedNames.remove(name);\n          // Adding a reference to the new name to prevent either the parent\n          // scopes or the current scope renaming another var to this new name.\n          referencedNames.add(newName);\n          List<Node> references = nameMap.get(name);\n          Preconditions.checkState(references != null);\n          for (Node n : references) {\n            Preconditions.checkState(n.getType() == Token.NAME);\n            n.setString(newName);\n          }\n          compiler.reportCodeChange();\n        }\n        nameMap.remove(name);\n      }\n    }",
        "comment": "/**\n     * For the Var declared in the current scope determine if it is possible\n     * to revert the name to its orginal form without conflicting with other\n     * values.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "start_loc": 460,
        "end_loc": 465,
        "buggy_function": "    @Override\n    public void addDeclaredName(String name) {\n      if (!declarations.containsKey(name)) {\n        declarations.put(name, getUniqueName(name));\n      }\n    }",
        "fixed_function": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (NodeUtil.isReferenceName(node)) {\n        String name = node.getString();\n        // Add all referenced names to the set so it is possible to check for\n        // conflicts.\n        referencedNames.add(name);\n        // Store only references to candidate names in the node map.\n        if (containsSeparator(name)) {\n          addCandidateNameReference(name, node);\n        }\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/Normalize.java",
        "start_loc": 78,
        "end_loc": 104,
        "buggy_function": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root,\n        new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function \n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes. \n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
        "fixed_function": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root,\n        new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function \n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes. \n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testOnlyInversion3": {
        "path": "com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java",
        "function_name": "testOnlyInversion3",
        "src": "public void testOnlyInversion3() {\n    invert = true;\n    test(\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a$$2;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a$$3;\" +\n        \"  }\" +\n        \"}\",\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testOnlyInversion3 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testOnlyInversion4": {
        "path": "com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java",
        "function_name": "testOnlyInversion4",
        "src": "public void testOnlyInversion4() {\n    invert = true;\n    test(\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a;a$$1++\" +\n        \"  }\" +\n        \"}\",\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a;a$$1++\" +\n        \"  }\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testOnlyInversion4 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testArguments": {
        "path": "com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java",
        "function_name": "testArguments",
        "src": "public void testArguments() {\n    // Set the test type\n    this.useDefaultRenamer = true;\n\n    invert = true;\n    // Don't distinguish between \"arguments\", it can't be made unique.\n    testSameWithInversion(\n        \"function foo(){var arguments;function bar(){var arguments;}}\");\n    // Don't introduce new references to arguments, it is special.\n    testSameWithInversion(\n        \"function foo(){var arguments$$1;}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testArguments --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testMakeLocalNamesUniqueWithContext1": {
        "path": "com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java",
        "function_name": "testMakeLocalNamesUniqueWithContext1",
        "src": "public void testMakeLocalNamesUniqueWithContext1() {\n    // Set the test type\n    this.useDefaultRenamer = true;\n\n    invert = true;\n    test(\n        \"var a;function foo(){var a$$inline_1; a = 1}\",\n        \"var a;function foo(){var a$$inline_1; a = 1}\");\n    test(\n        \"var a;function foo(){var a$$inline_1;}\",\n        \"var a;function foo(){var a;}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testMakeLocalNamesUniqueWithContext1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.NormalizeTest::testRemoveDuplicateVarDeclarations2": {
        "path": "com/google/javascript/jscomp/NormalizeTest.java",
        "function_name": "testRemoveDuplicateVarDeclarations2",
        "src": "public void testRemoveDuplicateVarDeclarations2() {\n    test(\"var e = 1; function f(){ try {} catch (e) {} var e = 2 }\",\n         \"var e = 1; function f(){ try {} catch (e$$2) {} var e$$1 = 2 }\");\n  }",
        "error_msg": "com.google.javascript.jscomp.NormalizeTest::testRemoveDuplicateVarDeclarations2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-138": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java",
        "start_loc": 200,
        "end_loc": 225,
        "buggy_function": "  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n      Node callee = condition.getFirstChild();\n      Node param = condition.getLastChild();\n      if (callee.getType() == GETPROP && param.isQualifiedName()) {\n        JSType paramType =  getTypeIfRefinable(param, blindScope);\n        if (paramType != null) {\n        Node left = callee.getFirstChild();\n        Node right = callee.getLastChild();\n        if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n            right.getType() == STRING) {\n          Function<TypeRestriction, JSType> restricter =\n              restricters.get(right.getString());\n          if (restricter != null) {\n            return restrictParameter(param, paramType, blindScope, restricter,\n                outcome);\n            }\n          }\n        }\n      }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }",
        "fixed_function": "  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n      Node callee = condition.getFirstChild();\n      Node param = condition.getLastChild();\n      if (callee.getType() == GETPROP && param.isQualifiedName()) {\n        JSType paramType =  getTypeIfRefinable(param, blindScope);\n        Node left = callee.getFirstChild();\n        Node right = callee.getLastChild();\n        if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n            right.getType() == STRING) {\n          Function<TypeRestriction, JSType> restricter =\n              restricters.get(right.getString());\n          if (restricter != null) {\n            return restrictParameter(param, paramType, blindScope, restricter,\n                outcome);\n          }\n        }\n      }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/TypeInference.java",
        "start_loc": 621,
        "end_loc": 652,
        "buggy_function": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null &&\n          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped in a weird way, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable.\n        // var t = null; function f() { (t); }\n\n          type = var.getType();\n          if (type == null) {\n            type = getNativeType(UNKNOWN_TYPE);\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
        "fixed_function": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped in a weird way, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable =\n            isInferred && unflowableVarNames.contains(varName);\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable.\n        // var t = null; function f() { (t); }\n        boolean nonLocalInferredSlot =\n            isInferred &&\n            syntacticScope.getParent() != null &&\n            var == syntacticScope.getParent().getSlot(varName);\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = getNativeType(UNKNOWN_TYPE);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsArrayOnNull": {
        "path": "com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java",
        "function_name": "testGoogIsArrayOnNull",
        "src": "public void testGoogIsArrayOnNull() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        null,\n        ARRAY_TYPE,\n        null);\n  }",
        "error_msg": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsArrayOnNull --> junit.framework.AssertionFailedError: expected:<Array> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<Array> but was:<null>"
      },
      "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsFunctionOnNull": {
        "path": "com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java",
        "function_name": "testGoogIsFunctionOnNull",
        "src": "public void testGoogIsFunctionOnNull() throws Exception {\n    testClosureFunction(\"goog.isFunction\",\n        null,\n        U2U_CONSTRUCTOR_TYPE,\n        null);\n  }",
        "error_msg": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsFunctionOnNull --> junit.framework.AssertionFailedError: expected:<Function> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<Function> but was:<null>"
      },
      "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsObjectOnNull": {
        "path": "com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java",
        "function_name": "testGoogIsObjectOnNull",
        "src": "public void testGoogIsObjectOnNull() throws Exception {\n    testClosureFunction(\"goog.isObject\",\n        null,\n        OBJECT_TYPE,\n        null);\n  }",
        "error_msg": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsObjectOnNull --> junit.framework.AssertionFailedError: expected:<Object> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<Object> but was:<null>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testIssue124b": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue124b",
        "src": "public void testIssue124b() throws Exception {\n    testTypes(\n        \"var t = null;\" +\n        \"function test() {\" +\n        \"  if (t != null) { t = null; }\" +\n        \"  t = undefined;\" +\n        \"}\",\n        \"condition always evaluates to false\\n\" +\n        \"left : (null|undefined)\\n\" +\n        \"right: null\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue124b --> junit.framework.ComparisonFailure: expected:<...tes to false",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...tes to false"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testIssue124": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue124",
        "src": "public void testIssue124() throws Exception {\n    testTypes(\n        \"var t = null;\" +\n        \"function test() {\" +\n        \"  if (t != null) { t = null; }\" +\n        \"  t = 1;\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue124 --> junit.framework.AssertionFailedError: unexpected warnings(s):",
        "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      }
    }
  },
  "Closure-141": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "start_loc": 584,
        "end_loc": 613,
        "buggy_function": "  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.NEW:\n        // Function calls or constructor can reference changed values.\n        // TODO(johnlenz): Add some mechanism for determining that functions\n        // are unaffected by side effects.\n        return true;\n      case Token.NAME:\n        // Non-constant names values may have been changed.\n        return !NodeUtil.isConstantName(n)\n            && !knownConstants.contains(n.getString());\n\n      // Properties on constant NAMEs can still be side-effected.\n      case Token.GETPROP:\n      case Token.GETELEM:\n        return true;\n\n        // Anonymous functions definitions are not changed by side-effects,\n        // and named functions are not part of expressions.\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (canBeSideEffected(c, knownConstants)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
        "fixed_function": "  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.NEW:\n        // Function calls or constructor can reference changed values.\n        // TODO(johnlenz): Add some mechanism for determining that functions\n        // are unaffected by side effects.\n        return true;\n      case Token.NAME:\n        // Non-constant names values may have been changed.\n        return !NodeUtil.isConstantName(n)\n            && !knownConstants.contains(n.getString());\n\n      // Properties on constant NAMEs can still be side-effected.\n      case Token.GETPROP:\n      case Token.GETELEM:\n        return true;\n\n      case Token.FUNCTION:\n        // Anonymous functions definitions are not changed by side-effects,\n        // and named functions are not part of expressions.\n        Preconditions.checkState(NodeUtil.isAnonymousFunction(n));\n        return false;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (canBeSideEffected(c, knownConstants)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
        "comment": "/**\n   * @param knownConstants A set of names known to be constant value at\n   * node 'n' (such as locals that are last written before n can execute).\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/PureFunctionIdentifier.java",
        "start_loc": 175,
        "end_loc": 198,
        "buggy_function": "  private static Collection<Definition> getCallableDefinitions(\n      DefinitionProvider definitionProvider, Node name) {\n      List<Definition> result = Lists.newArrayList();\n\n      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n      }\n      Collection<Definition> decls =\n          definitionProvider.getDefinitionsReferencedAt(name);\n      if (decls == null) {\n        return null;\n      }\n\n      for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n          result.add(current);\n        } else {\n          return null;\n        }\n      }\n\n      return result;\n  }",
        "fixed_function": "  private static Collection<Definition> getCallableDefinitions(\n      DefinitionProvider definitionProvider, Node name) {\n    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n      List<Definition> result = Lists.newArrayList();\n\n      Collection<Definition> decls =\n          definitionProvider.getDefinitionsReferencedAt(name);\n      if (decls == null) {\n        return null;\n      }\n\n      for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n          result.add(current);\n        } else {\n          return null;\n        }\n      }\n\n      return result;\n    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {\n      Node firstVal;\n      if (name.getType() == Token.HOOK) {\n        firstVal = name.getFirstChild().getNext();\n      } else {\n        firstVal = name.getFirstChild();\n      }\n\n      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,\n                                                            firstVal);\n      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,\n                                                            firstVal.getNext());\n      if (defs1 != null && defs2 != null) {\n        defs1.addAll(defs2);\n        return defs1;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }",
        "comment": "/**\n   * Query the DefinitionProvider for the list of definitions that\n   * correspond to a given qualified name subtree.  Return null if\n   * DefinitionProvider does not contain an entry for a given name,\n   * one or more of the values returned by getDeclarations is not\n   * callable, or the \"name\" node is not a GETPROP or NAME.\n   *\n   * @param definitionProvider The name reference graph\n   * @param name Query node\n   * @return non-empty definition list or null\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2": {
        "path": "com/google/javascript/jscomp/ExpresssionDecomposerTest.java",
        "function_name": "testCanExposeExpression2",
        "src": "public void testCanExposeExpression2() {\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"var x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"if(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"function (){ return foo();}\", \"foo\");\n\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() && 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() || 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() ? 0 : 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"(function(a){b = a})(foo())\", \"foo\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2 --> junit.framework.AssertionFailedError: expected:<MOVABLE> but was:<DECOMPOSABLE>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<MOVABLE> but was:<DECOMPOSABLE>"
      },
      "com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7": {
        "path": "com/google/javascript/jscomp/ExpresssionDecomposerTest.java",
        "function_name": "testCanExposeExpression7",
        "src": "public void testCanExposeExpression7() {\n    // Verify calls to anonymous function are movable.\n    helperCanExposeAnonymousFunctionExpression(\n        DecompositionType.MOVABLE,\n        \"(function(map){descriptions_=map})(\\n\" +\n            \"function(){\\n\" +\n                \"var ret={};\\n\" +\n                \"ret[INIT]='a';\\n\" +\n                \"ret[MIGRATION_BANNER_DISMISS]='b';\\n\" +\n                \"return ret\\n\" +\n            \"}()\\n\" +\n        \");\", 2);\n  }",
        "error_msg": "com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7 --> junit.framework.AssertionFailedError: expected:<MOVABLE> but was:<DECOMPOSABLE>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<MOVABLE> but was:<DECOMPOSABLE>"
      },
      "com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall": {
        "path": "com/google/javascript/jscomp/InlineFunctionsTest.java",
        "function_name": "testDecomposeAnonymousInCall",
        "src": "public void testDecomposeAnonymousInCall() {\n    test(\n        \"(function(map){descriptions_=map})(\\n\" +\n           \"function(){\\n\" +\n              \"var ret={};\\n\" +\n              \"ret[ONE]='a';\\n\" +\n              \"ret[TWO]='b';\\n\" +\n              \"return ret\\n\" +\n           \"}()\\n\" +\n        \");\",\n        \"{\" +\n        \"var JSCompiler_inline_result_0;\" +\n        \"var ret$$inline_2={};\\n\" +\n        \"ret$$inline_2[ONE]='a';\\n\" +\n        \"ret$$inline_2[TWO]='b';\\n\" +\n        \"JSCompiler_inline_result_0 = ret$$inline_2;\\n\" +\n        \"}\" +\n        \"{\" +\n        \"descriptions_=JSCompiler_inline_result_0;\" +\n        \"}\"\n        );\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall --> java.lang.IllegalStateException: Call site missed.",
        "clean_error_msg": "java.lang.IllegalStateException: Call site missed."
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects": {
        "path": "com/google/javascript/jscomp/PureFunctionIdentifierTest.java",
        "function_name": "testCallFunctionFOrGViaHookWithSideEffects",
        "src": "public void testCallFunctionFOrGViaHookWithSideEffects() throws Exception {\n    String source = \"var x = 0;\\n\" +\n        \"function f(){x = 10}\\n\" +\n        \"function g(){}\\n\" +\n        \"function h(){ (false ? f : g)() }\\n\" +\n        \"function i(){ (false ? g : f)() }\\n\" +\n        \"function j(){ (false ? f : f)() }\\n\" +\n        \"function k(){ (false ? g : g)() }\\n\" +\n        \"h(); i(); j(); k()\";\n\n    checkMarkedCalls(source, ImmutableList.<String>of(\"(g : g)\", \"k\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects --> junit.framework.AssertionFailedError: expected:<[(g : g), k]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[(g : g), k]> but was:<[]>"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH": {
        "path": "com/google/javascript/jscomp/PureFunctionIdentifierTest.java",
        "function_name": "testCallFunctionForGorH",
        "src": "public void testCallFunctionForGorH() throws Exception {\n    String source = \"function f(){}\\n\" +\n        \"function g(){}\\n\" +\n        \"function h(){}\\n\" +\n        \"function i(){ (false ? f : (g || h))() }\\n\" +\n        \"i()\";\n\n    checkMarkedCalls(source, ImmutableList.<String>of(\"(f : (g || h))\", \"i\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH --> junit.framework.AssertionFailedError: expected:<[(f : (g || h)), i]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[(f : (g || h)), i]> but was:<[]>"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG": {
        "path": "com/google/javascript/jscomp/PureFunctionIdentifierTest.java",
        "function_name": "testCallFunctionFOrG",
        "src": "public void testCallFunctionFOrG() throws Exception {\n    String source = \"function f(){}\\n\" +\n        \"function g(){}\\n\" +\n        \"function h(){ (f || g)() }\\n\" +\n        \"h()\";\n\n    checkMarkedCalls(source, ImmutableList.<String>of(\"(f || g)\", \"h\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG --> junit.framework.AssertionFailedError: expected:<[(f || g), h]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[(f || g), h]> but was:<[]>"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook": {
        "path": "com/google/javascript/jscomp/PureFunctionIdentifierTest.java",
        "function_name": "testCallFunctionFOrGViaHook",
        "src": "public void testCallFunctionFOrGViaHook() throws Exception {\n    String source = \"function f(){}\\n\" +\n        \"function g(){}\\n\" +\n        \"function h(){ (false ? f : g)() }\\n\" +\n        \"h()\";\n\n    checkMarkedCalls(source, ImmutableList.<String>of(\"(f : g)\", \"h\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook --> junit.framework.AssertionFailedError: expected:<[(f : g), h]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[(f : g), h]> but was:<[]>"
      },
      "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects": {
        "path": "com/google/javascript/jscomp/PureFunctionIdentifierTest.java",
        "function_name": "testCallFunctionFOrGWithSideEffects",
        "src": "public void testCallFunctionFOrGWithSideEffects() throws Exception {\n    String source = \"var x = 0;\\n\" +\n        \"function f(){x = 10}\\n\" +\n        \"function g(){}\\n\" +\n        \"function h(){ (f || g)() }\\n\" +\n        \"function i(){ (g || f)() }\\n\" +\n        \"function j(){ (f || f)() }\\n\" +\n        \"function k(){ (g || g)() }\\n\" +\n        \"h(); i(); j(); k()\";\n\n    checkMarkedCalls(source, ImmutableList.<String>of(\"(g || g)\", \"k\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects --> junit.framework.AssertionFailedError: expected:<[(g || g), k]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[(g || g), k]> but was:<[]>"
      }
    }
  },
  "Closure-142": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "start_loc": 90,
        "end_loc": 120,
        "buggy_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }",
        "fixed_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n      liveness.markAllParametersEscaped();\n    }\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "start_loc": 1112,
        "end_loc": 1206,
        "buggy_function": "  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
        "fixed_function": "  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n          if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
        "comment": "/**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CoalesceVariableNamesTest::testParameter4": {
        "path": "com/google/javascript/jscomp/CoalesceVariableNamesTest.java",
        "function_name": "testParameter4",
        "src": "public void testParameter4() {\n    // Make sure that we do not merge two-arg functions because of the\n    // IE sort bug (see comments in computeEscaped)\n    test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CoalesceVariableNamesTest::testParameter4 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseWithAnnotation": {
        "path": "com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java",
        "function_name": "testParseLicenseWithAnnotation",
        "src": "public void testParseLicenseWithAnnotation() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo \\n * @author Charlie Brown */\";\n    parse(comment);\n    assertEquals(\" Foo \\n @author Charlie Brown \",\n        node.getJSDocInfo().getLicense());\n  }",
        "error_msg": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseWithAnnotation --> junit.framework.ComparisonFailure: expected:< Foo ",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:< Foo"
      }
    }
  },
  "Closure-143": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "start_loc": 847,
        "end_loc": 895,
        "buggy_function": "  @VisibleForTesting\n  static void createDefineReplacements(List<String> definitions,\n      CompilerOptions options) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        if (assignment.length == 1) {\n          options.setDefineToBooleanLiteral(defName, true);\n          continue;\n        } else {\n          String defValue = assignment[1];\n\n          if (defValue.equals(\"true\")) {\n            options.setDefineToBooleanLiteral(defName, true);\n            continue;\n          } else if (defValue.equals(\"false\")) {\n            options.setDefineToBooleanLiteral(defName, false);\n            continue;\n          } else if (defValue.length() > 1\n              && ((defValue.charAt(0) == '\\'' &&\n                  defValue.charAt(defValue.length() - 1) == '\\'')\n            )) {\n            // If the value starts and ends with a single quote,\n            // we assume that it's a string.\n            String maybeStringVal =\n                defValue.substring(1, defValue.length() - 1);\n            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n              continue;\n            }\n          } else {\n            try {\n              options.setDefineToDoubleLiteral(defName,\n                  Double.parseDouble(defValue));\n              continue;\n            } catch (NumberFormatException e) {\n              // do nothing, it will be caught at the end\n            }\n          }\n        }\n      }\n\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
        "fixed_function": "  @VisibleForTesting\n  static void createDefineReplacements(List<String> definitions,\n      CompilerOptions options) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        if (assignment.length == 1) {\n          options.setDefineToBooleanLiteral(defName, true);\n          continue;\n        } else {\n          String defValue = assignment[1];\n\n          if (defValue.equals(\"true\")) {\n            options.setDefineToBooleanLiteral(defName, true);\n            continue;\n          } else if (defValue.equals(\"false\")) {\n            options.setDefineToBooleanLiteral(defName, false);\n            continue;\n          } else if (defValue.length() > 1\n              && ((defValue.charAt(0) == '\\'' &&\n                  defValue.charAt(defValue.length() - 1) == '\\'')\n                  || (defValue.charAt(0) == '\\\"' &&\n                      defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n            // If the value starts and ends with a single quote,\n            // we assume that it's a string.\n            String maybeStringVal =\n                defValue.substring(1, defValue.length() - 1);\n            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n              continue;\n            }\n          } else {\n            try {\n              options.setDefineToDoubleLiteral(defName,\n                  Double.parseDouble(defValue));\n              continue;\n            } catch (NumberFormatException e) {\n              // do nothing, it will be caught at the end\n            }\n          }\n        }\n      }\n\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
        "comment": "/**\n   * Create a map of constant names to constant values from a textual\n   * description of the map.\n   *\n   * @param definitions A list of overriding definitions for defines in\n   *     the form <name>[=<val>], where <val> is a number, boolean, or\n   *     single-quoted string without single quotes.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/RemoveConstantExpressions.java",
        "start_loc": 84,
        "end_loc": 94,
        "buggy_function": "    private void trySimplify(Node parent, Node node) {\n      if (node.getType() != Token.EXPR_RESULT) {\n        return;\n      }\n\n      Node exprBody = node.getFirstChild();\n      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n      ) {\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n      }\n    }",
        "fixed_function": "    private void trySimplify(Node parent, Node node) {\n      if (node.getType() != Token.EXPR_RESULT) {\n        return;\n      }\n\n      Node exprBody = node.getFirstChild();\n      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n          || exprBody.getType() == Token.NEW\n          || exprBody.getType() == Token.CALL) {\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n      }\n    }",
        "comment": "/**\n     * Attempts to replace the input node with a simpler but functionally\n     * equivalent set of nodes.\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testDefineFlag3": {
        "path": "com/google/javascript/jscomp/CommandLineRunnerTest.java",
        "function_name": "testDefineFlag3",
        "src": "public void testDefineFlag3() {\n    args.add(\"--define=FOO=\\\"x'\\\"\");\n    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n         \"var FOO = \\\"x'\\\";\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CommandLineRunnerTest::testDefineFlag3 --> java.lang.RuntimeException: --define flag syntax invalid: FOO=x'",
        "clean_error_msg": "java.lang.RuntimeException: --define flag syntax invalid: FOO=x'"
      },
      "com.google.javascript.jscomp.RemoveConstantExpressionsTest::testCall1": {
        "path": "com/google/javascript/jscomp/RemoveConstantExpressionsTest.java",
        "function_name": "testCall1",
        "src": "public void testCall1() {\n    test(\"Math.sin(0);\", \"\");\n  }",
        "error_msg": "com.google.javascript.jscomp.RemoveConstantExpressionsTest::testCall1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.RemoveConstantExpressionsTest::testNew1": {
        "path": "com/google/javascript/jscomp/RemoveConstantExpressionsTest.java",
        "function_name": "testNew1",
        "src": "public void testNew1() {\n    test(\"new Date;\", \"\");\n  }",
        "error_msg": "com.google.javascript.jscomp.RemoveConstantExpressionsTest::testNew1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-144": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "start_loc": 198,
        "end_loc": 207,
        "buggy_function": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ?\n        info.getReturnType().evaluate(scope, typeRegistry) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
        "fixed_function": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ?\n        info.getReturnType().evaluate(scope, typeRegistry) : null;\n    if (templateTypeName != null &&\n        returnType != null &&\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
        "comment": "/**\n   * Infer the return type from JSDocInfo.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "start_loc": 472,
        "end_loc": 510,
        "buggy_function": "  FunctionType buildAndRegister() {\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n      if (scope.isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(sourceNode)\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType)\n          .withTypeOfThis(thisType)\n          .withTemplateName(templateTypeName)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeName();\n\n    return fnType;\n  }",
        "fixed_function": "  FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) {\n    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n      return this;\n    }\n    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n    if (returnType == null) {\n      boolean hasNonEmptyReturns = false;\n      List<Node> worklist = Lists.newArrayList(functionBlock);\n      while (!worklist.isEmpty()) {\n        Node current = worklist.remove(worklist.size() - 1);\n        int cType = current.getType();\n        if (cType == Token.RETURN && current.getFirstChild() != null ||\n            cType == Token.THROW) {\n          hasNonEmptyReturns = true;\n          break;\n        } else if (NodeUtil.isStatementBlock(current) ||\n            NodeUtil.isControlStructure(current)) {\n          for (Node child = current.getFirstChild();\n               child != null; child = child.getNext()) {\n            worklist.add(child);\n          }\n        }\n      }\n\n      if (!hasNonEmptyReturns) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred = true;\n      }\n    }\n    return this;\n  }",
        "comment": "/**\n   * If we haven't found a return value yet, try to look at the \"return\"\n   * statements in the function.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "start_loc": 550,
        "end_loc": 644,
        "buggy_function": "    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Handle function aliases.\n      if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        if (info == null ||\n            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          // We don't really have any type information in the annotation.\n          // Before we give up on this function, look at the object we're\n          // assigning it to. For example, if the function looks like this:\n          // SubFoo.prototype.bar = function() { ... };\n          // We can use type information on Foo.prototype.bar and apply it\n          // to this function.\n          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              FunctionType propType = null;\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                propType = findOverriddenFunction(ownerType, propName);\n              }\n\n              if (propType != null) {\n                functionType =\n                    new FunctionTypeBuilder(\n                        name, compiler, errorRoot, sourceName, scope)\n                    .setSourceNode(fnRoot)\n                    .inferFromOverriddenFunction(propType, parametersNode)\n                    .inferThisType(info, owner)\n                    .buildAndRegister();\n              }\n            }\n          }\n        }\n      } // end if (functionType == null)\n\n      if (functionType == null) {\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }",
        "fixed_function": "    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Handle function aliases.\n      if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        if (info == null ||\n            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          // We don't really have any type information in the annotation.\n          // Before we give up on this function, look at the object we're\n          // assigning it to. For example, if the function looks like this:\n          // SubFoo.prototype.bar = function() { ... };\n          // We can use type information on Foo.prototype.bar and apply it\n          // to this function.\n          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              FunctionType propType = null;\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                propType = findOverriddenFunction(ownerType, propName);\n              }\n\n              if (propType != null) {\n                functionType =\n                    new FunctionTypeBuilder(\n                        name, compiler, errorRoot, sourceName, scope)\n                    .setSourceNode(fnRoot)\n                    .inferFromOverriddenFunction(propType, parametersNode)\n                    .inferThisType(info, owner)\n                    .inferReturnStatements(fnBlock)\n                    .buildAndRegister();\n              }\n            }\n          }\n        }\n      } // end if (functionType == null)\n\n      if (functionType == null) {\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .inferReturnStatements(fnBlock)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }",
        "comment": "/**\n     * Gets the function type from the function node and its attached\n     * {@link JSDocInfo}.\n     * @param name the function's name\n     * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 515,
        "end_loc": 521,
        "buggy_function": "  FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, call.parameters, newReturnType, inferred),\n        typeOfThis, null, false, false);\n  }",
        "fixed_function": "  FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(\n        registry, null, source,\n        new ArrowType(\n            registry, call.parameters, newReturnType, inferred),\n        typeOfThis, null, false, false);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsAssign": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsAssign",
        "src": "public void testTypeAnnotationsAssign() {\n    assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"var Foo = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsAssign --> junit.framework.ComparisonFailure: expected:</**",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsMember": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsMember",
        "src": "public void testTypeAnnotationsMemberSubclass() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\"\n        + \"/** @constructor \\n @extends {a.Foo} */ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsMember --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testOptionalTypesAnnotation": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testOptionalTypesAnnotation",
        "src": "public void testOptionalTypesAnnotation() {\n    assertTypeAnnotations(\n        \"/**\\n\" +\n        \" * @param {string=} x \\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {string=} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testOptionalTypesAnnotation --> junit.framework.ComparisonFailure: expected:<...param {string=} x",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...param {string=} x"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTempConstructor": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTempConstructor",
        "src": "public void testTempConstructor() {\n    assertTypeAnnotations(\n        \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n        \" /**\\n * @constructor\\n */\\nfunction t2() {}\\n\" +\n        \" t1.prototype = t2.prototype}\",\n        \"/**\\n * @return {undefined}\\n */\\nvar x = function() {\\n\" +\n        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n        \"function t1() {\\n  }\\n\" +\n        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n        \"function t2() {\\n  }\\n\" +\n        \"  t1.prototype = t2.prototype\\n}\"\n    );\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTempConstructor --> junit.framework.ComparisonFailure: expected:</**",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsDispatcher1": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsDispatcher1",
        "src": "public void testTypeAnnotationsDispatcher1() {\n    assertTypeAnnotations(\n        \"var a = {};\\n\" +\n        \"/** \\n\" +\n        \" * @constructor \\n\" +\n        \" * @javadispatch \\n\" +\n        \" */\\n\" +\n        \"a.Foo = function(){}\",\n        \"var a = {};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo = function() {\\n\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsDispatcher1 --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsDispatcher2": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsDispatcher2",
        "src": "public void testTypeAnnotationsDispatcher2() {\n    assertTypeAnnotations(\n        \"var a = {};\\n\" +\n        \"/** \\n\" +\n        \" * @constructor \\n\" +\n        \" */\\n\" +\n        \"a.Foo = function(){}\\n\" +\n        \"/**\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo.prototype.foo = function() {};\",\n\n        \"var a = {};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"a.Foo = function() {\\n\" +\n        \"};\\n\" +\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @javadispatch\\n\" +\n        \" */\\n\" +\n        \"a.Foo.prototype.foo = function() {\\n\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsDispatcher2 --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsImplements": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsImplements",
        "src": "public void testTypeAnnotationsImplements() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\\n\"\n        + \"/** @interface */ a.I = function(){};\\n\"\n        + \"/** @interface */ a.I2 = function(){};\\n\"\n        + \"/** @constructor \\n @extends {a.Foo}\\n\"\n        + \" * @implements {a.I} \\n @implements {a.I2}\\n\"\n        + \"*/ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @interface\\n */\\n\"\n        + \"a.I = function() {\\n};\\n\"\n        + \"/**\\n * @interface\\n */\\n\"\n        + \"a.I2 = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @implements {a.I}\\n\"\n        + \" * @implements {a.I2}\\n * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsImplements --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsNamespace": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsNamespace",
        "src": "public void testTypeAnnotationsNamespace() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsNamespace --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotations": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotations",
        "src": "public void testTypeAnnotations() {\n    assertTypeAnnotations(\n        \"/** @constructor */ function Foo(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"function Foo() {\\n}\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotations --> junit.framework.ComparisonFailure: expected:</**",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testVariableArgumentsTypesAnnotation": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testVariableArgumentsTypesAnnotation",
        "src": "public void testVariableArgumentsTypesAnnotation() {\n    assertTypeAnnotations(\n        \"/**\\n\" +\n        \" * @param {...string} x \\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {...string} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" +\n        \"var a = function(x) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testVariableArgumentsTypesAnnotation --> junit.framework.ComparisonFailure: expected:<...ram {...string} x",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ram {...string} x"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testEmitUnknownParamTypesAsAllType": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testEmitUnknownParamTypesAsAllType",
        "src": "public void testEmitUnknownParamTypesAsAllType() {\n    assertTypeAnnotations(\n        \"var a = function(x) {}\",\n        \"/**\\n\" +\n        \" * @param {*} x\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" */\\n\" + \n        \"var a = function(x) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testEmitUnknownParamTypesAsAllType --> junit.framework.ComparisonFailure: expected:<...*",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...*"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsMemberSubclass": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testTypeAnnotationsMemberSubclass",
        "src": "public void testTypeAnnotationsMemberSubclass() {\n    assertTypeAnnotations(\"var a = {};\"\n        + \"/** @constructor */ a.Foo = function(){};\"\n        + \"/** @constructor \\n @extends {a.Foo} */ a.Bar = function(){}\",\n        \"var a = {};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"a.Foo = function() {\\n};\\n\"\n        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n        + \" * @constructor\\n */\\n\"\n        + \"a.Bar = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsMemberSubclass --> junit.framework.ComparisonFailure: expected:<var a = {};",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a = {};"
      },
      "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest::testRewritePrototypeMethods2": {
        "path": "com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java",
        "function_name": "testRewritePrototypeMethods2",
        "src": "public void testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON);\n  }",
        "error_msg": "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest::testRewritePrototypeMethods2 --> junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): undefined, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): undefined, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = undefined]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): undefined, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): undefined, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = undefined]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>"
      },
      "com.google.javascript.jscomp.DisambiguatePropertiesTest::testStaticProperty": {
        "path": "com/google/javascript/jscomp/DisambiguatePropertiesTest.java",
        "function_name": "testStaticProperty",
        "src": "public void testStaticProperty() {\n    String js = \"\"\n      + \"/** @constructor */ function Foo() {} \\n\"\n      + \"/** @constructor */ function Bar() {}\\n\"\n      + \"Foo.a = 0;\"\n      + \"Bar.a = 0;\";\n    String output = \"\"\n        + \"function Foo(){}\"\n        + \"function Bar(){}\"\n        + \"Foo.function__this_Foo___undefined$a = 0;\"\n        + \"Bar.function__this_Bar___undefined$a = 0;\";\n\n    testSets(false, js, output,\n        \"{a=[[function (this:Bar): undefined],\" +\n        \" [function (this:Foo): undefined]]}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.DisambiguatePropertiesTest::testStaticProperty --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportDontEmitPrototypePathPrefix": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportDontEmitPrototypePathPrefix",
        "src": "public void testExportDontEmitPrototypePathPrefix() { \n    compileAndCheck(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"var Foo = function() {};\" +\n        \"/**\\n\" +\n        \" * @return {number}\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.m = function() {return 6;};\\n\" +\n        \"goog.exportSymbol('Foo', Foo);\\n\" +\n        \"goog.exportProperty(Foo.prototype, 'm', Foo.prototype.m);\",\n        \"/**\\n\" +\n        \" * @return {undefined}\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"var Foo = function() {\\n};\\n\" +\n        \"/**\\n\" +\n        \" * @return {number}\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.m = function() {\\n}\"\n    );  \n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportDontEmitPrototypePathPrefix --> junit.framework.ComparisonFailure: expected:</**",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportMultiple",
        "src": "public void testExportMultiple() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('a.b', a.b);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                    \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n\n                    \"var a = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} p1\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b = function(p1) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.c = function(d, e, f) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} g\\n\" +\n                    \" * @param {*} h\\n\" +\n                    \" * @param {*} i\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.prototype.c = function(g, h, i) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple --> junit.framework.ComparisonFailure: expected:<...",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<..."
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbolWithConstructor": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportSymbolWithConstructor",
        "src": "public void testExportSymbolWithConstructor() {\n    compileAndCheck(\"var internalName;\\n\" +\n                    \"/**\\n\" +\n                    \" * @constructor\\n\" +\n                    \" */\\n\" +  \n                    \"internalName = function() {\" +\n                    \"};\" +\n                    \"goog.exportSymbol('externalName', internalName)\",\n                    \"/**\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" * @constructor\\n\" +\n                    \" */\\n\" + \n                    \"var externalName = function() {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbolWithConstructor --> junit.framework.ComparisonFailure: expected:</**",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:</**"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbolDefinedInVar": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportSymbolDefinedInVar",
        "src": "public void testExportSymbolDefinedInVar() throws Exception {\n    compileAndCheck(\"var a = function(d, e, f) {};\" +\n                    \"goog.exportSymbol('foobar', a)\",\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var foobar = function(d, e, f) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbolDefinedInVar --> junit.framework.ComparisonFailure: expected:<...e",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbol": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportSymbol",
        "src": "public void testExportSymbol() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                    \"goog.exportSymbol('foobar', a.b.c)\",\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var foobar = function(d, e, f) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportSymbol --> junit.framework.ComparisonFailure: expected:<...e",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple2": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportMultiple2",
        "src": "public void testExportMultiple2() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('hello', a);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                    \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n\n                    \"var hello = {};\\n\" +\n                    \"hello.b = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"hello.b.c = function(d, e, f) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} g\\n\" +\n                    \" * @param {*} h\\n\" +\n                    \" * @param {*} i\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"hello.b.prototype.c = function(g, h, i) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple2 --> junit.framework.ComparisonFailure: expected:<...e",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple3": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportMultiple3",
        "src": "public void testExportMultiple3() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                    \"a.b.c = function(d, e, f) {};\" +\n                    \"a.b.prototype.c = function(g, h, i) {};\" +\n                    \"goog.exportSymbol('prefix', a.b);\" +\n                    \"goog.exportProperty(a.b, 'c', a.b.c);\",\n\n                    \"/**\\n\" +\n                    \" * @param {*} p1\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"var prefix = function(p1) {\\n};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"prefix.c = function(d, e, f) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportMultiple3 --> junit.framework.ComparisonFailure: expected:<...",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<..."
      },
      "com.google.javascript.jscomp.ExternExportsPassTest::testExportProperty": {
        "path": "com/google/javascript/jscomp/ExternExportsPassTest.java",
        "function_name": "testExportProperty",
        "src": "public void testExportProperty() throws Exception {\n    compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                    \"goog.exportProperty(a.b, 'cprop', a.b.c)\",\n                    \"var a = {};\\n\" +\n                    \"a.b = {};\\n\" +\n                    \"/**\\n\" +\n                    \" * @param {*} d\\n\" +\n                    \" * @param {*} e\\n\" +\n                    \" * @param {*} f\\n\" +\n                    \" * @return {undefined}\\n\" +\n                    \" */\\n\" +\n                    \"a.b.cprop = function(d, e, f) {\\n}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ExternExportsPassTest::testExportProperty --> junit.framework.ComparisonFailure: expected:<...e",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...e"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testNestedFunctionInference1": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testNestedFunctionInference1",
        "src": "public void testNestedFunctionInference1() throws Exception {\n    String nestedAssignOfFooAndBar =\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = f.prototype.bar = function(){};\";\n    testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testNestedFunctionInference1 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testScoping10": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testScoping10",
        "src": "public void testScoping10() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n\n    // a declared, b is not\n    assertTrue(p.scope.isDeclared(\"a\", false));\n    assertFalse(p.scope.isDeclared(\"b\", false));\n\n    // checking that a has the correct assigned type\n    assertEquals(\"function (): undefined\",\n        p.scope.getVar(\"a\").getType().toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testScoping10 --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateOldTypeDef": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testDuplicateOldTypeDef",
        "src": "public void testDuplicateOldTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {}; goog.typedef = true;\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @type {number} */ goog.Bar = goog.typedef\",\n        \"variable goog.Bar redefined with type number, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateOldTypeDef --> junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testBadConstructorCall": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testBadConstructorCall",
        "src": "public void testBadConstructorCall() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo();\",\n        \"Constructor function (this:Foo): undefined should be called \" +\n        \"with the \\\"new\\\" keyword\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testBadConstructorCall --> junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testDontAddMethodsIfNoConstructor",
        "src": "public void testDontAddMethodsIfNoConstructor()\n      throws Exception {\n    Node js1Node = parseAndTypeCheck(\n        \"function A() {}\" +\n        \"A.prototype = {m1: 5, m2: true}\");\n\n    JSType functionAType = js1Node.getFirstChild().getJSType();\n    assertEquals(\"function (): undefined\", functionAType.toString());\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testInterfaceInheritanceCheck11": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testInterfaceInheritanceCheck11",
        "src": "public void testInterfaceInheritanceCheck11() throws Exception {\n    testTypes(\n        \"/** @constructor */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from superclass Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testInterfaceInheritanceCheck11 --> junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testErrorMismatchingPropertyOnInterface5": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testErrorMismatchingPropertyOnInterface5",
        "src": "public void testErrorMismatchingPropertyOnInterface5() throws Exception {\n    testTypes(\"/** @interface */ function T() {};\\n\" +\n        \"/** @type {number} */T.prototype.x = function() { };\",\n        \"assignment to property x of T.prototype\\n\" +\n        \"found   : function (): undefined\\n\" +\n        \"required: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testErrorMismatchingPropertyOnInterface5 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateTypeDef": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testDuplicateTypeDef",
        "src": "public void testDuplicateTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @typedef {number} */ goog.Bar;\",\n        \"variable goog.Bar redefined with type None, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateTypeDef --> junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testBug911118": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testBug911118",
        "src": "public void testBug911118() throws Exception {\n    // verifying the type assigned to anonymous functions assigned variables\n    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n    JSType type = s.getVar(\"a\").getType();\n    assertEquals(\"function (): undefined\", type.toString());\n\n    // verifying the bug example\n    testTypes(\"function nullFunction() {};\" +\n        \"var foo = nullFunction;\" +\n        \"foo = function() {};\" +\n        \"foo();\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testBug911118 --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference12": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference12",
        "src": "public void testFunctionInference12() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"goog.f = function(){};\",\n        \"goog.f\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference12 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference13": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference13",
        "src": "public void testFunctionInference13() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Foo = function(){};\" +\n        \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n        \"eatFoo\",\n        \"function (goog.Foo): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference13 --> junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference15": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference15",
        "src": "public void testFunctionInference15() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"f.prototype.foo\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference15 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference16": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference16",
        "src": "public void testFunctionInference16() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"(new f).foo\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference16 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testPrototypePropertyReference": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testPrototypePropertyReference",
        "src": "public void testPrototypePropertyReference() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"\"\n        + \"/** @constructor */\\n\"\n        + \"function Foo() {}\\n\"\n        + \"/** @param {number} a */\\n\"\n        + \"Foo.prototype.bar = function(a){};\\n\"\n        + \"/** @param {Foo} f */\\n\"\n        + \"function baz(f) {\\n\"\n        + \"  Foo.prototype.bar.call(f, 3);\\n\"\n        + \"}\");\n    assertEquals(0, compiler.getErrorCount());\n    assertEquals(0, compiler.getWarningCount());\n\n    assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n    FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n    assertEquals(\"function (this:Foo, number): undefined\",\n                 fooType.getPrototype().getPropertyType(\"bar\").toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testPrototypePropertyReference --> junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testGoodExtends7": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testGoodExtends7",
        "src": "public void testGoodExtends7() throws Exception {\n    testFunctionType(\n        \"Function.prototype.inherits = function(x) {};\" +\n        \"/** @constructor */function base() {}\\n\" +\n        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n        \"derived.inherits(base);\",\n        \"(new derived).constructor\",\n        \"function (this:derived): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testGoodExtends7 --> junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testTypeRedefinition": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testTypeRedefinition",
        "src": "public void testTypeRedefinition() throws Exception {\n    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n        \"original definition at [testcode]:1 with type enum{a.A}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testTypeRedefinition --> junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference1": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference1",
        "src": "public void testFunctionInference1() throws Exception {\n    testFunctionType(\n        \"function f(a) {}\",\n        \"function (?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference1 --> junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference2": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference2",
        "src": "public void testFunctionInference2() throws Exception {\n    testFunctionType(\n        \"function f(a,b) {}\",\n        \"function (?, ?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference2 --> junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference3": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference3",
        "src": "public void testFunctionInference3() throws Exception {\n    testFunctionType(\n        \"function f(var_args) {}\",\n        \"function (...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference3 --> junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference4": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference4",
        "src": "public void testFunctionInference4() throws Exception {\n    testFunctionType(\n        \"function f(a,b,c,var_args) {}\",\n        \"function (?, ?, ?, ...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference4 --> junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference7": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference7",
        "src": "public void testFunctionInference7() throws Exception {\n    testFunctionType(\n        \"/** @this Date */function f(a,b,c,var_args) {}\",\n        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference7 --> junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference8": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference8",
        "src": "public void testFunctionInference8() throws Exception {\n    testFunctionType(\n        \"function f() {}\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference8 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference9": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testFunctionInference9",
        "src": "public void testFunctionInference9() throws Exception {\n    testFunctionType(\n        \"var f = function() {};\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testFunctionInference9 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testInterfaceInheritanceCheck7": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testInterfaceInheritanceCheck7",
        "src": "public void testInterfaceInheritanceCheck7() throws Exception {\n    testTypes(\n        \"/** @interface */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from interface Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testInterfaceInheritanceCheck7 --> junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateStaticMethodDecl1": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testDuplicateStaticMethodDecl1",
        "src": "public void testDuplicateStaticMethodDecl1() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (number): undefined, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (number): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateStaticMethodDecl1 --> junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>"
      },
      "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateStaticMethodDecl5": {
        "path": "com/google/javascript/jscomp/LooseTypeCheckTest.java",
        "function_name": "testDuplicateStaticMethodDecl5",
        "src": "public void testDuplicateStaticMethodDecl5() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"goog.foo = function(x) {};\" +\n        \"/** @return {undefined} */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (?): undefined, \" +\n        \"original definition at [testcode]:1 with type \" +\n        \"function (?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateStaticMethodDecl5 --> junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testNestedFunctionInference1": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testNestedFunctionInference1",
        "src": "public void testNestedFunctionInference1() throws Exception {\n    String nestedAssignOfFooAndBar =\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = f.prototype.bar = function(){};\";\n    testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testNestedFunctionInference1 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testScoping10": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testScoping10",
        "src": "public void testScoping10() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n\n    // a declared, b is not\n    assertTrue(p.scope.isDeclared(\"a\", false));\n    assertFalse(p.scope.isDeclared(\"b\", false));\n\n    // checking that a has the correct assigned type\n    assertEquals(\"function (): undefined\",\n        p.scope.getVar(\"a\").getType().toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testScoping10 --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDuplicateOldTypeDef": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testDuplicateOldTypeDef",
        "src": "public void testDuplicateOldTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {}; goog.typedef = true;\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @type {number} */ goog.Bar = goog.typedef\",\n        \"variable goog.Bar redefined with type number, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testDuplicateOldTypeDef --> junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn1": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInferredReturn1",
        "src": "public void testInferredReturn1() throws Exception {\n    testTypes(\n        \"function f() {} /** @param {number} x */ function g(x) {}\" +\n        \"g(f());\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : undefined\\n\" +\n        \"required: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn1 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn2": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInferredReturn2",
        "src": "public void testInferredReturn2() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype.bar = function() {}; \" +\n        \"/** @param {number} x */ function g(x) {}\" +\n        \"g((new Foo()).bar());\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : undefined\\n\" +\n        \"required: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn2 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn3": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInferredReturn3",
        "src": "public void testInferredReturn3() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype.bar = function() {}; \" +\n        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n        \"/** @return {number} \\n * @override  */ \" +\n        \"SubFoo.prototype.bar = function() { return 3; }; \",\n        \"mismatch of the bar property type and the type of the property \" +\n        \"it overrides from superclass Foo\\n\" +\n        \"original: function (this:Foo): undefined\\n\" +\n        \"override: function (this:SubFoo): number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn3 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn4": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInferredReturn4",
        "src": "public void testInferredReturn4() throws Exception {\n    // By design, this throws a warning. if you want global x to be\n    // defined to some other type of function, then you need to declare it\n    // as a greater type.\n    testTypes(\n        \"var x = function() {};\" +\n        \"x = /** @type {function(): number} */ (function() { return 3; });\",\n        \"assignment\\n\" +\n        \"found   : function (): number\\n\" +\n        \"required: function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn4 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn6": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInferredReturn6",
        "src": "public void testInferredReturn6() throws Exception {\n    testTypes(\n        \"/** @return {string} */\" +\n        \"function f() {\" +\n        \"  var x = function() {};\" +\n        \"  if (f()) \" +\n        \"    x = /** @type {function(): number} */ \" +\n        \"        (function() { return 3; });\" +\n        \"  return x();\" +\n        \"}\",\n        \"inconsistent return type\\n\" +\n        \"found   : (number|undefined)\\n\" +\n        \"required: string\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInferredReturn6 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testBadConstructorCall": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testBadConstructorCall",
        "src": "public void testBadConstructorCall() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo();\",\n        \"Constructor function (this:Foo): undefined should be called \" +\n        \"with the \\\"new\\\" keyword\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testBadConstructorCall --> junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:Foo): [undefined] should be called wi...> but was:<...unction (this:Foo): [?] should be called wi...>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDontAddMethodsIfNoConstructor": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testDontAddMethodsIfNoConstructor",
        "src": "public void testDontAddMethodsIfNoConstructor()\n      throws Exception {\n    Node js1Node = parseAndTypeCheck(\n        \"function A() {}\" +\n        \"A.prototype = {m1: 5, m2: true}\");\n\n    JSType functionAType = js1Node.getFirstChild().getJSType();\n    assertEquals(\"function (): undefined\", functionAType.toString());\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n    assertEquals(UNKNOWN_TYPE,\n        U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testDontAddMethodsIfNoConstructor --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck11": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInterfaceInheritanceCheck11",
        "src": "public void testInterfaceInheritanceCheck11() throws Exception {\n    testTypes(\n        \"/** @constructor */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from superclass Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck11 --> junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testErrorMismatchingPropertyOnInterface5": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testErrorMismatchingPropertyOnInterface5",
        "src": "public void testErrorMismatchingPropertyOnInterface5() throws Exception {\n    testTypes(\"/** @interface */ function T() {};\\n\" +\n        \"/** @type {number} */T.prototype.x = function() { };\",\n        \"assignment to property x of T.prototype\\n\" +\n        \"found   : function (): undefined\\n\" +\n        \"required: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testErrorMismatchingPropertyOnInterface5 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDuplicateTypeDef": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testDuplicateTypeDef",
        "src": "public void testDuplicateTypeDef() throws Exception {\n    testTypes(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Bar = function() {};\" +\n        \"/** @typedef {number} */ goog.Bar;\",\n        \"variable goog.Bar redefined with type None, \" +\n        \"original definition at [testcode]:1 \" +\n        \"with type function (this:goog.Bar): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testDuplicateTypeDef --> junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Bar): [undefined]> but was:<...on (this:goog.Bar): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testBug911118": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testBug911118",
        "src": "public void testBug911118() throws Exception {\n    // verifying the type assigned to function expressions assigned variables\n    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n    JSType type = s.getVar(\"a\").getType();\n    assertEquals(\"function (): undefined\", type.toString());\n\n    // verifying the bug example\n    testTypes(\"function nullFunction() {};\" +\n        \"var foo = nullFunction;\" +\n        \"foo = function() {};\" +\n        \"foo();\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testBug911118 --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference12": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference12",
        "src": "public void testFunctionInference12() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"goog.f = function(){};\",\n        \"goog.f\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference12 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference13": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference13",
        "src": "public void testFunctionInference13() throws Exception {\n    testFunctionType(\n        \"var goog = {};\" +\n        \"/** @constructor */ goog.Foo = function(){};\" +\n        \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n        \"eatFoo\",\n        \"function (goog.Foo): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference13 --> junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (goog.Foo): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference15": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference15",
        "src": "public void testFunctionInference15() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"f.prototype.foo\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference15 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference16": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference16",
        "src": "public void testFunctionInference16() throws Exception {\n    testFunctionType(\n        \"/** @constructor */ function f() {};\" +\n        \"f.prototype.foo = function(){};\",\n        \"(new f).foo\",\n        \"function (this:f): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference16 --> junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (this:f): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testPrototypePropertyReference": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testPrototypePropertyReference",
        "src": "public void testPrototypePropertyReference() throws Exception {\n    TypeCheckResult p = parseAndTypeCheckWithScope(\"\"\n        + \"/** @constructor */\\n\"\n        + \"function Foo() {}\\n\"\n        + \"/** @param {number} a */\\n\"\n        + \"Foo.prototype.bar = function(a){};\\n\"\n        + \"/** @param {Foo} f */\\n\"\n        + \"function baz(f) {\\n\"\n        + \"  Foo.prototype.bar.call(f, 3);\\n\"\n        + \"}\");\n    assertEquals(0, compiler.getErrorCount());\n    assertEquals(0, compiler.getWarningCount());\n\n    assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n    FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n    assertEquals(\"function (this:Foo, number): undefined\",\n                 fooType.getPrototype().getPropertyType(\"bar\").toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testPrototypePropertyReference --> junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...(this:Foo, number): [undefined]> but was:<...(this:Foo, number): [?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testGoodExtends7": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testGoodExtends7",
        "src": "public void testGoodExtends7() throws Exception {\n    testFunctionType(\n        \"Function.prototype.inherits = function(x) {};\" +\n        \"/** @constructor */function base() {}\\n\" +\n        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n        \"derived.inherits(base);\",\n        \"(new derived).constructor\",\n        \"function (this:derived): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testGoodExtends7 --> junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:derived): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testTypeRedefinition": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testTypeRedefinition",
        "src": "public void testTypeRedefinition() throws Exception {\n    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n        \"original definition at [testcode]:1 with type enum{a.A}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testTypeRedefinition --> junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...unction (this:a.A): [undefined], original definitio...> but was:<...unction (this:a.A): [?], original definitio...>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference1": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference1",
        "src": "public void testFunctionInference1() throws Exception {\n    testFunctionType(\n        \"function f(a) {}\",\n        \"function (?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference1 --> junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...d   : function (?): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference2": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference2",
        "src": "public void testFunctionInference2() throws Exception {\n    testFunctionType(\n        \"function f(a,b) {}\",\n        \"function (?, ?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference2 --> junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... : function (?, ?): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference3": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference3",
        "src": "public void testFunctionInference3() throws Exception {\n    testFunctionType(\n        \"function f(var_args) {}\",\n        \"function (...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference3 --> junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference4": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference4",
        "src": "public void testFunctionInference4() throws Exception {\n    testFunctionType(\n        \"function f(a,b,c,var_args) {}\",\n        \"function (?, ?, ?, ...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference4 --> junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... (?, ?, ?, ...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference7": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference7",
        "src": "public void testFunctionInference7() throws Exception {\n    testFunctionType(\n        \"/** @this Date */function f(a,b,c,var_args) {}\",\n        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference7 --> junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<..., ?, ?, ?, ...[?]): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference8": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference8",
        "src": "public void testFunctionInference8() throws Exception {\n    testFunctionType(\n        \"function f() {}\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference8 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference9": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testFunctionInference9",
        "src": "public void testFunctionInference9() throws Exception {\n    testFunctionType(\n        \"var f = function() {};\",\n        \"function (): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testFunctionInference9 --> junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...nd   : function (): [undefined]"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck7": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInterfaceInheritanceCheck7",
        "src": "public void testInterfaceInheritanceCheck7() throws Exception {\n    testTypes(\n        \"/** @interface */function Super() {};\" +\n        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n        \"function(bar) {};\",\n        \"mismatch of the foo property type and the type of the property it \" +\n        \"overrides from interface Super\\n\" +\n        \"original: function (this:Super, number): undefined\\n\" +\n        \"override: function (this:Sub, string): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck7 --> junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...his:Super, number): [undefined"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDuplicateStaticMethodDecl1": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testDuplicateStaticMethodDecl1",
        "src": "public void testDuplicateStaticMethodDecl1() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n        \"/** @param {number} x */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (number): undefined, \" +\n        \"original definition at [testcode]:1 with type function (number): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testDuplicateStaticMethodDecl1 --> junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... function (number): [undefined, original definition at [testcode]:1 with type function (number): undefined]> but was:<... function (number): [?, original definition at [testcode]:1 with type function (number): ?]>"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testDuplicateStaticMethodDecl5": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testDuplicateStaticMethodDecl5",
        "src": "public void testDuplicateStaticMethodDecl5() throws Exception {\n    testTypes(\n        \"var goog = goog || {};\" +\n        \"goog.foo = function(x) {};\" +\n        \"/** @return {undefined} */ goog.foo = function(x) {};\",\n        \"variable goog.foo redefined with type function (?): undefined, \" +\n        \"original definition at [testcode]:1 with type \" +\n        \"function (?): undefined\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testDuplicateStaticMethodDecl5 --> junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<... type function (?): [undefined]> but was:<... type function (?): [?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testConstructorNode": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testConstructorNode",
        "src": "public void testConstructorNode() {\n    testSame(\"var goog = {}; /** @constructor */ goog.Foo = function() {};\");\n\n    ObjectType ctor = (ObjectType) (findNameType(\"goog.Foo\", globalScope));\n    assertNotNull(ctor);\n    assertTrue(ctor.isConstructor());\n    assertEquals(\"function (this:goog.Foo): undefined\", ctor.toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testConstructorNode --> junit.framework.ComparisonFailure: expected:<...on (this:goog.Foo): [undefined]> but was:<...on (this:goog.Foo): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...on (this:goog.Foo): [undefined]> but was:<...on (this:goog.Foo): [?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertiesOnInterface": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testPropertiesOnInterface",
        "src": "public void testPropertiesOnInterface() throws Exception {\n    testSame(\"/** @interface */ var I = function() {};\" +\n        \"/** @type {number} */ I.prototype.bar;\" +\n        \"I.prototype.baz = function(){};\");\n\n    Var i = globalScope.getVar(\"I\");\n    assertEquals(\"function (this:I): ?\", i.getType().toString());\n    assertTrue(i.getType().isInterface());\n\n    ObjectType iPrototype = (ObjectType)\n        ((ObjectType) i.getType()).getPropertyType(\"prototype\");\n    assertEquals(\"I.prototype\", iPrototype.toString());\n    assertTrue(iPrototype.isFunctionPrototypeType());\n\n    assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n    assertEquals(\"function (this:I): undefined\",\n        iPrototype.getPropertyType(\"baz\").toString());\n\n    assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertiesOnInterface --> junit.framework.ComparisonFailure: expected:<function (this:I): [undefined]> but was:<function (this:I): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (this:I): [undefined]> but was:<function (this:I): [?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testMethodBeforeFunction": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testMethodBeforeFunction",
        "src": "public void testMethodBeforeFunction() throws Exception {\n    testSame(\n        \"var y = Window.prototype;\" +\n        \"Window.prototype.alert = function(message) {};\" +\n        \"/** @constructor */ function Window() {}\\n\" +\n        \"var window = new Window(); \\n\" +\n        \"var x = window;\");\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Window\", x.toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n    assertEquals(\"function (this:Window, ?): undefined\",\n        x.getPropertyType(\"alert\").toString());\n    assertTrue(x.isPropertyTypeDeclared(\"alert\"));\n\n    ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n    assertEquals(\"function (this:Window, ?): undefined\",\n        y.getPropertyType(\"alert\").toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testMethodBeforeFunction --> junit.framework.ComparisonFailure: expected:<...n (this:Window, ?): [undefined]> but was:<...n (this:Window, ?): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...n (this:Window, ?): [undefined]> but was:<...n (this:Window, ?): [?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testConstructorProperty": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testConstructorProperty",
        "src": "public void testConstructorProperty() {\n    testSame(\"var foo = {}; /** @constructor */ foo.Bar = function() {};\");\n    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n    assertTrue(foo.hasProperty(\"Bar\"));\n    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n\n    JSType fooBar = foo.getPropertyType(\"Bar\");\n    assertEquals(\"function (this:foo.Bar): undefined\", fooBar.toString());\n    assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"Bar\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testConstructorProperty --> junit.framework.ComparisonFailure: expected:<...ion (this:foo.Bar): [undefined]> but was:<...ion (this:foo.Bar): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ion (this:foo.Bar): [undefined]> but was:<...ion (this:foo.Bar): [?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testReturnTypeInference1": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testReturnTypeInference1",
        "src": "public void testReturnTypeInference1() {\n    testSame(\"function f() {}\");\n    assertEquals(\n        \"function (): undefined\",\n        findNameType(\"f\", globalScope).toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testReturnTypeInference1 --> junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<function (): [undefined]> but was:<function (): [?]>"
      }
    }
  },
  "Closure-147": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "start_loc": 84,
        "end_loc": 142,
        "buggy_function": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
        "fixed_function": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n            pType == Token.OBJECTLIT)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
        "comment": "/**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/RuntimeTypeCheck.java",
        "start_loc": 239,
        "end_loc": 274,
        "buggy_function": "    private void visitFunction(NodeTraversal t, Node n) {\n      FunctionType funType = (FunctionType) n.getJSType();\n      Node block = n.getLastChild();\n      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n      Node insertionPoint = null;\n\n      // To satisfy normalization constraints, the type checking must be\n      // added after any inner function declarations.\n\n      for (Node paramType : funType.getParameters()) {\n        // Can this ever happen?\n        if (paramName == null) {\n          return;\n        }\n\n        Node checkNode = createCheckTypeCallNode(\n            paramType.getJSType(), paramName.cloneTree());\n\n        if (checkNode == null) {\n          // We don't know how to check this parameter type.\n          paramName = paramName.getNext();\n          continue;\n        }\n\n        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n        if (insertionPoint == null) {\n          block.addChildToFront(checkNode);\n        } else {\n          block.addChildAfter(checkNode, insertionPoint);\n        }\n\n        compiler.reportCodeChange();\n        paramName = paramName.getNext();\n        insertionPoint = checkNode;\n      }\n    }",
        "fixed_function": "    private void visitFunction(NodeTraversal t, Node n) {\n      FunctionType funType = (FunctionType) n.getJSType();\n      Node block = n.getLastChild();\n      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n      Node insertionPoint = null;\n\n      // To satisfy normalization constraints, the type checking must be\n      // added after any inner function declarations.\n      for (Node next = block.getFirstChild();\n           next != null && NodeUtil.isFunctionDeclaration(next);\n           next = next.getNext()) {\n        insertionPoint = next;\n      }\n\n      for (Node paramType : funType.getParameters()) {\n        // Can this ever happen?\n        if (paramName == null) {\n          return;\n        }\n\n        Node checkNode = createCheckTypeCallNode(\n            paramType.getJSType(), paramName.cloneTree());\n\n        if (checkNode == null) {\n          // We don't know how to check this parameter type.\n          paramName = paramName.getNext();\n          continue;\n        }\n\n        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n        if (insertionPoint == null) {\n          block.addChildToFront(checkNode);\n        } else {\n          block.addChildAfter(checkNode, insertionPoint);\n        }\n\n        compiler.reportCodeChange();\n        paramName = paramName.getNext();\n        insertionPoint = checkNode;\n      }\n    }",
        "comment": "/**\n     * Insert checks for the parameters of the function.\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CheckGlobalThisTest::testIssue182a": {
        "path": "com/google/javascript/jscomp/CheckGlobalThisTest.java",
        "function_name": "testIssue182a",
        "src": "public void testIssue182a() {\n    testFailure(\"var NS = {read: function() { return this.foo; }};\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CheckGlobalThisTest::testIssue182a --> junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>"
      },
      "com.google.javascript.jscomp.CheckGlobalThisTest::testIssue182b": {
        "path": "com/google/javascript/jscomp/CheckGlobalThisTest.java",
        "function_name": "testIssue182b",
        "src": "public void testIssue182b() {\n    testFailure(\"var NS = {write: function() { this.foo = 3; }};\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CheckGlobalThisTest::testIssue182b --> junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>"
      },
      "com.google.javascript.jscomp.RuntimeTypeCheckTest::testValueWithInnerFn": {
        "path": "com/google/javascript/jscomp/RuntimeTypeCheckTest.java",
        "function_name": "testValueWithInnerFn",
        "src": "public void testValueWithInnerFn() {\n    testChecks(\"/** @param {number} i */ function f(i) { function g() {} }\",\n        \"function f(i) {\" +\n        \"  function g() {}\" +\n        \"  jscomp.typecheck.checkType(i, \" +\n        \"      [jscomp.typecheck.valueChecker('number')]);\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.RuntimeTypeCheckTest::testValueWithInnerFn --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-148": {
    "function_num": 10,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "start_loc": 156,
        "end_loc": 200,
        "buggy_function": "  private Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n      return originalTypeofNode;\n    }\n\n    String typeNameString = null;\n\n    switch (argumentNode.getType()) {\n      case Token.STRING:\n        typeNameString = \"string\";\n        break;\n      case Token.NUMBER:\n        typeNameString = \"number\";\n        break;\n      case Token.TRUE:\n      case Token.FALSE:\n        typeNameString = \"boolean\";\n        break;\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.ARRAYLIT:\n        typeNameString = \"object\";\n        break;\n      case Token.NAME:\n        // We assume here that programs don't change the value of the\n        // keyword undefined to something other than the value undefined.\n        if (\"undefined\".equals(argumentNode.getString())) {\n          typeNameString = \"undefined\";\n        }\n        break;\n    }\n\n    if (typeNameString != null) {\n      Node newNode = Node.newString(typeNameString);\n      originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return originalTypeofNode;\n  }",
        "fixed_function": "  private Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n      return originalTypeofNode;\n    }\n\n    String typeNameString = null;\n\n    switch (argumentNode.getType()) {\n      case Token.STRING:\n        typeNameString = \"string\";\n        break;\n      case Token.NUMBER:\n        typeNameString = \"number\";\n        break;\n      case Token.TRUE:\n      case Token.FALSE:\n        typeNameString = \"boolean\";\n        break;\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.ARRAYLIT:\n        typeNameString = \"object\";\n        break;\n      case Token.VOID:\n        typeNameString = \"undefined\";\n        break;\n      case Token.NAME:\n        // We assume here that programs don't change the value of the\n        // keyword undefined to something other than the value undefined.\n        if (\"undefined\".equals(argumentNode.getString())) {\n          typeNameString = \"undefined\";\n        }\n        break;\n    }\n\n    if (typeNameString != null) {\n      Node newNode = Node.newString(typeNameString);\n      originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return originalTypeofNode;\n  }",
        "comment": "/**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 93,
        "end_loc": 113,
        "buggy_function": "    void appendTo(Appendable out) throws IOException {\n      out.append(\"[\");\n\n      out.append(sourceFile);\n      // The source file rarely changes, so cache the escaped string.\n\n      out.append(\",\");\n\n\n      out.append(String.valueOf(originalPosition.getLineNumber()));\n\n      out.append(\",\");\n      out.append(String.valueOf(originalPosition.getCharacterIndex()));\n\n      if (originalName != null) {\n        out.append(\",\");\n        out.append(originalName);\n      }\n\n      out.append(\"]\");\n    }",
        "fixed_function": "    private void appendMappingTo(\n        Mapping m, Appendable out) throws IOException {\n      out.append(\"[\");\n\n      String sourceFile = m.sourceFile;\n      // The source file rarely changes, so cache the escaped string.\n      String escapedSourceFile;\n      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n        lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n      }\n      escapedSourceFile = lastSourceFileEscaped;\n\n      out.append(escapedSourceFile);\n      out.append(\",\");\n\n      int line = m.originalPosition.getLineNumber();\n      if (line != lastLine) {\n        lastLineString = String.valueOf(line);\n      }\n      String lineValue = lastLineString;\n\n      out.append(lineValue);\n\n      out.append(\",\");\n      out.append(String.valueOf(\n          m.originalPosition.getCharacterIndex()));\n\n      if (m.originalName != null) {\n        out.append(\",\");\n        out.append(escapeString(m.originalName));\n      }\n\n      out.append(\"]\\n\");\n    }",
        "comment": "/**\n     * Appends the mapping to the given buffer.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 153,
        "end_loc": 205,
        "buggy_function": "  void addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n      lastSourceFile = sourceFile;\n      lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n    // Create the new mapping.\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n\n    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n      mapping.originalName = escapeString(originalName);\n    }\n\n      // If the mapping is found on the first line, we need to offset\n      // its character position by the number of characters found on\n      // the *last* line of the source file to which the code is\n      // being generated.\n      int offsetLine = offsetPosition.getLineNumber();\n      int startOffsetPosition = offsetPosition.getCharacterIndex();\n      int endOffsetPosition = offsetPosition.getCharacterIndex();\n\n      if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n      }\n\n      if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n      }\n\n      mapping.startPosition =\n          new Position(startPosition.getLineNumber() + offsetLine,\n                       startPosition.getCharacterIndex() + startOffsetPosition);\n\n      mapping.endPosition =\n          new Position(endPosition.getLineNumber() + offsetLine,\n                       endPosition.getCharacterIndex() + endOffsetPosition);\n\n    mappings.add(mapping);\n  }",
        "fixed_function": "    void appendMappings(Appendable out) throws IOException {\n      for (Mapping m : mappings) {\n        if (m.used) {\n          appendMappingTo(m, out);\n        }\n      }\n    }",
        "comment": "/**\n     * Add used mappings to the supplied Appendable.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 257,
        "end_loc": 264,
        "buggy_function": "  private int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n      int endPositionLine = mapping.endPosition.getLineNumber();\n      maxLine = Math.max(maxLine, endPositionLine);\n    }\n    return maxLine + prefixPosition.getLineNumber();\n  }",
        "fixed_function": "  private static String escapeString(String value) {\n    return CodeGenerator.escapeToDoubleQuotedJsString(value);\n  }",
        "comment": "/**\n   * Escapes the given string for JSON.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 272,
        "end_loc": 330,
        "buggy_function": "  public void appendTo(Appendable out, String name) throws IOException {\n    // Write the mappings out to the file. The format of the generated\n    // source map is three sections, each deliminated by a magic comment.\n    //\n    // The first section contains an array for each line of the generated\n    // code, where each element in the array is the ID of the mapping which\n    // best represents the index-th character found on that line of the\n    // generated source code.\n    //\n    // The second section contains an array per generated line. Unused.\n    //\n    // The third and final section contains an array per line, each of which\n    // represents a mapping with a unique ID. The mappings are added in order.\n    // The array itself contains a tuple representing\n    // ['source file', line, col (, 'original name')]\n    //\n    // Example for 2 lines of generated code (with line numbers added for\n    // readability):\n    //\n    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n    // 4)  /** Begin file information. **/\n    // 5)  []\n    // 6)  []\n    // 7)  /** Begin mapping definitions. **/\n    // 8)  [\"a.js\", 1, 34]\n    // 9)  [\"a.js\", 5, 2]\n    // 10) [\"b.js\", 1, 3, \"event\"]\n    // 11) [\"c.js\", 1, 4]\n    // 12) [\"d.js\", 3, 78, \"foo\"]\n\n    int maxLine = findLastLine();\n\n    // Add the line character maps.\n    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out)).appendLineMappings();\n\n    // Add the source file maps.\n    out.append(\"/** Begin file information. **/\\n\");\n\n    // This section is unused but we need one entry per line to\n    // prevent changing the format.\n    for (int i = 0; i <= maxLine; ++i) {\n      out.append(\"[]\\n\");\n    }\n\n    // Add the mappings themselves.\n    out.append(\"/** Begin mapping definitions. **/\\n\");\n\n    for (Mapping mapping : mappings) {\n      mapping.appendTo(out);\n      out.append(\"\\n\");\n    }\n  }",
        "fixed_function": "  void addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    // Create the new mapping.\n    Mapping mapping = new Mapping();\n    mapping.sourceFile = sourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n\n    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n      mapping.originalName = originalName;\n    }\n\n    if (offsetPosition.getLineNumber() == 0\n        && offsetPosition.getCharacterIndex() == 0) {\n      mapping.startPosition = startPosition;\n      mapping.endPosition = endPosition;\n    } else {\n      // If the mapping is found on the first line, we need to offset\n      // its character position by the number of characters found on\n      // the *last* line of the source file to which the code is\n      // being generated.\n      int offsetLine = offsetPosition.getLineNumber();\n      int startOffsetPosition = offsetPosition.getCharacterIndex();\n      int endOffsetPosition = offsetPosition.getCharacterIndex();\n\n      if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n      }\n\n      if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n      }\n\n      mapping.startPosition =\n          new Position(startPosition.getLineNumber() + offsetLine,\n                       startPosition.getCharacterIndex() + startOffsetPosition);\n\n      mapping.endPosition =\n          new Position(endPosition.getLineNumber() + offsetLine,\n                       endPosition.getCharacterIndex() + endOffsetPosition);\n    }\n\n    mappings.add(mapping);\n  }",
        "comment": "/**\n   * Adds a mapping for the given node.  Mappings must be added in order.\n   *\n   * @param node The node that the new mapping represents.\n   * @param startPosition The position on the starting line\n   * @param endPosition The position on the ending line.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 367,
        "end_loc": 444,
        "buggy_function": "    void appendLineMappings() throws IOException {\n      Preconditions.checkState(!mappings.isEmpty());\n\n      // Start the first line.\n      openLine();\n\n\n      // And close the final line.\n\n    /**\n     * Begin the entry for a new line.\n     */\n\n    /**\n     * End the entry for a line.\n     */\n\n    /**\n     * Add a new char position entry.\n     * @param id The mapping id to record.\n     */\n\n  /**\n   * Mark any visited mapping as \"used\".\n   */\n    /**\n     * @throws IOException\n     */\n\n    /**\n     * @param m The mapping for the current code segment. null if the segment\n     *     is unmapped.\n     * @param line The starting line for this code segment.\n     * @param col The starting column for this code segment.\n     * @param endLine The ending line\n     * @param endCol The ending column\n     * @throws IOException\n     */\n\n  /**\n   * Walk the mappings and visit each segment of the mappings, unmapped\n   * segments are visited with a null mapping, unused mapping are not visited.\n   */\n    // The last line and column written\n\n\n    // Append the line mapping entries.\n\n      // The mapping list is ordered as a pre-order traversal.  The mapping\n      // positions give us enough information to rebuild the stack and this\n      // allows the building of the source map in O(n) time.\n      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n      for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n          Mapping previous = stack.pop();\n          writeClosedMapping(previous);\n        }\n\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n\n        stack.push(m);\n      }\n\n      // There are no more children to be had, simply close the remaining\n      // mappings in the reverse order of when they encountered.\n      while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n      }\n      closeLine();\n    }",
        "fixed_function": "  void reset() {\n    mappings = Lists.newArrayList();\n    offsetPosition = new Position(0, 0);\n    prefixPosition = new Position(0, 0);\n  }",
        "comment": "/**\n   * Resets the source map for reuse for the generation of a new source file.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 452,
        "end_loc": 459,
        "buggy_function": "    private void addCharEntry(String id) throws IOException {\n      if (firstChar) {\n        firstChar = false;\n      } else {\n        out.append(\",\");\n      }\n      out.append(id);\n    }",
        "fixed_function": "  public void appendTo(Appendable out, String name) throws IOException {\n    // Write the mappings out to the file. The format of the generated\n    // source map is three sections, each deliminated by a magic comment.\n    //\n    // The first section contains an array for each line of the generated\n    // code, where each element in the array is the ID of the mapping which\n    // best represents the index-th character found on that line of the\n    // generated source code.\n    //\n    // The second section contains an array per generated line. Unused.\n    //\n    // The third and final section contains an array per line, each of which\n    // represents a mapping with a unique ID. The mappings are added in order.\n    // The array itself contains a tuple representing\n    // ['source file', line, col (, 'original name')]\n    //\n    // Example for 2 lines of generated code (with line numbers added for\n    // readability):\n    //\n    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n    // 4)  /** Begin file information. **/\n    // 5)  []\n    // 6)  []\n    // 7)  /** Begin mapping definitions. **/\n    // 8)  [\"a.js\", 1, 34]\n    // 9)  [\"a.js\", 5, 2]\n    // 10) [\"b.js\", 1, 3, \"event\"]\n    // 11) [\"c.js\", 1, 4]\n    // 12) [\"d.js\", 3, 78, \"foo\"]\n\n    int maxLine = prepMappings();\n\n    // Add the line character maps.\n    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out)).appendLineMappings();\n\n    // Add the source file maps.\n    out.append(\"/** Begin file information. **/\\n\");\n\n    // This section is unused but we need one entry per line to\n    // prevent changing the format.\n    for (int i = 0; i <= maxLine; ++i) {\n      out.append(\"[]\\n\");\n    }\n\n    // Add the mappings themselves.\n    out.append(\"/** Begin mapping definitions. **/\\n\");\n\n    (new MappingWriter()).appendMappings(out);\n  }",
        "comment": "/**\n   * Appends the source map in LavaBug format to the given buffer.\n   *\n   * @param out The stream to which the map will be appended.\n   * @param name The name of the generated source file that this source map\n   *   represents.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 496,
        "end_loc": 504,
        "buggy_function": "    private void writeClosedMapping(Mapping m) throws IOException {\n      int nextLine = getAdjustedLine(m.endPosition);\n      int nextCol = getAdjustedCol(m.endPosition);\n      // If this anything remaining in this mapping beyond the\n      // current line and column position, write it out now.\n      if (line < nextLine || (line == nextLine && col < nextCol)) {\n        writeCharsUpTo(nextLine, nextCol, m.id);\n      }\n    }",
        "fixed_function": "  private int prepMappings() throws IOException {\n    // Mark any unused mappings.\n    (new MappingTraversal()).traverse(new UsedMappingCheck());\n\n    // Renumber used mappings and keep track of the last line.\n    int id = 0;\n    int maxLine = 0;\n    for (Mapping m : mappings) {\n      if (m.used) {\n        m.id = id++;\n        int endPositionLine = m.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine);\n      }\n    }\n\n    // Adjust for the prefix.\n    return maxLine + prefixPosition.getLineNumber();\n  }",
        "comment": "/**\n   * Assigns sequential ids to used mappings, and returns the last line mapped.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 509,
        "end_loc": 516,
        "buggy_function": "    private void writeCharsBetween(Mapping prev, Mapping next)\n        throws IOException {\n      int nextLine = getAdjustedLine(next.startPosition);\n      int nextCol = getAdjustedCol(next.startPosition);\n      // If the previous value is null, no mapping exists.\n      int id = (prev != null) ? prev.id : UNMAPPED;\n      writeCharsUpTo(nextLine, nextCol, id);\n    }",
        "fixed_function": "    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n      throws IOException {\n\n      int id = (m != null) ? m.id : UNMAPPED;\n      if (lastId != id) {\n        // Prevent the creation of unnecessary temporary stings for often\n        // repeated values.\n        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n        lastId = id;\n      }\n      String idString = lastIdString;\n\n      for (int i = line; i <= nextLine; i++) {\n        if (i == nextLine) {\n          for (int j = col; j < nextCol; j++) {\n            addCharEntry(idString);\n          }\n          break;\n        }\n\n        closeLine();\n        openLine();\n      }\n    }",
        "comment": "/**\n     * As each segment is visited write out the appropriate line mapping.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SourceMap.java",
        "start_loc": 522,
        "end_loc": 547,
        "buggy_function": "    private void writeCharsUpTo(\n        int nextLine, int nextCol, int id)\n        throws IOException {\n      Preconditions.checkState(line <= nextLine, \"\");\n      Preconditions.checkState(line < nextLine || col <= nextCol);\n\n      if (line == nextLine && col == nextCol) {\n        // Nothing to do.\n        return;\n      }\n\n      String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n      for (int i = line; i <= nextLine; i++) {\n        if (i == nextLine) {\n          for (int j = col; j < nextCol; j++) {\n            addCharEntry(idString);\n          }\n          break;\n        }\n        closeLine();\n        openLine();\n      }\n\n      line = nextLine;\n      col = nextCol;\n    }",
        "fixed_function": "    void appendLineMappings() throws IOException {\n      Preconditions.checkState(!mappings.isEmpty());\n\n      // Start the first line.\n      openLine();\n\n      (new MappingTraversal()).traverse(this);\n\n      // And close the final line.\n      closeLine();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof": {
        "path": "com/google/javascript/jscomp/PeepholeFoldConstantsTest.java",
        "function_name": "testFoldTypeof",
        "src": "public void testFoldTypeof() {\n    fold(\"x = typeof 1\", \"x = \\\"number\\\"\");\n    fold(\"x = typeof 'foo'\", \"x = \\\"string\\\"\");\n    fold(\"x = typeof true\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof false\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof null\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof undefined\", \"x = \\\"undefined\\\"\");\n    fold(\"x = typeof void 0\", \"x = \\\"undefined\\\"\");\n    fold(\"x = typeof []\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof [1]\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof [1,[]]\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof {}\", \"x = \\\"object\\\"\");\n\n    foldSame(\"x = typeof[1,[foo()]]\");\n    foldSame(\"x = typeof{bathwater:baby()}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0": {
        "path": "com/google/javascript/jscomp/SourceMapTest.java",
        "function_name": "testGoldenOutput0",
        "src": "public void testGoldenOutput0() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"\",\n\n                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\",\" +\n                   \" \\\"count\\\": 1 }\\n\" +\n\n                   \"[]\\n\" +\n\n                   \"/** Begin file information. **/\\n\" +\n                   \"[]\\n\" +\n\n                   \"/** Begin mapping definitions. **/\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0 --> junit.framework.ComparisonFailure: expected:<...ng definitions. **/",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ng definitions. **/"
      },
      "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1": {
        "path": "com/google/javascript/jscomp/SourceMapTest.java",
        "function_name": "testGoldenOutput1",
        "src": "public void testGoldenOutput1() throws Exception {\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                   \"\\\"count\\\": 1 }\\n\" +\n\n                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,6,\" +\n                   \"9,9,9,6,10,11,11,11,11,11,11,11,12,12,12,12,5]\\n\" +\n\n                   \"/** Begin file information. **/\\n\" +\n                   \"[]\\n\" +\n\n                   \"/** Begin mapping definitions. **/\\n\" +\n                   \"[\\\"testcode\\\",1,9]\\n\" +\n                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,10]\\n\" +\n                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,21]\\n\" +\n                   \"[\\\"testcode\\\",1,23]\\n\" +\n                   \"[\\\"testcode\\\",1,23,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,29,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,35,\\\"bar\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,41]\\n\" +\n                   \"[\\\"testcode\\\",1,44]\\n\" +\n                   \"[\\\"testcode\\\",1,51,\\\"foo\\\"]\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1 --> junit.framework.ComparisonFailure: expected:<...ode, count: 1 }",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ode, count: 1 }"
      },
      "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2": {
        "path": "com/google/javascript/jscomp/SourceMapTest.java",
        "function_name": "testGoldenOutput2",
        "src": "public void testGoldenOutput2() throws Exception {\n    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                   \"\\nreturn foo;\\n}\",\n\n                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                   \"\\\"count\\\": 1 }\\n\" +\n\n                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,\" +\n                   \"6,9,9,9,6,10,10,10,11,11,11,11,11,11,11,12,12,12,\" +\n                   \"12,5]\\n\" +\n\n                   \"/** Begin file information. **/\\n\" +\n                   \"[]\\n\" +\n                   \"/** Begin mapping definitions. **/\\n\" +\n                   \"[\\\"testcode\\\",1,9]\\n\" +\n                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,10]\\n\" +\n                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n                   \"[\\\"testcode\\\",1,21]\\n\" +\n                   \"[\\\"testcode\\\",5,0]\\n\" +\n                   \"[\\\"testcode\\\",5,0,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",5,6,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",5,12,\\\"bar\\\"]\\n\" +\n                   \"[\\\"testcode\\\",5,18,\\\"foo\\\"]\\n\" +\n                   \"[\\\"testcode\\\",6,0]\\n\" +\n                   \"[\\\"testcode\\\",6,7,\\\"foo\\\"]\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2 --> junit.framework.ComparisonFailure: expected:<...ode, count: 1 }",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ode, count: 1 }"
      },
      "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3": {
        "path": "com/google/javascript/jscomp/SourceMapTest.java",
        "function_name": "testGoldenOutput3",
        "src": "public void testGoldenOutput3() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;\",\n\n                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                   \"\\\"count\\\": 1 }\\n\" +\n\n                   \"[0,0,0]\\n\" +\n\n                   \"/** Begin file information. **/\\n\" +\n                   \"[]\\n\" +\n                   \"/** Begin mapping definitions. **/\\n\" +\n                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3 --> junit.framework.ComparisonFailure: expected:<...ode, count: 1 }",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ode, count: 1 }"
      },
      "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4": {
        "path": "com/google/javascript/jscomp/SourceMapTest.java",
        "function_name": "testGoldenOutput4",
        "src": "public void testGoldenOutput4() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;   boo;   goo;\",\n\n                   \"/** Begin line maps. **/\" +\n                   \"{ \\\"file\\\" : \\\"testcode\\\", \\\"count\\\": 1 }\\n\" +\n                   \"[0,0,0,1,1,1,1,2,2,2,2]\\n\" +\n\n                   \"/** Begin file information. **/\\n\" +\n                   \"[]\\n\" +\n\n                   \"/** Begin mapping definitions. **/\\n\" +\n                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\" +\n                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,7,\\\"boo\\\"]\\n\" +\n                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,14,\\\"goo\\\"]\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4 --> junit.framework.ComparisonFailure: expected:<...ode, count: 1 }",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ode, count: 1 }"
      }
    }
  },
  "Closure-149": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "start_loc": 141,
        "end_loc": 179,
        "buggy_function": "  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompOff, CheckLevel.OFF);\n\n    createDefineReplacements(config.define, options);\n\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      options.jsOutputFile = config.jsOutputFile;\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMapSerialized =\n          VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMapSerialized =\n          VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n  }",
        "fixed_function": "  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompOff, CheckLevel.OFF);\n\n    createDefineReplacements(config.define, options);\n\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n\n    options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      options.jsOutputFile = config.jsOutputFile;\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMapSerialized =\n          VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMapSerialized =\n          VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n  }",
        "comment": "/**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "start_loc": 504,
        "end_loc": 547,
        "buggy_function": "  protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n\n    List<JSSourceFile> externsList = createExterns();\n    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n\n    compiler = createCompiler();\n    B options = createOptions();\n\n    JSModule[] modules = null;\n    Result result;\n\n    setRunOptions(options);\n    if (inputCharset == Charsets.UTF_8) {\n      options.outputCharset = Charsets.US_ASCII;\n    } else {\n      options.outputCharset = inputCharset;\n    }\n\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n      out = toWriter(options.jsOutputFile, inputCharset.name());\n    }\n\n    List<String> jsFiles = config.js;\n    List<String> moduleSpecs = config.module;\n    if (!moduleSpecs.isEmpty()) {\n      modules = createJsModules(moduleSpecs, jsFiles);\n      result = compiler.compile(externs, modules, options);\n    } else {\n      List<JSSourceFile> inputList = createSourceInputs(jsFiles);\n      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n      inputList.toArray(inputs);\n      result = compiler.compile(externs, inputs, options);\n    }\n\n    int errCode = processResults(result, modules, options);\n    // Close the output if we are writing to a file.\n    if (writeOutputToFile) {\n      ((Writer)out).close();\n    }\n    return errCode;\n  }",
        "fixed_function": "  protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n\n    List<JSSourceFile> externsList = createExterns();\n    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n\n    compiler = createCompiler();\n    B options = createOptions();\n\n    JSModule[] modules = null;\n    Result result;\n\n    setRunOptions(options);\n\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n      out = toWriter(options.jsOutputFile, inputCharset.name());\n    }\n\n    List<String> jsFiles = config.js;\n    List<String> moduleSpecs = config.module;\n    if (!moduleSpecs.isEmpty()) {\n      modules = createJsModules(moduleSpecs, jsFiles);\n      result = compiler.compile(externs, modules, options);\n    } else {\n      List<JSSourceFile> inputList = createSourceInputs(jsFiles);\n      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n      inputList.toArray(inputs);\n      result = compiler.compile(externs, inputs, options);\n    }\n\n    int errCode = processResults(result, modules, options);\n    // Close the output if we are writing to a file.\n    if (writeOutputToFile) {\n      ((Writer)out).close();\n    }\n    return errCode;\n  }",
        "comment": "/**\n   * Parses command-line arguments and runs the compiler.\n   *\n   * @return system exit status\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "start_loc": 454,
        "end_loc": 473,
        "buggy_function": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n  }",
        "fixed_function": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n    return options;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/Compiler.java",
        "start_loc": 1355,
        "end_loc": 1366,
        "buggy_function": "  private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n\n    Charset charset = options.outputCharset;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }",
        "fixed_function": "  private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }",
        "comment": "/**\n   * Generates JavaScript source code for an AST.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testCharSetExpansion": {
        "path": "com/google/javascript/jscomp/CommandLineRunnerTest.java",
        "function_name": "testCharSetExpansion",
        "src": "public void testCharSetExpansion() {\n    testSame(\"\");\n    assertEquals(\"US-ASCII\", lastCompiler.getOptions().outputCharset);\n    args.add(\"--charset=UTF-8\");\n    testSame(\"\");\n    assertEquals(\"UTF-8\", lastCompiler.getOptions().outputCharset);\n  }",
        "error_msg": "com.google.javascript.jscomp.CommandLineRunnerTest::testCharSetExpansion --> junit.framework.AssertionFailedError: expected:<US-ASCII> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<US-ASCII> but was:<null>"
      }
    }
  },
  "Closure-153": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/Normalize.java",
        "start_loc": 636,
        "end_loc": 683,
        "buggy_function": "    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      Var v = s.getVar(name);\n\n        // We allow variables to be duplicate declared if one\n        // declaration appears in source and the other in externs.\n        // This deals with issues where a browser built-in is declared\n        // in one browser but not in another.\n\n      // If name is \"arguments\", Var maybe null.\n      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n            name);\n        compiler.report(\n            JSError.make(\n                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n                CATCH_BLOCK_VAR_ERROR, name));\n      } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n          s.undeclare(v);\n          s.declare(name, n, n.getJSType(), v.input);\n          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n              v.getParentNode().getParent());\n        }\n      } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        replaceVarWithAssignment(n, parent, gramps);\n      }\n    }",
        "fixed_function": "    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, CompilerInput input) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      Node parent = n.getParent();\n      Var v = s.getVar(name);\n\n      if (v != null && s.isGlobal()) {\n        // We allow variables to be duplicate declared if one\n        // declaration appears in source and the other in externs.\n        // This deals with issues where a browser built-in is declared\n        // in one browser but not in another.\n        if (v.isExtern() && !input.isExtern()) {\n          if (hasOkDuplicateDeclaration.add(v)) {\n            return;\n          }\n        }\n      }\n\n      // If name is \"arguments\", Var maybe null.\n      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n            name);\n        compiler.report(\n            JSError.make(\n                input.getName(), n,\n                CATCH_BLOCK_VAR_ERROR, name));\n      } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n          s.undeclare(v);\n          s.declare(name, n, n.getJSType(), v.input);\n          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n              v.getParentNode().getParent());\n        }\n      } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        replaceVarWithAssignment(n, parent, parent.getParent());\n      }\n    }",
        "comment": "/**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "start_loc": 83,
        "end_loc": 113,
        "buggy_function": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnName, fnNameNode, n, null, null, n);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a.getString(), a, args, n, null, n);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
        "fixed_function": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "start_loc": 118,
        "end_loc": 173,
        "buggy_function": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          Preconditions.checkState(child.getType() == Token.NAME);\n          String name = child.getString();\n          declareVar(name, child, n, parent, null, n);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var.getString(), var, n, parent, null, n);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
        "fixed_function": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
        "comment": "/**\n   * Scans and gather variables declarations under a Node\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "start_loc": 188,
        "end_loc": 226,
        "buggy_function": "    public void onRedeclaration(\n        Scope s, String name,\n        Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n\n      // Don't allow multiple variables to be declared at the top level scope\n      if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH &&\n            parent.getType() == Token.CATCH) {\n          // Okay, both are 'catch(x)' variables.\n          return;\n        }\n\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n          info = parent.getJSDocInfo();\n        }\n        allowDupe =\n            info != null && info.getSuppressions().contains(\"duplicate\");\n\n        if (!allowDupe) {\n          compiler.report(\n              JSError.make(sourceName, n,\n                           VAR_MULTIPLY_DECLARED_ERROR,\n                           name,\n                           (origVar.input != null\n                            ? origVar.input.getName()\n                            : \"??\")));\n        }\n      } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(\n            JSError.make(sourceName, n,\n                VAR_ARGUMENTS_SHADOWED_ERROR));\n      }\n    }",
        "fixed_function": "    public void onRedeclaration(\n        Scope s, String name, Node n, CompilerInput input) {\n      Node parent = n.getParent();\n\n      // Don't allow multiple variables to be declared at the top level scope\n      if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH &&\n            parent.getType() == Token.CATCH) {\n          // Okay, both are 'catch(x)' variables.\n          return;\n        }\n\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n          info = parent.getJSDocInfo();\n        }\n        allowDupe =\n            info != null && info.getSuppressions().contains(\"duplicate\");\n\n        if (!allowDupe) {\n          compiler.report(\n              JSError.make(sourceName, n,\n                           VAR_MULTIPLY_DECLARED_ERROR,\n                           name,\n                           (origVar.input != null\n                            ? origVar.input.getName()\n                            : \"??\")));\n        }\n      } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(\n            JSError.make(sourceName, n,\n                VAR_ARGUMENTS_SHADOWED_ERROR));\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "start_loc": 235,
        "end_loc": 246,
        "buggy_function": "  private void declareVar(String name, Node n, Node parent,\n                          Node gramps, JSType declaredType,\n                          Node nodeWithLineNumber) {\n\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n      scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n  }",
        "fixed_function": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n\n    CompilerInput input = compiler.getInput(sourceName);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
        "comment": "/**\n   * Declares a variable.\n   *\n   * @param n The node corresponding to the variable name.\n   * @param declaredType The variable's type, according to JSDoc\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.NormalizeTest::testDuplicateVarInExterns": {
        "path": "com/google/javascript/jscomp/NormalizeTest.java",
        "function_name": "testDuplicateVarInExterns",
        "src": "public void testDuplicateVarInExterns() {\n    test(\"var extern;\",\n         \"/** @suppress {duplicate} */ var extern = 3;\", \"var extern = 3;\",\n         null, null);\n  }",
        "error_msg": "com.google.javascript.jscomp.NormalizeTest::testDuplicateVarInExterns --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.NormalizeTest::testMakeLocalNamesUnique": {
        "path": "com/google/javascript/jscomp/NormalizeTest.java",
        "function_name": "testMakeLocalNamesUnique",
        "src": "public void testMakeLocalNamesUnique() {\n    if (!Normalize.MAKE_LOCAL_NAMES_UNIQUE) {\n      return;\n    }\n\n    // Verify global names are untouched.\n    testSame(\"var a;\");\n\n    // Verify global names are untouched.\n    testSame(\"a;\");\n\n    // Local names are made unique.\n    test(\"var a;function foo(a){var b;a}\",\n         \"var a;function foo(a$$1){var b;a$$1}\");\n    test(\"var a;function foo(){var b;a}function boo(){var b;a}\",\n         \"var a;function foo(){var b;a}function boo(){var b$$1;a}\");\n    test(\"function foo(a){var b}\" +\n         \"function boo(a){var b}\",\n         \"function foo(a){var b}\" +\n         \"function boo(a$$1){var b$$1}\");\n\n    // Verify function expressions are renamed.\n    test(\"var a = function foo(){foo()};var b = function foo(){foo()};\",\n         \"var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};\");\n\n    // Verify catch exceptions names are made unique\n    test(\"try { } catch(e) {e;}\",\n         \"try { } catch(e) {e;}\");\n    test(\"try { } catch(e) {e;}; try { } catch(e) {e;}\",\n         \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}\");\n    test(\"try { } catch(e) {e; try { } catch(e) {e;}};\",\n         \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n\n    // Verify the 1st global redefinition of extern definition is not removed.\n    test(\"/** @suppress {duplicate} */\\nvar window;\", \"var window;\");\n\n    // Verify the 2nd global redefinition of extern definition is removed.\n    test(\"/** @suppress {duplicate} */\\nvar window;\" +\n         \"/** @suppress {duplicate} */\\nvar window;\", \"var window;\");\n\n    // Verify local masking extern made unique.\n    test(\"function f() {var window}\",\n         \"function f() {var window$$1}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.NormalizeTest::testMakeLocalNamesUnique --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-154": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "start_loc": 1014,
        "end_loc": 1098,
        "buggy_function": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n        if (reportMissingOverride.isOn() && !declaredOverride &&\n            interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n        if (interfaceHasProperty) {\n          JSType interfacePropType =\n              interfaceType.getPrototype().getPropertyType(propertyName);\n          if (!propertyType.canAssignTo(interfacePropType)) {\n            compiler.report(t.makeError(n,\n                HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,\n                interfaceType.getTopMostDefiningType(propertyName).toString(),\n                interfacePropType.toString(), propertyType.toString()));\n          }\n        }\n      }\n    }\n\n    if (!declaredOverride && !superClassHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    JSType topInstanceType = superClassHasProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n        !declaredOverride && superClassHasProperty) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n      // there's no @override to check\n      return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getPrototype().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (!foundInterfaceProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }",
        "fixed_function": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n        if (reportMissingOverride.isOn() && !declaredOverride &&\n            interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride && !superClassHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    JSType topInstanceType = superClassHasProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n        !declaredOverride && superClassHasProperty) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n      // there's no @override to check\n      return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getPrototype().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (!foundInterfaceProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }",
        "comment": "/**\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "start_loc": 576,
        "end_loc": 590,
        "buggy_function": "  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    if (!instance.hasProperty(prop)) {\n      // Not implemented\n      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n      sourceName = sourceName == null ? \"\" : sourceName;\n      if (shouldReport) {\n        compiler.report(JSError.make(sourceName, n,\n            INTERFACE_METHOD_NOT_IMPLEMENTED,\n            prop, implementedInterface.toString(), instance.toString()));\n      }\n      registerMismatch(instance, implementedInterface);\n        // Implemented, but not correctly typed\n    }\n  }",
        "fixed_function": "  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    if (!instance.hasProperty(prop)) {\n      // Not implemented\n      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n      sourceName = sourceName == null ? \"\" : sourceName;\n      if (shouldReport) {\n        compiler.report(JSError.make(sourceName, n,\n            INTERFACE_METHOD_NOT_IMPLEMENTED,\n            prop, implementedInterface.toString(), instance.toString()));\n      }\n      registerMismatch(instance, implementedInterface);\n    } else {\n      JSType found = instance.getPropertyType(prop);\n      JSType required\n        = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        // Implemented, but not correctly typed\n        if (shouldReport) {\n          FunctionType constructor\n            = implementedInterface.toObjectType().getConstructor();\n          compiler.report(t.makeError(n,\n              HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n              constructor.getTopMostDefiningType(prop).toString(),\n              required.toString(), found.toString()));\n        }\n        registerMismatch(found, required);\n      }\n    }\n  }",
        "comment": "/**\n   * Expect that the peroperty in an interface that this type implements is\n   * implemented and correctly typed.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck12": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testInterfaceInheritanceCheck12",
        "src": "public void testInterfaceInheritanceCheck12() throws Exception {\n    testTypes(\n        \"/** @interface */ function I() {};\\n\" +\n        \"/** @type {string} */ I.prototype.foobar;\\n\" +\n        \"/** \\n * @constructor \\n * @implements {I} */\\n\" +\n        \"function C() {\\n\" +\n        \"/** \\n * @type {number} */ this.foobar = 2;};\\n\" +\n        \"/** @type {I} */ \\n var test = new C(); alert(test.foobar);\",\n        \"mismatch of the foobar property type and the type of the property\" +\n        \" it overrides from interface I\\n\" +\n        \"original: string\\n\" +\n        \"override: number\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck12 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      }
    }
  },
  "Closure-155": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "start_loc": 196,
        "end_loc": 223,
        "buggy_function": "    private void doInlinesForScope(NodeTraversal t,\n        Map<Var, ReferenceCollection> referenceMap) {\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo);\n        }\n      }\n    }",
        "fixed_function": "    private void doInlinesForScope(NodeTraversal t,\n        Map<Var, ReferenceCollection> referenceMap) {\n\n      boolean maybeModifiedArguments =\n          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n        }\n      }\n    }",
        "comment": "/**\n     * For all variables in this scope, see if they are only used once.\n     * If it looks safe to do so, inline them.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "start_loc": 229,
        "end_loc": 297,
        "buggy_function": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNameNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (\n          !staleVars.contains(v) && referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNameNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }",
        "fixed_function": "    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, Map<Var, ReferenceCollection> referenceMap) {\n      if (scope.isLocal()) {\n        Var arguments = scope.getArgumentsVar();\n        ReferenceCollection refs = referenceMap.get(arguments);\n        if (refs != null && !refs.references.isEmpty()) {\n          for (Reference ref : refs.references) {\n            Node refNode = ref.getNameNode();\n            Node refParent = ref.getParent();\n            // Any reference that is not a read of the arguments property\n            // consider a escape of the arguments object.\n            if (!(NodeUtil.isGet(refParent)\n                && refNode == ref.getParent().getFirstChild()\n                && !isLValue(refParent))) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "start_loc": 121,
        "end_loc": 133,
        "buggy_function": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n      Var v = t.getScope().getVar(n.getString());\n      if (v != null && varFilter.apply(v)) {\n        addReference(t, v,\n            new Reference(n, parent, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }",
        "fixed_function": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n      Var v;\n      if (n.getString().equals(\"arguments\")) {\n        v = t.getScope().getArgumentsVar();\n      } else {\n        v = t.getScope().getVar(n.getString());\n      }\n      if (v != null && varFilter.apply(v)) {\n        addReference(t, v,\n            new Reference(n, parent, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }",
        "comment": "/**\n   * For each node, update the block stack and reference collection\n   * as appropriate.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.InlineVariablesTest::testArgumentsModifiedInInnerFunction": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testArgumentsModifiedInInnerFunction",
        "src": "public void testArgumentsModifiedInInnerFunction() {\n    test(\n      \"function g(callback) {\\n\" +\n      \"  var f = callback;\\n\" +\n      \"  f.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\",\n      \"function g(callback) {\\n\" +\n      \"  callback.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testArgumentsModifiedInInnerFunction --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testArgumentsModifiedInOuterFunction": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testArgumentsModifiedInOuterFunction",
        "src": "public void testArgumentsModifiedInOuterFunction() {\n    test(\n      \"function g(callback) {\\n\" +\n      \"  var f = callback;\\n\" +\n      \"  arguments[0] = this;\\n\" +\n      \"  f.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\",\n      \"function g(callback) {\\n\" +\n      \"  var f = callback;\\n\" +\n      \"  arguments[0] = this;\\n\" +\n      \"  f.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    callback.apply(this);\\n\" +\n      \"  }\" +\n      \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testArgumentsModifiedInOuterFunction --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testIssue378ModifiedArguments1": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testIssue378ModifiedArguments1",
        "src": "public void testIssue378ModifiedArguments1() {\n    testSame(\n        \"function g(callback) {\\n\" +\n        \"  var f = callback;\\n\" +\n        \"  arguments[0] = this;\\n\" +\n        \"  f.apply(this, arguments);\\n\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testIssue378ModifiedArguments1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testIssue378ModifiedArguments2": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testIssue378ModifiedArguments2",
        "src": "public void testIssue378ModifiedArguments2() {\n    testSame(\n        \"function g(callback) {\\n\" +\n        \"  /** @const */\\n\" +\n        \"  var f = callback;\\n\" +\n        \"  arguments[0] = this;\\n\" +\n        \"  f.apply(this, arguments);\\n\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testIssue378ModifiedArguments2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments1": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testIssue378EscapedArguments1",
        "src": "public void testIssue378EscapedArguments1() {\n    testSame(\n        \"function g(callback) {\\n\" +\n        \"  var f = callback;\\n\" +\n        \"  h(arguments,this);\\n\" +\n        \"  f.apply(this, arguments);\\n\" +\n        \"}\\n\" +\n        \"function h(a,b) {\\n\" +\n        \"  a[0] = b;\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments1 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments2": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testIssue378EscapedArguments2",
        "src": "public void testIssue378EscapedArguments2() {\n    testSame(\n        \"function g(callback) {\\n\" +\n        \"  /** @const */\\n\" +\n        \"  var f = callback;\\n\" +\n        \"  h(arguments,this);\\n\" +\n        \"  f.apply(this);\\n\" +\n        \"}\\n\" +\n        \"function h(a,b) {\\n\" +\n        \"  a[0] = b;\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments2 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments4": {
        "path": "com/google/javascript/jscomp/InlineVariablesTest.java",
        "function_name": "testIssue378EscapedArguments4",
        "src": "public void testIssue378EscapedArguments4() {\n    testSame(\n        \"function g(callback) {\\n\" +\n        \"  var f = callback;\\n\" +\n        \"  h(arguments[0],this);\\n\" +\n        \"  f.apply(this, arguments);\\n\" +\n        \"}\\n\" +\n        \"function h(a,b) {\\n\" +\n        \"  a[0] = b;\" +\n        \"}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.InlineVariablesTest::testIssue378EscapedArguments4 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-157": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "start_loc": 82,
        "end_loc": 722,
        "buggy_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          add(jsString(n.getString(), outputCharsetEncoder));\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (c.getType() == Token.STRING &&\n                !c.isQuotedString() &&\n                !TokenStream.isKeyword(c.getString()) &&\n                TokenStream.isJSIdentifier(c.getString()) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(c.getString())) {\n              add(c.getString());\n            } else {\n              // Determine if the string is a simple number.\n              addExpr(c, 1);\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "fixed_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(\n            childCount ==\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            add(jsString(n.getString(), outputCharsetEncoder));\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.getType() == Token.STRING);\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "start_loc": 343,
        "end_loc": 356,
        "buggy_function": "    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name)n);\n      } else {\n        ret = transform(n);\n        Preconditions.checkState(ret.getType() == Token.NUMBER\n            || ret.getType() == Token.STRING);\n        if (ret.getType() == Token.STRING) {\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n        }\n      }\n      return ret;\n    }",
        "fixed_function": "  private Node transformNumberAsString(NumberLiteral literalNode) {\n    JSDocInfo jsDocInfo = handleJsDoc(literalNode);\n    Node irNode = newStringNode(getStringValue(literalNode.getNumber()));\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, literalNode);\n    return irNode;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/RenamePrototypes.java",
        "start_loc": 313,
        "end_loc": 343,
        "buggy_function": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n          if (dest.getType() == Token.STRING) {\n            String s = dest.getString();\n            if (s.equals(\"prototype\")) {\n              processPrototypeParent(parent, t.getInput());\n            } else {\n              markPropertyAccessCandidate(dest, t.getInput());\n            }\n          }\n          break;\n        case Token.OBJECTLIT:\n          if (!prototypeObjLits.contains(n)) {\n            // Object literals have their property name/value pairs as a flat\n            // list as their children. We want every other node in order to get\n            // only the property names.\n            for (Node child = n.getFirstChild();\n                 child != null;\n                 child = child.getNext()) {\n\n              if (child.getType() != Token.NUMBER) {\n                markObjLitPropertyCandidate(child, t.getInput());\n              }\n            }\n          }\n          break;\n      }\n    }",
        "fixed_function": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n          if (dest.getType() == Token.STRING) {\n            String s = dest.getString();\n            if (s.equals(\"prototype\")) {\n              processPrototypeParent(parent, t.getInput());\n            } else {\n              markPropertyAccessCandidate(dest, t.getInput());\n            }\n          }\n          break;\n        case Token.OBJECTLIT:\n          if (!prototypeObjLits.contains(n)) {\n            // Object literals have their property name/value pairs as a flat\n            // list as their children. We want every other node in order to get\n            // only the property names.\n            for (Node child = n.getFirstChild();\n                 child != null;\n                 child = child.getNext()) {\n\n              if (TokenStream.isJSIdentifier(child.getString())) {\n                markObjLitPropertyCandidate(child, t.getInput());\n              }\n            }\n          }\n          break;\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/RenamePrototypes.java",
        "start_loc": 350,
        "end_loc": 385,
        "buggy_function": "    private void processPrototypeParent(Node n, CompilerInput input) {\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n          if (dest.getType() == Token.STRING) {\n            markPrototypePropertyCandidate(dest, input);\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n          Node map;\n          if (n.getType() == Token.ASSIGN) {\n            map = n.getFirstChild().getNext();\n          } else {\n            map = n.getLastChild();\n          }\n          if (map.getType() == Token.OBJECTLIT) {\n            // Remember this node so that we can avoid processing it again when\n            // the traversal reaches it.\n            prototypeObjLits.add(map);\n\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              if (key.getType() != Token.NUMBER) {\n               // May be STRING, GET, or SET\n                markPrototypePropertyCandidate(key, input);\n              }\n            }\n          }\n          break;\n      }\n    }",
        "fixed_function": "    private void processPrototypeParent(Node n, CompilerInput input) {\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n          if (dest.getType() == Token.STRING) {\n            markPrototypePropertyCandidate(dest, input);\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n          Node map;\n          if (n.getType() == Token.ASSIGN) {\n            map = n.getFirstChild().getNext();\n          } else {\n            map = n.getLastChild();\n          }\n          if (map.getType() == Token.OBJECTLIT) {\n            // Remember this node so that we can avoid processing it again when\n            // the traversal reaches it.\n            prototypeObjLits.add(map);\n\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              if (TokenStream.isJSIdentifier(key.getString())) {\n               // May be STRING, GET, or SET\n                markPrototypePropertyCandidate(key, input);\n              }\n            }\n          }\n          break;\n      }\n    }",
        "comment": "/**\n     * Processes the parent of a GETPROP prototype, which can either be\n     * another GETPROP (in the case of Foo.prototype.bar), or can be\n     * an assignment (in the case of Foo.prototype = ...).\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CodePrinterTest::testObjectLit2": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testObjectLit2",
        "src": "public void testObjectLit2() {\n    assertPrint(\"var x={1:1}\", \"var x={1:1}\");\n    assertPrint(\"var x={'1':1}\", \"var x={1:1}\");\n    assertPrint(\"var x={'1.0':1}\", \"var x={\\\"1.0\\\":1}\");\n    assertPrint(\"var x={1.5:1}\", \"var x={\\\"1.5\\\":1}\");\n\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testObjectLit2 --> junit.framework.ComparisonFailure: expected:<var x={[1]:1}> but was:<var x={[1]:1}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var x={[1]:1}> but was:<var x={[1]:1}>"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testObjectLit3": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testObjectLit3",
        "src": "public void testObjectLit3() {\n    assertPrint(\"var x={3E9:1}\",\n                \"var x={3E9:1}\");\n    assertPrint(\"var x={'3000000000':1}\", // More than 31 bits\n                \"var x={3E9:1}\");\n    assertPrint(\"var x={'3000000001':1}\",\n                \"var x={3000000001:1}\");\n    assertPrint(\"var x={'6000000001':1}\",  // More than 32 bits\n                \"var x={6000000001:1}\");\n    assertPrint(\"var x={\\\"12345678901234567\\\":1}\",  // More than 53 bits\n                \"var x={\\\"12345678901234567\\\":1}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testObjectLit3 --> junit.framework.ComparisonFailure: expected:<var x={[3E9]:1}> but was:<var x={[3000000000]:1}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var x={[3E9]:1}> but was:<var x={[3000000000]:1}>"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testGetter": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testGetter",
        "src": "public void testGetter() {\n    assertPrint(\"var x = {}\", \"var x={}\");\n    assertPrint(\"var x = {get a() {return 1}}\", \"var x={get a(){return 1}}\");\n    assertPrint(\n      \"var x = {get a() {}, get b(){}}\",\n      \"var x={get a(){},get b(){}}\");\n\n    assertPrint(\n      \"var x = {get 'a'() {return 1}}\",\n      \"var x={get \\\"a\\\"(){return 1}}\");\n\n    assertPrint(\n      \"var x = {get 1() {return 1}}\",\n      \"var x={get 1(){return 1}}\");\n\n    assertPrint(\n      \"var x = {get \\\"()\\\"() {return 1}}\",\n      \"var x={get \\\"()\\\"(){return 1}}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testGetter --> junit.framework.ComparisonFailure: expected:<var x={get [a](){return 1}}> but was:<var x={get [a](){return 1}}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var x={get [a](){return 1}}> but was:<var x={get [a](){return 1}}>"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testSetter": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testSetter",
        "src": "public void testSetter() {\n    assertPrint(\"var x = {}\", \"var x={}\");\n    assertPrint(\n       \"var x = {set a(y) {return 1}}\",\n       \"var x={set a(y){return 1}}\");\n\n    assertPrint(\n      \"var x = {get 'a'() {return 1}}\",\n      \"var x={get \\\"a\\\"(){return 1}}\");\n\n    assertPrint(\n      \"var x = {set 1(y) {return 1}}\",\n      \"var x={set 1(y){return 1}}\");\n\n    assertPrint(\n      \"var x = {set \\\"(x)\\\"(y) {return 1}}\",\n      \"var x={set \\\"(x)\\\"(y){return 1}}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testSetter --> junit.framework.ComparisonFailure: expected:<var x={get [a](){return 1}}> but was:<var x={get [a](){return 1}}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var x={get [a](){return 1}}> but was:<var x={get [a](){return 1}}>"
      },
      "com.google.javascript.jscomp.FunctionNamesTest::testFunctionsNamesAndIds": {
        "path": "com/google/javascript/jscomp/FunctionNamesTest.java",
        "function_name": "testFunctionsNamesAndIds",
        "src": "public void testFunctionsNamesAndIds() {\n    final String jsSource =\n        \"goog.widget = function(str) {\\n\" +\n        \"  this.member_fn = function() {};\\n\" +\n        \"  local_fn = function() {};\\n\" +\n        \"  (function(a){})(1);\\n\" +\n        \"}\\n\" +\n        \"function foo() {\\n\" +\n        \"  function bar() {}\\n\" +\n        \"}\\n\" +\n        \"literal = {f1 : function(){}, f2 : function(){}};\\n\" +\n        \"goog.array.map(arr, function named(){});\\n\" +\n        \"goog.array.map(arr, function(){});\\n\" +\n        \"named_twice = function quax(){};\\n\" +\n        \"recliteral = {l1 : {l2 : function(){}}};\\n\" +\n        \"namedliteral = {n1 : function litnamed(){}};\\n\" +\n        \"namedrecliteral = {n1 : {n2 : function reclitnamed(){}}};\\n\" +\n        \"numliteral = {1 : function(){}};\\n\" +\n        \"recnumliteral = {1 : {a : function(){}}};\\n\";\n\n    testSame(jsSource);\n\n    final Map<Integer, String> idNameMap = Maps.newLinkedHashMap();\n    int count = 0;\n    for (Node f : functionNames.getFunctionNodeList()) {\n      int id = functionNames.getFunctionId(f);\n      String name = functionNames.getFunctionName(f);\n      idNameMap.put(id, name);\n      count++;\n    }\n\n    assertEquals(\"Unexpected number of functions\", 16, count);\n\n    final Map<Integer, String> expectedMap = Maps.newLinkedHashMap();\n\n    expectedMap.put(0, \"goog.widget.member_fn\");\n    expectedMap.put(1, \"goog.widget::local_fn\");\n    expectedMap.put(2, \"goog.widget::<anonymous>\");\n    expectedMap.put(3, \"goog.widget\");\n    expectedMap.put(4, \"foo::bar\");\n    expectedMap.put(5, \"foo\");\n    expectedMap.put(6, \"literal.f1\");\n    expectedMap.put(7, \"literal.f2\");\n    expectedMap.put(8, \"named\");\n    expectedMap.put(9, \"<anonymous>\");\n    expectedMap.put(10, \"quax\");\n    expectedMap.put(11, \"recliteral.l1.l2\");\n    expectedMap.put(12, \"litnamed\");\n    expectedMap.put(13, \"reclitnamed\");\n    expectedMap.put(14, \"numliteral.__2\");\n    expectedMap.put(15, \"recnumliteral.__3.a\");\n    assertEquals(\"Function id/name mismatch\",\n                 expectedMap, idNameMap);\n  }",
        "error_msg": "com.google.javascript.jscomp.FunctionNamesTest::testFunctionsNamesAndIds --> junit.framework.AssertionFailedError: Function id/name mismatch expected:<{0=goog.widget.member_fn, 1=goog.widget::local_fn, 2=goog.widget::<anonymous>, 3=goog.widget, 4=foo::bar, 5=foo, 6=literal.f1, 7=literal.f2, 8=named, 9=<anonymous>, 10=quax, 11=recliteral.l1.l2, 12=litnamed, 13=reclitnamed, 14=numliteral.__2, 15=recnumliteral.__3.a}> but was:<{0=goog.widget.member_fn, 1=goog.widget::local_fn, 2=goog.widget::<anonymous>, 3=goog.widget, 4=foo::bar, 5=foo, 6=literal.f1, 7=literal.f2, 8=named, 9=<anonymous>, 10=quax, 11=recliteral.l1.l2, 12=litnamed, 13=reclitnamed, 14=<anonymous>, 15=<anonymous>}>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Function id/name mismatch expected:<{0=goog.widget.member_fn, 1=goog.widget::local_fn, 2=goog.widget::<anonymous>, 3=goog.widget, 4=foo::bar, 5=foo, 6=literal.f1, 7=literal.f2, 8=named, 9=<anonymous>, 10=quax, 11=recliteral.l1.l2, 12=litnamed, 13=reclitnamed, 14=numliteral.__2, 15=recnumliteral.__3.a}> but was:<{0=goog.widget.member_fn, 1=goog.widget::local_fn, 2=goog.widget::<anonymous>, 3=goog.widget, 4=foo::bar, 5=foo, 6=literal.f1, 7=literal.f2, 8=named, 9=<anonymous>, 10=quax, 11=recliteral.l1.l2, 12=litnamed, 13=reclitnamed, 14=<anonymous>, 15=<anonymous>}>"
      },
      "com.google.javascript.jscomp.RenamePropertiesTest::testPrototypePropertiesAsObjLitKeys2": {
        "path": "com/google/javascript/jscomp/RenamePropertiesTest.java",
        "function_name": "testPrototypePropertiesAsObjLitKeys2",
        "src": "public void testPrototypePropertiesAsObjLitKeys2() {\n    testSame(\"Bar.prototype = {get 2(){}}; bar[2];\");\n\n    testSame(\"Bar.prototype = {get 'a'(){}}; bar['a'];\");\n\n    test(\"Bar.prototype = {get getA(){}}; bar.getA;\",\n         \"Bar.prototype = {get a(){}}; bar.a;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.RenamePropertiesTest::testPrototypePropertiesAsObjLitKeys2 --> java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      },
      "com.google.javascript.jscomp.RenamePropertiesTest::testPrototypePropertiesAsObjLitKeys3": {
        "path": "com/google/javascript/jscomp/RenamePropertiesTest.java",
        "function_name": "testPrototypePropertiesAsObjLitKeys3",
        "src": "public void testPrototypePropertiesAsObjLitKeys3() {\n    testSame(\"Bar.prototype = {set 2(x){}}; bar[2];\");\n\n    testSame(\"Bar.prototype = {set 'a'(x){}}; bar['a'];\");\n\n    test(\"Bar.prototype = {set getA(x){}}; bar.getA;\",\n         \"Bar.prototype = {set a(x){}}; bar.a;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.RenamePropertiesTest::testPrototypePropertiesAsObjLitKeys3 --> java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      },
      "com.google.javascript.jscomp.SimpleDefinitionFinderTest::testDefineNumber": {
        "path": "com/google/javascript/jscomp/SimpleDefinitionFinderTest.java",
        "function_name": "testDefineNumber",
        "src": "public void testDefineNumber() throws Exception {\n    checkDefinitionsInJs(\n        \"var a = 1\",\n        ImmutableSet.of(\"DEF NAME a -> NUMBER\"));\n\n    checkDefinitionsInJs(\n        \"a = 1\",\n        ImmutableSet.of(\"DEF NAME a -> NUMBER\"));\n\n    checkDefinitionsInJs(\n        \"a.b = 1\",\n        ImmutableSet.of(\"DEF GETPROP a.b -> NUMBER\"));\n\n    // getelem expressions are invisible to the definition gatherer.\n    checkDefinitionsInJs(\n        \"a[\\\"b\\\"] = 1\",\n        ImmutableSet.<String>of());\n\n    checkDefinitionsInJs(\n        \"f().b = 1\",\n        ImmutableSet.of(\"DEF GETPROP null -> NUMBER\"));\n\n    checkDefinitionsInJs(\n        \"({a : 1}); o.a\",\n        ImmutableSet.of(\"DEF STRING null -> NUMBER\",\n                        \"USE GETPROP o.a -> [NUMBER]\"));\n\n    // TODO(johnlenz): Fix this.\n    checkDefinitionsInJs(\n      \"({'a' : 1}); o['a']\",\n      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n\n    checkDefinitionsInJs(\n      \"({1 : 1}); o[1]\",\n      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n\n    checkDefinitionsInJs(\n        \"var a = {b : 1}; a.b\",\n        ImmutableSet.of(\"DEF NAME a -> <null>\",\n                        \"DEF STRING null -> NUMBER\",\n                        \"USE NAME a -> [<null>]\",\n                        \"USE GETPROP a.b -> [NUMBER]\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.SimpleDefinitionFinderTest::testDefineNumber --> junit.framework.AssertionFailedError: expected:<[DEF STRING null -> NUMBER]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[DEF STRING null -> NUMBER]> but was:<[]>"
      },
      "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral6": {
        "path": "com/google/javascript/jscomp/parsing/IRFactoryTest.java",
        "function_name": "testObjectLiteral6",
        "src": "public void testObjectLiteral6() {\n    testNewParser(\"({1: true})\",\n      \"SCRIPT 0\\n\" +\n      \"    EXPR_RESULT 0\\n\" +\n      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n      \"            STRING 1 0 [quoted: 1]\\n\" +\n      \"                TRUE 0\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral6 --> junit.framework.ComparisonFailure: expected:<...: true]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...: true]"
      },
      "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral7": {
        "path": "com/google/javascript/jscomp/parsing/IRFactoryTest.java",
        "function_name": "testObjectLiteral7",
        "src": "public void testObjectLiteral7() {\n    mode = LanguageMode.ECMASCRIPT5;\n\n    testNewParser(\"({get 1() {}})\",\n      \"SCRIPT 0\\n\" +\n      \"    EXPR_RESULT 0\\n\" +\n      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n      \"            GET 1 0 [quoted: 1]\\n\" +\n      \"                FUNCTION  0\\n\" +\n      \"                    NAME  0\\n\" +\n      \"                    LP 0\\n\" +\n      \"                    BLOCK 0\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral7 --> junit.framework.ComparisonFailure: expected:<...ue]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ue]"
      },
      "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral8": {
        "path": "com/google/javascript/jscomp/parsing/IRFactoryTest.java",
        "function_name": "testObjectLiteral8",
        "src": "public void testObjectLiteral8() {\n    mode = LanguageMode.ECMASCRIPT5;\n\n    testNewParser(\"({set 1(a) {}})\",\n      \"SCRIPT 0\\n\" +\n      \"    EXPR_RESULT 0\\n\" +\n      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n      \"            SET 1 0 [quoted: 1]\\n\" +\n      \"                FUNCTION  0\\n\" +\n      \"                    NAME  0\\n\" +\n      \"                    LP 0\\n\" +\n      \"                        NAME a 0\\n\" +\n      \"                    BLOCK 0\\n\");\n  }",
        "error_msg": "com.google.javascript.jscomp.parsing.IRFactoryTest::testObjectLiteral8 --> junit.framework.ComparisonFailure: expected:<...ue]",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...ue]"
      },
      "com.google.javascript.jscomp.parsing.ParserTest::testObjectLiteralDoc1": {
        "path": "com/google/javascript/jscomp/parsing/ParserTest.java",
        "function_name": "testObjectLiteralDoc1",
        "src": "public void testObjectLiteralDoc1() {\n    Node n = parse(\"var x = {/** @type {number} */ 1: 2};\");\n\n    Node objectLit = n.getFirstChild().getFirstChild().getFirstChild();\n    assertEquals(Token.OBJECTLIT, objectLit.getType());\n\n    Node number = objectLit.getFirstChild();\n    assertEquals(Token.STRING, number.getType());\n    assertNotNull(number.getJSDocInfo());\n  }",
        "error_msg": "com.google.javascript.jscomp.parsing.ParserTest::testObjectLiteralDoc1 --> junit.framework.AssertionFailedError: expected:<40> but was:<39>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<40> but was:<39>"
      }
    }
  },
  "Closure-158": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "start_loc": 193,
        "end_loc": 257,
        "buggy_function": "  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompOff, CheckLevel.OFF);\n\n    createDefineOrTweakReplacements(config.define, options, false);\n\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    if (config.closureEntryPoints.size() > 0) {\n      options.setManageClosureDependencies(config.closureEntryPoints);\n    }\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n\n    outputCharset = options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      options.jsOutputFile = config.jsOutputFile;\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMapSerialized =\n          VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMapSerialized =\n          VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n\n    if (config.languageIn.length() > 0) {\n      if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") ||\n          config.languageIn.equals(\"ES5_STRICT\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n      } else if (config.languageIn.equals(\"ECMASCRIPT5\") ||\n          config.languageIn.equals(\"ES5\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n      } else if (config.languageIn.equals(\"ECMASCRIPT3\") ||\n                 config.languageIn.equals(\"ES3\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n      } else {\n        throw new FlagUsageException(\"Unknown language `\" + config.languageIn +\n                                     \"' specified.\");\n      }\n    }\n\n    options.acceptConstKeyword = config.acceptConstKeyword;\n  }",
        "fixed_function": "  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    if (config.warningGuards != null) {\n      for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {\n        diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level);\n      }\n    }\n\n    createDefineOrTweakReplacements(config.define, options, false);\n\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    if (config.closureEntryPoints.size() > 0) {\n      options.setManageClosureDependencies(config.closureEntryPoints);\n    }\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n\n    outputCharset = options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      options.jsOutputFile = config.jsOutputFile;\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMapSerialized =\n          VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMapSerialized =\n          VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n\n    if (config.languageIn.length() > 0) {\n      if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") ||\n          config.languageIn.equals(\"ES5_STRICT\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n      } else if (config.languageIn.equals(\"ECMASCRIPT5\") ||\n          config.languageIn.equals(\"ES5\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n      } else if (config.languageIn.equals(\"ECMASCRIPT3\") ||\n                 config.languageIn.equals(\"ES3\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n      } else {\n        throw new FlagUsageException(\"Unknown language `\" + config.languageIn +\n                                     \"' specified.\");\n      }\n    }\n\n    options.acceptConstKeyword = config.acceptConstKeyword;\n  }",
        "comment": "/**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "start_loc": 1502,
        "end_loc": 1506,
        "buggy_function": "    CommandLineConfig setJscompError(List<String> jscompError) {\n      this.jscompError.clear();\n      this.jscompError.addAll(jscompError);\n      return this;\n    }",
        "fixed_function": "    CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {\n      this.warningGuards = spec;\n      return this;\n    }",
        "comment": "/**\n     * Add warning guards.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "start_loc": 470,
        "end_loc": 493,
        "buggy_function": "  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException {\n    List<String> argsInFile = Lists.newArrayList();\n    File flagFileInput = new File(flags.flag_file);\n    StringTokenizer tokenizer = new StringTokenizer(\n        Files.toString(flagFileInput, Charset.defaultCharset()));\n\n    while (tokenizer.hasMoreTokens()) {\n        argsInFile.add(tokenizer.nextToken());\n    }\n\n    flags.flag_file = \"\";\n    List<String> processedFileArgs\n        = processArgs(argsInFile.toArray(new String[] {}));\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n\n    // Currently we are not supporting this (prevent direct/indirect loops)\n    if (!flags.flag_file.equals(\"\")) {\n      err.println(\"ERROR - Arguments in the file cannot contain \"\n          + \"--flagfile option.\");\n      isConfigValid = false;\n    }\n  }",
        "fixed_function": "  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException {\n    List<String> argsInFile = Lists.newArrayList();\n    File flagFileInput = new File(flags.flag_file);\n    StringTokenizer tokenizer = new StringTokenizer(\n        Files.toString(flagFileInput, Charset.defaultCharset()));\n\n    while (tokenizer.hasMoreTokens()) {\n        argsInFile.add(tokenizer.nextToken());\n    }\n\n    flags.flag_file = \"\";\n    List<String> processedFileArgs\n        = processArgs(argsInFile.toArray(new String[] {}));\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\n    Flags.warningGuardSpec.clear();\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n\n    // Currently we are not supporting this (prevent direct/indirect loops)\n    if (!flags.flag_file.equals(\"\")) {\n      err.println(\"ERROR - Arguments in the file cannot contain \"\n          + \"--flagfile option.\");\n      isConfigValid = false;\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "start_loc": 495,
        "end_loc": 563,
        "buggy_function": "  private void initConfigFromFlags(String[] args, PrintStream err) {\n\n    List<String> processedArgs = processArgs(args);\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    isConfigValid = true;\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n      // For contains --flagfile flag\n      if (!flags.flag_file.equals(\"\")) {\n        processFlagFile(err);\n      }\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      isConfigValid = false;\n    } catch (IOException ioErr) {\n      err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n      isConfigValid = false;\n    }\n\n    if (flags.version) {\n      ResourceBundle config = ResourceBundle.getBundle(configResource);\n      err.println(\n          \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n          \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n          \"Built on: \" + config.getString(\"compiler.date\"));\n      err.flush();\n    }\n\n    if (!isConfigValid || flags.display_help) {\n      isConfigValid = false;\n      parser.printUsage(err);\n    } else {\n      getCommandLineConfig()\n          .setPrintTree(flags.print_tree)\n          .setComputePhaseOrdering(flags.compute_phase_ordering)\n          .setPrintAst(flags.print_ast)\n          .setPrintPassGraph(flags.print_pass_graph)\n          .setJscompDevMode(flags.jscomp_dev_mode)\n          .setLoggingLevel(flags.logging_level)\n          .setExterns(flags.externs)\n          .setJs(flags.js)\n          .setJsOutputFile(flags.js_output_file)\n          .setModule(flags.module)\n          .setVariableMapInputFile(flags.variable_map_input_file)\n          .setPropertyMapInputFile(flags.property_map_input_file)\n          .setVariableMapOutputFile(flags.variable_map_output_file)\n          .setCreateNameMapFiles(flags.create_name_map_files)\n          .setPropertyMapOutputFile(flags.property_map_output_file)\n          .setCodingConvention(flags.third_party ?\n               new DefaultCodingConvention() :\n               new ClosureCodingConvention())\n          .setSummaryDetailLevel(flags.summary_detail_level)\n          .setOutputWrapper(flags.output_wrapper)\n          .setModuleWrapper(flags.module_wrapper)\n          .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n          .setCreateSourceMap(flags.create_source_map)\n          .setJscompError(flags.jscomp_error)\n          .setJscompWarning(flags.jscomp_warning)\n          .setJscompOff(flags.jscomp_off)\n          .setDefine(flags.define)\n          .setCharset(flags.charset)\n          .setManageClosureDependencies(flags.manage_closure_dependencies)\n          .setClosureEntryPoints(flags.closure_entry_point)\n          .setOutputManifest(flags.output_manifest)\n          .setAcceptConstKeyword(flags.accept_const_keyword)\n          .setLanguageIn(flags.language_in);\n    }\n  }",
        "fixed_function": "  private void initConfigFromFlags(String[] args, PrintStream err) {\n\n    List<String> processedArgs = processArgs(args);\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    Flags.warningGuardSpec.clear();\n    isConfigValid = true;\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n      // For contains --flagfile flag\n      if (!flags.flag_file.equals(\"\")) {\n        processFlagFile(err);\n      }\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      isConfigValid = false;\n    } catch (IOException ioErr) {\n      err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n      isConfigValid = false;\n    }\n\n    if (flags.version) {\n      ResourceBundle config = ResourceBundle.getBundle(configResource);\n      err.println(\n          \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n          \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n          \"Built on: \" + config.getString(\"compiler.date\"));\n      err.flush();\n    }\n\n    if (!isConfigValid || flags.display_help) {\n      isConfigValid = false;\n      parser.printUsage(err);\n    } else {\n      getCommandLineConfig()\n          .setPrintTree(flags.print_tree)\n          .setComputePhaseOrdering(flags.compute_phase_ordering)\n          .setPrintAst(flags.print_ast)\n          .setPrintPassGraph(flags.print_pass_graph)\n          .setJscompDevMode(flags.jscomp_dev_mode)\n          .setLoggingLevel(flags.logging_level)\n          .setExterns(flags.externs)\n          .setJs(flags.js)\n          .setJsOutputFile(flags.js_output_file)\n          .setModule(flags.module)\n          .setVariableMapInputFile(flags.variable_map_input_file)\n          .setPropertyMapInputFile(flags.property_map_input_file)\n          .setVariableMapOutputFile(flags.variable_map_output_file)\n          .setCreateNameMapFiles(flags.create_name_map_files)\n          .setPropertyMapOutputFile(flags.property_map_output_file)\n          .setCodingConvention(flags.third_party ?\n               new DefaultCodingConvention() :\n               new ClosureCodingConvention())\n          .setSummaryDetailLevel(flags.summary_detail_level)\n          .setOutputWrapper(flags.output_wrapper)\n          .setModuleWrapper(flags.module_wrapper)\n          .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n          .setCreateSourceMap(flags.create_source_map)\n          .setWarningGuardSpec(Flags.warningGuardSpec)\n          .setDefine(flags.define)\n          .setCharset(flags.charset)\n          .setManageClosureDependencies(flags.manage_closure_dependencies)\n          .setClosureEntryPoints(flags.closure_entry_point)\n          .setOutputManifest(flags.output_manifest)\n          .setAcceptConstKeyword(flags.accept_const_keyword)\n          .setLanguageIn(flags.language_in);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "start_loc": 186,
        "end_loc": 193,
        "buggy_function": "  void setWarningLevels(CompilerOptions options,\n      List<String> diagnosticGroups, CheckLevel level) {\n    for (String name : diagnosticGroups) {\n    DiagnosticGroup group = forName(name);\n    Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n    options.setWarningLevel(group, level);\n    }\n  }",
        "fixed_function": "  void setWarningLevel(CompilerOptions options,\n      String name, CheckLevel level) {\n    DiagnosticGroup group = forName(name);\n    Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n    options.setWarningLevel(group, level);\n  }",
        "comment": "/**\n   * Adds warning levels by name.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CommandLineRunnerTest::testWarningGuardOrdering2": {
        "path": "com/google/javascript/jscomp/CommandLineRunnerTest.java",
        "function_name": "testWarningGuardOrdering2",
        "src": "public void testWarningGuardOrdering2() {\n    args.add(\"--jscomp_off=globalThis\");\n    args.add(\"--jscomp_error=globalThis\");\n    test(\"function f() { this.a = 3; }\", CheckGlobalThis.GLOBAL_THIS);\n  }",
        "error_msg": "com.google.javascript.jscomp.CommandLineRunnerTest::testWarningGuardOrdering2 --> junit.framework.AssertionFailedError: Expected exactly one warning or error Errors: ",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exactly one warning or error Errors:"
      },
      "com.google.javascript.jscomp.CommandLineRunnerTest::testWarningGuardOrdering4": {
        "path": "com/google/javascript/jscomp/CommandLineRunnerTest.java",
        "function_name": "testWarningGuardOrdering4",
        "src": "public void testWarningGuardOrdering4() {\n    args.add(\"--jscomp_off=globalThis\");\n    args.add(\"--jscomp_warning=globalThis\");\n    test(\"function f() { this.a = 3; }\", CheckGlobalThis.GLOBAL_THIS);\n  }",
        "error_msg": "com.google.javascript.jscomp.CommandLineRunnerTest::testWarningGuardOrdering4 --> junit.framework.AssertionFailedError: Expected exactly one warning or error Errors: ",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exactly one warning or error Errors:"
      }
    }
  },
  "Closure-162": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "start_loc": 220,
        "end_loc": 227,
        "buggy_function": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n      }\n    }",
        "fixed_function": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "start_loc": 297,
        "end_loc": 367,
        "buggy_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n\n\n      // Validate the top level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n\n            aliasDefinitionsInOrder.add(n);\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n          }\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
        "fixed_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = scope.getVar(name);\n            aliases.put(name, aliasVar);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n          } else {\n            // TODO(robbyw): Support using locals for private variables.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n      }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.ScopedAliasesTest::testForwardJsDoc": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testForwardJsDoc",
        "src": "public void testForwardJsDoc() {\n    testScoped(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {Foo.Bar} x */ function actual(x) {3}\" +\n        \"var Foo = foo.Foo;\" +\n        \"/** @constructor */ Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\",\n\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function actual(x) {3}\" +\n        \"/** @constructor */ foo.Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\");\n    verifyTypes();\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testForwardJsDoc --> junit.framework.AssertionFailedError: expected:<[STRING foo.Foo.Bar 4 [source_file: testcode]",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[STRING foo.Foo.Bar 4 [source_file: testcode]"
      }
    }
  },
  "Closure-163": {
    "function_num": 17,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 201,
        "end_loc": 203,
        "buggy_function": "    private ProcessProperties() {\n      symbolStack.push(new NameContext(globalNode));\n    }",
        "fixed_function": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode();\n      if (n.isFunction()) {\n        String propName = getPrototypePropertyNameFromRValue(n);\n        if (propName != null) {\n          symbolStack.push(\n              new NameContext(\n                  getNameInfoForName(propName, PROPERTY),\n                  t.getScope()));\n        } else if (isGlobalFunctionDeclaration(t, n)) {\n          Node parent = n.getParent();\n          String name = parent.isName() ?\n              parent.getString() /* VAR */ :\n              n.getFirstChild().getString() /* named function */;\n          symbolStack.push(\n              new NameContext(getNameInfoForName(name, VAR), t.getScope()));\n        } else {\n          // NOTE(nicksantos): We use the same anonymous node for all\n          // functions that do not have reasonable names. I can't remember\n          // at the moment why we do this. I think it's because anonymous\n          // nodes can never have in-edges. They're just there as a placeholder\n          // for scope information, and do not matter in the edge propagation.\n          symbolStack.push(new NameContext(anonymousNode, t.getScope()));\n        }\n      } else {\n        Preconditions.checkState(t.inGlobalScope());\n        symbolStack.push(new NameContext(globalNode, t.getScope()));\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 204,
        "end_loc": 212,
        "buggy_function": "    @Override\n    public void enterScope(NodeTraversal t) {\n      symbolStack.peek().scope = t.getScope();\n          // NOTE(nicksantos): We use the same anonymous node for all\n          // functions that do not have reasonable names. I can't remember\n          // at the moment why we do this. I think it's because anonymous\n          // nodes can never have in-edges. They're just there as a placeholder\n          // for scope information, and do not matter in the edge propagation.\n    }",
        "fixed_function": "    @Override\n    public void exitScope(NodeTraversal t) {\n      symbolStack.pop();\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 214,
        "end_loc": 217,
        "buggy_function": "    @Override\n    public void exitScope(NodeTraversal t) {\n\n    }",
        "fixed_function": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      // Process prototype assignments to non-functions.\n      String propName = processNonFunctionPrototypeAssign(n, parent);\n      if (propName != null) {\n        symbolStack.push(\n            new NameContext(\n                getNameInfoForName(propName, PROPERTY), null));\n      }\n      return true;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 219,
        "end_loc": 234,
        "buggy_function": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      // Process prototype assignments to non-functions.\n      if (isPrototypePropertyAssign(n)) {\n        symbolStack.push(new NameContext(getNameInfoForName(\n                n.getFirstChild().getLastChild().getString(), PROPERTY)));\n      } else if (isGlobalFunctionDeclaration(t, n)) {\n        String name = parent.isName() ?\n            parent.getString() /* VAR */ :\n            n.getFirstChild().getString() /* named function */;\n        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n      } else if (n.isFunction()) {\n        symbolStack.push(new NameContext(anonymousNode));\n      }\n      return true;\n    }",
        "fixed_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isGetProp()) {\n        String propName = n.getFirstChild().getNext().getString();\n\n        if (n.isQualifiedName()) {\n          if (propName.equals(\"prototype\")) {\n            if (processPrototypeRef(t, n)) {\n              return;\n            }\n          } else if (compiler.getCodingConvention().isExported(propName)) {\n            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n            return;\n          } else {\n            // Do not mark prototype prop assigns as a 'use' in the global scope.\n            if (n.getParent().isAssign() && n.getNext() != null) {\n              String rValueName = getPrototypePropertyNameFromRValue(n);\n              if (rValueName != null) {\n                return;\n              }\n            }\n          }\n        }\n\n        addSymbolUse(propName, t.getModule(), PROPERTY);\n      } else if (n.isObjectLit()) {\n        // Make sure that we're not handling object literals being\n        // assigned to a prototype, as in:\n        // Foo.prototype = {bar: 3, baz: 5};\n        String lValueName = NodeUtil.getBestLValueName(\n            NodeUtil.getBestLValue(n));\n        if (lValueName != null && lValueName.endsWith(\".prototype\")) {\n          return;\n        }\n\n        // var x = {a: 1, b: 2}\n        // should count as a use of property a and b.\n        for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n             propNameNode = propNameNode.getNext()) {\n          // May be STRING, GET, or SET, but NUMBER isn't interesting.\n          if (!propNameNode.isQuotedString()) {\n            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n          }\n        }\n      } else if (n.isName()) {\n        String name = n.getString();\n\n        Var var = t.getScope().getVar(name);\n        if (var != null) {\n          // Only process global functions.\n          if (var.isGlobal()) {\n            if (var.getInitialValue() != null &&\n                var.getInitialValue().isFunction()) {\n              if (t.inGlobalScope()) {\n                if (!processGlobalFunctionDeclaration(t, n, var)) {\n                  addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                }\n              } else {\n                addSymbolUse(name, t.getModule(), VAR);\n              }\n            }\n\n          // If it is not a global, it might be accessing a local of the outer\n          // scope. If that's the case the functions between the variable's\n          // declaring scope and the variable reference scope cannot be moved.\n          } else if (var.getScope() != t.getScope()){\n            for (int i = symbolStack.size() - 1; i >= 0; i--) {\n              NameContext context = symbolStack.get(i);\n              if (context.scope == var.getScope()) {\n                break;\n              }\n\n              context.name.readClosureVariables = true;\n            }\n          }\n        }\n      }\n\n      // Process prototype assignments to non-functions.\n      if (processNonFunctionPrototypeAssign(n, parent) != null) {\n        symbolStack.pop();\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 236,
        "end_loc": 309,
        "buggy_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isGetProp()) {\n        String propName = n.getFirstChild().getNext().getString();\n\n          if (propName.equals(\"prototype\")) {\n          processPrototypeParent(t, parent);\n          } else if (compiler.getCodingConvention().isExported(propName)) {\n            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n          } else {\n            // Do not mark prototype prop assigns as a 'use' in the global scope.\n          addSymbolUse(propName, t.getModule(), PROPERTY);\n        }\n\n      } else if (n.isObjectLit() &&\n        // Make sure that we're not handling object literals being\n        // assigned to a prototype, as in:\n        // Foo.prototype = {bar: 3, baz: 5};\n          !(parent.isAssign() &&\n            parent.getFirstChild().isGetProp() &&\n            parent.getFirstChild().getLastChild().getString().equals(\n                \"prototype\"))) {\n\n        // var x = {a: 1, b: 2}\n        // should count as a use of property a and b.\n        for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n             propNameNode = propNameNode.getNext()) {\n          // May be STRING, GET, or SET, but NUMBER isn't interesting.\n          if (!propNameNode.isQuotedString()) {\n            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n          }\n        }\n      } else if (n.isName()) {\n        String name = n.getString();\n\n        Var var = t.getScope().getVar(name);\n        if (var != null) {\n          // Only process global functions.\n          if (var.isGlobal()) {\n            if (var.getInitialValue() != null &&\n                var.getInitialValue().isFunction()) {\n              if (t.inGlobalScope()) {\n                if (!processGlobalFunctionDeclaration(t, n, parent,\n                        parent.getParent())) {\n                  addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                }\n              } else {\n                addSymbolUse(name, t.getModule(), VAR);\n              }\n            }\n\n          // If it is not a global, it might be accessing a local of the outer\n          // scope. If that's the case the functions between the variable's\n          // declaring scope and the variable reference scope cannot be moved.\n          } else if (var.getScope() != t.getScope()){\n            for (int i = symbolStack.size() - 1; i >= 0; i--) {\n              NameContext context = symbolStack.get(i);\n              if (context.scope == var.getScope()) {\n                break;\n              }\n\n              context.name.readClosureVariables = true;\n            }\n          }\n        }\n      }\n\n      // Process prototype assignments to non-functions.\n      if (isPrototypePropertyAssign(n) ||\n          isGlobalFunctionDeclaration(t, n) ||\n          n.isFunction()) {\n        symbolStack.pop();\n      }\n    }",
        "fixed_function": "    private String processNonFunctionPrototypeAssign(Node n, Node parent) {\n      if (isAssignRValue(n, parent) && !n.isFunction()) {\n        return getPrototypePropertyNameFromRValue(n);\n      }\n      return null;\n    }",
        "comment": "/**\n     * If this is a non-function prototype assign, return the prop name.\n     * Otherwise, return null.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 335,
        "end_loc": 343,
        "buggy_function": "    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      // Make sure we're either in the global scope, or the function\n      // we're looking at is the root of the current local scope.\n\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.isFunction() &&\n           n.getParent().isName());\n    }",
        "fixed_function": "    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      // Make sure we're either in the global scope, or the function\n      // we're looking at is the root of the current local scope.\n      Scope s = t.getScope();\n      if (!(s.isGlobal() ||\n            s.getDepth() == 1 && s.getRootNode() == n)) {\n        return false;\n      }\n\n      return NodeUtil.isFunctionDeclaration(n) ||\n          n.isFunction() && n.getParent().isName();\n    }",
        "comment": "/**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 348,
        "end_loc": 375,
        "buggy_function": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.isGetProp()\n          && assign.getParent().isExprResult()) {\n        boolean isChainedProperty =\n            n.getFirstChild().isGetProp();\n\n    /**\n     * Returns the name of a prototype property being assigned to this r-value.\n     *\n     * Returns null if this is not the R-value of a prototype property, or if\n     * the R-value is used in multiple expressions (i.e., if there's\n     * a prototype property assignment in a more complex expression).\n     */\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.isString() &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n\n      return false;\n    }",
        "fixed_function": "    private boolean isAssignRValue(Node n, Node parent) {\n      return parent != null && parent.isAssign() && parent.getFirstChild() != n;\n    }",
        "comment": "/**\n     * Returns true if this is the r-value of an assignment.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 381,
        "end_loc": 404,
        "buggy_function": "    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n          isGlobalFunctionDeclaration(t, parent) ||\n          // Check for a VAR declaration.\n          firstChild != null &&\n          isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(\n            new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) ||\n            anchorUnusedVars) {\n          addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n\n        return true;\n      }\n      return false;\n    }",
        "fixed_function": "    private String getPrototypePropertyNameFromRValue(Node rValue) {\n      Node lValue = NodeUtil.getBestLValue(rValue);\n      if (lValue == null ||\n          lValue.getParent() == null ||\n          lValue.getParent().getParent() == null ||\n          !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) ||\n            NodeUtil.isExprAssign(lValue.getParent().getParent()))) {\n        return null;\n      }\n\n      String lValueName =\n          NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));\n      if (lValueName == null) {\n        return null;\n      }\n      int lastDot = lValueName.lastIndexOf('.');\n      if (lastDot == -1) {\n        return null;\n      }\n\n      String firstPart = lValueName.substring(0, lastDot);\n      if (!firstPart.endsWith(\".prototype\")) {\n        return null;\n      }\n\n      return lValueName.substring(lastDot + 1);\n    }",
        "comment": "/**\n     * Returns the name of a prototype property being assigned to this r-value.\n     *\n     * Returns null if this is not the R-value of a prototype property, or if\n     * the R-value is used in multiple expressions (i.e., if there's\n     * a prototype property assignment in a more complex expression).\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 412,
        "end_loc": 448,
        "buggy_function": "    private void processPrototypeParent(NodeTraversal t, Node n) {\n\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n          Node dest = n.getFirstChild().getNext();\n          Node parent = n.getParent();\n          Node grandParent = parent.getParent();\n\n          if (dest.isString() &&\n              NodeUtil.isExprAssign(grandParent) &&\n              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n            String name = dest.getString();\n            Property prop = new AssignmentProperty(\n                grandParent,\n                t.getModule());\n            getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n          Node map = n.getFirstChild().getNext();\n          if (map.isObjectLit()) {\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              // May be STRING, GET, or SET,\n              String name = key.getString();\n              Property prop = new LiteralProperty(\n                  key, key.getFirstChild(), map, n,\n                  t.getModule());\n              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            }\n          }\n          break;\n      }\n    }",
        "fixed_function": "    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Var v) {\n      Node firstChild = nameNode.getFirstChild();\n      Node parent = nameNode.getParent();\n\n      if (// Check for a named FUNCTION.\n          isGlobalFunctionDeclaration(t, parent) ||\n          // Check for a VAR declaration.\n          firstChild != null &&\n          isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(\n            new GlobalFunction(nameNode, v, t.getModule()));\n\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) ||\n            anchorUnusedVars) {\n          addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n\n        return true;\n      }\n      return false;\n    }",
        "comment": "/**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 518,
        "end_loc": 524,
        "buggy_function": "    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n      Preconditions.checkState(\n          parent.isVar() ||\n          NodeUtil.isFunctionDeclaration(parent));\n      this.nameNode = nameNode;\n      this.module = module;\n    }",
        "fixed_function": "    private boolean processPrototypeRef(NodeTraversal t, Node ref) {\n      Node root = NodeUtil.getRootOfQualifiedName(ref);\n\n      Node n = ref.getParent();\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n          Node dest = n.getFirstChild().getNext();\n          Node parent = n.getParent();\n          Node grandParent = parent.getParent();\n\n          if (dest.isString() &&\n              NodeUtil.isExprAssign(grandParent) &&\n              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n            String name = dest.getString();\n            Property prop = new AssignmentProperty(\n                grandParent,\n                t.getScope().getVar(root.getString()),\n                t.getModule());\n            getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            return true;\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n          Node map = n.getFirstChild().getNext();\n          if (map.isObjectLit()) {\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              // May be STRING, GET, or SET,\n              String name = key.getString();\n              Property prop = new LiteralProperty(\n                  key, key.getFirstChild(), map, n,\n                  t.getScope().getVar(root.getString()),\n                  t.getModule());\n              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            }\n            return true;\n          }\n          break;\n      }\n      return false;\n    }",
        "comment": "/**\n     * Processes the GETPROP of prototype, which can either be under\n     * another GETPROP (in the case of Foo.prototype.bar), or can be\n     * under an assignment (in the case of Foo.prototype = ...).\n     * @return True if a declaration was added.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 526,
        "end_loc": 536,
        "buggy_function": "    @Override\n\n    public void remove() {\n      Node parent = nameNode.getParent();\n      if (parent.isFunction() || parent.hasOneChild()) {\n        NodeUtil.removeChild(parent.getParent(), parent);\n      } else {\n        Preconditions.checkState(parent.isVar());\n        parent.removeChild(nameNode);\n      }\n    }",
        "fixed_function": "    GlobalFunction(Node nameNode, Var var, JSModule module) {\n      Node parent = nameNode.getParent();\n      Preconditions.checkState(\n          parent.isVar() ||\n          NodeUtil.isFunctionDeclaration(parent));\n      this.nameNode = nameNode;\n      this.var = var;\n      this.module = module;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 581,
        "end_loc": 584,
        "buggy_function": "    AssignmentProperty(Node node, JSModule module) {\n      this.exprNode = node;\n      this.module = module;\n    }",
        "fixed_function": "    @Override\n    public Var getRootVar() {\n      return var;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 586,
        "end_loc": 590,
        "buggy_function": "    @Override\n\n    public void remove() {\n      NodeUtil.removeChild(exprNode.getParent(), exprNode);\n    }",
        "fixed_function": "    @Override\n    public void remove() {\n      Node parent = nameNode.getParent();\n      if (parent.isFunction() || parent.hasOneChild()) {\n        NodeUtil.removeChild(parent.getParent(), parent);\n      } else {\n        Preconditions.checkState(parent.isVar());\n        parent.removeChild(nameNode);\n      }\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 625,
        "end_loc": 632,
        "buggy_function": "    LiteralProperty(Node key, Node value, Node map, Node assign,\n        JSModule module) {\n      this.key = key;\n      this.value = value;\n      this.map = map;\n      this.assign = assign;\n      this.module = module;\n    }",
        "fixed_function": "    AssignmentProperty(Node node, Var rootVar, JSModule module) {\n      this.exprNode = node;\n      this.rootVar = rootVar;\n      this.module = module;\n    }",
        "comment": "/**\n     * @param node An EXPR node.\n     */"
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 634,
        "end_loc": 638,
        "buggy_function": "    @Override\n\n    public void remove() {\n      map.removeChild(key);\n    }",
        "fixed_function": "    @Override\n    public Var getRootVar() {\n      return rootVar;\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
        "start_loc": 667,
        "end_loc": 669,
        "buggy_function": "    NameContext(NameInfo name) {\n      this.name = name;\n    }",
        "fixed_function": "    @Override\n    public void remove() {\n      NodeUtil.removeChild(exprNode.getParent(), exprNode);\n    }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/CrossModuleMethodMotion.java",
        "start_loc": 96,
        "end_loc": 196,
        "buggy_function": "  private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n        // The code below can't do anything with unreferenced name\n        // infos.  They should be skipped to avoid NPE since their\n        // deepestCommonModuleRef is null.\n        continue;\n      }\n\n      if (nameInfo.readsClosureVariables()) {\n        continue;\n      }\n\n      JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n      if (deepestCommonModuleRef == null) {\n        compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n        continue;\n      }\n\n      Iterator<Symbol> declarations =\n          nameInfo.getDeclarations().descendingIterator();\n      while (declarations.hasNext()) {\n        Symbol symbol = declarations.next();\n        if (!(symbol instanceof Property)) {\n          continue;\n        }\n        Property prop = (Property) symbol;\n\n        // We should only move a property across modules if:\n        // 1) We can move it deeper in the module graph, and\n        // 2) it's a function, and\n        // 3) it is not a get or a set, and\n        // 4) the class is available in the global scope.\n        //\n        // #1 should be obvious. #2 is more subtle. It's possible\n        // to copy off of a prototype, as in the code:\n        // for (var k in Foo.prototype) {\n        //   doSomethingWith(Foo.prototype[k]);\n        // }\n        // This is a common way to implement pseudo-multiple inheritance in JS.\n        //\n        // So if we move a prototype method into a deeper module, we must\n        // replace it with a stub function so that it preserves its original\n        // behavior.\n\n        Node value = prop.getValue();\n        if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n            value.isFunction()) {\n          Node valueParent = value.getParent();\n          if (valueParent.isGetterDef()\n              || valueParent.isSetterDef()) {\n            // TODO(johnlenz): a GET or SET can't be deferred like a normal\n            // FUNCTION property definition as a mix-in would get the result\n            // of a GET instead of the function itself.\n            continue;\n          }\n          Node proto = prop.getPrototype();\n          int stubId = idGenerator.newId();\n\n          // example: JSCompiler_stubMethod(id);\n          Node stubCall = IR.call(\n              IR.name(STUB_METHOD_NAME),\n              IR.number(stubId))\n              .copyInformationFromForTree(value);\n          stubCall.putBooleanProp(Node.FREE_CALL, true);\n\n          // stub out the method in the original module\n          // A.prototype.b = JSCompiler_stubMethod(id);\n          valueParent.replaceChild(value, stubCall);\n\n          // unstub the function body in the deeper module\n          Node unstubParent = compiler.getNodeForCodeInsertion(\n              deepestCommonModuleRef);\n          Node unstubCall = IR.call(\n              IR.name(UNSTUB_METHOD_NAME),\n              IR.number(stubId),\n              value);\n          unstubCall.putBooleanProp(Node.FREE_CALL, true);\n          unstubParent.addChildToFront(\n              // A.prototype.b = JSCompiler_unstubMethod(id, body);\n              IR.exprResult(\n                  IR.assign(\n                      IR.getprop(\n                          proto.cloneTree(),\n                          IR.string(nameInfo.name)),\n                      unstubCall))\n                  .copyInformationFromForTree(value));\n\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n      // Declare stub functions in the top-most module.\n      Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n      compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n          declarations.removeChildren());\n    }\n  }",
        "fixed_function": "  private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n        // The code below can't do anything with unreferenced name\n        // infos.  They should be skipped to avoid NPE since their\n        // deepestCommonModuleRef is null.\n        continue;\n      }\n\n      if (nameInfo.readsClosureVariables()) {\n        continue;\n      }\n\n      JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n      if (deepestCommonModuleRef == null) {\n        compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n        continue;\n      }\n\n      Iterator<Symbol> declarations =\n          nameInfo.getDeclarations().descendingIterator();\n      while (declarations.hasNext()) {\n        Symbol symbol = declarations.next();\n        if (!(symbol instanceof Property)) {\n          continue;\n        }\n        Property prop = (Property) symbol;\n\n        // We should only move a property across modules if:\n        // 1) We can move it deeper in the module graph, and\n        // 2) it's a function, and\n        // 3) it is not a get or a set, and\n        // 4) the class is available in the global scope.\n        //\n        // #1 should be obvious. #2 is more subtle. It's possible\n        // to copy off of a prototype, as in the code:\n        // for (var k in Foo.prototype) {\n        //   doSomethingWith(Foo.prototype[k]);\n        // }\n        // This is a common way to implement pseudo-multiple inheritance in JS.\n        //\n        // So if we move a prototype method into a deeper module, we must\n        // replace it with a stub function so that it preserves its original\n        // behavior.\n        if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {\n          continue;\n        }\n\n        Node value = prop.getValue();\n        if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n            value.isFunction()) {\n          Node valueParent = value.getParent();\n          if (valueParent.isGetterDef()\n              || valueParent.isSetterDef()) {\n            // TODO(johnlenz): a GET or SET can't be deferred like a normal\n            // FUNCTION property definition as a mix-in would get the result\n            // of a GET instead of the function itself.\n            continue;\n          }\n          Node proto = prop.getPrototype();\n          int stubId = idGenerator.newId();\n\n          // example: JSCompiler_stubMethod(id);\n          Node stubCall = IR.call(\n              IR.name(STUB_METHOD_NAME),\n              IR.number(stubId))\n              .copyInformationFromForTree(value);\n          stubCall.putBooleanProp(Node.FREE_CALL, true);\n\n          // stub out the method in the original module\n          // A.prototype.b = JSCompiler_stubMethod(id);\n          valueParent.replaceChild(value, stubCall);\n\n          // unstub the function body in the deeper module\n          Node unstubParent = compiler.getNodeForCodeInsertion(\n              deepestCommonModuleRef);\n          Node unstubCall = IR.call(\n              IR.name(UNSTUB_METHOD_NAME),\n              IR.number(stubId),\n              value);\n          unstubCall.putBooleanProp(Node.FREE_CALL, true);\n          unstubParent.addChildToFront(\n              // A.prototype.b = JSCompiler_unstubMethod(id, body);\n              IR.exprResult(\n                  IR.assign(\n                      IR.getprop(\n                          proto.cloneTree(),\n                          IR.string(nameInfo.name)),\n                      unstubCall))\n                  .copyInformationFromForTree(value));\n\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n      // Declare stub functions in the top-most module.\n      Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n      compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n          declarations.removeChildren());\n    }\n  }",
        "comment": "/**\n   * Move methods deeper in the module graph when possible.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600b": {
        "path": "com/google/javascript/jscomp/CrossModuleMethodMotionTest.java",
        "function_name": "testIssue600b",
        "src": "public void testIssue600b() {\n    testSame(\n        createModuleChain(\n            \"var jQuery1 = (function() {\\n\" +\n            \"  var jQuery2 = function() {};\\n\" +\n            \"  jQuery2.prototype = {\\n\" +\n            \"    size: function() {\\n\" +\n            \"      return 1;\\n\" +\n            \"    }\\n\" +\n            \"  };\\n\" +\n            \"  return jQuery2;\\n\" +\n            \"})();\\n\",\n\n            \"(function() {\" +\n            \"  var div = jQuery1('div');\" +\n            \"  div.size();\" +\n            \"})();\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600b --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600e": {
        "path": "com/google/javascript/jscomp/CrossModuleMethodMotionTest.java",
        "function_name": "testIssue600e",
        "src": "public void testIssue600e() {\n    testSame(\n        createModuleChain(\n            \"var jQuery2 = function() {};\\n\" +\n            \"(function() {\" +\n            \"  var theLoneliestNumber = 1;\\n\" +\n            \"  jQuery2.prototype = {\\n\" +\n            \"    size: function() {\\n\" +\n            \"      return theLoneliestNumber;\\n\" +\n            \"    }\\n\" +\n            \"  };\\n\" +\n            \"})();\",\n\n            \"(function() {\" +\n            \"  var div = jQuery2('div');\" +\n            \"  div.size();\" +\n            \"})();\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600e --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600": {
        "path": "com/google/javascript/jscomp/CrossModuleMethodMotionTest.java",
        "function_name": "testIssue600",
        "src": "public void testIssue600() {\n    testSame(\n        createModuleChain(\n            \"var jQuery1 = (function() {\\n\" +\n            \"  var jQuery2 = function() {};\\n\" +\n            \"  var theLoneliestNumber = 1;\\n\" +\n            \"  jQuery2.prototype = {\\n\" +\n            \"    size: function() {\\n\" +\n            \"      return theLoneliestNumber;\\n\" +\n            \"    }\\n\" +\n            \"  };\\n\" +\n            \"  return jQuery2;\\n\" +\n            \"})();\\n\",\n\n            \"(function() {\" +\n            \"  var div = jQuery1('div');\" +\n            \"  div.size();\" +\n            \"})();\"));\n  }",
        "error_msg": "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600 --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-165": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "start_loc": 690,
        "end_loc": 704,
        "buggy_function": "  public boolean canPropertyBeDefined(JSType type, String propertyName) {\n    if (typesIndexedByProperty.containsKey(propertyName)) {\n      for (JSType alt :\n               typesIndexedByProperty.get(propertyName).getAlternates()) {\n        JSType greatestSubtype = alt.getGreatestSubtype(type);\n        if (!greatestSubtype.isEmptyType()) {\n          // We've found a type with this property. Now we just have to make\n          // sure it's not a type used for internal bookkeeping.\n\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
        "fixed_function": "  public boolean canPropertyBeDefined(JSType type, String propertyName) {\n    if (typesIndexedByProperty.containsKey(propertyName)) {\n      for (JSType alt :\n               typesIndexedByProperty.get(propertyName).getAlternates()) {\n        JSType greatestSubtype = alt.getGreatestSubtype(type);\n        if (!greatestSubtype.isEmptyType()) {\n          // We've found a type with this property. Now we just have to make\n          // sure it's not a type used for internal bookkeeping.\n          RecordType maybeRecordType = greatestSubtype.toMaybeRecordType();\n          if (maybeRecordType != null && maybeRecordType.isSynthetic()) {\n            continue;\n          }\n\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
        "comment": "/**\n   * Returns whether the given property can possibly be set on the given type.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "start_loc": 83,
        "end_loc": 99,
        "buggy_function": "  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n        defineDeclaredProperty(\n            property, prop.getType(), prop.getPropertyNode());\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }",
        "fixed_function": "  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    this(registry, properties, true);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "start_loc": 148,
        "end_loc": 207,
        "buggy_function": "  JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isEquivalentTo(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }",
        "fixed_function": "  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties,\n      boolean declared) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n    this.declared = declared;\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n      if (declared) {\n        defineDeclaredProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      } else {\n        defineSynthesizedProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      }\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }",
        "comment": "/**\n   * Creates a record type.\n   *\n   * @param registry The type registry under which this type lives.\n   * @param properties A map of all the properties of this record type.\n   * @param declared Whether this is a declared or synthesized type.\n   *     A synthesized record type is just used for bookkeeping\n   *     in the type system. A declared record type was actually used in the\n   *     user's program.\n   * @throws IllegalStateException if the {@code RecordProperty} associated\n   *         with a property is null.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "start_loc": 85,
        "end_loc": 93,
        "buggy_function": "  public JSType build() {\n     // If we have an empty record, simply return the object type.\n    if (isEmpty) {\n       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    }\n\n    return new RecordType(\n        registry, Collections.unmodifiableMap(properties));\n  }",
        "fixed_function": "  void setSynthesized(boolean synthesized) {\n    isDeclared = !synthesized;\n  }",
        "comment": "/** See the comments on RecordType about synthetic types. */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue725": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue725",
        "src": "public void testIssue725() throws Exception {\n    testTypes(\n        \"/** @typedef {{name: string}} */ var RecordType1;\" +\n        \"/** @typedef {{name2: string}} */ var RecordType2;\" +\n        \"/** @param {RecordType1} rec */ function f(rec) {\" +\n        \"  alert(rec.name2);\" +\n        \"}\",\n        \"Property name2 never defined on rec\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue725 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      }
    }
  },
  "Closure-167": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "start_loc": 272,
        "end_loc": 305,
        "buggy_function": "  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftIsRefineable, merged.typeA,\n          right, rightIsRefineable, merged.typeB);\n    }\n    return blindScope;\n  }",
        "fixed_function": "  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? merged.typeA : null,\n          right, rightType, rightIsRefineable ? merged.typeB : null);\n    }\n    return blindScope;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "start_loc": 307,
        "end_loc": 352,
        "buggy_function": "  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftIsRefineable, restrictedLeftType,\n          right, rightIsRefineable, restrictedRightType);\n    }\n    return blindScope;\n  }",
        "fixed_function": "  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? restrictedLeftType : null,\n          right, rightType, rightIsRefineable ? restrictedRightType : null);\n    }\n    return blindScope;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "start_loc": 392,
        "end_loc": 400,
        "buggy_function": "  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "fixed_function": "  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "comment": "/**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "start_loc": 405,
        "end_loc": 424,
        "buggy_function": "  private FlowScope maybeRestrictTwoNames(\n      FlowScope blindScope,\n      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight =\n        rightIsRefineable && restrictedRightType != null;\n    if (shouldRefineLeft || shouldRefineRight) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (shouldRefineLeft) {\n        declareNameInScope(informed, left, restrictedLeftType);\n      }\n      if (shouldRefineRight) {\n        declareNameInScope(informed, right, restrictedRightType);\n      }\n      return informed;\n    }\n    return blindScope;\n  }",
        "fixed_function": "  private FlowScope maybeRestrictTwoNames(\n      FlowScope blindScope,\n      Node left, JSType originalLeftType, JSType restrictedLeftType,\n      Node right, JSType originalRightType, JSType restrictedRightType) {\n    boolean shouldRefineLeft =\n        restrictedLeftType != null && restrictedLeftType != originalLeftType;\n    boolean shouldRefineRight =\n        restrictedRightType != null && restrictedRightType != originalRightType;\n    if (shouldRefineLeft || shouldRefineRight) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (shouldRefineLeft) {\n        declareNameInScope(informed, left, restrictedLeftType);\n      }\n      if (shouldRefineRight) {\n        declareNameInScope(informed, right, restrictedRightType);\n      }\n      return informed;\n    }\n    return blindScope;\n  }",
        "comment": "/**\n   * @see maybeRestrictName\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "start_loc": 426,
        "end_loc": 437,
        "buggy_function": "  private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n      JSType restrictedType =\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, name, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
        "fixed_function": "  private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n      return maybeRestrictName(\n          blindScope, name, type,\n          type.getRestrictedTypeGivenToBooleanOutcome(outcome));\n    }\n    return blindScope;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "start_loc": 882,
        "end_loc": 890,
        "buggy_function": "  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
        "fixed_function": "  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n    if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
        "comment": "/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue783": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue783",
        "src": "public void testIssue783() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var Type = function () {\" +\n        \"  /** @type {Type} */\" +\n        \"  this.me_ = this;\" +\n        \"};\" +\n        \"Type.prototype.doIt = function() {\" +\n        \"  var me = this.me_;\" +\n        \"  for (var i = 0; i < me.unknownProp; i++) {}\" +\n        \"};\",\n        \"Property unknownProp never defined on Type\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue783 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testMissingProperty20",
        "src": "public void testMissingProperty20() throws Exception {\n    testTypes(\n        \"/** @param {Object} x */\" +\n        \"function f(x) { if (x.foo) { } else { x.foo(); } }\",\n        \"Property foo never defined on Object\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean": {
        "path": "com/google/javascript/rhino/jstype/JSTypeTest.java",
        "function_name": "testRestrictedTypeGivenToBoolean",
        "src": "@SuppressWarnings(\"checked\")\n      public void testRestrictedTypeGivenToBoolean() {\n    // simple cases\n    assertTypeEquals(BOOLEAN_TYPE,\n        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(BOOLEAN_TYPE,\n        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NULL_TYPE,\n        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NUMBER_TYPE,\n        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NUMBER_TYPE,\n        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(STRING_TYPE,\n        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(STRING_TYPE,\n        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(STRING_OBJECT_TYPE,\n        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(VOID_TYPE,\n        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_OBJECT_TYPE,\n        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(NO_TYPE,\n        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NO_TYPE,\n        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(ALL_TYPE,\n        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(ALL_TYPE,\n        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(UNKNOWN_TYPE,\n        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    // unions\n    UnionType nullableStringValue =\n        (UnionType) createNullableType(STRING_TYPE);\n    assertTypeEquals(STRING_TYPE,\n        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(nullableStringValue,\n        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));\n\n    UnionType nullableStringObject =\n        (UnionType) createNullableType(STRING_OBJECT_TYPE);\n    assertTypeEquals(STRING_OBJECT_TYPE,\n        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));\n    assertTypeEquals(NULL_TYPE,\n        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));\n  }",
        "error_msg": "com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean --> junit.framework.AssertionFailedError: Expected: ??",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected: ??"
      }
    }
  },
  "Closure-169": {
    "function_num": 14,
    "functions": [
      {
        "path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "start_loc": 177,
        "end_loc": 201,
        "buggy_function": "  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n                otherParamType, tolerateUnknowns)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
        "fixed_function": "  boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n                otherParamType, eqMethod)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
        "comment": "/**\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "start_loc": 203,
        "end_loc": 210,
        "buggy_function": "  boolean checkArrowEquivalenceHelper(\n      ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n      return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n  }",
        "fixed_function": "  boolean checkArrowEquivalenceHelper(\n      ArrowType that, EquivalenceMethod eqMethod) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {\n      return false;\n    }\n    return hasEqualParameters(that, eqMethod);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 789,
        "end_loc": 828,
        "buggy_function": "  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call, false)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }",
        "fixed_function": "  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }",
        "comment": "/**\n   * Try to get the sup/inf of two functions by looking at the\n   * piecewise components.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 889,
        "end_loc": 910,
        "buggy_function": "  boolean checkFunctionEquivalenceHelper(\n      FunctionType that, boolean tolerateUnknowns) {\n    if (isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (isInterface()) {\n      if (that.isInterface()) {\n        return getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n\n    return typeOfThis.checkEquivalenceHelper(\n        that.typeOfThis, tolerateUnknowns) &&\n        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n  }",
        "fixed_function": "  boolean checkFunctionEquivalenceHelper(\n      FunctionType that, EquivalenceMethod eqMethod) {\n    if (isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (isInterface()) {\n      if (that.isInterface()) {\n        return getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n\n    return typeOfThis.checkEquivalenceHelper(\n        that.typeOfThis, eqMethod) &&\n        call.checkArrowEquivalenceHelper(that.call, eqMethod);\n  }",
        "comment": "/**\n   * Two function types are equal if their signatures match. Since they don't\n   * have signatures, two interfaces are equal if their names match.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "start_loc": 917,
        "end_loc": 919,
        "buggy_function": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n  }",
        "fixed_function": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(\n        otherType.call, EquivalenceMethod.IDENTITY);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "start_loc": 491,
        "end_loc": 493,
        "buggy_function": "  public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, false);\n  }",
        "fixed_function": "  public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);\n  }",
        "comment": "/**\n   * Checks if two types are equivalent.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "start_loc": 499,
        "end_loc": 501,
        "buggy_function": "  public final boolean isInvariant(JSType that) {\n    return checkEquivalenceHelper(that, false);\n  }",
        "fixed_function": "  public final boolean isInvariant(JSType that) {\n    return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);\n  }",
        "comment": "/**\n   * Checks if two types are invariant.\n   * @see EquivalenceMethod\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "start_loc": 513,
        "end_loc": 515,
        "buggy_function": "  public final boolean differsFrom(JSType that) {\n    return !checkEquivalenceHelper(that, true);\n  }",
        "fixed_function": "  public final boolean differsFrom(JSType that) {\n    return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);\n  }",
        "comment": "/**\n   * Whether this type is meaningfully different from {@code that} type for\n   * the purposes of data flow analysis.\n   *\n   * This is a trickier check than pure equality, because it has to properly\n   * handle unknown types. See {@code EquivalenceMethod} for more info.\n   *\n   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n   *     unknowns</a>\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "start_loc": 520,
        "end_loc": 606,
        "buggy_function": "  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n      if (tolerateUnknowns) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n          that.toMaybeUnionType(), tolerateUnknowns);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), tolerateUnknowns);\n    }\n\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n      // Check if one type is parameterized, but the other is not.\n      boolean paramsMatch = false;\n      if (thisParamType != null && thatParamType != null) {\n        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n            thatParamType.getParameterType(), tolerateUnknowns);\n      } else if (tolerateUnknowns) {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      } else {\n        paramsMatch = false;\n      }\n\n      JSType thisRootType = thisParamType == null ?\n          this : thisParamType.getReferencedTypeInternal();\n      JSType thatRootType = thatParamType == null ?\n          that : thatParamType.getReferencedTypeInternal();\n      return paramsMatch &&\n          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n              that, tolerateUnknowns);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          tolerateUnknowns);\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }",
        "fixed_function": "  boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n      if (eqMethod == EquivalenceMethod.INVARIANT) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n        return true;\n      } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n          that.toMaybeUnionType(), eqMethod);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), eqMethod);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), eqMethod);\n    }\n\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n      // Check if one type is parameterized, but the other is not.\n      boolean paramsMatch = false;\n      if (thisParamType != null && thatParamType != null) {\n        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n            thatParamType.getParameterType(), eqMethod);\n      } else if (eqMethod == EquivalenceMethod.IDENTITY) {\n        paramsMatch = false;\n      } else {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      }\n\n      JSType thisRootType = thisParamType == null ?\n          this : thisParamType.getReferencedTypeInternal();\n      JSType thatRootType = thatParamType == null ?\n          that : thatParamType.getReferencedTypeInternal();\n      return paramsMatch &&\n          thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n              that, eqMethod);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          eqMethod);\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }",
        "comment": "/**\n   * An equivalence visitor.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "start_loc": 117,
        "end_loc": 131,
        "buggy_function": "  boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, boolean tolerateUnknowns) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).checkEquivalenceHelper(\n              properties.get(key), tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "fixed_function": "  boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, EquivalenceMethod eqMethod) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).checkEquivalenceHelper(\n              properties.get(key), eqMethod)) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "start_loc": 153,
        "end_loc": 213,
        "buggy_function": "  JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n      builder.setSynthesized(true);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isInvariant(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }",
        "fixed_function": "  JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n      builder.setSynthesized(true);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isInvariant(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              propType.isInvariant(altPropType)) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "start_loc": 243,
        "end_loc": 286,
        "buggy_function": "  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n        // If one inferred property isn't a subtype,\n        // then the whole record isn't covariant.\n        if (!propA.isSubtype(propB)) {\n          return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
        "fixed_function": "  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n        // If one inferred property isn't a subtype,\n        // then the whole record isn't covariant.\n        if (!propA.isSubtype(propB)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
        "comment": "/** Determines if typeA is a subtype of typeB */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "start_loc": 333,
        "end_loc": 345,
        "buggy_function": "  boolean checkUnionEquivalenceHelper(\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "fixed_function": "  boolean checkUnionEquivalenceHelper(\n      UnionType that, EquivalenceMethod eqMethod) {\n    if (eqMethod == EquivalenceMethod.IDENTITY\n        && alternates.size() != that.alternates.size()) {\n      return false;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, eqMethod)) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "comment": "/**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */"
      },
      {
        "path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "start_loc": 347,
        "end_loc": 354,
        "buggy_function": "  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "fixed_function": "  private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {\n    for (JSType alternate : alternates) {\n      if (alternate.checkEquivalenceHelper(type, eqMethod)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue791": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue791",
        "src": "public void testIssue791() throws Exception {\n    testTypes(\n        \"/** @param {{func: function()}} obj */\" +\n        \"function test1(obj) {}\" +\n        \"var fnStruc1 = {};\" +\n        \"fnStruc1.func = function() {};\" +\n        \"test1(fnStruc1);\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue791 --> junit.framework.AssertionFailedError: unexpected warnings(s):",
        "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):"
      },
      "com.google.javascript.rhino.jstype.RecordTypeTest::testSubtypeWithUnknowns2": {
        "path": "com/google/javascript/rhino/jstype/RecordTypeTest.java",
        "function_name": "testSubtypeWithUnknowns2",
        "src": "public void testSubtypeWithUnknowns2() throws Exception {\n    JSType recordA = new RecordTypeBuilder(registry)\n        .addProperty(\"a\",\n            new FunctionBuilder(registry)\n            .withReturnType(NUMBER_TYPE)\n            .build(),\n            null)\n        .build();\n    JSType recordB = new RecordTypeBuilder(registry)\n        .addProperty(\"a\",\n            new FunctionBuilder(registry)\n            .withReturnType(UNKNOWN_TYPE)\n            .build(),\n            null)\n        .build();\n    assertTrue(recordA.isSubtype(recordB));\n    assertTrue(recordB.isSubtype(recordA));\n  }",
        "error_msg": "com.google.javascript.rhino.jstype.RecordTypeTest::testSubtypeWithUnknowns2 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Closure-171": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/TypeInference.java",
        "start_loc": 719,
        "end_loc": 773,
        "buggy_function": "  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n      scope = traverse(name.getFirstChild(), scope);\n    }\n\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n      return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null &&\n        n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n      return scope;\n    }\n\n    String qObjName = NodeUtil.getBestLValueName(\n        NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null;\n         name = name.getNext()) {\n      String memberName = NodeUtil.getObjectLitKeyName(name);\n      if (memberName != null) {\n        JSType rawValueType =  name.getFirstChild().getJSType();\n        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            name, rawValueType);\n        if (valueType == null) {\n          valueType = unknownType;\n        }\n        objectType.defineInferredProperty(memberName, valueType, name);\n\n        // Do normal flow inference if this is a direct property assignment.\n        if (qObjName != null && name.isStringKey()) {\n          String qKeyName = qObjName + \".\" + memberName;\n          Var var = syntacticScope.getVar(qKeyName);\n          JSType oldType = var == null ? null : var.getType();\n          if (var != null && var.isTypeInferred()) {\n            var.setType(oldType == null ?\n                valueType : oldType.getLeastSupertype(oldType));\n          }\n\n          scope.inferQualifiedSlot(name, qKeyName,\n              oldType == null ? unknownType : oldType,\n              valueType);\n        }\n      } else {\n        n.setJSType(unknownType);\n      }\n    }\n    return scope;\n  }",
        "fixed_function": "  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n      scope = traverse(name.getFirstChild(), scope);\n    }\n\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {\n      return scope;\n    }\n\n    String qObjName = NodeUtil.getBestLValueName(\n        NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null;\n         name = name.getNext()) {\n      String memberName = NodeUtil.getObjectLitKeyName(name);\n      if (memberName != null) {\n        JSType rawValueType =  name.getFirstChild().getJSType();\n        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            name, rawValueType);\n        if (valueType == null) {\n          valueType = unknownType;\n        }\n        objectType.defineInferredProperty(memberName, valueType, name);\n\n        // Do normal flow inference if this is a direct property assignment.\n        if (qObjName != null && name.isStringKey()) {\n          String qKeyName = qObjName + \".\" + memberName;\n          Var var = syntacticScope.getVar(qKeyName);\n          JSType oldType = var == null ? null : var.getType();\n          if (var != null && var.isTypeInferred()) {\n            var.setType(oldType == null ?\n                valueType : oldType.getLeastSupertype(oldType));\n          }\n\n          scope.inferQualifiedSlot(name, qKeyName,\n              oldType == null ? unknownType : oldType,\n              valueType);\n        }\n      } else {\n        n.setJSType(unknownType);\n      }\n    }\n    return scope;\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "start_loc": 1661,
        "end_loc": 1706,
        "buggy_function": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototype sets are always declared.\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
        "fixed_function": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototype sets are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        return false;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
        "comment": "/**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.TypeCheckTest::testIssue1023": {
        "path": "com/google/javascript/jscomp/TypeCheckTest.java",
        "function_name": "testIssue1023",
        "src": "public void testIssue1023() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"(function () {\" +\n        \"  F.prototype = {\" +\n        \"    /** @param {string} x */\" +\n        \"    bar: function (x) {  }\" +\n        \"  };\" +\n        \"})();\" +\n        \"(new F()).bar(true)\",\n        \"actual parameter 1 of F.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: string\");\n  }",
        "error_msg": "com.google.javascript.jscomp.TypeCheckTest::testIssue1023 --> junit.framework.AssertionFailedError: expected a warning",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testMethodBeforeFunction2": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testMethodBeforeFunction2",
        "src": "public void testMethodBeforeFunction2() throws Exception {\n    testSame(\n        \"var y = Window.prototype;\" +\n        \"Window.prototype = {alert: function(message) {}};\" +\n        \"/** @constructor */ function Window() {}\\n\" +\n        \"var window = new Window(); \\n\" +\n        \"var x = window;\");\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Window\", x.toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n    assertEquals(\"function (this:Window, ?): undefined\",\n        x.getPropertyType(\"alert\").toString());\n    assertFalse(x.isPropertyTypeDeclared(\"alert\"));\n\n    ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n    assertEquals(\"function (this:Window, ?): undefined\",\n        y.getPropertyType(\"alert\").toString());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testMethodBeforeFunction2 --> junit.framework.ComparisonFailure: expected:<[function (this:Window, ?): undefined]> but was:<[?]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[function (this:Window, ?): undefined]> but was:<[?]>"
      },
      "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertiesOnInterface2": {
        "path": "com/google/javascript/jscomp/TypedScopeCreatorTest.java",
        "function_name": "testPropertiesOnInterface2",
        "src": "public void testPropertiesOnInterface2() throws Exception {\n    testSame(\"/** @interface */ var I = function() {};\" +\n        \"I.prototype = {baz: function(){}};\" +\n        \"/** @type {number} */ I.prototype.bar;\");\n\n    Var i = globalScope.getVar(\"I\");\n    assertEquals(\"function (this:I): ?\", i.getType().toString());\n    assertTrue(i.getType().isInterface());\n\n    ObjectType iPrototype = (ObjectType)\n        ((ObjectType) i.getType()).getPropertyType(\"prototype\");\n    assertEquals(\"I.prototype\", iPrototype.toString());\n    assertTrue(iPrototype.isFunctionPrototypeType());\n\n    assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n\n    assertEquals(\"function (this:I): undefined\",\n        iPrototype.getPropertyType(\"baz\").toString());\n\n    assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n  }",
        "error_msg": "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertiesOnInterface2 --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Closure-173": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "start_loc": 107,
        "end_loc": 768,
        "buggy_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          // Check for ECMASCRIPT3 keywords.\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "fixed_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          // Check for ECMASCRIPT3 keywords.\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "start_loc": 65,
        "end_loc": 106,
        "buggy_function": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (!node.isCall()) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldSimpleFunctionCall(node);\n          if (result == node) {\n            result = tryFoldImmediateCallToBoundFunction(node);\n          }\n        }\n        return result;\n\n      case Token.RETURN:\n        return tryReduceReturn(node);\n\n      case Token.COMMA:\n        return trySplitComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n\n      default:\n        return node; //Nothing changed\n    }\n  }",
        "fixed_function": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (!node.isCall()) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldSimpleFunctionCall(node);\n          if (result == node) {\n            result = tryFoldImmediateCallToBoundFunction(node);\n          }\n        }\n        return result;\n\n      case Token.RETURN:\n        return tryReduceReturn(node);\n\n      case Token.COMMA:\n        return trySplitComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return tryRotateAssociativeOperator(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }",
        "comment": "/**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */"
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.CodePrinterTest::testPrint": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testPrint",
        "src": "public void testPrint() {\n    assertPrint(\"10 + a + b\", \"10+a+b\");\n    assertPrint(\"10 + (30*50)\", \"10+30*50\");\n    assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");\n    assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");\n    assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");\n    assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");\n    assertPrint(\"a instanceof b\", \"a instanceof b\");\n    assertPrint(\"typeof(a)\", \"typeof a\");\n    assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");\n\n    // Safari: needs ';' at the end of a throw statement\n    assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");\n    // Safari 3 needs a \"{\" around a single function\n    assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");\n\n    assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");\n\n    assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");\n    assertPrint(\"x-- >> 1\", \"x-- >>1\");\n\n    assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");\n\n    // Associativity\n    assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");\n    assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");\n    assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");\n\n    // Nested assignments\n    assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");\n    assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");\n    assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");\n    assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");\n\n    // Precedence\n    assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");\n    assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");\n\n    // optional '()' for new\n\n    // simple new\n    assertPrint(\"new A\", \"new A\");\n    assertPrint(\"new A()\", \"new A\");\n    assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");\n\n    // calling instance method directly after new\n    assertPrint(\"new A().a()\", \"(new A).a()\");\n    assertPrint(\"(new A).a()\", \"(new A).a()\");\n\n    // this case should be fixed\n    assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");\n\n    // internal class\n    assertPrint(\"new A.B\", \"new A.B\");\n    assertPrint(\"new A.B()\", \"new A.B\");\n    assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");\n\n    // calling instance method directly after new internal class\n    assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");\n    assertPrint(\"new A.B().a()\", \"(new A.B).a()\");\n    // this case should be fixed\n    assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    assertPrint(\"x + +y\", \"x+ +y\");\n    assertPrint(\"x - (-y)\", \"x- -y\");\n    assertPrint(\"x++ +y\", \"x++ +y\");\n    assertPrint(\"x-- -y\", \"x-- -y\");\n    assertPrint(\"x++ -y\", \"x++-y\");\n\n    // Label\n    assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");\n    assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");\n\n    // Object literals.\n    assertPrint(\"({})\", \"({})\");\n    assertPrint(\"var x = {};\", \"var x={}\");\n    assertPrint(\"({}).x\", \"({}).x\");\n    assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");\n    assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");\n    assertPrint(\"({}) || 1\", \"({})||1\");\n    assertPrint(\"1 || ({})\", \"1||{}\");\n    assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");\n    assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");\n    assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");\n    assertPrint(\"typeof ({})\", \"typeof{}\");\n    assertPrint(\"f({})\", \"f({})\");\n\n    // Anonymous function expressions.\n    assertPrint(\"(function(){})\", \"(function(){})\");\n    assertPrint(\"(function(){})()\", \"(function(){})()\");\n    assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");\n    assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");\n    assertPrint(\"var x = function() { };\", \"var x=function(){}\");\n    assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");\n    assertPrint(\"(function() {}), 2\", \"(function(){}),2\");\n\n    // Name functions expression.\n    assertPrint(\"(function f(){})\", \"(function f(){})\");\n\n    // Function declaration.\n    assertPrint(\"function f(){}\", \"function f(){}\");\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");\n    assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");\n\n    // Test if statement and for statements with single statements in body.\n    assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");\n    assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");\n    assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");\n\n    assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");\n    assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");\n    assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");\n\n    // Test nested var statement\n    assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");\n    assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");\n    assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");\n    assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");\n\n    // Test the right-associative unary operators for spurious parens\n    assertPrint(\"! ! true\", \"!!true\");\n    assertPrint(\"!(!(true))\", \"!!true\");\n    assertPrint(\"typeof(void(0))\", \"typeof void 0\");\n    assertPrint(\"typeof(void(!0))\", \"typeof void!0\");\n    assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\"); // chained unary plus/minus\n    assertPrint(\"+(--x)\", \"+--x\");\n    assertPrint(\"-(++x)\", \"-++x\");\n\n    // needs a space to prevent an ambiguous parse\n    assertPrint(\"-(--x)\", \"- --x\");\n    assertPrint(\"!(~~5)\", \"!~~5\");\n    assertPrint(\"~(a/b)\", \"~(a/b)\");\n\n    // Preserve parens to overcome greedy binding of NEW\n    assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");\n    assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");\n    assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");\n\n    // Make sure that HOOK is right associative\n    assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");\n    assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");\n    assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");\n\n    // Test nested ifs\n    assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");\n\n    // Test comma.\n    assertPrint(\"a,b,c\", \"a,b,c\");\n    assertPrint(\"(a,b),c\", \"a,b,c\");\n    assertPrint(\"a,(b,c)\", \"a,b,c\");\n    assertPrint(\"x=a,b,c\", \"x=a,b,c\");\n    assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");\n    assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");\n    assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");\n    assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");\n    assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");\n    assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");\n    assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");\n    assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");\n    assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");\n    assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");\n    assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");\n    assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");\n    assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");\n    assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");\n    assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");\n    assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");\n    assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");\n    assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");\n\n    // EMPTY nodes\n    assertPrint(\"if (x){}\", \"if(x);\");\n    assertPrint(\"if(x);\", \"if(x);\");\n    assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");\n    assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");\n    assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");\n    assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testPrint --> junit.framework.ComparisonFailure: expected:<var a,b,c;a||[(b||c);a*(b*c);a|(b|c)]> but was:<var a,b,c;a||[b||c;a*b*c;a|b|c]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<var a,b,c;a||[(b||c);a*(b*c);a|(b|c)]> but was:<var a,b,c;a||[b||c;a*b*c;a|b|c]>"
      },
      "com.google.javascript.jscomp.CodePrinterTest::testIssue1062": {
        "path": "com/google/javascript/jscomp/CodePrinterTest.java",
        "function_name": "testIssue1062",
        "src": "public void testIssue1062() {\n    assertPrintSame(\"3*(4%3*5)\");\n  }",
        "error_msg": "com.google.javascript.jscomp.CodePrinterTest::testIssue1062 --> junit.framework.ComparisonFailure: expected:<3*[(4%3*5)]> but was:<3*[4%3*5]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<3*[(4%3*5)]> but was:<3*[4%3*5]>"
      },
      "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity": {
        "path": "com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java",
        "function_name": "testAssocitivity",
        "src": "public void testAssocitivity() {\n    test(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c\");\n    testSame(\"var a,b,c; a % (b % c); a / (b / c); a - (b - c);\");\n  }",
        "error_msg": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Closure-174": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/com/google/javascript/jscomp/JsAst.java",
        "start_loc": 81,
        "end_loc": 108,
        "buggy_function": "  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
        "fixed_function": "  private void parse(AbstractCompiler compiler) {\n    int startErrorCount = compiler.getErrorManager().getErrorCount();\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null ||\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n        (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
        "comment": ""
      },
      {
        "path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "start_loc": 2360,
        "end_loc": 2372,
        "buggy_function": "  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }",
        "fixed_function": "  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else if (value != null) {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(nameNode);\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }",
        "comment": "/**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */"
      },
      {
        "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "start_loc": 351,
        "end_loc": 398,
        "buggy_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVarAssign) {\n          Node value = v.getInitialValue().detachFromParent();\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "fixed_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103a": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testIssue1103a",
        "src": "public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103a --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>"
      },
      "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103b": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testIssue1103b",
        "src": "public void testIssue1103b() {\n    test(\"goog.scope(function () {\" +\n         \"  var a = foo, b, c = 1;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103b --> java.lang.RuntimeException: INTERNAL COMPILER ERROR.",
        "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR."
      },
      "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103c": {
        "path": "com/google/javascript/jscomp/ScopedAliasesTest.java",
        "function_name": "testIssue1103c",
        "src": "public void testIssue1103c() {\n    test(\"goog.scope(function () {\" +\n         \"  /** @type {number} */ var a;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"/** @type {number} */ $jscomp.scope.a;\");\n  }",
        "error_msg": "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103c --> junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>"
      }
    }
  },
  "Codec-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "start_loc": 50,
        "end_loc": 140,
        "buggy_function": "    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase();\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }",
        "fixed_function": "    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }",
        "comment": "/**\n     * Find the caverphone value of a String. \n     *\n     * @param txt String to find the caverphone code for\n     * @return A caverphone code corresponding to the String supplied\n     */"
      },
      {
        "path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "start_loc": 81,
        "end_loc": 313,
        "buggy_function": "    public String metaphone(String txt) {\n        boolean hard = false ;\n        if ((txt == null) || (txt.length() == 0)) {\n            return \"\" ;\n        }\n        // single character is itself\n        if (txt.length() == 1) {\n            return txt.toUpperCase() ;\n        }\n      \n        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n      \n        StringBuffer local = new StringBuffer(40); // manipulate\n        StringBuffer code = new StringBuffer(10) ; //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K' : \n        case 'G' : \n        case 'P' : /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W' : /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1); \n                break ;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X' : /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break ;\n        default :\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        int wdsz = local.length();\n        int n = 0 ;\n\n        while ((code.length() < this.getMaxCodeLen()) && \n        \t   (n < wdsz) ) { // max code size of 4 works well\n            char symb = local.charAt(n) ;\n            // remove duplicate letters except C\n            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                n++ ;\n            } else { // not dup\n                switch(symb) {\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    if (n == 0) { \n                        code.append(symb);\n                    }\n                    break ; // only use vowel if leading char\n                case 'B' :\n                    if ( isPreviousChar(local, n, 'M') && \n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n\t\t\t\t\t\tbreak;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C' : // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') && \n                         !isLastChar(wdsz, n) && \n                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X'); \n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K') ; \n                        break ;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if ((n == 0) && \n                        \t(wdsz >= 3) && \n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else { \n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else { \n                        code.append('K');\n                    }\n                    break ;\n                case 'D' :\n                    if (!isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'G') && \n                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                        code.append('J'); n += 2 ;\n                    } else { \n                        code.append('T');\n                    }\n                    break ;\n                case 'G' : // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&  \n                        isNextChar(local,n,'H') && \n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if ((n > 0) && \n                    \t( regionMatch(local, n, \"GN\") ||\n\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true ;\n                    } else {\n                        hard = false ;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n                        (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break ;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break ; // terminal H\n                    }\n                    if ((n > 0) && \n                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F': \n                case 'J' : \n                case 'L' :\n                case 'M': \n                case 'N' : \n                case 'R' :\n                    code.append(symb); \n                    break;\n                case 'K' :\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break ;\n                case 'P' :\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'Q' :\n                    code.append('K');\n                    break;\n                case 'S' :\n                    if (regionMatch(local,n,\"SH\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T' :\n                    if (regionMatch(local,n,\"TIA\") || \n\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n                        code.append('X'); \n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n\t\t\t\t\t\t// Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break ;\n                case 'V' :\n                    code.append('F'); break ;\n                case 'W' : case 'Y' : // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) && \n                    \tisVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'X' :\n                    code.append('K'); code.append('S');\n                    break ;\n                case 'Z' :\n                    code.append('S'); break ;\n                } // end switch\n                n++ ;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) { \n            \tcode.setLength(this.getMaxCodeLen()); \n            }\n        }\n        return code.toString();\n    }",
        "fixed_function": "    public String metaphone(String txt) {\n        boolean hard = false ;\n        if ((txt == null) || (txt.length() == 0)) {\n            return \"\" ;\n        }\n        // single character is itself\n        if (txt.length() == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH) ;\n        }\n      \n        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n      \n        StringBuffer local = new StringBuffer(40); // manipulate\n        StringBuffer code = new StringBuffer(10) ; //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K' : \n        case 'G' : \n        case 'P' : /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W' : /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1); \n                break ;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X' : /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break ;\n        default :\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        int wdsz = local.length();\n        int n = 0 ;\n\n        while ((code.length() < this.getMaxCodeLen()) && \n        \t   (n < wdsz) ) { // max code size of 4 works well\n            char symb = local.charAt(n) ;\n            // remove duplicate letters except C\n            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                n++ ;\n            } else { // not dup\n                switch(symb) {\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    if (n == 0) { \n                        code.append(symb);\n                    }\n                    break ; // only use vowel if leading char\n                case 'B' :\n                    if ( isPreviousChar(local, n, 'M') && \n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n\t\t\t\t\t\tbreak;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C' : // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') && \n                         !isLastChar(wdsz, n) && \n                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X'); \n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K') ; \n                        break ;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if ((n == 0) && \n                        \t(wdsz >= 3) && \n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else { \n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else { \n                        code.append('K');\n                    }\n                    break ;\n                case 'D' :\n                    if (!isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'G') && \n                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                        code.append('J'); n += 2 ;\n                    } else { \n                        code.append('T');\n                    }\n                    break ;\n                case 'G' : // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&  \n                        isNextChar(local,n,'H') && \n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if ((n > 0) && \n                    \t( regionMatch(local, n, \"GN\") ||\n\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true ;\n                    } else {\n                        hard = false ;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n                        (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break ;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break ; // terminal H\n                    }\n                    if ((n > 0) && \n                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F': \n                case 'J' : \n                case 'L' :\n                case 'M': \n                case 'N' : \n                case 'R' :\n                    code.append(symb); \n                    break;\n                case 'K' :\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break ;\n                case 'P' :\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'Q' :\n                    code.append('K');\n                    break;\n                case 'S' :\n                    if (regionMatch(local,n,\"SH\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T' :\n                    if (regionMatch(local,n,\"TIA\") || \n\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n                        code.append('X'); \n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n\t\t\t\t\t\t// Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break ;\n                case 'V' :\n                    code.append('F'); break ;\n                case 'W' : case 'Y' : // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) && \n                    \tisVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'X' :\n                    code.append('K'); code.append('S');\n                    break ;\n                case 'Z' :\n                    code.append('S'); break ;\n                } // end switch\n                n++ ;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) { \n            \tcode.setLength(this.getMaxCodeLen()); \n            }\n        }\n        return code.toString();\n    }",
        "comment": "/**\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     */"
      },
      {
        "path": "src/java/org/apache/commons/codec/language/SoundexUtils.java",
        "start_loc": 40,
        "end_loc": 56,
        "buggy_function": "    static String clean(String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        int len = str.length();\n        char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase();\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "fixed_function": "    static String clean(String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        int len = str.length();\n        char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "comment": "/**\n\t * Cleans up the input string before Soundex processing by only returning\n\t * upper case letters.\n\t * \n\t * @param str\n\t *                  The String to clean.\n\t * @return A clean String.\n\t */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.codec.language.CaverphoneTest::testLocaleIndependence": {
        "path": "org/apache/commons/codec/language/CaverphoneTest.java",
        "function_name": "testLocaleIndependence",
        "src": "",
        "error_msg": "org.apache.commons.codec.language.CaverphoneTest::testLocaleIndependence --> junit.framework.ComparisonFailure: tr:  expected:<[A]111111111> but was:<[1]111111111>",
        "clean_error_msg": "junit.framework.ComparisonFailure: tr:  expected:<[A]111111111> but was:<[1]111111111>"
      },
      "org.apache.commons.codec.language.DoubleMetaphoneTest::testLocaleIndependence": {
        "path": "org/apache/commons/codec/language/DoubleMetaphoneTest.java",
        "function_name": "testLocaleIndependence",
        "src": "",
        "error_msg": "org.apache.commons.codec.language.DoubleMetaphoneTest::testLocaleIndependence --> junit.framework.ComparisonFailure: tr:  expected:<[I]> but was:<[\u0130]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: tr:  expected:<[I]> but was:<[\u0130]>"
      },
      "org.apache.commons.codec.language.MetaphoneTest::testLocaleIndependence": {
        "path": "org/apache/commons/codec/language/MetaphoneTest.java",
        "function_name": "testLocaleIndependence",
        "src": "",
        "error_msg": "org.apache.commons.codec.language.MetaphoneTest::testLocaleIndependence --> junit.framework.ComparisonFailure: tr:  expected:<[I]> but was:<[\u0130]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: tr:  expected:<[I]> but was:<[\u0130]>"
      },
      "org.apache.commons.codec.language.RefinedSoundexTest::testLocaleIndependence": {
        "path": "org/apache/commons/codec/language/RefinedSoundexTest.java",
        "function_name": "testLocaleIndependence",
        "src": "",
        "error_msg": "org.apache.commons.codec.language.RefinedSoundexTest::testLocaleIndependence --> junit.framework.AssertionFailedError: tr: 239",
        "clean_error_msg": "junit.framework.AssertionFailedError: tr: 239"
      },
      "org.apache.commons.codec.language.SoundexTest::testLocaleIndependence": {
        "path": "org/apache/commons/codec/language/SoundexTest.java",
        "function_name": "testLocaleIndependence",
        "src": "",
        "error_msg": "org.apache.commons.codec.language.SoundexTest::testLocaleIndependence --> junit.framework.AssertionFailedError: tr: The character is not mapped: \u0130",
        "clean_error_msg": "junit.framework.AssertionFailedError: tr: The character is not mapped: \u0130"
      }
    }
  },
  "Codec-8": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "start_loc": 419,
        "end_loc": 425,
        "buggy_function": "    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }",
        "fixed_function": "    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }",
        "comment": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */"
      },
      {
        "path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "start_loc": 138,
        "end_loc": 182,
        "buggy_function": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }",
        "fixed_function": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }",
        "comment": "/**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105": {
        "path": "org/apache/commons/codec/binary/Base64InputStreamTest.java",
        "function_name": "testCodec105",
        "src": "public void testCodec105() throws IOException {\n        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n        for (int i = 0; i < 5; i++) {\n            in.read();\n        }\n    }",
        "error_msg": "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105 --> java.lang.ArrayIndexOutOfBoundsException: 2",
        "clean_error_msg": "java.lang.ArrayIndexOutOfBoundsException: 2"
      }
    }
  },
  "Codec-14": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "start_loc": 100,
        "end_loc": 104,
        "buggy_function": "    static {\n        for (final NameType s : NameType.values()) {\n            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n        }\n    }",
        "fixed_function": "    static {\n        for (final NameType s : NameType.values()) {\n            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "start_loc": 329,
        "end_loc": 365,
        "buggy_function": "    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"finalRules can not be null\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    // not found, appending as-is\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n            // phonemes with the same text but different language set get lost\n            phonemes.addAll(subBuilder.getPhonemes());\n        }\n\n        return new PhonemeBuilder(phonemes);\n    }",
        "fixed_function": "    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"finalRules can not be null\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    // not found, appending as-is\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n            // phonemes with the same text but different language set get lost\n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n                if (phonemes.containsKey(newPhoneme)) {\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\n                } else {\n                    phonemes.put(newPhoneme, newPhoneme);\n                }\n            }\n        }\n\n        return new PhonemeBuilder(phonemes.keySet());\n    }",
        "comment": "/**\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion": {
        "path": "org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java",
        "function_name": "testCompatibilityWithOriginalVersion",
        "src": "@Test\n    public void testCompatibilityWithOriginalVersion() {\n        // see CODEC-187\n        // comparison: http://stevemorse.org/census/soundex.html\n\n        Map<String, String> args = new TreeMap<String, String>();\n        args.put(\"nameType\", \"GENERIC\");\n        args.put(\"ruleType\", \"APPROX\");\n\n        assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\");\n        assertEquals(encode(args, true, \"Bendzin\"), \"bndzn|bntsn|bnzn|vndzn|vntsn\");\n\n        args.put(\"nameType\", \"ASHKENAZI\");\n        args.put(\"ruleType\", \"APPROX\");\n\n        assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom\");\n        assertEquals(encode(args, true, \"Halpern\"), \"YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn\");\n\n    }",
        "error_msg": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion --> junit.framework.AssertionFailedError: expected:<...dzn|bntsn|bnzn|vndzn[]> but was:<...dzn|bntsn|bnzn|vndzn[|vntsn]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...dzn|bntsn|bnzn|vndzn[]> but was:<...dzn|bntsn|bnzn|vndzn[|vntsn]>"
      }
    }
  },
  "Commons_suncalc-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/shredzone/commons/suncalc/MoonTimes.java",
        "start_loc": 113,
        "end_loc": 169,
        "buggy_function": "        @Override\n        public MoonTimes execute() {\n            JulianDate jd = getJulianDate();\n\n            Double rise = null;\n            Double set = null;\n            boolean alwaysUp = false;\n            boolean alwaysDown = false;\n\n            double y_minus = correctedMoonHeight(jd);\n            int maxHours = fullCycle ? 365 * 24 : 24;\n            for (int hour = 1; hour < maxHours; hour += 2) {\n                double y_0 = correctedMoonHeight(jd.atHour(hour));\n                double y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));\n\n\n                QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);\n                double ye = qi.getYe();\n\n                if (qi.getNumberOfRoots() == 1) {\n                    if (y_minus < 0.0) {\n                        if (rise == null) {\n                            rise = qi.getRoot1() + hour;\n                        }\n                    } else {\n                        if (set == null) {\n                            set = qi.getRoot1() + hour;\n                        }\n                    }\n                } else if (qi.getNumberOfRoots() == 2) {\n                    if (rise == null) {\n                        rise = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());\n                    }\n                    if (set == null) {\n                        set = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());\n                    }\n                }\n\n                if (hour == 23 && rise == null && set == null) {\n                    alwaysUp = ye >= 0.0;\n                    alwaysDown = ye < 0.0;\n                }\n\n                if (rise != null && set != null) {\n                    break;\n                }\n\n                y_minus = y_plus;\n\n            }\n\n            return new MoonTimes(\n                    rise != null ? jd.atHour(rise).getDateTruncated(getTruncatedTo()) : null,\n                    set != null ? jd.atHour(set).getDateTruncated(getTruncatedTo()) : null,\n                    alwaysUp,\n                    alwaysDown);\n        }",
        "fixed_function": "        @Override\n        public MoonTimes execute() {\n            JulianDate jd = getJulianDate();\n\n            Double rise = null;\n            Double set = null;\n            boolean alwaysUp = false;\n            boolean alwaysDown = false;\n\n            int hour = 0;\n            int maxHours = fullCycle ? 365 * 24 : 24;\n\n            double y_minus = correctedMoonHeight(jd.atHour(hour - 1.0));\n            double y_0 = correctedMoonHeight(jd.atHour(hour));\n            double y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));\n\n            while (hour <= maxHours) {\n                QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);\n                double ye = qi.getYe();\n\n                if (qi.getNumberOfRoots() == 1) {\n                    double rt = qi.getRoot1() + hour;\n                    if (y_minus < 0.0) {\n                        if (rise == null && rt >= 0.0) {\n                            rise = rt;\n                        }\n                    } else {\n                        if (set == null && rt >= 0.0) {\n                            set = rt;\n                        }\n                    }\n                } else if (qi.getNumberOfRoots() == 2) {\n                    if (rise == null) {\n                        double rt = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());\n                        if (rt >= 0.0) {\n                            rise = rt;\n                        }\n                    }\n                    if (set == null) {\n                        double rt = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());\n                        if (rt >= 0.0) {\n                            set = rt;\n                        }\n                    }\n                }\n\n                if (hour == 23 && rise == null && set == null) {\n                    alwaysUp = ye >= 0.0;\n                    alwaysDown = ye < 0.0;\n                }\n\n                if (rise != null && set != null) {\n                    break;\n                }\n\n                hour++;\n                y_minus = y_0;\n                y_0 = y_plus;\n                y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));\n            }\n\n            if (!fullCycle) {\n                if (rise != null && rise >= 24.0) {\n                    rise = null;\n                }\n                if (set != null && set >= 24.0) {\n                    set = null;\n                }\n            }\n\n            return new MoonTimes(\n                    rise != null ? jd.atHour(rise).getDateTruncated(getTruncatedTo()) : null,\n                    set != null ? jd.atHour(set).getDateTruncated(getTruncatedTo()) : null,\n                    alwaysUp,\n                    alwaysDown);\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/shredzone/commons/suncalc/SunTimes.java",
        "start_loc": 269,
        "end_loc": 351,
        "buggy_function": "        @Override\n        public SunTimes execute() {\n            JulianDate jd = getJulianDate();\n\n            Double rise = null;\n            Double set = null;\n            Double noon = null;\n            Double nadir = null;\n            boolean alwaysUp = false;\n            boolean alwaysDown = false;\n            double ye;\n\n            double y_minus = correctedSunHeight(jd);\n            if (y_minus > 0.0) {\n                alwaysUp = true;\n            } else {\n                alwaysDown = true;\n            }\n\n            int maxHours = fullCycle ? 365 * 24 : 24;\n            for (int hour = 1; hour < maxHours; hour++) {\n                double y_0 = correctedSunHeight(jd.atHour(hour));\n                double y_plus = correctedSunHeight(jd.atHour(hour + 1.0));\n\n                QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);\n                ye = qi.getYe();\n\n                if (qi.getNumberOfRoots() == 1) {\n                    if (y_minus < 0.0) {\n                        if (rise == null) {\n                            rise = qi.getRoot1() + hour;\n                        }\n                    } else {\n                        if (set == null) {\n                            set = qi.getRoot1() + hour;\n                        }\n                    }\n                } else if (qi.getNumberOfRoots() == 2) {\n                    if (rise == null) {\n                        rise = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());\n                    }\n                    if (set == null) {\n                        set = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());\n                    }\n                }\n\n                if (hour < 24) {\n                    double xeAbs = Math.abs(qi.getXe());\n                    if (xeAbs <= 1.0) {\n                        double xeHour = qi.getXe() + hour;\n                        if (qi.isMaximum()) {\n                            noon = xeHour;\n                        } else {\n                            nadir = xeHour;\n                        }\n                    }\n                }\n\n                if (hour == 23) {\n                    if (rise != null) {\n                        alwaysDown = false;\n                    }\n                    if (set != null) {\n                        alwaysUp = false;\n                    }\n                }\n\n                if (hour >= 24 && rise != null && set != null) {\n                    break;\n                }\n\n                y_minus = y_0;\n            }\n\n            return new SunTimes(\n                    rise != null ? jd.atHour(rise).getDateTruncated(getTruncatedTo()) : null,\n                    set != null ? jd.atHour(set).getDateTruncated(getTruncatedTo()) : null,\n                    noon != null ? jd.atHour(noon).getDateTruncated(getTruncatedTo()) : null,\n                    nadir != null ? jd.atHour(nadir).getDateTruncated(getTruncatedTo()) : null,\n                    alwaysUp,\n                    alwaysDown\n                );\n        }",
        "fixed_function": "        @Override\n        public SunTimes execute() {\n            JulianDate jd = getJulianDate();\n\n            Double rise = null;\n            Double set = null;\n            Double noon = null;\n            Double nadir = null;\n            boolean alwaysUp = false;\n            boolean alwaysDown = false;\n            double ye;\n\n            int hour = 0;\n            int maxHours = fullCycle ? 365 * 24 : 24;\n\n            double y_minus = correctedSunHeight(jd.atHour(hour - 1.0));\n            double y_0 = correctedSunHeight(jd.atHour(hour));\n            double y_plus = correctedSunHeight(jd.atHour(hour + 1.0));\n\n            if (y_0 > 0.0) {\n                alwaysUp = true;\n            } else {\n                alwaysDown = true;\n            }\n\n            while (hour <= maxHours) {\n                QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);\n                ye = qi.getYe();\n\n                if (qi.getNumberOfRoots() == 1) {\n                    double rt = qi.getRoot1() + hour;\n                    if (y_minus < 0.0) {\n                        if (rise == null && rt >= 0.0) {\n                            rise = rt;\n                        }\n                    } else {\n                        if (set == null && rt >= 0.0) {\n                            set = rt;\n                        }\n                    }\n                } else if (qi.getNumberOfRoots() == 2) {\n                    if (rise == null) {\n                        double rt = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());\n                        if (rt >= 0.0) {\n                            rise = rt;\n                        }\n                    }\n                    if (set == null) {\n                        double rt = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());\n                        if (rt >= 0.0) {\n                            set = rt;\n                        }\n                    }\n                }\n\n                if (hour <= 24) {\n                    double xeAbs = Math.abs(qi.getXe());\n                    if (xeAbs <= 1.0) {\n                        double xeHour = qi.getXe() + hour;\n                        if (xeHour >= 0.0 && xeHour < 24.0) {\n                            if (qi.isMaximum()) {\n                                noon = xeHour;\n                            } else {\n                                nadir = xeHour;\n                            }\n                        }\n                    }\n                }\n\n                if (hour == 23) {\n                    if (rise != null) {\n                        alwaysDown = false;\n                    }\n                    if (set != null) {\n                        alwaysUp = false;\n                    }\n                }\n\n                if (hour >= 24 && rise != null && set != null) {\n                    break;\n                }\n\n                hour++;\n                y_minus = y_0;\n                y_0 = y_plus;\n                y_plus = correctedSunHeight(jd.atHour(hour + 1.0));\n            }\n\n            if (!fullCycle) {\n                if (rise != null && rise >= 24.0) {\n                    rise = null;\n                }\n                if (set != null && set >= 24.0) {\n                    set = null;\n                }\n            }\n\n            return new SunTimes(\n                    rise != null ? jd.atHour(rise).getDateTruncated(getTruncatedTo()) : null,\n                    set != null ? jd.atHour(set).getDateTruncated(getTruncatedTo()) : null,\n                    noon != null ? jd.atHour(noon).getDateTruncated(getTruncatedTo()) : null,\n                    nadir != null ? jd.atHour(nadir).getDateTruncated(getTruncatedTo()) : null,\n                    alwaysUp,\n                    alwaysDown\n                );\n        }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.shredzone.commons.suncalc.MoonTimesTest::testPuertoWilliams": {
        "path": "org/shredzone/commons/suncalc/MoonTimesTest.java",
        "function_name": "testPuertoWilliams",
        "src": "@Test\n    public void testPuertoWilliams() {\n        MoonTimes mt = MoonTimes.compute().on(2017, 7, 13).utc().at(PUERTO_WILLIAMS)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt.getRise()).as(\"rise\").isEqualTo(\"2017-07-13T00:31:33Z\");\n        assertThat(mt.getSet()).as(\"set\").isEqualTo(\"2017-07-13T14:48:33Z\");\n    }",
        "error_msg": "org.shredzone.commons.suncalc.MoonTimesTest::testPuertoWilliams --> junit.framework.AssertionFailedError: [rise] expected:<2017-07-12T17:31:[33].000> but was:<2017-07-12T17:31:[12].000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [rise] expected:<2017-07-12T17:31:[33].000> but was:<2017-07-12T17:31:[12].000>"
      },
      "org.shredzone.commons.suncalc.MoonTimesTest::testAlert": {
        "path": "org/shredzone/commons/suncalc/MoonTimesTest.java",
        "function_name": "testAlert",
        "src": "@Test\n    public void testAlert() {\n        MoonTimes mt1 = MoonTimes.compute().on(2017, 7, 12).utc().at(ALERT)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt1.isAlwaysUp()).as(\"alwaysup\").isFalse();\n        assertThat(mt1.isAlwaysDown()).as(\"alwaysdown\").isTrue();\n\n        MoonTimes mt2 = MoonTimes.compute().on(2017, 7, 12).utc().at(ALERT).fullCycle()\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt2.getRise()).as(\"rise\").isEqualTo(\"2017-07-14T05:45:33Z\");\n        assertThat(mt2.getSet()).as(\"set\").isEqualTo(\"2017-07-14T11:26:12Z\");\n        assertThat(mt2.isAlwaysUp()).as(\"alwaysup\").isFalse();\n        assertThat(mt2.isAlwaysDown()).as(\"alwaysdown\").isTrue();\n\n        MoonTimes mt3 = MoonTimes.compute().on(2017, 7, 14).utc().at(ALERT)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt3.getRise()).as(\"rise\").isEqualTo(\"2017-07-14T05:45:33Z\");\n        assertThat(mt3.getSet()).as(\"set\").isEqualTo(\"2017-07-14T11:26:12Z\");\n        assertThat(mt3.isAlwaysUp()).as(\"alwaysup\").isFalse();\n        assertThat(mt3.isAlwaysDown()).as(\"alwaysdown\").isFalse();\n\n        MoonTimes mt4 = MoonTimes.compute().on(2017, 7, 18).utc().at(ALERT).oneDay()\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt4.isAlwaysUp()).as(\"alwaysup\").isTrue();\n        assertThat(mt4.isAlwaysDown()).as(\"alwaysdown\").isFalse();\n\n        MoonTimes mt5 = MoonTimes.compute().on(2017, 7, 18).utc().at(ALERT).fullCycle()\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt5.getRise()).as(\"rise\").isEqualTo(\"2017-07-27T11:59:07Z\");\n        assertThat(mt5.getSet()).as(\"set\").isEqualTo(\"2017-07-27T04:07:24Z\");\n        assertThat(mt5.isAlwaysUp()).as(\"alwaysup\").isTrue();\n        assertThat(mt5.isAlwaysDown()).as(\"alwaysdown\").isFalse();\n    }",
        "error_msg": "org.shredzone.commons.suncalc.MoonTimesTest::testAlert --> junit.framework.AssertionFailedError: [set] expected:<2017-07-26T21:07:[2]4.000> but was:<2017-07-26T21:07:[1]4.000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [set] expected:<2017-07-26T21:07:[2]4.000> but was:<2017-07-26T21:07:[1]4.000>"
      },
      "org.shredzone.commons.suncalc.MoonTimesTest::testWellington": {
        "path": "org/shredzone/commons/suncalc/MoonTimesTest.java",
        "function_name": "testWellington",
        "src": "@Test\n    public void testWellington() {\n        MoonTimes mt1 = MoonTimes.compute().on(2017, 7, 12).utc().at(WELLINGTON)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt1.getRise()).as(\"rise\").isEqualTo(\"2017-07-12T08:05:55Z\");\n        assertThat(mt1.getSet()).as(\"set\").isEqualTo(\"2017-07-12T21:57:35Z\");\n\n        MoonTimes mt2 = MoonTimes.compute().on(2017, 7, 12).timezone(\"NZ\").at(WELLINGTON)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt2.getRise()).as(\"rise\").isEqualTo(\"2017-07-12T20:05:55+12:00\");\n        assertThat(mt2.getSet()).as(\"set\").isEqualTo(\"2017-07-12T09:22:59+12:00\");\n    }",
        "error_msg": "org.shredzone.commons.suncalc.MoonTimesTest::testWellington --> junit.framework.AssertionFailedError: [rise] expected:<2017-07-12T01:05:5[5].000> but was:<2017-07-12T01:05:5[0].000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [rise] expected:<2017-07-12T01:05:5[5].000> but was:<2017-07-12T01:05:5[0].000>"
      },
      "org.shredzone.commons.suncalc.MoonTimesTest::testSingapore": {
        "path": "org/shredzone/commons/suncalc/MoonTimesTest.java",
        "function_name": "testSingapore",
        "src": "@Test\n    public void testSingapore() {\n        MoonTimes mt = MoonTimes.compute().on(2017, 7, 13).utc().at(SINGAPORE)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt.getRise()).as(\"rise\").isEqualTo(\"2017-07-13T14:35:11Z\");\n        assertThat(mt.getSet()).as(\"set\").isEqualTo(\"2017-07-13T02:08:55Z\");\n    }",
        "error_msg": "org.shredzone.commons.suncalc.MoonTimesTest::testSingapore --> junit.framework.AssertionFailedError: [set] expected:<2017-07-12T19:08:5[5].000> but was:<2017-07-12T19:08:5[4].000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [set] expected:<2017-07-12T19:08:5[5].000> but was:<2017-07-12T19:08:5[4].000>"
      },
      "org.shredzone.commons.suncalc.MoonTimesTest::testCologne": {
        "path": "org/shredzone/commons/suncalc/MoonTimesTest.java",
        "function_name": "testCologne",
        "src": "@Test\n    public void testCologne() {\n        MoonTimes mt = MoonTimes.compute().on(2017, 7, 12).utc().at(COLOGNE)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(mt.getRise()).as(\"rise\").isEqualTo(\"2017-07-12T21:25:58Z\");\n        assertThat(mt.getSet()).as(\"set\").isEqualTo(\"2017-07-12T06:53:27Z\");\n        assertThat(mt.isAlwaysUp()).as(\"alwaysup\").isFalse();\n        assertThat(mt.isAlwaysDown()).as(\"alwaysdown\").isFalse();\n    }",
        "error_msg": "org.shredzone.commons.suncalc.MoonTimesTest::testCologne --> junit.framework.AssertionFailedError: [set] expected:<2017-07-11T23:53:[27].000> but was:<2017-07-11T23:53:[19].000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [set] expected:<2017-07-11T23:53:[27].000> but was:<2017-07-11T23:53:[19].000>"
      },
      "org.shredzone.commons.suncalc.SunTimesTest::testCologne": {
        "path": "org/shredzone/commons/suncalc/SunTimesTest.java",
        "function_name": "testCologne",
        "src": "@Test\n    public void testCologne() {\n        Map<Twilight, String> riseTimes = new EnumMap<>(Twilight.class);\n        riseTimes.put(Twilight.ASTRONOMICAL, \"2017-08-10T01:44:18Z\");\n        riseTimes.put(Twilight.NAUTICAL,     \"2017-08-10T02:44:57Z\");\n        riseTimes.put(Twilight.CIVIL,        \"2017-08-10T03:34:01Z\");\n        riseTimes.put(Twilight.BLUE_HOUR,    \"2017-08-10T03:48:59Z\");\n        riseTimes.put(Twilight.VISUAL,       \"2017-08-10T04:11:49Z\");\n        riseTimes.put(Twilight.VISUAL_LOWER, \"2017-08-10T04:15:33Z\");\n        riseTimes.put(Twilight.HORIZON,      \"2017-08-10T04:17:44Z\");\n        riseTimes.put(Twilight.GOLDEN_HOUR,  \"2017-08-10T04:58:33Z\");\n\n        Map<Twilight, String> setTimes = new EnumMap<>(Twilight.class);\n        setTimes.put(Twilight.GOLDEN_HOUR,   \"2017-08-10T18:15:49Z\");\n        setTimes.put(Twilight.HORIZON,       \"2017-08-10T18:56:30Z\");\n        setTimes.put(Twilight.VISUAL_LOWER,  \"2017-08-10T18:58:39Z\");\n        setTimes.put(Twilight.VISUAL,        \"2017-08-10T19:02:20Z\");\n        setTimes.put(Twilight.BLUE_HOUR,     \"2017-08-10T19:25:16Z\");\n        setTimes.put(Twilight.CIVIL,         \"2017-08-10T19:40:13Z\");\n        setTimes.put(Twilight.NAUTICAL,      \"2017-08-10T20:28:56Z\");\n        setTimes.put(Twilight.ASTRONOMICAL,  \"2017-08-10T21:28:43Z\");\n\n        for (Twilight angle : Twilight.values()) {\n            SunTimes times = SunTimes.compute().at(COLOGNE).on(2017, 8, 10).utc()\n                            .twilight(angle)\n                            .truncatedTo(Unit.SECONDS).execute();\n            assertThat(times.getRise()).as(\"%s-rise\", angle.name()).isEqualTo(riseTimes.get(angle));\n            assertThat(times.getSet()).as(\"%s-set\", angle.name()).isEqualTo(setTimes.get(angle));\n            assertThat(times.getNoon()).as(\"noon\").isEqualTo(\"2017-08-10T11:37:38Z\");\n            assertThat(times.getNadir()).as(\"nadir\").isEqualTo(\"2017-08-10T23:37:51Z\");\n            assertThat(times.isAlwaysDown()).as(\"always-down\").isFalse();\n            assertThat(times.isAlwaysUp()).as(\"always-up\").isFalse();\n        }\n\n        SunTimes times = SunTimes.compute().at(COLOGNE).on(2017, 8, 10).utc()\n                        .twilight(-4.0)\n                        .truncatedTo(Unit.SECONDS).execute();\n        assertThat(times.getRise()).as(\"rise\").isEqualTo(\"2017-08-10T03:48:59Z\");\n        assertThat(times.getSet()).as(\"set\").isEqualTo(\"2017-08-10T19:25:16Z\");\n        assertThat(times.getNoon()).as(\"noon\").isEqualTo(\"2017-08-10T11:37:38Z\");\n        assertThat(times.getNadir()).as(\"nadir\").isEqualTo(\"2017-08-10T23:37:51Z\");\n        assertThat(times.isAlwaysDown()).as(\"always-down\").isFalse();\n        assertThat(times.isAlwaysUp()).as(\"always-up\").isFalse();\n    }",
        "error_msg": "org.shredzone.commons.suncalc.SunTimesTest::testCologne --> junit.framework.AssertionFailedError: [nadir] expected:<2017-08-10T16:37:5[1].000> but was:<2017-08-10T16:37:5[9].000>",
        "clean_error_msg": "junit.framework.AssertionFailedError: [nadir] expected:<2017-08-10T16:37:5[1].000> but was:<2017-08-10T16:37:5[9].000>"
      },
      "org.shredzone.commons.suncalc.SunTimesTest::testJustBeforeJustAfter": {
        "path": "org/shredzone/commons/suncalc/SunTimesTest.java",
        "function_name": "testJustBeforeJustAfter",
        "src": "@Test\n    public void testJustBeforeJustAfter() {\n        // Thanks to @isomeme for providing the test cases for issue #18.\n\n        long shortDuration = 2 * 60 * 1000L;\n        long longDuration = 30 * 60 * 1000L;\n        SunTimes.Parameters param = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)\n                .on(2020, 5, 3).truncatedTo(Unit.SECONDS);\n        Date noon = param.execute().getNoon();\n        Date noonNextDay = param.plusDays(1).execute().getNoon();\n        long acceptableError = 65 * 1000L;\n\n        Date wellBeforeNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)\n                .on(new Date(noon.getTime() - longDuration))\n                .truncatedTo(Unit.SECONDS).execute().getNoon();\n        assertThat(Math.abs(wellBeforeNoon.getTime() - noon.getTime()))\n                .as(\"wellBeforeNoon\").isLessThan(acceptableError);\n\n        Date justBeforeNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)\n                .on(new Date(noon.getTime() - shortDuration))\n                .truncatedTo(Unit.SECONDS).execute().getNoon();\n        assertThat(Math.abs(justBeforeNoon.getTime() - noon.getTime()))\n                .as(\"justBeforeNoon\").isLessThan(acceptableError);\n\n        Date justAfterNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)\n                .on(new Date(noon.getTime() + shortDuration))\n                .truncatedTo(Unit.SECONDS).execute().getNoon();\n        assertThat(Math.abs(justAfterNoon.getTime() - noonNextDay.getTime()))\n                .as(\"justAfterNoon\").isLessThan(acceptableError);\n\n        Date wellAfterNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)\n                .on(new Date(noon.getTime() + longDuration))\n                .truncatedTo(Unit.SECONDS).execute().getNoon();\n        assertThat(Math.abs(wellAfterNoon.getTime() - noonNextDay.getTime()))\n                .as(\"wellAfterNoon\").isLessThan(acceptableError);\n\n        Date nadirWellAfterNoon = SunTimes.compute().on(wellAfterNoon).timezone(SANTA_MONICA_TZ)\n                .at(SANTA_MONICA).execute().getNadir();\n        Date nadirJustBeforeNadir = SunTimes.compute()\n                .on(new Date(nadirWellAfterNoon.getTime() - shortDuration))\n                .at(SANTA_MONICA).timezone(SANTA_MONICA_TZ).execute().getNadir();\n        assertThat(Math.abs(nadirWellAfterNoon.getTime() - nadirJustBeforeNadir.getTime()))\n                .as(\"nadir\").isLessThan(acceptableError);\n    }",
        "error_msg": "org.shredzone.commons.suncalc.SunTimesTest::testJustBeforeJustAfter --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Compress-4": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
        "start_loc": 334,
        "end_loc": 340,
        "buggy_function": "    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            out.close();\n            this.closed = true;\n        }\n    }",
        "fixed_function": "    public void close() throws IOException {\n        if (!this.closed) {\n            out.close();\n            this.closed = true;\n        }\n    }",
        "comment": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
        "start_loc": 124,
        "end_loc": 131,
        "buggy_function": "    public void close() throws IOException {\n        if (!closed) {\n            finish();\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }",
        "fixed_function": "    public void close() throws IOException {\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }",
        "comment": "/**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
        "start_loc": 529,
        "end_loc": 537,
        "buggy_function": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "fixed_function": "    public void close() throws IOException {\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "comment": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java",
        "start_loc": 67,
        "end_loc": 129,
        "buggy_function": "    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        return results;\n    }",
        "fixed_function": "    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        out.finish();\n        return results;\n    }",
        "comment": "/**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker": {
        "path": "org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java",
        "function_name": "testJarMarker",
        "src": "public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        }\n    }",
        "error_msg": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripImplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testCP437FileRoundtripImplicitUnicodeExtra",
        "src": "public void testCP437FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, false);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripImplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripImplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testUtf8FileRoundtripImplicitUnicodeExtra",
        "src": "public void testUtf8FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, false);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripImplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripExplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testCP437FileRoundtripExplicitUnicodeExtra",
        "src": "public void testCP437FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, true);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripExplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripExplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testUtf8FileRoundtripExplicitUnicodeExtra",
        "src": "public void testUtf8FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, true);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripExplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripImplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testASCIIFileRoundtripImplicitUnicodeExtra",
        "src": "public void testASCIIFileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, false);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripImplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSImplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
        "src": "public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, false);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSImplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testZipArchiveInputStreamReadsUnicodeFields",
        "src": "public void testZipArchiveInputStreamReadsUnicodeFields()\n        throws IOException {\n        File file = File.createTempFile(\"unicode-test\", \".zip\");\n        ZipFile zf = null;\n        try {\n            createTestFile(file, US_ASCII, false, true);\n            zf = new ZipFile(file, US_ASCII, true);\n            assertNotNull(zf.getEntry(ASCII_TXT));\n            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n        } finally {\n            ZipFile.closeQuietly(zf);\n            if (file.exists()) {\n                file.delete();\n            }\n        }\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripExplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testASCIIFileRoundtripExplicitUnicodeExtra",
        "src": "public void testASCIIFileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, true);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripExplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      },
      "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSExplicitUnicodeExtra": {
        "path": "org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
        "function_name": "testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
        "src": "public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, true);\n    }",
        "error_msg": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSExplicitUnicodeExtra --> java.io.IOException: central directory is empty, can't expand corrupt archive.",
        "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive."
      }
    }
  },
  "Compress-29": {
    "function_num": 8,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
        "start_loc": 269,
        "end_loc": 310,
        "buggy_function": "    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n                return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }",
        "fixed_function": "    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new JarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new JarArchiveOutputStream(out);\n            }\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }",
        "comment": "/**\n     * Create an archive output stream from an archiver name and an output stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * written to a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java",
        "start_loc": 324,
        "end_loc": 405,
        "buggy_function": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ZipArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ZipArchiveInputStream(in);\n                }\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new JarArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new JarArchiveInputStream(in);\n                }\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new CpioArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new CpioArchiveInputStream(in);\n                }\n            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n                    return new ArjArchiveInputStream(in);\n            } else if (SevenZFile.matches(signature, signatureLength)) {\n                throw new StreamingNotSupportedException(SEVEN_Z);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in, encoding);\n                    }\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                } finally {\n                    IOUtils.closeQuietly(tais);\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
        "fixed_function": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ZipArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ZipArchiveInputStream(in);\n                }\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new JarArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new JarArchiveInputStream(in);\n                }\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new CpioArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new CpioArchiveInputStream(in);\n                }\n            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ArjArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ArjArchiveInputStream(in);\n                }\n            } else if (SevenZFile.matches(signature, signatureLength)) {\n                throw new StreamingNotSupportedException(SEVEN_Z);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in, encoding);\n                    }\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                } finally {\n                    IOUtils.closeQuietly(tais);\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
        "comment": "/**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java",
        "start_loc": 152,
        "end_loc": 156,
        "buggy_function": "    public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n        this.in = in;\n        this.blockSize = blockSize;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }",
        "fixed_function": "    public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n        this.in = in;\n        this.blockSize = blockSize;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }",
        "comment": "/**\n     * Construct the cpio input stream with a blocksize of {@link CpioConstants#BLOCK_SIZE BLOCK_SIZE}.\n     * \n     * @param in\n     *            The cpio stream\n     * @param blockSize\n     *            The block size of the archive.\n     * @param encoding\n     *            The encoding of file names to expect - use null for\n     *            the platform's default.\n     * @since 1.6\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
        "start_loc": 147,
        "end_loc": 163,
        "buggy_function": "    public CpioArchiveOutputStream(final OutputStream out, final short format,\n                                   final int blockSize, final String encoding) {\n        this.out = out;\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n        }\n        this.entryFormat = format;\n        this.blockSize = blockSize;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }",
        "fixed_function": "    public CpioArchiveOutputStream(final OutputStream out, final short format,\n                                   final int blockSize, final String encoding) {\n        this.out = out;\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \"+format);\n\n        }\n        this.entryFormat = format;\n        this.blockSize = blockSize;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    }",
        "comment": "/**\n     * Construct the cpio output stream with a specified format using\n     * ASCII as the file name encoding.\n     * \n     * @param out\n     *            The cpio stream\n     * @param format\n     *            The format of the stream\n     * @param blockSize\n     *            The block size of the archive.\n     * @param encoding\n     *            The encoding of file names to write - use null for\n     *            the platform's default.\n     * \n     * @since 1.6\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java",
        "start_loc": 100,
        "end_loc": 146,
        "buggy_function": "    public DumpArchiveInputStream(InputStream is, String encoding)\n        throws ArchiveException {\n        this.raw = new TapeInputStream(is);\n        this.hasHitEOF = false;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        try {\n            // read header, verify it's a dump archive.\n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new UnrecognizedFormatException();\n            }\n\n            // get summary information\n            summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n            // reset buffer with actual block size.\n            raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n            // allocate our read buffer.\n            blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n            // skip past CLRI and BITS segments since we don't handle them yet.\n            readCLRI();\n            readBITS();\n        } catch (IOException ex) {\n            throw new ArchiveException(ex.getMessage(), ex);\n        }\n\n        // put in a dummy record for the root node.\n        Dirent root = new Dirent(2, 2, 4, \".\");\n        names.put(2, root);\n\n        // use priority based on queue to ensure parent directories are\n        // released first.\n        queue = new PriorityQueue<DumpArchiveEntry>(10,\n                new Comparator<DumpArchiveEntry>() {\n                    public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n                        if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                            return Integer.MAX_VALUE;\n                        }\n\n                        return p.getOriginalName().compareTo(q.getOriginalName());\n                    }\n                });\n    }",
        "fixed_function": "    public DumpArchiveInputStream(InputStream is, String encoding)\n        throws ArchiveException {\n        this.raw = new TapeInputStream(is);\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        try {\n            // read header, verify it's a dump archive.\n            byte[] headerBytes = raw.readRecord();\n\n            if (!DumpArchiveUtil.verify(headerBytes)) {\n                throw new UnrecognizedFormatException();\n            }\n\n            // get summary information\n            summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n            // reset buffer with actual block size.\n            raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n            // allocate our read buffer.\n            blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n            // skip past CLRI and BITS segments since we don't handle them yet.\n            readCLRI();\n            readBITS();\n        } catch (IOException ex) {\n            throw new ArchiveException(ex.getMessage(), ex);\n        }\n\n        // put in a dummy record for the root node.\n        Dirent root = new Dirent(2, 2, 4, \".\");\n        names.put(2, root);\n\n        // use priority based on queue to ensure parent directories are\n        // released first.\n        queue = new PriorityQueue<DumpArchiveEntry>(10,\n                new Comparator<DumpArchiveEntry>() {\n                    public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n                        if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                            return Integer.MAX_VALUE;\n                        }\n\n                        return p.getOriginalName().compareTo(q.getOriginalName());\n                    }\n                });\n    }",
        "comment": "/**\n     * Constructor.\n     *\n     * @param is\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @since 1.6\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java",
        "start_loc": 138,
        "end_loc": 145,
        "buggy_function": "    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\n                                 String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }",
        "fixed_function": "    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\n                                 String encoding) {\n        this.is = is;\n        this.hasHitEOF = false;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.recordSize = recordSize;\n        this.blockSize = blockSize;\n    }",
        "comment": "/**\n     * Constructor for TarInputStream.\n     * @param is the input stream to use\n     * @param blockSize the block size to use\n     * @param recordSize the record size to use\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
        "start_loc": 152,
        "end_loc": 162,
        "buggy_function": "    public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                  int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n        this.recordSize = recordSize;\n        this.recordsPerBlock = blockSize / recordSize;\n    }",
        "fixed_function": "    public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                  int recordSize, String encoding) {\n        out = new CountingOutputStream(os);\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n        this.recordSize = recordSize;\n        this.recordsPerBlock = blockSize / recordSize;\n    }",
        "comment": "/**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param blockSize the block size to use\n     * @param recordSize the record size to use\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
        "start_loc": 180,
        "end_loc": 191,
        "buggy_function": "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }",
        "fixed_function": "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }",
        "comment": "/**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStream": {
        "path": "org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java",
        "function_name": "testEncodingInputStream",
        "src": "@Test\n    public void testEncodingInputStreamAutodetect() throws Exception {\n        int failed = 0;\n        for(int i = 1; i <= TESTS.length; i++) {\n            TestData test = TESTS[i-1];\n            ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n            final String field = getField(ais,test.fieldName);\n            if (!eq(test.expectedEncoding,field)) {\n                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n                failed++;\n            }\n        }\n        if (failed > 0) {\n            fail(\"Tests failed: \" + failed);\n        }\n    }",
        "error_msg": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStream --> junit.framework.AssertionFailedError: Tests failed: 20",
        "clean_error_msg": "junit.framework.AssertionFailedError: Tests failed: 20"
      },
      "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStreamAutodetect": {
        "path": "org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java",
        "function_name": "testEncodingInputStreamAutodetect",
        "src": "@Test\n    public void testEncodingInputStreamAutodetect() throws Exception {\n        int failed = 0;\n        for(int i = 1; i <= TESTS.length; i++) {\n            TestData test = TESTS[i-1];\n            ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n            final String field = getField(ais,test.fieldName);\n            if (!eq(test.expectedEncoding,field)) {\n                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n                failed++;\n            }\n        }\n        if (failed > 0) {\n            fail(\"Tests failed: \" + failed);\n        }\n    }",
        "error_msg": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStreamAutodetect --> junit.framework.AssertionFailedError: Tests failed: 24",
        "clean_error_msg": "junit.framework.AssertionFailedError: Tests failed: 24"
      },
      "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingOutputStream": {
        "path": "org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java",
        "function_name": "testEncodingOutputStream",
        "src": "@Test\n    public void testEncodingOutputStream() throws Exception {\n        int failed = 0;\n        for(int i = 1; i <= TESTS.length; i++) {\n            TestData test = TESTS[i-1];\n            if (test.hasOutputStream) {\n                ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n                final String field = getField(ais, test.fieldName);\n                if (!eq(test.expectedEncoding, field)) {\n                    System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n                    failed++;\n                }\n            }\n        }\n        if (failed > 0) {\n            fail(\"Tests failed: \" + failed);\n        }\n    }",
        "error_msg": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingOutputStream --> junit.framework.AssertionFailedError: Tests failed: 14",
        "clean_error_msg": "junit.framework.AssertionFailedError: Tests failed: 14"
      }
    }
  },
  "Coveralls_maven_plugin-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/eluder/coveralls/maven/plugin/logging/DryRunLogger.java",
        "start_loc": 25,
        "end_loc": 31,
        "buggy_function": "    @Override\n    public void log(final Log log) {\n        if (dryRun) {\n            log.info(\"Dry run enabled, Coveralls report will not be submitted to API\");\n            log.info(coverallsFile.length() + \" bytes of data was recorded in \" + coverallsFile.getAbsolutePath());\n        }\n    }",
        "fixed_function": "    @Override\n    public void log(final Log log) {\n        if (dryRun) {\n            log.info(\"Dry run enabled, Coveralls report will NOT be submitted to API\");\n            log.info(coverallsFile.length() + \" bytes of data was recorded in \" + coverallsFile.getAbsolutePath());\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/eluder/coveralls/maven/plugin/logging/JobLogger.java",
        "start_loc": 48,
        "end_loc": 68,
        "buggy_function": "    @Override\n    public void log(final Log log) {\n        String starting = \"Starting Coveralls job\";\n        if (job.getServiceName() != null) {\n            starting += \" for \" + job.getServiceName();\n            if (job.getServiceJobId() != null) {\n                starting += \" (\" + job.getServiceJobId() + \")\";\n            }\n        }\n        log.info(starting);\n        \n        if (job.getRepoToken() != null) {\n            log.info(\"Using repository token <secret>\");\n        }\n        \n        if (job.getGit() != null) {\n            String commit = job.getGit().getHead().getId();\n            String branch = job.getGit().getBranch();\n            log.info(\"Git commit \" + commit.substring(0, 7) + \" in \" + branch);\n        }\n    }",
        "fixed_function": "    @Override\n    public void log(final Log log) {\n        String starting = \"Starting Coveralls job\";\n        if (job.getServiceName() != null) {\n            starting += \" for \" + job.getServiceName();\n            if (job.getServiceJobId() != null) {\n                starting += \" (\" + job.getServiceJobId() + \")\";\n            }\n        }\n        if (job.isDryRun()) {\n            starting += \" in dry run mode\";\n        }\n        log.info(starting);\n        \n        if (job.getRepoToken() != null) {\n            log.info(\"Using repository token <secret>\");\n        }\n        \n        if (job.getGit() != null) {\n            String commit = job.getGit().getHead().getId();\n            String branch = job.getGit().getBranch();\n            log.info(\"Git commit \" + commit.substring(0, 7) + \" in \" + branch);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.eluder.coveralls.maven.plugin.logging.DryRunLoggerTest::testLogDryRunEnabled": {
        "path": "org/eluder/coveralls/maven/plugin/logging/DryRunLoggerTest.java",
        "function_name": "testLogDryRunEnabled",
        "src": "@Test\n    public void testLogDryRunEnabled() {\n        when(coverallsFileMock.length()).thenReturn(1024l);\n        when(coverallsFileMock.getAbsolutePath()).thenReturn(\"/target/coveralls.json\");\n        \n        new DryRunLogger(true, coverallsFileMock).log(logMock);\n        \n        verify(logMock).info(\"Dry run enabled, Coveralls report will NOT be submitted to API\");\n        verify(logMock).info(\"1024 bytes of data was recorded in /target/coveralls.json\");\n    }",
        "error_msg": "org.eluder.coveralls.maven.plugin.logging.DryRunLoggerTest::testLogDryRunEnabled --> Argument(s) are different! Wanted:",
        "clean_error_msg": "Argument(s) are different! Wanted:"
      },
      "org.eluder.coveralls.maven.plugin.logging.JobLoggerTest::testLogDryRun": {
        "path": "org/eluder/coveralls/maven/plugin/logging/JobLoggerTest.java",
        "function_name": "testLogDryRun",
        "src": "@Test\n    public void testLogDryRun() {\n        when(jobMock.isDryRun()).thenReturn(true);\n        \n        new JobLogger(jobMock).log(logMock);\n        \n        verify(logMock).info(\"Starting Coveralls job in dry run mode\");\n        verifyNoMoreInteractions(logMock);        \n    }",
        "error_msg": "org.eluder.coveralls.maven.plugin.logging.JobLoggerTest::testLogDryRun --> Argument(s) are different! Wanted:",
        "clean_error_msg": "Argument(s) are different! Wanted:"
      },
      "org.eluder.coveralls.maven.plugin.logging.JobLoggerTest::testLogFullJob": {
        "path": "org/eluder/coveralls/maven/plugin/logging/JobLoggerTest.java",
        "function_name": "testLogFullJob",
        "src": "@Test\n    public void testLogFullJob() {\n        Git git = new Git(new Head(\"ab679cf2d81ac\", null, null, null, null, null), \"master\", null);\n        when(jobMock.getServiceName()).thenReturn(\"service\");\n        when(jobMock.getServiceJobId()).thenReturn(\"666\");\n        when(jobMock.getRepoToken()).thenReturn(\"123456789\");\n        when(jobMock.isDryRun()).thenReturn(true);\n        when(jobMock.getGit()).thenReturn(git);\n        \n        new JobLogger(jobMock).log(logMock);\n        \n        verify(logMock).info(\"Starting Coveralls job for service (666) in dry run mode\");\n        verify(logMock).info(\"Using repository token <secret>\");\n        verify(logMock).info(\"Git commit ab679cf in master\");\n        verifyNoMoreInteractions(logMock);\n    }",
        "error_msg": "org.eluder.coveralls.maven.plugin.logging.JobLoggerTest::testLogFullJob --> Argument(s) are different! Wanted:",
        "clean_error_msg": "Argument(s) are different! Wanted:"
      }
    }
  },
  "Coveralls_maven_plugin-7": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/eluder/coveralls/maven/plugin/AbstractCoverallsMojo.java",
        "start_loc": 167,
        "end_loc": 203,
        "buggy_function": "    @Override\n    public final void execute() throws MojoExecutionException, MojoFailureException {\n        if (skip) {\n            getLog().info(\"Skip property set, skipping plugin execution\");\n            return;\n        }\n        \n        try {\n            createEnvironment().setup();\n            SourceLoader sourceLoader = createSourceLoader();\n            CoverageParser parser = createCoverageParser(sourceLoader);\n            Job job = createJob();\n            job.validate().throwOrInform(getLog());\n            JsonWriter writer = createJsonWriter(job);\n            CoverallsClient client = createCoverallsClient();\n            List<Logger> reporters = new ArrayList<Logger>();\n            reporters.add(new JobLogger(job));\n            SourceCallback sourceCallback = createSourceCallbackChain(writer, reporters);\n            reporters.add(new DryRunLogger(job.isDryRun(), writer.getCoverallsFile()));\n            \n            report(reporters, Position.BEFORE);\n            writeCoveralls(writer, sourceLoader, sourceCallback, parser);\n            report(reporters, Position.AFTER);\n            \n            if (!job.isDryRun()) {\n                submitData(client, writer.getCoverallsFile());\n            }\n        } catch (MojoFailureException ex) {\n            throw ex;\n        } catch (ProcessingException ex) {\n            throw new MojoFailureException(\"Processing of input or output data failed\", ex);\n        } catch (IOException ex) {\n            throw new MojoFailureException(\"I/O operation failed\", ex);\n        } catch (Exception ex) {\n            throw new MojoExecutionException(\"Build error\", ex);\n        }\n    }",
        "fixed_function": "    @Override\n    public final void execute() throws MojoExecutionException, MojoFailureException {\n        if (skip) {\n            getLog().info(\"Skip property set, skipping plugin execution\");\n            return;\n        }\n        \n        try {\n            createEnvironment().setup();\n            SourceLoader sourceLoader = createSourceLoader();\n            CoverageParser parser = createCoverageParser(sourceLoader);\n            Job job = createJob();\n            job.validate().throwOrInform(getLog());\n            JsonWriter writer = createJsonWriter(job);\n            CoverallsClient client = createCoverallsClient();\n            List<Logger> reporters = new ArrayList<Logger>();\n            reporters.add(new JobLogger(job));\n            SourceCallback sourceCallback = createSourceCallbackChain(writer, reporters);\n            reporters.add(new DryRunLogger(job.isDryRun(), writer.getCoverallsFile()));\n            \n            report(reporters, Position.BEFORE);\n            writeCoveralls(writer, sourceLoader, sourceCallback, parser);\n            report(reporters, Position.AFTER);\n            \n            if (!job.isDryRun()) {\n                submitData(client, writer.getCoverallsFile());\n            }\n        } catch (ProcessingException ex) {\n            throw new MojoFailureException(\"Processing of input or output data failed\", ex);\n        } catch (IOException ex) {\n            throw new MojoFailureException(\"I/O operation failed\", ex);\n        } catch (Exception ex) {\n            throw new MojoExecutionException(\"Build error\", ex);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/eluder/coveralls/maven/plugin/AbstractCoverallsMojo.java",
        "start_loc": 305,
        "end_loc": 319,
        "buggy_function": "    private void submitData(final CoverallsClient client, final File coverallsFile) throws MojoFailureException, ProcessingException, IOException {\n        getLog().info(\"Submitting Coveralls data to API\");\n        long now = System.currentTimeMillis();\n            CoverallsResponse response = client.submit(coverallsFile);\n            long duration = System.currentTimeMillis() - now;\n        if (!response.isError()) {\n            getLog().info(\"Successfully submitted Coveralls data in \" + duration + \"ms for \" + response.getMessage());\n            getLog().info(response.getUrl());\n            getLog().info(\"*** It might take hours for Coveralls to update the actual coverage numbers for a job\");\n            getLog().info(\"    If you see question marks in the report, please be patient\");\n        } else {\n            getLog().error(\"Failed to submit Coveralls data in \" + duration + \"ms\");\n            throw new MojoFailureException(\"Failed to submit coveralls report: \" + response.getMessage());\n        }\n    }",
        "fixed_function": "    private void submitData(final CoverallsClient client, final File coverallsFile) throws ProcessingException, IOException {\n        getLog().info(\"Submitting Coveralls data to API\");\n        long now = System.currentTimeMillis();\n        try {\n            CoverallsResponse response = client.submit(coverallsFile);\n            long duration = System.currentTimeMillis() - now;\n            getLog().info(\"Successfully submitted Coveralls data in \" + duration + \"ms for \" + response.getMessage());\n            getLog().info(response.getUrl());\n            getLog().info(\"*** It might take hours for Coveralls to update the actual coverage numbers for a job\");\n            getLog().info(\"    If you see question marks in the report, please be patient\");\n        } catch (ProcessingException ex) {\n            long duration = System.currentTimeMillis() - now;\n            getLog().error(\"Submission failed in \" + duration + \"ms while processing data\");\n            throw ex;\n        } catch (IOException ex) {\n            long duration = System.currentTimeMillis() - now;\n            getLog().error(\"Submission failed in \" + duration + \"ms while handling I/O operations\");\n            throw ex;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/eluder/coveralls/maven/plugin/httpclient/CoverallsClient.java",
        "start_loc": 95,
        "end_loc": 106,
        "buggy_function": "    private CoverallsResponse parseResponse(final HttpResponse response) throws ProcessingException, IOException {\n        HttpEntity entity = response.getEntity();\n        ContentType contentType = ContentType.getOrDefault(entity);\n        InputStreamReader reader = new InputStreamReader(entity.getContent(), contentType.getCharset());\n        try {\n            return objectMapper.readValue(reader, CoverallsResponse.class);\n        } catch (JsonProcessingException ex) {\n            throw new ProcessingException(ex);\n        } finally {\n            IOUtil.close(reader);\n        }\n    }",
        "fixed_function": "    private CoverallsResponse parseResponse(final HttpResponse response) throws ProcessingException, IOException {\n        HttpEntity entity = response.getEntity();\n        ContentType contentType = ContentType.getOrDefault(entity);\n        InputStreamReader reader = null;\n        try {\n            reader = new InputStreamReader(entity.getContent(), contentType.getCharset());\n            CoverallsResponse cr = objectMapper.readValue(reader, CoverallsResponse.class);\n            if (cr.isError()) {\n                throw new ProcessingException(getResponseErrorMessage(response, cr.getMessage()));\n            }\n            return cr;\n        } catch (JsonProcessingException ex) {\n            throw new ProcessingException(getResponseErrorMessage(response, ex.getMessage()), ex);\n        } catch (IOException ex) {\n            throw new IOException(getResponseErrorMessage(response, ex.getMessage()), ex);\n        } finally {\n            IOUtil.close(reader);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.eluder.coveralls.maven.plugin.httpclient.CoverallsClientTest::testParseErrorousResponse": {
        "path": "org/eluder/coveralls/maven/plugin/httpclient/CoverallsClientTest.java",
        "function_name": "testParseErrorousResponse",
        "src": "@Test(expected = ProcessingException.class)\n    public void testParseErrorousResponse() throws Exception {\n        StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 400, \"Bad Request\");\n        when(httpClientMock.execute(any(HttpUriRequest.class))).thenReturn(httpResponseMock);\n        when(httpResponseMock.getStatusLine()).thenReturn(statusLine);\n        when(httpResponseMock.getEntity()).thenReturn(httpEntityMock);\n        when(httpEntityMock.getContent()).thenReturn(coverallsResponse(new CoverallsResponse(\"failure\", true, \"submission failed\")));\n        CoverallsClient client = new CoverallsClient(\"http://test.com/coveralls\", httpClientMock, new ObjectMapper());\n        client.submit(file);\n    }",
        "error_msg": "org.eluder.coveralls.maven.plugin.httpclient.CoverallsClientTest::testParseErrorousResponse --> junit.framework.AssertionFailedError: Expected exception: org.eluder.coveralls.maven.plugin.ProcessingException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: org.eluder.coveralls.maven.plugin.ProcessingException"
      }
    }
  },
  "Docker_java_api-3": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/amihaiemil/docker/PayloadOf.java",
        "start_loc": 63,
        "end_loc": 82,
        "buggy_function": "    PayloadOf(final HttpRequest request) {\n        this(() -> {\n            try {\n                final JsonObject body;\n                if (request instanceof HttpEntityEnclosingRequest) {\n                    body = Json.createReader(\n                        ((HttpEntityEnclosingRequest) request).getEntity()\n                            .getContent()\n                    ).readObject();\n                } else {\n                    body =  Json.createObjectBuilder().build();\n                }\n                return body;\n            } catch (final IOException ex) {\n                throw new IllegalStateException(\n                    \"Cannot read request payload\", ex\n                );\n            }\n        });\n    }",
        "fixed_function": "    PayloadOf(final HttpRequest request) {\n        super(() -> {\n            try {\n                final JsonObject body;\n                if (request instanceof HttpEntityEnclosingRequest) {\n                    body = Json.createReader(\n                        ((HttpEntityEnclosingRequest) request).getEntity()\n                            .getContent()\n                    ).readObject();\n                } else {\n                    body =  Json.createObjectBuilder().build();\n                }\n                return body;\n            } catch (final IOException ex) {\n                throw new IllegalStateException(\n                    \"Cannot read request payload\", ex\n                );\n            }\n        });\n    }",
        "comment": "/**\n     * Ctor.\n     * \n     * @param request The http request\n     * @throws IllegalStateException if the request's payload cannot be read\n     */"
      },
      {
        "path": "src/main/java/com/amihaiemil/docker/PayloadOf.java",
        "start_loc": 89,
        "end_loc": 101,
        "buggy_function": "    PayloadOf(final HttpResponse response) {\n        this(() -> {\n            try {\n                return Json.createReader(\n                    response.getEntity().getContent()\n                ).readObject();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(\n                    \"Cannot read response payload\", ex\n                );\n            }\n        });\n    }",
        "fixed_function": "    PayloadOf(final HttpResponse response) {\n        super(() -> {\n            try {\n                return Json.createReader(\n                    response.getEntity().getContent()\n                ).readObject();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(\n                    \"Cannot read response payload\", ex\n                );\n            }\n        });\n    }",
        "comment": "/**\n     * Ctor.\n     * @param response The http response.\n     * @throws IllegalStateException if the response's payload cannot be read\n     */"
      },
      {
        "path": "src/main/java/com/amihaiemil/docker/UnexpectedResponseException.java",
        "start_loc": 68,
        "end_loc": 78,
        "buggy_function": "    public UnexpectedResponseException(\n        final String endpoint, final int actualStatus,\n        final int expectedStatus, final JsonObject body\n    ) {\n        // @checkstyle LineLength (1 line)\n        super(\"Expected status \" + expectedStatus + \" but got \" + actualStatus + \" when calling \" + endpoint);\n        this.endpoint = endpoint;\n        this.actualStatus = actualStatus;\n        this.expectedStatus = expectedStatus;\n        this.payload = body;\n    }",
        "fixed_function": "    public UnexpectedResponseException(\n        final String endpoint, final int actualStatus,\n        final int expectedStatus, final JsonObject body\n    ) {\n        super(String.format(\n            // @checkstyle LineLength (1 line)\n            \"Expected status %s but got %s when calling %s. Response body was %s\",\n            expectedStatus, actualStatus, endpoint, body.toString()\n        ));\n        this.endpoint = endpoint;\n        this.actualStatus = actualStatus;\n        this.expectedStatus = expectedStatus;\n        this.payload = body;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.amihaiemil.docker.UnexpectedResponseExceptionTestCase::returnsMessageWithPayload": {
        "path": "com/amihaiemil/docker/UnexpectedResponseExceptionTestCase.java",
        "function_name": "returnsMessageWithPayload",
        "src": "@Test\n    public void returnsMessageWithPayload() {\n        final JsonObject payload = Json.createObjectBuilder()\n            .add(\"message\", \"Some error\")\n            .build();\n        MatcherAssert.assertThat(\n            new UnexpectedResponseException(\n                \"/uri\", HttpStatus.SC_OK, HttpStatus.SC_OK, payload\n            ).getMessage(),\n            Matchers.endsWith(payload.toString())\n        );\n    }",
        "error_msg": "com.amihaiemil.docker.UnexpectedResponseExceptionTestCase::returnsMessageWithPayload --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.amihaiemil.docker.UnexpectedResponseExceptionTestCase::returnsMessage": {
        "path": "com/amihaiemil/docker/UnexpectedResponseExceptionTestCase.java",
        "function_name": "returnsMessage",
        "src": "@Test\n    public void returnsMessage() {\n        MatcherAssert.assertThat(\n            new UnexpectedResponseException(\n                \"/uri\", HttpStatus.SC_NOT_FOUND,\n                HttpStatus.SC_OK, Json.createObjectBuilder().build()\n            ).getMessage(),\n            Matchers.startsWith(\n                // @checkstyle LineLength (1 line)\n                \"Expected status 200 but got 404 when calling /uri. Response body was\"\n            )\n        );\n    }",
        "error_msg": "com.amihaiemil.docker.UnexpectedResponseExceptionTestCase::returnsMessage --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Docker_java_api-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/amihaiemil/docker/ListedImages.java",
        "start_loc": 79,
        "end_loc": 107,
        "buggy_function": "    @Override\n    public Iterator<Image> iterator() {\n        final UncheckedUriBuilder uri = new UncheckedUriBuilder(\n            super.baseUri().toString().concat(\"/json\")\n        );\n        if (!this.filters.isEmpty()) {\n            final JsonObjectBuilder json = Json.createObjectBuilder();\n            this.filters.forEach(\n                (name, values) -> {\n                    final JsonArrayBuilder array = Json.createArrayBuilder();\n                    values.forEach(array::add);\n                    json.add(name, array);\n                }\n            );\n            uri.addParameter(\"filters\", json.build().toString());\n        }\n        return new ResourcesIterator<>(\n            super.client(),\n            new HttpGet(uri.build()),\n            img -> new RtImage(\n                img,\n                super.client(),\n                URI.create(\n                    super.baseUri().toString() + \"/\" + img.getString(\"Id\")\n                ),\n                super.docker()\n            )\n        );\n    }",
        "fixed_function": "    @Override\n    public Iterator<Image> iterator() {\n        final UncheckedUriBuilder uri = new UncheckedUriBuilder(\n            super.baseUri().toString().concat(\"/json\")\n        ).addFilters(this.filters);\n        \n        return new ResourcesIterator<>(\n            super.client(),\n            new HttpGet(uri.build()),\n            img -> new RtImage(\n                img,\n                super.client(),\n                URI.create(\n                    super.baseUri().toString() + \"/\" + img.getString(\"Id\")\n                ),\n                super.docker()\n            )\n        );\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/amihaiemil/docker/ListedVolumes.java",
        "start_loc": 75,
        "end_loc": 96,
        "buggy_function": "    @Override\n    public Iterator<Volume> iterator() {\n        return new ResourcesIterator<>(\n            super.client(),\n            new HttpGet(\n                String.format(\"%s/%s\",\n                    super.baseUri().toString(),\n                    \"volumes\")\n            ),\n            volume -> new RtVolume(\n                volume,\n                super.client(),\n                URI.create(\n                    String.format(\"%s/%s\",\n                        super.baseUri().toString(),\n                        volume.getString(\"Name\")\n                    )\n                ),\n                super.docker()\n            )\n        );\n    }",
        "fixed_function": "    @Override\n    public Iterator<Volume> iterator() {\n        final UncheckedUriBuilder uri = new UncheckedUriBuilder(\n                super.baseUri().toString()\n        ).addFilters(this.filters);\n        \n        return new ResourcesIterator<>(\n            super.client(),\n            new HttpGet(\n                uri.build()\n            ),\n            volume -> new RtVolume(\n                volume,\n                super.client(),\n                URI.create(\n                    String.format(\"%s/%s\",\n                        super.baseUri().toString(),\n                        volume.getString(\"Name\")\n                    )\n                ),\n                super.docker()\n            )\n        );\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.amihaiemil.docker.ListedVolumesTestCase::iterateWithFilters": {
        "path": "com/amihaiemil/docker/ListedVolumesTestCase.java",
        "function_name": "iterateWithFilters",
        "src": "@Test\n    public void iterateWithFilters() throws IOException {\n        new ListedVolumes(\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_OK,\n                    //@checkstyle LineLength (1 line)\n                    \"[{\\\"Name\\\": \\\"abc1\\\"}, {\\\"Name\\\": \\\"def2\\\"}, {\\\"Name\\\": \\\"ghi3\\\"}, {\\\"Name\\\":\\\"jkl4\\\"}]\"\n                ),\n                new Condition(\n                    \"iterate() must send a GET request\",\n                    req -> \"GET\".equals(req.getRequestLine().getMethod())\n                ),\n                new Condition(\n                    //@checkstyle LineLength (1 line)\n                    \"iterate() query parameters must include the filters provided\",\n                    req -> {\n                        // @checkstyle LineLength (1 line)\n                        final List<NameValuePair> params = new UncheckedUriBuilder(\n                            req.getRequestLine().getUri()\n                        ).getQueryParams();\n                        // @checkstyle BooleanExpressionComplexity (5 lines)\n                        return params.size() == 1\n                            && \"filters\".equals(params.get(0).getName())\n                            && params.get(0).getValue().contains(\"Name\")\n                            && params.get(0).getValue().contains(\"\\\"def2\\\"\")\n                            && params.get(0).getValue().contains(\"\\\"jkl4\\\"\");\n                    }\n                )\n            ),\n            URI.create(\"http://localhost/volumes\"),\n            Mockito.mock(Docker.class),\n            Collections.singletonMap(\"Name\", Arrays.asList(\"def2\", \"jkl4\"))\n        ).iterator();\n    }",
        "error_msg": "com.amihaiemil.docker.ListedVolumesTestCase::iterateWithFilters --> junit.framework.AssertionFailedError: iterate() query parameters must include the filters provided",
        "clean_error_msg": "junit.framework.AssertionFailedError: iterate() query parameters must include the filters provided"
      }
    }
  },
  "Docker_java_api-8": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/amihaiemil/docker/RtPlugin.java",
        "start_loc": 122,
        "end_loc": 132,
        "buggy_function": "    @Override\n    public void upgrade(final String remote, final JsonArray properties)\n        throws IOException, UnexpectedResponseException {\n        throw new UnsupportedOperationException(\n            String.join(\" \",\n                \"RtPlugin.upgrade() is not yet implemented.\",\n                \"If you can contribute please\",\n                \"do it here: https://www.github.com/amihaiemil/docker-java-api\"\n            )\n        );\n    }",
        "fixed_function": "    @Override\n    public void upgrade(final String remote, final JsonArray properties)\n        throws IOException, UnexpectedResponseException {\n        final HttpPost upgrade =\n            new HttpPost(\n                new UncheckedUriBuilder(this.uri.toString().concat(\"/upgrade\"))\n                    .addParameter(\"remote\", remote)\n                    .build()\n            );\n        try {\n            upgrade.setEntity(\n                new StringEntity(\n                    properties.toString(), ContentType.APPLICATION_JSON\n                )\n            );\n            this.client.execute(\n                upgrade,\n                new MatchStatus(\n                    upgrade.getURI(),\n                    HttpStatus.SC_NO_CONTENT\n                )\n            );\n        } finally {\n            upgrade.releaseConnection();\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/amihaiemil/docker/RtPlugin.java",
        "start_loc": 134,
        "end_loc": 143,
        "buggy_function": "    @Override\n    public void push() throws IOException, UnexpectedResponseException {\n        throw new UnsupportedOperationException(\n            String.join(\" \",\n                \"RtPlugin.push() is not yet implemented.\",\n                \"If you can contribute please\",\n                \"do it here: https://www.github.com/amihaiemil/docker-java-api\"\n            )\n        );\n    }",
        "fixed_function": "    @Override\n    public void push() throws IOException, UnexpectedResponseException {\n        final HttpPost push =\n            new HttpPost(\n                String.format(\"%s/%s\", this.uri.toString(), \"push\")\n            );\n        try {\n            this.client.execute(\n                push,\n                new MatchStatus(\n                    push.getURI(),\n                    HttpStatus.SC_OK\n                )\n            );\n        } finally {\n            push.releaseConnection();\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.amihaiemil.docker.RtPluginTestCase::pushOk": {
        "path": "com/amihaiemil/docker/RtPluginTestCase.java",
        "function_name": "pushOk",
        "src": "@Test\n    public void pushOk() throws Exception {\n        new ListedPlugins(\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_NO_CONTENT\n                )\n            ),\n            URI.create(\"http://localhost/plugins\"),\n            DOCKER\n        ).pullAndInstall(\n            \"vieus/sshfs\",\n            \"sshfs\",\n            Json.createArrayBuilder().add(\n                Json.createObjectBuilder()\n                    .add(\"Name\", \"network\")\n                    .add(\"Description\", \"\")\n                    .add(\"Value\", \"host\")\n            ).build()\n        );\n        final Plugin plugin = new RtPlugin(\n            Json.createObjectBuilder().build(),\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_OK\n                ),\n                new Condition(\n                    \"Method should be a POST\",\n                    req -> \"POST\".equals(req.getRequestLine().getMethod())\n                ),\n                new Condition(\n                    \"Resource path must be /{name}/push\",\n                    req -> req.getRequestLine().getUri()\n                        .endsWith(\"/sshfs/push\")\n                )\n            ),\n            URI.create(\"http://localhost/plugins/sshfs\"),\n            DOCKER\n        );\n        plugin.push();\n    }",
        "error_msg": "com.amihaiemil.docker.RtPluginTestCase::pushOk --> java.lang.UnsupportedOperationException: RtPlugin.push() is not yet implemented. If you can contribute please do it here: https://www.github.com/amihaiemil/docker-java-api",
        "clean_error_msg": "java.lang.UnsupportedOperationException: RtPlugin.push() is not yet implemented. If you can contribute please do it here: https://www.github.com/amihaiemil/docker-java-api"
      },
      "com.amihaiemil.docker.RtPluginTestCase::upgradeFailsPluginNotInstalled": {
        "path": "com/amihaiemil/docker/RtPluginTestCase.java",
        "function_name": "upgradeFailsPluginNotInstalled",
        "src": "@Test(expected = UnexpectedResponseException.class)\n    public void upgradeFailsPluginNotInstalled() throws Exception {\n        final Plugin plugin = new RtPlugin(\n            Json.createObjectBuilder().build(),\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_NOT_FOUND\n                ),\n                new Condition(\n                    \"Method should be a POST\",\n                    req -> \"POST\".equals(req.getRequestLine().getMethod())\n                ),\n                new Condition(\n                    \"Resource path must be /{name}/upgrade?remote=test\",\n                    req -> req.getRequestLine().getUri()\n                        .endsWith(\"/sshfs/upgrade?remote=test\")\n                )\n            ),\n            URI.create(\"http://localhost/plugins/sshfs\"),\n            DOCKER\n        );\n        final JsonArray properties = Json.createArrayBuilder().add(\n            Json.createObjectBuilder()\n                .add(\"Name\", \"mount\")\n                .add(\"Description\", \"\")\n                .add(\"Value\", \"/data\")\n        ).build();\n        plugin.upgrade(\"test\", properties);\n    }",
        "error_msg": "com.amihaiemil.docker.RtPluginTestCase::upgradeFailsPluginNotInstalled --> java.lang.Exception: Unexpected exception, expected<com.amihaiemil.docker.UnexpectedResponseException> but was<java.lang.UnsupportedOperationException>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<com.amihaiemil.docker.UnexpectedResponseException> but was<java.lang.UnsupportedOperationException>"
      },
      "com.amihaiemil.docker.RtPluginTestCase::pushFailsPluginNotInstalled": {
        "path": "com/amihaiemil/docker/RtPluginTestCase.java",
        "function_name": "pushFailsPluginNotInstalled",
        "src": "@Test(expected = UnexpectedResponseException.class)\n    public void pushFailsPluginNotInstalled() throws Exception {\n        final Plugin plugin = new RtPlugin(\n            Json.createObjectBuilder().build(),\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_NOT_FOUND\n                ),\n                new Condition(\n                    \"Method should be a POST\",\n                    req -> \"POST\".equals(req.getRequestLine().getMethod())\n                ),\n                new Condition(\n                    \"Resource path must be /{name}/push\",\n                    req -> req.getRequestLine().getUri()\n                        .endsWith(\"/sshfs/push\")\n                )\n            ),\n            URI.create(\"http://localhost/plugins/sshfs\"),\n            DOCKER\n        );\n        plugin.push();\n    }",
        "error_msg": "com.amihaiemil.docker.RtPluginTestCase::pushFailsPluginNotInstalled --> java.lang.Exception: Unexpected exception, expected<com.amihaiemil.docker.UnexpectedResponseException> but was<java.lang.UnsupportedOperationException>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<com.amihaiemil.docker.UnexpectedResponseException> but was<java.lang.UnsupportedOperationException>"
      },
      "com.amihaiemil.docker.RtPluginTestCase::upgradeOk": {
        "path": "com/amihaiemil/docker/RtPluginTestCase.java",
        "function_name": "upgradeOk",
        "src": "@Test\n    public void upgradeOk() throws Exception {\n        new ListedPlugins(\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_NO_CONTENT\n                )\n            ),\n            URI.create(\"http://localhost/plugins\"),\n            DOCKER\n        ).pullAndInstall(\n            \"vieus/sshfs\",\n            \"sshfs\",\n            Json.createArrayBuilder().add(\n                Json.createObjectBuilder()\n                    .add(\"Name\", \"network\")\n                    .add(\"Description\", \"\")\n                    .add(\"Value\", \"host\")\n            ).build()\n        );\n        final JsonArray properties = Json.createArrayBuilder().add(\n            Json.createObjectBuilder()\n                .add(\"Name\", \"mount\")\n                .add(\"Description\", \"\")\n                .add(\"Value\", \"/data\")\n        ).build();\n        final Plugin plugin = new RtPlugin(\n            Json.createObjectBuilder().build(),\n            new AssertRequest(\n                new Response(\n                    HttpStatus.SC_NO_CONTENT\n                ),\n                new Condition(\n                    \"Method should be a POST\",\n                    req -> \"POST\".equals(req.getRequestLine().getMethod())\n                ),\n                new Condition(\n                    \"Resource path must be /{name}/upgrade?remote=test\",\n                    req -> req.getRequestLine().getUri()\n                        .endsWith(\"/sshfs/upgrade?remote=test\")\n                ),\n                new Condition(\n                    \"upgrade() must send JsonArray request body\",\n                    req -> {\n                        JsonObject payload =\n                            new ArrayPayloadOf(req).next();\n                        return \"mount\".equals(payload.getString(\"Name\"))\n                            && \"/data\".equals(payload.getString(\"Value\"));\n                    }\n                )\n            ),\n            URI.create(\"http://localhost/plugins/sshfs\"),\n            DOCKER\n        );\n        plugin.upgrade(\"test\", properties);\n    }",
        "error_msg": "com.amihaiemil.docker.RtPluginTestCase::upgradeOk --> java.lang.UnsupportedOperationException: RtPlugin.upgrade() is not yet implemented. If you can contribute please do it here: https://www.github.com/amihaiemil/docker-java-api",
        "clean_error_msg": "java.lang.UnsupportedOperationException: RtPlugin.upgrade() is not yet implemented. If you can contribute please do it here: https://www.github.com/amihaiemil/docker-java-api"
      }
    }
  },
  "Graph-3": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/graph/model/BaseMutableGraph.java",
        "start_loc": 104,
        "end_loc": 115,
        "buggy_function": "    protected void internalAddEdge( V head, E e, V tail )\n    {\n        getAdjacencyList().get( head ).add( tail );\n\n        VertexPair<V> vertexPair = new VertexPair<V>( head, tail );\n        getIndexedEdges().put( vertexPair, e );\n\n        if ( !getIndexedVertices().containsKey( e ) )\n        {\n            getIndexedVertices().put( e, vertexPair );\n        }\n    }",
        "fixed_function": "    protected void internalAddEdge( V head, E e, V tail )\n    {\n        getAdjacencyList().get( head ).add( tail );\n\n        final VertexPair<V> vertexPair = new VertexPair<V>( head, tail );\n        getIndexedEdges().put( vertexPair, e );\n\n        if ( !getIndexedVertices().containsKey( e ) )\n        {\n            getIndexedVertices().put( e, vertexPair );\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/commons/graph/model/BaseMutableGraph.java",
        "start_loc": 126,
        "end_loc": 133,
        "buggy_function": "    public final void removeEdge( E e )\n    {\n        checkGraphCondition( e != null, \"Impossible to remove a null Edge from the Graph\" );\n        \n\n        decorateRemoveEdge( e );\n\n    }",
        "fixed_function": "    protected void internalRemoveEdge( V head, E e, V tail )\n    {\n        final VertexPair<V> vertexPair = new VertexPair<V>( head, tail );\n        getIndexedVertices().remove( e );\n        getIndexedEdges().remove( vertexPair );\n        getAdjacencyList().get( vertexPair.getHead() ).remove( vertexPair.getTail() );\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/commons/graph/model/DirectedMutableGraph.java",
        "start_loc": 121,
        "end_loc": 124,
        "buggy_function": "    @Override\n    protected void decorateRemoveEdge( E e )\n    {\n    }",
        "fixed_function": "    @Override\n    protected void decorateRemoveEdge( E e )\n    {\n        final VertexPair<V> vertices = getVertices( e );\n        inbound.get( vertices.getTail() ).remove( vertices.getHead() );\n        outbound.get( vertices.getHead() ).remove( vertices.getTail() );\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/graph/model/UndirectedMutableGraph.java",
        "start_loc": 77,
        "end_loc": 80,
        "buggy_function": "    @Override\n    protected void decorateRemoveEdge( E e )\n    {\n    }",
        "fixed_function": "    @Override\n    protected void decorateRemoveEdge( E e )\n    {\n        internalRemoveEdge( getVertices( e ).getTail(), e, getVertices( e ).getHead() );\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.graph.model.BaseMutableGraphTestCase::testUndirectedGraphRemoveEdge": {
        "path": "org/apache/commons/graph/model/BaseMutableGraphTestCase.java",
        "function_name": "testUndirectedGraphRemoveEdge",
        "src": "@Test\n    public final void testUndirectedGraphRemoveEdge()\n    {\n        // Test a complete undirect graph.\n        final UndirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge> g =\n            new UndirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge>();\n\n        final BaseLabeledVertex source = new BaseLabeledVertex( valueOf( 1 ) );\n        final BaseLabeledVertex target = new BaseLabeledVertex( valueOf( 2 ) );\n\n        buildCompleteGraph( 10, g );\n\n        BaseLabeledEdge e = g.getEdge( source, target );\n        g.removeEdge( e );\n\n        BaseLabeledEdge edge = g.getEdge( source, target );\n\n        assertNull( edge );\n    }",
        "error_msg": "org.apache.commons.graph.model.BaseMutableGraphTestCase::testUndirectedGraphRemoveEdge --> junit.framework.AssertionFailedError: expected null, but was:<{ 1 } -> { 2 }()>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected null, but was:<{ 1 } -> { 2 }()>"
      },
      "org.apache.commons.graph.model.BaseMutableGraphTestCase::testUndirectedGraphRemoveEdgeNotExists": {
        "path": "org/apache/commons/graph/model/BaseMutableGraphTestCase.java",
        "function_name": "testUndirectedGraphRemoveEdgeNotExists",
        "src": "@Test( expected = GraphException.class )\n    public final void testUndirectedGraphRemoveEdgeNotExists()\n    {\n        // Test a complete undirect graph.\n        UndirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge> g = null;\n        BaseLabeledEdge e = null;\n        try\n        {\n            g = new UndirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge>();\n            buildCompleteGraph( 10, g );\n\n            e = new BaseLabeledEdge( \"NOT EXIST\" );\n        }\n        catch ( GraphException ex )\n        {\n            fail( ex.getMessage() );\n        }\n\n        g.removeEdge( e );\n\n    }",
        "error_msg": "org.apache.commons.graph.model.BaseMutableGraphTestCase::testUndirectedGraphRemoveEdgeNotExists --> junit.framework.AssertionFailedError: Expected exception: org.apache.commons.graph.GraphException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.graph.GraphException"
      },
      "org.apache.commons.graph.model.BaseMutableGraphTestCase::testDirectedGraphRemoveEdge": {
        "path": "org/apache/commons/graph/model/BaseMutableGraphTestCase.java",
        "function_name": "testDirectedGraphRemoveEdge",
        "src": "@Test\n    public final void testDirectedGraphRemoveEdge()\n    {\n        // Test a complete undirect graph.\n        final DirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge> g = new DirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge>();\n\n        final BaseLabeledVertex source = new BaseLabeledVertex( valueOf( 1 ) );\n        final BaseLabeledVertex target = new BaseLabeledVertex( valueOf( 2 ) );\n\n        buildCompleteGraph( 10, g );\n\n        BaseLabeledEdge e = g.getEdge( source, target );\n        g.removeEdge( e );\n        \n        BaseLabeledEdge edge = g.getEdge( source, target );\n        assertNull( edge  );\n    }",
        "error_msg": "org.apache.commons.graph.model.BaseMutableGraphTestCase::testDirectedGraphRemoveEdge --> junit.framework.AssertionFailedError: expected null, but was:<{ 1 } -> { 2 }()>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected null, but was:<{ 1 } -> { 2 }()>"
      },
      "org.apache.commons.graph.model.BaseMutableGraphTestCase::testDirectedGraphRemoveEdgeNotExists": {
        "path": "org/apache/commons/graph/model/BaseMutableGraphTestCase.java",
        "function_name": "testDirectedGraphRemoveEdgeNotExists",
        "src": "@Test( expected = GraphException.class )\n    public final void testDirectedGraphRemoveEdgeNotExists()\n    {\n        // Test a complete undirect graph.\n        DirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge> g = null;\n        BaseLabeledEdge e = null;\n        try\n        {\n            g = new DirectedMutableGraph<BaseLabeledVertex, BaseLabeledEdge>();\n            buildCompleteGraph( 10, g );\n\n            e = new BaseLabeledEdge( \"NOT EXIST\" );\n        }\n        catch ( GraphException ex )\n        {\n            fail( ex.getMessage() );\n        }\n\n        g.removeEdge( e );\n\n    }",
        "error_msg": "org.apache.commons.graph.model.BaseMutableGraphTestCase::testDirectedGraphRemoveEdgeNotExists --> junit.framework.AssertionFailedError: Expected exception: org.apache.commons.graph.GraphException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.graph.GraphException"
      }
    }
  },
  "Gson-16": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "start_loc": 63,
        "end_loc": 68,
        "buggy_function": "  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  }",
        "fixed_function": "  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }",
        "comment": ""
      },
      {
        "path": "/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "start_loc": 98,
        "end_loc": 112,
        "buggy_function": "  private Date deserializeToDate(JsonElement json) {\n    synchronized (localFormat) {\n      try {\n      \treturn localFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return iso8601Format.parse(json.getAsString());\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(json.getAsString(), e);\n      }\n    }\n  }",
        "fixed_function": "  private Date deserializeToDate(JsonElement json) {\n    synchronized (localFormat) {\n      try {\n      \treturn localFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(json.getAsString(), e);\n      }\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601": {
        "path": "com/google/gson/DefaultDateTypeAdapterTest.java",
        "function_name": "testDateDeserializationISO8601",
        "src": "public void testDateDeserializationISO8601() throws Exception {\n  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n    assertParsed(\"1970-01-01T00:00Z\", adapter);\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n  }",
        "error_msg": "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601 --> com.google.gson.JsonSyntaxException: 1970-01-01T00:00:00.000Z",
        "clean_error_msg": "com.google.gson.JsonSyntaxException: 1970-01-01T00:00:00.000Z"
      }
    }
  },
  "Gson-22": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/com/google/gson/Gson.java",
        "start_loc": 180,
        "end_loc": 254,
        "buggy_function": "  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\n      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n      LongSerializationPolicy longSerializationPolicy,\n      List<TypeAdapterFactory> typeAdapterFactories) {\n    this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n    this.excluder = excluder;\n    this.fieldNamingStrategy = fieldNamingStrategy;\n    this.serializeNulls = serializeNulls;\n    this.generateNonExecutableJson = generateNonExecutableGson;\n    this.htmlSafe = htmlSafe;\n    this.prettyPrinting = prettyPrinting;\n    this.lenient = lenient;\n\n    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n    // built-in type adapters that cannot be overridden\n    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n    factories.add(ObjectTypeAdapter.FACTORY);\n\n    // the excluder must precede all adapters that handle user-defined types\n    factories.add(excluder);\n\n    // user's type adapters\n    factories.addAll(typeAdapterFactories);\n\n    // type adapters for basic platform types\n    factories.add(TypeAdapters.STRING_FACTORY);\n    factories.add(TypeAdapters.INTEGER_FACTORY);\n    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.BYTE_FACTORY);\n    factories.add(TypeAdapters.SHORT_FACTORY);\n    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\n    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n    factories.add(TypeAdapters.newFactory(double.class, Double.class,\n            doubleAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.newFactory(float.class, Float.class,\n            floatAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.NUMBER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\n    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n    factories.add(TypeAdapters.CHARACTER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n    factories.add(TypeAdapters.URL_FACTORY);\n    factories.add(TypeAdapters.URI_FACTORY);\n    factories.add(TypeAdapters.UUID_FACTORY);\n    factories.add(TypeAdapters.CURRENCY_FACTORY);\n    factories.add(TypeAdapters.LOCALE_FACTORY);\n    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n    factories.add(TypeAdapters.BIT_SET_FACTORY);\n    factories.add(DateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CALENDAR_FACTORY);\n    factories.add(TimeTypeAdapter.FACTORY);\n    factories.add(SqlDateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n    factories.add(ArrayTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CLASS_FACTORY);\n\n    // type adapters for composite and user-defined types\n    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n    factories.add(TypeAdapters.ENUM_FACTORY);\n    factories.add(new ReflectiveTypeAdapterFactory(\n        constructorConstructor, fieldNamingStrategy, excluder));\n\n    this.factories = Collections.unmodifiableList(factories);\n  }",
        "fixed_function": "  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\n      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n      LongSerializationPolicy longSerializationPolicy,\n      List<TypeAdapterFactory> typeAdapterFactories) {\n    this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n    this.excluder = excluder;\n    this.fieldNamingStrategy = fieldNamingStrategy;\n    this.serializeNulls = serializeNulls;\n    this.generateNonExecutableJson = generateNonExecutableGson;\n    this.htmlSafe = htmlSafe;\n    this.prettyPrinting = prettyPrinting;\n    this.lenient = lenient;\n\n    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n    // built-in type adapters that cannot be overridden\n    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n    factories.add(ObjectTypeAdapter.FACTORY);\n\n    // the excluder must precede all adapters that handle user-defined types\n    factories.add(excluder);\n\n    // user's type adapters\n    factories.addAll(typeAdapterFactories);\n\n    // type adapters for basic platform types\n    factories.add(TypeAdapters.STRING_FACTORY);\n    factories.add(TypeAdapters.INTEGER_FACTORY);\n    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.BYTE_FACTORY);\n    factories.add(TypeAdapters.SHORT_FACTORY);\n    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\n    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n    factories.add(TypeAdapters.newFactory(double.class, Double.class,\n            doubleAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.newFactory(float.class, Float.class,\n            floatAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.NUMBER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\n    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n    factories.add(TypeAdapters.CHARACTER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n    factories.add(TypeAdapters.URL_FACTORY);\n    factories.add(TypeAdapters.URI_FACTORY);\n    factories.add(TypeAdapters.UUID_FACTORY);\n    factories.add(TypeAdapters.CURRENCY_FACTORY);\n    factories.add(TypeAdapters.LOCALE_FACTORY);\n    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n    factories.add(TypeAdapters.BIT_SET_FACTORY);\n    factories.add(DateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CALENDAR_FACTORY);\n    factories.add(TimeTypeAdapter.FACTORY);\n    factories.add(SqlDateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n    factories.add(ArrayTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CLASS_FACTORY);\n\n    // type adapters for composite and user-defined types\n    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\n    factories.add(jsonAdapterFactory);\n    factories.add(TypeAdapters.ENUM_FACTORY);\n    factories.add(new ReflectiveTypeAdapterFactory(\n        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\n    this.factories = Collections.unmodifiableList(factories);\n  }",
        "comment": ""
      },
      {
        "path": "/src/main/java/com/google/gson/Gson.java",
        "start_loc": 488,
        "end_loc": 508,
        "buggy_function": "  public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via\n    // our @JsonAdapter annotation.\n\n    boolean skipPastFound = false;\n    if (!factories.contains(skipPast)) skipPastFound = true;\n    for (TypeAdapterFactory factory : factories) {\n      if (!skipPastFound) {\n        if (factory == skipPast) {\n          skipPastFound = true;\n        }\n        continue;\n      }\n\n      TypeAdapter<T> candidate = factory.create(this, type);\n      if (candidate != null) {\n        return candidate;\n      }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n  }",
        "fixed_function": "  public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via\n    // our @JsonAdapter annotation.\n    if (!factories.contains(skipPast)) {\n      skipPast = jsonAdapterFactory;\n    }\n\n    boolean skipPastFound = false;\n    for (TypeAdapterFactory factory : factories) {\n      if (!skipPastFound) {\n        if (factory == skipPast) {\n          skipPastFound = true;\n        }\n        continue;\n      }\n\n      TypeAdapter<T> candidate = factory.create(this, type);\n      if (candidate != null) {\n        return candidate;\n      }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n  }",
        "comment": "/**\n   * This method is used to get an alternate type adapter for the specified type. This is used\n   * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\n   * may have registered. This features is typically used when you want to register a type\n   * adapter that does a little bit of work but then delegates further processing to the Gson\n   * default type adapter. Here is an example:\n   * <p>Let's say we want to write a type adapter that counts the number of objects being read\n   *  from or written to JSON. We can achieve this by writing a type adapter factory that uses\n   *  the <code>getDelegateAdapter</code> method:\n   *  <pre> {@code\n   *  class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   *    public int numReads = 0;\n   *    public int numWrites = 0;\n   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n   *      return new TypeAdapter<T>() {\n   *        public void write(JsonWriter out, T value) throws IOException {\n   *          ++numWrites;\n   *          delegate.write(out, value);\n   *        }\n   *        public T read(JsonReader in) throws IOException {\n   *          ++numReads;\n   *          return delegate.read(in);\n   *        }\n   *      };\n   *    }\n   *  }\n   *  } </pre>\n   *  This factory can now be used like this:\n   *  <pre> {@code\n   *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();\n   *  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();\n   *  // Call gson.toJson() and fromJson methods on objects\n   *  System.out.println(\"Num JSON reads\" + stats.numReads);\n   *  System.out.println(\"Num JSON writes\" + stats.numWrites);\n   *  }</pre>\n   *  Note that this call will skip all factories registered before {@code skipPast}. In case of\n   *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n   *  that the order of registration does not prevent this method from reaching a factory they\n   *  would expect to reply from this call.\n   *  Note that since you can not override type adapter factories for String and Java primitive\n   *  types, our stats factory will not count the number of String or primitives that will be\n   *  read or written.\n   * @param skipPast The type adapter factory that needs to be skipped while searching for\n   *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter\n   *   factory from where {@link #getDelegateAdapter} method is being invoked).\n   * @param type Type for which the delegate adapter is being searched for.\n   *\n   * @since 2.2\n   */"
      }
    ],
    "trigger_test": {
      "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testJsonSerializerDeserializerBasedJsonAdapterOnClass": {
        "path": "com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java",
        "function_name": "testJsonSerializerDeserializerBasedJsonAdapterOnClass",
        "src": "public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {\n    Gson gson = new Gson();\n    String json = gson.toJson(new Computer2(new User2(\"Inderjeet Singh\")));\n    assertEquals(\"{\\\"user\\\":\\\"UserSerializerDeserializer2\\\"}\", json);\n    Computer2 computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer2.class);\n    assertEquals(\"UserSerializerDeserializer2\", computer.user.name);\n  }",
        "error_msg": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testJsonSerializerDeserializerBasedJsonAdapterOnClass --> java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.",
        "clean_error_msg": "java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."
      },
      "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testDifferentJsonAdaptersForGenericFieldsOfSameRawType": {
        "path": "com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java",
        "function_name": "testDifferentJsonAdaptersForGenericFieldsOfSameRawType",
        "src": "public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {\n    Container c = new Container(\"Foo\", 10);\n    Gson gson = new Gson();\n    String json = gson.toJson(c);\n    assertTrue(json.contains(\"\\\"a\\\":\\\"BaseStringAdapter\\\"\"));\n    assertTrue(json.contains(\"\\\"b\\\":\\\"BaseIntegerAdapter\\\"\"));\n  }",
        "error_msg": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testDifferentJsonAdaptersForGenericFieldsOfSameRawType --> java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.",
        "clean_error_msg": "java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."
      },
      "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testJsonSerializerDeserializerBasedJsonAdapterOnFields": {
        "path": "com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java",
        "function_name": "testJsonSerializerDeserializerBasedJsonAdapterOnFields",
        "src": "public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {\n    Gson gson = new Gson();\n    String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\"), null, new User(\"Jesse Wilson\")));\n    assertEquals(\"{\\\"user1\\\":\\\"UserSerializer\\\",\\\"user3\\\":\\\"UserSerializerDeserializer\\\"}\", json);\n    Computer computer = gson.fromJson(\"{'user2':'Jesse Wilson','user3':'Jake Wharton'}\", Computer.class);\n    assertEquals(\"UserSerializer\", computer.user2.name);\n    assertEquals(\"UserSerializerDeserializer\", computer.user3.name);\n  }",
        "error_msg": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest::testJsonSerializerDeserializerBasedJsonAdapterOnFields --> java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.",
        "clean_error_msg": "java.lang.IllegalArgumentException: @JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."
      }
    }
  },
  "Gson-24": {
    "function_num": 3,
    "functions": [
      {
        "path": "/src/main/java/com/google/gson/JsonDeserializationVisitor.java",
        "start_loc": 40,
        "end_loc": 52,
        "buggy_function": "  public JsonDeserializationVisitor(JsonElement json, Type targetType,\n      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n      JsonDeserializationContext context) {\n    Preconditions.checkNotNull(json);\n    this.targetType = targetType;\n    this.factory = factory;\n    this.objectConstructor = objectConstructor;\n    this.deserializers = deserializers;\n    this.json = json;\n    this.context = context;\n    this.constructed = false;\n  }",
        "fixed_function": "  public JsonDeserializationVisitor(JsonElement json, Type targetType,\n      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n      JsonDeserializationContext context) {\n    Preconditions.checkNotNull(json);\n    this.targetType = targetType;\n    this.factory = factory;\n    this.objectConstructor = objectConstructor;\n    this.deserializers = deserializers;\n    this.json = json;\n    this.context = context;\n  }",
        "comment": ""
      },
      {
        "path": "/src/main/java/com/google/gson/JsonDeserializationVisitor.java",
        "start_loc": 54,
        "end_loc": 60,
        "buggy_function": "  public T getTarget() {\n    if (!constructed) {\n      target = constructTarget();\n      constructed = true;\n    }\n    return target;\n  }",
        "fixed_function": "  public T getTarget() {\n    if (target == null) {\n      target = constructTarget();\n    }\n    return target;\n  }",
        "comment": ""
      },
      {
        "path": "/src/main/java/com/google/gson/JsonDeserializationVisitor.java",
        "start_loc": 70,
        "end_loc": 80,
        "buggy_function": "  @SuppressWarnings(\"unchecked\")\n  public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n    if (pair == null) {\n      return false;\n    }    \n    Object value = invokeCustomDeserializer(json, pair);\n    target = (T) value;\n    constructed = true;\n    return true;\n  }",
        "fixed_function": "  @SuppressWarnings(\"unchecked\")\n  public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n    if (pair == null) {\n      return false;\n    }    \n    if (!json.isJsonNull()) {\n      JsonDeserializer deserializer = pair.getFirst();\n      Type objType = pair.getSecond().getType();\n      target = (T) deserializer.deserialize(json, objType, context);\n    }\n    return true;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.google.gson.functional.NullObjectAndFieldTest::testCustomTypeAdapterPassesNullDesrialization": {
        "path": "com/google/gson/functional/NullObjectAndFieldTest.java",
        "function_name": "testCustomTypeAdapterPassesNullDesrialization",
        "src": "public void testCustomTypeAdapterPassesNullDesrialization() {\n    Gson gson = new GsonBuilder()\n        .registerTypeAdapter(ObjectWithField.class, new JsonDeserializer<ObjectWithField>() {\n          public ObjectWithField deserialize(JsonElement json, Type type,\n              JsonDeserializationContext context) {\n            return context.deserialize(null, type);\n          }\n        }).create();\n    String json = \"{value:'value1'}\";\n    ObjectWithField target = gson.fromJson(json, ObjectWithField.class);\n    assertFalse(\"value1\".equals(target.value));\n  }",
        "error_msg": "com.google.gson.functional.NullObjectAndFieldTest::testCustomTypeAdapterPassesNullDesrialization --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Hivemall_core-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/hivemall/topicmodel/LDAUDTF.java",
        "start_loc": 43,
        "end_loc": 52,
        "buggy_function": "    public LDAUDTF() {\n        super();\n\n        this.alpha = 1.f / topics;\n        this.eta = 1.f / topics;\n        this.numDocs = -1L;\n        this.tau0 = 64.d;\n        this.kappa = 0.7;\n        this.delta = DEFAULT_DELTA;\n    }",
        "fixed_function": "    public LDAUDTF() {\n        super();\n\n        this.alpha = 1.f / topics;\n        this.eta = 1.f / topics;\n        this.numDocs = 0L;\n        this.tau0 = 64.d;\n        this.kappa = 0.7;\n        this.delta = DEFAULT_DELTA;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/hivemall/topicmodel/LDAUDTF.java",
        "start_loc": 68,
        "end_loc": 88,
        "buggy_function": "    @Override\n    protected CommandLine processOptions(ObjectInspector[] argOIs) throws UDFArgumentException {\n        CommandLine cl = super.processOptions(argOIs);\n\n        if (cl != null) {\n            this.alpha = Primitives.parseFloat(cl.getOptionValue(\"alpha\"), 1.f / topics);\n            this.eta = Primitives.parseFloat(cl.getOptionValue(\"eta\"), 1.f / topics);\n            this.numDocs = Primitives.parseLong(cl.getOptionValue(\"num_docs\"), -1L);\n            this.tau0 = Primitives.parseDouble(cl.getOptionValue(\"tau0\"), 64.d);\n            if (tau0 <= 0.d) {\n                throw new UDFArgumentException(\"'-tau0' must be positive: \" + tau0);\n            }\n            this.kappa = Primitives.parseDouble(cl.getOptionValue(\"kappa\"), 0.7d);\n            if (kappa <= 0.5 || kappa > 1.d) {\n                throw new UDFArgumentException(\"'-kappa' must be in (0.5, 1.0]: \" + kappa);\n            }\n            this.delta = Primitives.parseDouble(cl.getOptionValue(\"delta\"), DEFAULT_DELTA);\n        }\n\n        return cl;\n    }",
        "fixed_function": "    @Override\n    protected CommandLine processOptions(ObjectInspector[] argOIs) throws UDFArgumentException {\n        CommandLine cl = super.processOptions(argOIs);\n\n        if (cl != null) {\n            this.alpha = Primitives.parseFloat(cl.getOptionValue(\"alpha\"), 1.f / topics);\n            this.eta = Primitives.parseFloat(cl.getOptionValue(\"eta\"), 1.f / topics);\n            this.numDocs = Primitives.parseLong(cl.getOptionValue(\"num_docs\"), 0L);\n            this.tau0 = Primitives.parseDouble(cl.getOptionValue(\"tau0\"), 64.d);\n            if (tau0 <= 0.d) {\n                throw new UDFArgumentException(\"'-tau0' must be positive: \" + tau0);\n            }\n            this.kappa = Primitives.parseDouble(cl.getOptionValue(\"kappa\"), 0.7d);\n            if (kappa <= 0.5 || kappa > 1.d) {\n                throw new UDFArgumentException(\"'-kappa' must be in (0.5, 1.0]: \" + kappa);\n            }\n            this.delta = Primitives.parseDouble(cl.getOptionValue(\"delta\"), DEFAULT_DELTA);\n        }\n\n        return cl;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "hivemall.topicmodel.LDAUDTFTest::testSingleRow": {
        "path": "hivemall/topicmodel/LDAUDTFTest.java",
        "function_name": "testSingleRow",
        "src": "@Test\n    public void testSingleRow() throws HiveException {\n        LDAUDTF udtf = new LDAUDTF();\n        final int numTopics = 2;\n        ObjectInspector[] argOIs = new ObjectInspector[] {\n                ObjectInspectorFactory.getStandardListObjectInspector(\n                    PrimitiveObjectInspectorFactory.javaStringObjectInspector),\n                ObjectInspectorUtils.getConstantObjectInspector(\n                    PrimitiveObjectInspectorFactory.javaStringObjectInspector,\n                    \"-topics \" + numTopics)};\n        udtf.initialize(argOIs);\n\n        String[] doc1 = new String[] {\"1\", \"2\", \"3\"};\n        udtf.process(new Object[] {Arrays.asList(doc1)});\n\n        final MutableInt cnt = new MutableInt(0);\n        udtf.setCollector(new Collector() {\n            @Override\n            public void collect(Object arg0) throws HiveException {\n                cnt.addValue(1);\n            }\n        });\n        udtf.close();\n\n        Assert.assertEquals(doc1.length * numTopics, cnt.getValue());\n    }",
        "error_msg": "hivemall.topicmodel.LDAUDTFTest::testSingleRow --> junit.framework.AssertionFailedError: expected:<6> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<6> but was:<0>"
      }
    }
  },
  "IO-22": {
    "function_num": 2,
    "functions": [
      {
        "path": "./src/main/java/org/apache/commons/io/input/BrokenInputStream.java",
        "start_loc": 103,
        "end_loc": 106,
        "buggy_function": "    @Override\n    public void close() throws IOException {\n        throw new IOException(exception.getMessage());\n    }",
        "fixed_function": "    @Override\n    public void close() throws IOException {\n        throw exception;\n    }",
        "comment": "/**\n     * Throws the configured exception.\n     *\n     * @throws IOException always thrown\n     */"
      },
      {
        "path": "./src/main/java/org/apache/commons/io/output/BrokenOutputStream.java",
        "start_loc": 80,
        "end_loc": 83,
        "buggy_function": "    @Override\n    public void close() throws IOException {\n        throw new IOException(exception.getMessage());\n    }",
        "fixed_function": "    @Override\n    public void close() throws IOException {\n        throw exception;\n    }",
        "comment": "/**\n     * Throws the configured exception.\n     *\n     * @throws IOException always thrown\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.io.input.BrokenInputStreamTest::testClose": {
        "path": "org/apache/commons/io/input/BrokenInputStreamTest.java",
        "function_name": "testClose",
        "src": "public void testClose() {\n        try {\n            stream.close();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertEquals(exception, e);\n        }\n    }",
        "error_msg": "org.apache.commons.io.input.BrokenInputStreamTest::testClose --> junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>"
      },
      "org.apache.commons.io.input.TaggedInputStreamTest::testBrokenStream": {
        "path": "org/apache/commons/io/input/TaggedInputStreamTest.java",
        "function_name": "testBrokenStream",
        "src": "public void testBrokenStream() {\n        final IOException exception = new IOException(\"test exception\");\n        final TaggedInputStream stream =\n            new TaggedInputStream(new BrokenInputStream(exception));\n\n        // Test the available() method\n        try {\n            stream.available();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n\n        // Test the read() method\n        try {\n            stream.read();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n\n        // Test the close() method\n        try {\n            stream.close();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n    }",
        "error_msg": "org.apache.commons.io.input.TaggedInputStreamTest::testBrokenStream --> junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>"
      },
      "org.apache.commons.io.output.BrokenOutputStreamTest::testClose": {
        "path": "org/apache/commons/io/output/BrokenOutputStreamTest.java",
        "function_name": "testClose",
        "src": "public void testClose() {\n        try {\n            stream.close();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertEquals(exception, e);\n        }\n    }",
        "error_msg": "org.apache.commons.io.output.BrokenOutputStreamTest::testClose --> junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>"
      },
      "org.apache.commons.io.output.TaggedOutputStreamTest::testBrokenStream": {
        "path": "org/apache/commons/io/output/TaggedOutputStreamTest.java",
        "function_name": "testBrokenStream",
        "src": "public void testBrokenStream() {\n        final IOException exception = new IOException(\"test exception\");\n        final TaggedOutputStream stream =\n            new TaggedOutputStream(new BrokenOutputStream(exception));\n\n        // Test the write() method\n        try {\n            stream.write('x');\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n\n        // Test the flush() method\n        try {\n            stream.flush();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n\n        // Test the close() method\n        try {\n            stream.close();\n            fail(\"Expected exception not thrown.\");\n        } catch (final IOException e) {\n            assertTrue(stream.isCauseOf(e));\n            try {\n                stream.throwIfCauseOf(e);\n                fail(\"Expected exception not thrown.\");\n            } catch (final IOException e2) {\n                assertEquals(exception, e2);\n            }\n        }\n    }",
        "error_msg": "org.apache.commons.io.output.TaggedOutputStreamTest::testBrokenStream --> junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<java.io.IOException: test exception> but was:<java.io.IOException: test exception>"
      }
    }
  },
  "JacksonCore-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/io/NumberInput.java",
        "start_loc": 293,
        "end_loc": 296,
        "buggy_function": "    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n            return new BigDecimal(numStr);\n    }",
        "fixed_function": "    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n        try {\n            return new BigDecimal(numStr);\n        } catch (NumberFormatException e) {\n            throw _badBigDecimal(numStr);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/io/NumberInput.java",
        "start_loc": 302,
        "end_loc": 306,
        "buggy_function": "    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n            throws NumberFormatException\n    {\n            return new BigDecimal(buffer, offset, len);\n    }",
        "fixed_function": "    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n            throws NumberFormatException\n    {\n        try {\n            return new BigDecimal(buffer, offset, len);\n        } catch (NumberFormatException e) {\n            throw _badBigDecimal(new String(buffer, offset, len));\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java",
        "start_loc": 382,
        "end_loc": 399,
        "buggy_function": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "fixed_function": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "comment": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestParserNonStandard::testAllowNaN": {
        "path": "com/fasterxml/jackson/core/json/TestParserNonStandard.java",
        "function_name": "testAllowNaN",
        "src": "public void testAllowNaN() throws Exception {\n        _testAllowNaN(false);\n        _testAllowNaN(true);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestParserNonStandard::testAllowNaN --> junit.framework.AssertionFailedError: Expected an exception with one of substrings ([can not be represented as BigDecimal]): got one with message null",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([can not be represented as BigDecimal]): got one with message null"
      }
    }
  },
  "JacksonCore-2": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 846,
        "end_loc": 959,
        "buggy_function": "    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }",
        "fixed_function": "    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }",
        "comment": "/**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 968,
        "end_loc": 1085,
        "buggy_function": "    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }",
        "fixed_function": "    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }",
        "comment": "/**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 1184,
        "end_loc": 1247,
        "buggy_function": "    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
        "fixed_function": "    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
        "comment": "/**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 1253,
        "end_loc": 1284,
        "buggy_function": "    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }",
        "fixed_function": "    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }",
        "comment": "/**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 1323,
        "end_loc": 1412,
        "buggy_function": "    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }",
        "fixed_function": "    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 2540,
        "end_loc": 2584,
        "buggy_function": "    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }",
        "fixed_function": "    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }",
        "comment": "/**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersBytes": {
        "path": "com/fasterxml/jackson/core/json/TestParserErrorHandling.java",
        "function_name": "testMangledNumbersBytes",
        "src": "public void testMangledNumbersBytes() throws Exception {\n        _testMangledNumbers(true);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersBytes --> junit.framework.AssertionFailedError: Should have gotten an exception; instead got token: VALUE_NUMBER_INT",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should have gotten an exception; instead got token: VALUE_NUMBER_INT"
      },
      "com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersChars": {
        "path": "com/fasterxml/jackson/core/json/TestParserErrorHandling.java",
        "function_name": "testMangledNumbersChars",
        "src": "public void testMangledNumbersChars() throws Exception {\n        _testMangledNumbers(false);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersChars --> junit.framework.AssertionFailedError: Should have gotten an exception; instead got token: VALUE_NUMBER_INT",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should have gotten an exception; instead got token: VALUE_NUMBER_INT"
      }
    }
  },
  "JacksonCore-9": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
        "start_loc": 387,
        "end_loc": 393,
        "buggy_function": "    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        return getValueAsString(null);\n    }",
        "fixed_function": "    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
        "start_loc": 395,
        "end_loc": 404,
        "buggy_function": "    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }",
        "fixed_function": "    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 243,
        "end_loc": 254,
        "buggy_function": "    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }",
        "fixed_function": "    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 257,
        "end_loc": 267,
        "buggy_function": "    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }",
        "fixed_function": "    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 295,
        "end_loc": 306,
        "buggy_function": "    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }",
        "fixed_function": "    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 309,
        "end_loc": 320,
        "buggy_function": "    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }",
        "fixed_function": "    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextBytes": {
        "path": "com/fasterxml/jackson/core/json/TestJsonParser.java",
        "function_name": "testGetValueAsTextBytes",
        "src": "public void testGetValueAsTextBytes() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        _testGetValueAsText(f, true, false);\n        _testGetValueAsText(f, true, true);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextBytes --> junit.framework.ComparisonFailure: expected:<a> but was:<null>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<a> but was:<null>"
      },
      "com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextChars": {
        "path": "com/fasterxml/jackson/core/json/TestJsonParser.java",
        "function_name": "testGetValueAsTextChars",
        "src": "public void testGetValueAsTextChars() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        _testGetValueAsText(f, false, false);\n        _testGetValueAsText(f, false, true);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextChars --> junit.framework.ComparisonFailure: expected:<a> but was:<null>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<a> but was:<null>"
      }
    }
  },
  "JacksonCore-12": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 573,
        "end_loc": 705,
        "buggy_function": "    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }",
        "fixed_function": "    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }",
        "comment": "/**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 731,
        "end_loc": 808,
        "buggy_function": "    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }",
        "fixed_function": "    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 810,
        "end_loc": 912,
        "buggy_function": "    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }",
        "fixed_function": "    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 914,
        "end_loc": 958,
        "buggy_function": "    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }",
        "fixed_function": "    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 960,
        "end_loc": 1014,
        "buggy_function": "    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }",
        "fixed_function": "    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 2667,
        "end_loc": 2675,
        "buggy_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }",
        "fixed_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    -1L, _nameInputTotal, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                -1L, _tokenInputTotal, _tokenInputRow,\n                getTokenColumnNr());\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 3613,
        "end_loc": 3624,
        "buggy_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                getTokenCharacterOffset(), -1L, getTokenLineNr(),\n                getTokenColumnNr());\n    }",
        "fixed_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                _tokenInputTotal, -1L, _tokenInputRow,\n                getTokenColumnNr());\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader": {
        "path": "com/fasterxml/jackson/core/json/LocationInObjectTest.java",
        "function_name": "testOffsetWithObjectFieldsUsingReader",
        "src": "public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader --> junit.framework.AssertionFailedError: expected:<6> but was:<1>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<6> but was:<1>"
      }
    }
  },
  "JacksonCore-18": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
        "start_loc": 433,
        "end_loc": 436,
        "buggy_function": "    protected String _asString(BigDecimal value) throws IOException {\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n        return value.toString();\n    }",
        "fixed_function": "    protected String _asString(BigDecimal value) throws IOException {\n        if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n            int scale = value.scale();\n            if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n                _reportError(String.format(\n\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\nscale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n            }\n            return value.toPlainString();\n        }\n        return value.toString();\n    }",
        "comment": "/**\n     * Helper method used to serialize a {@link java.math.BigDecimal} as a String,\n     * for serialization, taking into account configuration settings\n     *\n     * @since 2.7.7\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
        "start_loc": 902,
        "end_loc": 917,
        "buggy_function": "    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "fixed_function": "    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
        "start_loc": 679,
        "end_loc": 694,
        "buggy_function": "    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "fixed_function": "    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures::testTooBigBigDecimal": {
        "path": "com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java",
        "function_name": "testTooBigBigDecimal",
        "src": "public void testTooBigBigDecimal() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n\n        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]\n        BigDecimal BIG = new BigDecimal(\"1E+9999\");\n        BigDecimal TOO_BIG = new BigDecimal(\"1E+10000\");\n        BigDecimal SMALL = new BigDecimal(\"1E-9999\");\n        BigDecimal TOO_SMALL = new BigDecimal(\"1E-10000\");\n\n        for (boolean useBytes : new boolean[] { false, true } ) {\n            for (boolean asString : new boolean[] { false, true } ) {\n                JsonGenerator g;\n                \n                if (useBytes) {\n                    g = f.createGenerator(new ByteArrayOutputStream());\n                } else {\n                    g = f.createGenerator(new StringWriter());\n                }\n                if (asString) {\n                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                }\n\n                // first, ok cases:\n                g.writeStartArray();\n                g.writeNumber(BIG);\n                g.writeNumber(SMALL);\n                g.writeEndArray();\n                g.close();\n\n                // then invalid\n                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {\n                    if (useBytes) {\n                        g = f.createGenerator(new ByteArrayOutputStream());\n                    } else {\n                        g = f.createGenerator(new StringWriter());\n                    }\n                    if (asString) {\n                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                    }\n                    try {\n                        g.writeNumber(input);\n                        fail(\"Should not have written without exception: \"+input);\n                    } catch (JsonGenerationException e) {\n                        verifyException(e, \"Attempt to write plain `java.math.BigDecimal`\");\n                        verifyException(e, \"illegal scale\");\n                    }\n                    g.close();\n                }\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures::testTooBigBigDecimal --> junit.framework.AssertionFailedError: Should not have written without exception: 1E+10000",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should not have written without exception: 1E+10000"
      }
    }
  },
  "JacksonCore-19": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 1374,
        "end_loc": 1495,
        "buggy_function": "    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }",
        "fixed_function": "    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }",
        "comment": "/**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 1536,
        "end_loc": 1627,
        "buggy_function": "    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per [core#105], need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }",
        "fixed_function": "    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per [core#105], need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestNumericValues::testLongerFloatingPoint": {
        "path": "com/fasterxml/jackson/core/json/TestNumericValues.java",
        "function_name": "testLongerFloatingPoint",
        "src": "public void testLongerFloatingPoint() throws Exception\n    {\n        StringBuilder input = new StringBuilder();\n        for (int i = 1; i < 201; i++) {\n            input.append(1);\n        }\n        input.append(\".0\");\n        final String DOC = input.toString();\n\n        // test out with both Reader and ByteArrayInputStream\n        JsonParser p;\n\n        p = FACTORY.createParser(new StringReader(DOC));\n        _testLongerFloat(p, DOC);\n        p.close();\n        \n        p = FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")));\n        _testLongerFloat(p, DOC);\n        p.close();\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestNumericValues::testLongerFloatingPoint --> java.lang.ArrayIndexOutOfBoundsException: 200",
        "clean_error_msg": "java.lang.ArrayIndexOutOfBoundsException: 200"
      }
    }
  },
  "JacksonCore-24": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserBase.java",
        "start_loc": 867,
        "end_loc": 872,
        "buggy_function": "    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n    {\n        final String numDesc = _longIntegerDesc(rawNum);\n        _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n                (expType == NR_LONG) ? \"long\" : \"int\");\n    }",
        "fixed_function": "    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n    {\n        if (expType == NR_INT) {\n            reportOverflowInt(rawNum);\n        } else {\n            reportOverflowLong(rawNum);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserBase.java",
        "start_loc": 880,
        "end_loc": 912,
        "buggy_function": "    protected void convertNumberToInt() throws IOException\n    {\n        // First, converting from long ought to be easy\n        if ((_numTypesValid & NR_LONG) != 0) {\n            // Let's verify it's lossless conversion by simple roundtrip\n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }",
        "fixed_function": "    protected void convertNumberToInt() throws IOException\n    {\n        // First, converting from long ought to be easy\n        if ((_numTypesValid & NR_LONG) != 0) {\n            // Let's verify it's lossless conversion by simple roundtrip\n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                reportOverflowInt(getText(), currentToken());\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Numeric conversions\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
        "start_loc": 564,
        "end_loc": 567,
        "buggy_function": "    protected void reportOverflowInt(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n    }",
        "fixed_function": "    protected void reportOverflowInt(String numDesc) throws IOException {\n        reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
        "start_loc": 581,
        "end_loc": 584,
        "buggy_function": "    protected void reportOverflowLong(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n    }",
        "fixed_function": "    protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n                inputType, Integer.TYPE);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToLongFailing": {
        "path": "com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java",
        "function_name": "testToLongFailing",
        "src": "public void testToLongFailing() throws Exception\n    {\n        AsyncReaderWrapper p;\n\n        // BigInteger -> error\n        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n        p = createParser(String.valueOf(big));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n        assertEquals(big, p.getBigIntegerValue());\n        assertEquals(big, p.getNumberValue());\n        try {\n            p.getLongValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of long\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Long.TYPE, e.getTargetType());\n        }\n        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);\n        p = createParser(String.valueOf(small));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(small, p.getBigIntegerValue());\n        try {\n            p.getLongValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of long\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Long.TYPE, e.getTargetType());\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToLongFailing --> com.fasterxml.jackson.core.JsonParseException: Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)"
      },
      "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToIntFailing": {
        "path": "com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java",
        "function_name": "testToIntFailing",
        "src": "public void testToIntFailing() throws Exception\n    {\n        AsyncReaderWrapper p;\n\n        // long -> error\n        long big = 1L + Integer.MAX_VALUE;\n        p = createParser(String.valueOf(big));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(big, p.getLongValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n        long small = -1L + Integer.MIN_VALUE;\n        p = createParser(String.valueOf(small));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(Long.valueOf(small), p.getNumberValue());\n        assertEquals(small, p.getLongValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n\n        // double -> error\n        p = createParser(String.valueOf(big)+\".0\");\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n        assertEquals((double) big, p.getDoubleValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n        p = createParser(String.valueOf(small)+\".0\");\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n        assertEquals((double) small, p.getDoubleValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n\n        // BigInteger -> error\n        p = createParser(String.valueOf(big));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n        p = createParser(String.valueOf(small));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());\n        try {\n            p.getIntValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of int\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Integer.TYPE, e.getTargetType());\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToIntFailing --> com.fasterxml.jackson.core.JsonParseException: Numeric value (2147483648) out of range of int",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (2147483648) out of range of int"
      },
      "com.fasterxml.jackson.core.read.NumberCoercionTest::testToLongFailing": {
        "path": "com/fasterxml/jackson/core/read/NumberCoercionTest.java",
        "function_name": "testToLongFailing",
        "src": "@SuppressWarnings(\"resource\")\n    public void testToLongFailing() throws Exception\n    {\n        for (int mode : ALL_STREAMING_MODES) {\n            JsonParser p;\n\n            // BigInteger -> error\n            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n            p = createParser(mode, String.valueOf(big));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n            assertEquals(big, p.getBigIntegerValue());\n            assertEquals(big, p.getNumberValue());\n            try {\n                p.getLongValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of long\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Long.TYPE, e.getTargetType());\n            }\n            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);\n            p = createParser(mode, String.valueOf(small));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(small, p.getBigIntegerValue());\n            try {\n                p.getLongValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of long\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Long.TYPE, e.getTargetType());\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberCoercionTest::testToLongFailing --> com.fasterxml.jackson.core.JsonParseException: Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)"
      },
      "com.fasterxml.jackson.core.read.NumberCoercionTest::testToIntFailing": {
        "path": "com/fasterxml/jackson/core/read/NumberCoercionTest.java",
        "function_name": "testToIntFailing",
        "src": "@SuppressWarnings(\"resource\")\n    public void testToIntFailing() throws Exception\n    {\n        for (int mode : ALL_STREAMING_MODES) {\n            JsonParser p;\n\n            // long -> error\n            long big = 1L + Integer.MAX_VALUE;\n            p = createParser(mode, String.valueOf(big));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(big, p.getLongValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n            long small = -1L + Integer.MIN_VALUE;\n            p = createParser(mode, String.valueOf(small));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(Long.valueOf(small), p.getNumberValue());\n            assertEquals(small, p.getLongValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n\n            // double -> error\n            p = createParser(mode, String.valueOf(big)+\".0\");\n            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n            assertEquals((double) big, p.getDoubleValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n            p = createParser(mode, String.valueOf(small)+\".0\");\n            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n            assertEquals((double) small, p.getDoubleValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n\n            // BigInteger -> error\n            p = createParser(mode, String.valueOf(big));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n            p = createParser(mode, String.valueOf(small));\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());\n            try {\n                p.getIntValue();\n                fail(\"Should not pass\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of int\");\n                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n                assertEquals(Integer.TYPE, e.getTargetType());\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberCoercionTest::testToIntFailing --> com.fasterxml.jackson.core.JsonParseException: Numeric value (2147483648) out of range of int",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (2147483648) out of range of int"
      },
      "com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousLongOverflow": {
        "path": "com/fasterxml/jackson/core/read/NumberOverflowTest.java",
        "function_name": "testMaliciousLongOverflow",
        "src": "public void testMaliciousLongOverflow() throws Exception\n    {\n        for (int mode : ALL_STREAMING_MODES) {\n            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {\n                JsonParser p = createParser(mode, doc);\n                assertToken(JsonToken.START_ARRAY, p.nextToken());\n                assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n                try {\n                    p.getLongValue();\n                    fail(\"Should not pass\");\n                } catch (InputCoercionException e) {\n                    verifyException(e, \"out of range of long\");\n                    verifyException(e, \"Integer with \"+BIG_NUM_LEN+\" digits\");\n                }\n                p.close();\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousLongOverflow --> com.fasterxml.jackson.core.JsonParseException: Numeric value ([Integer with 199999 digits]) out of range of long",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value ([Integer with 199999 digits]) out of range of long"
      },
      "com.fasterxml.jackson.core.read.NumberOverflowTest::testSimpleLongOverflow": {
        "path": "com/fasterxml/jackson/core/read/NumberOverflowTest.java",
        "function_name": "testSimpleLongOverflow",
        "src": "public void testSimpleLongOverflow() throws Exception\n    {\n        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);\n        below = below.subtract(BigInteger.ONE);\n        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);\n        above = above.add(BigInteger.ONE);\n\n        String DOC_BELOW = below.toString() + \" \";\n        String DOC_ABOVE = below.toString() + \" \";\n\n        for (int mode : ALL_MODES) {\n            JsonParser p = createParser(FACTORY, mode, DOC_BELOW);\n            p.nextToken();\n            try {\n                long x = p.getLongValue();\n                fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of long\");\n            }\n            p.close();\n\n            p = createParser(mode, DOC_ABOVE);\n            p.nextToken();\n            try {\n                long x = p.getLongValue();\n                fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);\n            } catch (InputCoercionException e) {\n                verifyException(e, \"out of range of long\");\n            }\n            p.close();\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberOverflowTest::testSimpleLongOverflow --> com.fasterxml.jackson.core.JsonParseException: Numeric value (-9223372036854775809) out of range of long",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (-9223372036854775809) out of range of long"
      },
      "com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousIntOverflow": {
        "path": "com/fasterxml/jackson/core/read/NumberOverflowTest.java",
        "function_name": "testMaliciousIntOverflow",
        "src": "public void testMaliciousIntOverflow() throws Exception\n    {\n        for (int mode : ALL_STREAMING_MODES) {\n            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {\n                JsonParser p = createParser(mode, doc);\n                assertToken(JsonToken.START_ARRAY, p.nextToken());\n                assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n                try {\n                    p.getIntValue();\n                    fail(\"Should not pass\");\n                } catch (InputCoercionException e) {\n                    verifyException(e, \"out of range of int\");\n                    verifyException(e, \"Integer with \"+BIG_NUM_LEN+\" digits\");\n                }\n                p.close();\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousIntOverflow --> com.fasterxml.jackson.core.JsonParseException: Numeric value ([Integer with 199999 digits]) out of range of int",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value ([Integer with 199999 digits]) out of range of int"
      },
      "com.fasterxml.jackson.core.read.NumberParsingTest::testSimpleLong": {
        "path": "com/fasterxml/jackson/core/read/NumberParsingTest.java",
        "function_name": "testSimpleLong",
        "src": "public void testSimpleLong() throws Exception\n    {\n        _testSimpleLong(MODE_INPUT_STREAM);\n        _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);\n        _testSimpleLong(MODE_READER);\n        _testSimpleLong(MODE_DATA_INPUT);\n    }",
        "error_msg": "com.fasterxml.jackson.core.read.NumberParsingTest::testSimpleLong --> com.fasterxml.jackson.core.JsonParseException: Numeric value (12345678907) out of range of int",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Numeric value (12345678907) out of range of int"
      }
    }
  },
  "JacksonCore-31": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
        "start_loc": 1347,
        "end_loc": 1390,
        "buggy_function": "    protected JsonToken _handleUnexpectedValue(int i)\n        throws IOException, JsonParseException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApostropheValue();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }",
        "fixed_function": "    protected JsonToken _handleUnexpectedValue(int i)\n        throws IOException, JsonParseException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApostropheValue();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }",
        "comment": "/**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
        "start_loc": 2246,
        "end_loc": 2282,
        "buggy_function": "    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException, JsonParseException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApostropheValue();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }",
        "fixed_function": "    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException, JsonParseException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApostropheValue();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }",
        "comment": "/**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.core.json.TestParserErrorHandling::testInvalidKeywordsReader": {
        "path": "com/fasterxml/jackson/core/json/TestParserErrorHandling.java",
        "function_name": "testInvalidKeywordsReader",
        "src": "public void testInvalidKeywordsReader() throws Exception {\n        _testInvalidKeywords(false);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestParserErrorHandling::testInvalidKeywordsReader --> junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Unrecognized token]): got one with message Unexpected character ('F' (code 70)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Unrecognized token]): got one with message Unexpected character ('F' (code 70)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')"
      },
      "com.fasterxml.jackson.core.json.TestParserErrorHandling::testInvalidKeywordsStream": {
        "path": "com/fasterxml/jackson/core/json/TestParserErrorHandling.java",
        "function_name": "testInvalidKeywordsStream",
        "src": "public void testInvalidKeywordsStream() throws Exception {\n        _testInvalidKeywords(true);\n    }",
        "error_msg": "com.fasterxml.jackson.core.json.TestParserErrorHandling::testInvalidKeywordsStream --> junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Unrecognized token]): got one with message Unexpected character ('F' (code 70)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Unrecognized token]): got one with message Unexpected character ('F' (code 70)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')"
      }
    }
  },
  "JacksonDatabind-10": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java",
        "start_loc": 27,
        "end_loc": 34,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    public AnyGetterWriter(BeanProperty property,\n            AnnotatedMember accessor, MapSerializer serializer)\n    {\n        _accessor = accessor;\n        _property = property;\n            _mapSerializer = (MapSerializer) serializer;\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    public AnyGetterWriter(BeanProperty property,\n            AnnotatedMember accessor, JsonSerializer<?> serializer)\n    {\n        _accessor = accessor;\n        _property = property;\n        _serializer = (JsonSerializer<Object>) serializer;\n        if (serializer instanceof MapSerializer) {\n            _mapSerializer = (MapSerializer) serializer;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java",
        "start_loc": 36,
        "end_loc": 52,
        "buggy_function": "    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n            return;\n        }\n    }",
        "fixed_function": "    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n            return;\n        }\n        _serializer.serialize(value, gen, provider);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java",
        "start_loc": 57,
        "end_loc": 75,
        "buggy_function": "    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);\n            return;\n        }\n        // ... not sure how custom handler would do it\n    }",
        "fixed_function": "    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);\n            return;\n        }\n        // ... not sure how custom handler would do it\n        _serializer.serialize(value, gen, provider);\n    }",
        "comment": "/**\n     * @since 2.3\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java",
        "start_loc": 78,
        "end_loc": 83,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n        if (_serializer instanceof ContextualSerializer) {\n            JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property);\n            _serializer = (JsonSerializer<Object>) ser;\n            if (ser instanceof MapSerializer) {\n                _mapSerializer = (MapSerializer) ser;\n            }\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
        "start_loc": 334,
        "end_loc": 424,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }",
        "comment": "/**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.ser.TestAnyGetter::testIssue705": {
        "path": "com/fasterxml/jackson/databind/ser/TestAnyGetter.java",
        "function_name": "testIssue705",
        "src": "public void testIssue705() throws Exception\n    {\n        Issue705Bean input = new Issue705Bean(\"key\", \"value\");        \n        String json = MAPPER.writeValueAsString(input);\n        assertEquals(\"{\\\"stuff\\\":\\\"[key/value]\\\"}\", json);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.TestAnyGetter::testIssue705 --> junit.framework.ComparisonFailure: expected:<{[stuff:[key/value]]}> but was:<{[key:value]}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<{[stuff:[key/value]]}> but was:<{[key:value]}>"
      }
    }
  },
  "JacksonDatabind-13": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java",
        "start_loc": 81,
        "end_loc": 131,
        "buggy_function": "    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n    {\n        /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n         *   missing id already works.\n         */\n\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n\n        if (_objectIds == null) {\n            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n        } else {\n            ReadableObjectId entry = _objectIds.get(key);\n            if (entry != null) {\n                return entry;\n            }\n        }\n\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        } else {\n            for (ObjectIdResolver res : _objectIdResolvers) {\n                if (res.canUseFor(resolverType)) {\n                    resolver = res;\n                    break;\n                }\n            }\n        }\n\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            /*\n            if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n                resolver = new SimpleObjectIdResolver();\n            }\n            */\n            _objectIdResolvers.add(resolver);\n        }\n\n        ReadableObjectId entry = new ReadableObjectId(key);\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }",
        "fixed_function": "    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n    {\n        /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n         *   missing id already works.\n         */\n        if (id == null) {\n            return null;\n        }\n\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n\n        if (_objectIds == null) {\n            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n        } else {\n            ReadableObjectId entry = _objectIds.get(key);\n            if (entry != null) {\n                return entry;\n            }\n        }\n\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        } else {\n            for (ObjectIdResolver res : _objectIdResolvers) {\n                if (res.canUseFor(resolverType)) {\n                    resolver = res;\n                    break;\n                }\n            }\n        }\n\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            /*\n            if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n                resolver = new SimpleObjectIdResolver();\n            }\n            */\n            _objectIdResolvers.add(resolver);\n        }\n\n        ReadableObjectId entry = new ReadableObjectId(key);\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Abstract methods impls, Object Id\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java",
        "start_loc": 80,
        "end_loc": 101,
        "buggy_function": "    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        Object id = _valueDeserializer.deserialize(jp, ctxt);\n\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        \n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }",
        "fixed_function": "    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        Object id = _valueDeserializer.deserialize(jp, ctxt);\n\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        if (id == null) {\n            return null;\n        }\n        \n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.struct.TestObjectIdDeserialization::testNullObjectId": {
        "path": "com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java",
        "function_name": "testNullObjectId",
        "src": "public void testNullObjectId() throws Exception\n    {\n        // Ok, so missing Object Id is ok, but so is null.\n        \n        Identifiable value = MAPPER.readValue\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), Identifiable.class);\n        assertNotNull(value);\n        assertEquals(3, value.value);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.struct.TestObjectIdDeserialization::testNullObjectId --> com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.struct.Identifiable[id])",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.struct.Identifiable[id])"
      }
    }
  },
  "JacksonDatabind-15": {
    "function_num": 9,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
        "start_loc": 125,
        "end_loc": 167,
        "buggy_function": "    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }",
        "fixed_function": "    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }",
        "comment": "/**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java",
        "start_loc": 357,
        "end_loc": 376,
        "buggy_function": "    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                    return new StdDelegatingSerializer(conv, delegateType, ser);\n                }\n            }\n        }\n        return null;\n    }",
        "fixed_function": "    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null\n                            : provider.findValueSerializer(delegateType, prop);\n                    return new StdDelegatingSerializer(conv, delegateType, ser);\n                }\n            }\n        }\n        return null;\n    }",
        "comment": "/**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 106,
        "end_loc": 128,
        "buggy_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> delSer = _delegateSerializer;\n        JavaType delegateType = _delegateType;\n\n        if (delSer == null) {\n            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n            if (delegateType == null) {\n                delegateType = _converter.getOutputType(provider.getTypeFactory());\n            }\n            /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n             *    java.lang.Object (or missing generic), [databind#731]\n             */\n                delSer = provider.findValueSerializer(delegateType);\n        }\n        if (delSer instanceof ContextualSerializer) {\n            delSer = provider.handleSecondaryContextualization(delSer, property);\n        }\n        return (delSer == _delegateSerializer) ? this\n                : withDelegate(_converter, delegateType, delSer);\n    }",
        "fixed_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> delSer = _delegateSerializer;\n        JavaType delegateType = _delegateType;\n\n        if (delSer == null) {\n            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n            if (delegateType == null) {\n                delegateType = _converter.getOutputType(provider.getTypeFactory());\n            }\n            /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n             *    java.lang.Object (or missing generic), [databind#731]\n             */\n            if (!delegateType.isJavaLangObject()) {\n                delSer = provider.findValueSerializer(delegateType);\n            }\n        }\n        if (delSer instanceof ContextualSerializer) {\n            delSer = provider.handleSecondaryContextualization(delSer, property);\n        }\n        if (delSer == _delegateSerializer && delegateType == _delegateType) {\n            return this;\n        }\n        return withDelegate(_converter, delegateType, delSer);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 151,
        "end_loc": 162,
        "buggy_function": "    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n    {\n        Object delegateValue = convertValue(value);\n        // should we accept nulls?\n        if (delegateValue == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n        _delegateSerializer.serialize(delegateValue, gen, provider);\n    }",
        "fixed_function": "    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n    {\n        Object delegateValue = convertValue(value);\n        // should we accept nulls?\n        if (delegateValue == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n        JsonSerializer<Object> ser = _delegateSerializer;\n        if (ser == null) {\n            ser = _findSerializer(delegateValue, provider);\n        }\n        ser.serialize(delegateValue, gen, provider);\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Serialization\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 164,
        "end_loc": 173,
        "buggy_function": "    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException\n    {\n        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n         *    let's give it a chance?\n         */\n        Object delegateValue = convertValue(value);\n        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n    }",
        "fixed_function": "    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException\n    {\n        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n         *    let's give it a chance?\n         */\n        Object delegateValue = convertValue(value);\n        JsonSerializer<Object> ser = _delegateSerializer;\n        if (ser == null) {\n            ser = _findSerializer(value, provider);\n        }\n        ser.serializeWithType(delegateValue, gen, provider, typeSer);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 175,
        "end_loc": 181,
        "buggy_function": "    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value)\n    {\n        Object delegateValue = convertValue(value);\n        return _delegateSerializer.isEmpty(delegateValue);\n    }",
        "fixed_function": "    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value)\n    {\n        Object delegateValue = convertValue(value);\n        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n            return (value == null);\n        }\n        return _delegateSerializer.isEmpty(delegateValue);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 183,
        "end_loc": 188,
        "buggy_function": "    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value)\n    {\n        Object delegateValue = convertValue(value);\n        return _delegateSerializer.isEmpty(prov, delegateValue);\n    }",
        "fixed_function": "    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value)\n    {\n        Object delegateValue = convertValue(value);\n        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n            return (value == null);\n        }\n        return _delegateSerializer.isEmpty(prov, delegateValue);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java",
        "start_loc": 216,
        "end_loc": 225,
        "buggy_function": "    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n         *    properly... but for now, try this:\n         */\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    }",
        "fixed_function": "    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n         *    properly... but for now, try this:\n         */\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n        if (_delegateSerializer != null) {\n            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java",
        "start_loc": 245,
        "end_loc": 270,
        "buggy_function": "    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException\n    {\n        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n         *   when applying contextual content converter; this is not ideal way,\n         *   but should work for most cases.\n         */\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null && prop != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationContentConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    if (existingSerializer == null) {\n                        existingSerializer = provider.findValueSerializer(delegateType);\n                    }\n                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                }\n            }\n        }\n        return existingSerializer;\n    }",
        "fixed_function": "    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException\n    {\n        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n         *   when applying contextual content converter; this is not ideal way,\n         *   but should work for most cases.\n         */\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null && prop != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationContentConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {\n                        existingSerializer = provider.findValueSerializer(delegateType);\n                    }\n                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                }\n            }\n        }\n        return existingSerializer;\n    }",
        "comment": "/**\n     * Helper method that can be used to see if specified property has annotation\n     * indicating that a converter is to be used for contained values (contents\n     * of structured types; array/List/Map values)\n     * \n     * @param existingSerializer (optional) configured content\n     *    serializer if one already exists.\n     * \n     * @since 2.2\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.convert.TestConvertingSerializer::testIssue731": {
        "path": "com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java",
        "function_name": "testIssue731",
        "src": "public void testIssue731() throws Exception\n    {\n        String json = objectWriter().writeValueAsString(new ConvertingBeanWithUntypedConverter(1, 2));\n        // must be  {\"a\":2,\"b\":4}\n        assertEquals(\"{\\\"a\\\":2,\\\"b\\\":4}\", json);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.convert.TestConvertingSerializer::testIssue731 --> com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.fasterxml.jackson.databind.convert.TestConvertingSerializer$DummyBean and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.fasterxml.jackson.databind.convert.TestConvertingSerializer$DummyBean and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )"
      }
    }
  },
  "JacksonDatabind-22": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
        "start_loc": 544,
        "end_loc": 628,
        "buggy_function": "    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n\n        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,\n         *   with just one important exception: if value type is \"untyped\", let's\n         *   leave it as is; no clean way to make it work.\n         */\n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        // Let's see what we can learn about element/content/value type, type serializer for it:\n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        // if elements have type serializer, can not force static typing:\n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { // implements java.util.Map\n            MapLikeType mlt = (MapLikeType) type;\n            /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n             *  key serializer from property annotations, and can lead to caching\n             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.\n             *  But we do need to check class annotations.\n             */\n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                MapLikeType mlType = (MapLikeType) type;\n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                        }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }",
        "fixed_function": "    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n\n        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,\n         *   with just one important exception: if value type is \"untyped\", let's\n         *   leave it as is; no clean way to make it work.\n         */\n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        // Let's see what we can learn about element/content/value type, type serializer for it:\n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        // if elements have type serializer, can not force static typing:\n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { // implements java.util.Map\n            MapLikeType mlt = (MapLikeType) type;\n            /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n             *  key serializer from property annotations, and can lead to caching\n             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.\n             *  But we do need to check class annotations.\n             */\n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            MapLikeType mlType = (MapLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { // (2) Annotations-based ones:\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { // (2) Annotations-based ones:\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }",
        "comment": "/**\n     * @since 2.1\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
        "start_loc": 636,
        "end_loc": 701,
        "buggy_function": "    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n                // We may also want to use serialize Collections \"as beans\", if (and only if)\n                // this is specified with `@JsonFormat(shape=Object)`\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    // this may or may not be available (Class doesn't; type of field/method does)\n                    JavaType enumType = type.getContentType();\n                    // and even if nominally there is something, only use if it really is enum\n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            // [JACKSON-829] Must NOT use if we have custom serializer\n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        // [JACKSON-829] Must NOT use if we have custom serializer\n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                }\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException\n    {\n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n            if (ser == null) {\n                // We may also want to use serialize Collections \"as beans\", if (and only if)\n                // this is specified with `@JsonFormat(shape=Object)`\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    // this may or may not be available (Class doesn't; type of field/method does)\n                    JavaType enumType = type.getContentType();\n                    // and even if nominally there is something, only use if it really is enum\n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            // [JACKSON-829] Must NOT use if we have custom serializer\n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        // [JACKSON-829] Must NOT use if we have custom serializer\n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                    }\n                }\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }",
        "comment": "/**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.List} types that support efficient by-index access\n     * \n     * @since 2.1\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
        "start_loc": 737,
        "end_loc": 791,
        "buggy_function": "    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        \n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n                // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                /*\n                if (EnumMap.class.isAssignableFrom(type.getRawClass())\n                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                    JavaType keyType = type.getKeyType();\n                    // Need to find key enum values...\n                    EnumValues enums = null;\n                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n                        @SuppressWarnings(\"unchecked\")\n                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n                        enums = EnumValues.construct(config, enumClass);\n                    }\n                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                        elementTypeSerializer, elementValueSerializer);\n                } else {\n                */\n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        \n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n            if (ser == null) {\n                // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                /*\n                if (EnumMap.class.isAssignableFrom(type.getRawClass())\n                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                    JavaType keyType = type.getKeyType();\n                    // Need to find key enum values...\n                    EnumValues enums = null;\n                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n                        @SuppressWarnings(\"unchecked\")\n                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n                        enums = EnumValues.construct(config, enumClass);\n                    }\n                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                        elementTypeSerializer, elementValueSerializer);\n                } else {\n                */\n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }",
        "comment": "/**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.Map} types.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java",
        "start_loc": 831,
        "end_loc": 874,
        "buggy_function": "    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array\n        //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n        //   so we need not do primary annotation lookup here.\n        //   So all we need is (1) Custom, (2) Default array serializers\n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             // Important: do NOT use standard serializers if non-standard element value serializer specified\n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     // other standard types?\n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         // [databind#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array\n        //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n        //   so we need not do primary annotation lookup here.\n        //   So all we need is (1) Custom, (2) Default array serializers\n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             // Important: do NOT use standard serializers if non-standard element value serializer specified\n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     // other standard types?\n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         // [databind#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }",
        "comment": "/**\n     * Helper method that handles configuration details when constructing serializers for\n     * <code>Object[]</code> (and subtypes, except for String).\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
        "start_loc": 170,
        "end_loc": 248,
        "buggy_function": "    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n            //    this call was BEFORE custom serializer lookup, which was wrong.\n        }\n        \n        if (ser == null) {\n            // Otherwise, we will check \"primary types\"; both marker types that\n            // indicate specific handling (JsonSerializable), or main types that have\n            // precedence over container types\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [databind#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n            //    this call was BEFORE custom serializer lookup, which was wrong.\n            if (ser == null) {\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n        }\n        \n        if (ser == null) {\n            // Otherwise, we will check \"primary types\"; both marker types that\n            // indicate specific handling (JsonSerializable), or main types that have\n            // precedence over container types\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [databind#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.ser.TestJsonValue::testJsonValueWithCustomOverride": {
        "path": "com/fasterxml/jackson/databind/ser/TestJsonValue.java",
        "function_name": "testJsonValueWithCustomOverride",
        "src": "public void testJsonValueWithCustomOverride() throws Exception\n    {\n        final Bean838 INPUT = new Bean838();\n\n        // by default, @JsonValue should be used\n        assertEquals(quote(\"value\"), MAPPER.writeValueAsString(INPUT));\n\n        // but custom serializer should override it\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerModule(new SimpleModule()\n            .addSerializer(Bean838.class, new Bean838Serializer())\n            );\n        assertEquals(\"42\", mapper.writeValueAsString(INPUT));\n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.TestJsonValue::testJsonValueWithCustomOverride --> junit.framework.ComparisonFailure: expected:<[42]> but was:<[value]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[42]> but was:<[value]>"
      }
    }
  },
  "JacksonDatabind-25": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
        "start_loc": 1747,
        "end_loc": 1811,
        "buggy_function": "    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }",
        "fixed_function": "    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }",
        "comment": "/**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
        "start_loc": 468,
        "end_loc": 543,
        "buggy_function": "    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }",
        "fixed_function": "    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }",
        "comment": "/**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type derived from the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
        "start_loc": 144,
        "end_loc": 184,
        "buggy_function": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = _baseType.narrowBy(type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }",
        "fixed_function": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java",
        "start_loc": 70,
        "end_loc": 81,
        "buggy_function": "    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return type.narrowBy(dst);\n    }",
        "fixed_function": "    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return config.getTypeFactory().constructSpecializedType(type, dst);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890": {
        "path": "com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java",
        "function_name": "testByteArrayTypeOverride890",
        "src": "public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n        assertNotNull(result);\n        assertNotNull(result.someBytes);\n        assertEquals(byte[].class, result.someBytes.getClass());\n    }",
        "error_msg": "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890 --> com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean"
      }
    }
  },
  "JacksonDatabind-30": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "start_loc": 2504,
        "end_loc": 2520,
        "buggy_function": "    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } ",
        "fixed_function": "    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } ",
        "comment": "/**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: while results are usually identical to that of serialization followed\n     * by deserialization, this is not always the case. In some cases serialization\n     * into intermediate representation will retain encapsulation of things like\n     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n     * node identity ({@link JsonNode}). If so, result is a valid tree, but values\n     * are not re-constructed through actual JSON representation. So if transformation\n     * requires actual materialization of JSON (or other data format that this mapper\n     * produces), it will be necessary to do actual serialization.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "start_loc": 3408,
        "end_loc": 3455,
        "buggy_function": "    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
        "fixed_function": "    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
        "comment": "/**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "start_loc": 177,
        "end_loc": 188,
        "buggy_function": "    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }",
        "fixed_function": "    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        _forceBigDecimal = (ctxt == null) ? false\n                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    }",
        "comment": "/**\n     * @since 2.7\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "start_loc": 917,
        "end_loc": 990,
        "buggy_function": "    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }",
        "fixed_function": "    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n        _forceBigDecimal = b;\n        return this;\n    }",
        "comment": "/**\n     * @since 2.7\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965": {
        "path": "com/fasterxml/jackson/databind/jsontype/TestExternalId.java",
        "function_name": "testBigDecimal965",
        "src": "public void testBigDecimal965() throws Exception\n    {\n\n        Wrapper965 w = new Wrapper965();\n        w.typeEnum = Type965.BIG_DECIMAL;\n        final String NUM_STR = \"-10000000000.0000000001\";\n        w.value = new BigDecimal(NUM_STR);\n\n        String json = MAPPER.writeValueAsString(w);\n\n        // simple sanity check so serialization is faithful\n        if (!json.contains(NUM_STR)) {\n            fail(\"JSON content should contain value '\"+NUM_STR+\"', does not appear to: \"+json);\n        }\n        \n        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)\n                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n                .readValue(json);\n\n        assertEquals(w.typeEnum, w2.typeEnum);\n        assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n            w.value.equals(w2.value));\n    }",
        "error_msg": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965 --> junit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10"
      }
    }
  },
  "JacksonDatabind-38": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java",
        "start_loc": 46,
        "end_loc": 54,
        "buggy_function": "    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        return new CollectionType(rawType, null,\n                // !!! TODO: Wrong, does have supertypes, but:\n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }",
        "fixed_function": "    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 1)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, elemT);\n        }\n        return new CollectionType(rawType, bindings,\n                // !!! TODO: Wrong, does have supertypes, but:\n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }",
        "comment": "/**\n     * @deprecated Since 2.7, remove from 2.8\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/MapType.java",
        "start_loc": 42,
        "end_loc": 50,
        "buggy_function": "    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n    {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        // !!! TODO: Wrong, does have supertypes\n        return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }",
        "fixed_function": "    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n    {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 2)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, keyT, valueT);\n        }\n        // !!! TODO: Wrong, does have supertypes\n        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java",
        "start_loc": 100,
        "end_loc": 118,
        "buggy_function": "    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls, TypeBindings.emptyBindings(),\n                _bogusSuperClass(cls), null, null, null, false);\n    }",
        "fixed_function": "    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        TypeBindings b = TypeBindings.emptyBindings();\n        return new SimpleType(cls, b,\n                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n    }",
        "comment": "/**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitMapType": {
        "path": "com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java",
        "function_name": "testExplicitMapType",
        "src": "@SuppressWarnings(\"deprecation\")\n    public void testExplicitMapType() throws Exception\n    {\n        JavaType key = SimpleType.construct(String.class);\n        JavaType elem = SimpleType.construct(Point.class);\n        JavaType t = MapType.construct(Map.class, key, elem);\n\n        final String json = aposToQuotes(\"{'x':{'x':3,'y':5}}\");        \n\n        Map<String,Point> m = MAPPER.readValue(json, t);\n        assertNotNull(m);\n        assertEquals(1, m.size());\n        Object ob = m.values().iterator().next();\n        assertEquals(Point.class, ob.getClass());\n        Point p = (Point) ob;\n        assertEquals(3, p.x);\n        assertEquals(5, p.getY());\n    }",
        "error_msg": "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitMapType --> junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>"
      },
      "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitCollectionType": {
        "path": "com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java",
        "function_name": "testExplicitCollectionType",
        "src": "@SuppressWarnings(\"deprecation\")\n    public void testExplicitCollectionType() throws Exception\n    {\n        JavaType elem = SimpleType.construct(Point.class);\n        JavaType t = CollectionType.construct(List.class, elem);\n\n        final String json = aposToQuotes(\"[ {'x':1,'y':2}, {'x':3,'y':6 }]\");        \n\n        List<Point> l = MAPPER.readValue(json, t);\n        assertNotNull(l);\n        assertEquals(2, l.size());\n        Object ob = l.get(0);\n        assertEquals(Point.class, ob.getClass());\n        Point p = (Point) ob;\n        assertEquals(1, p.x);\n        assertEquals(2, p.getY());\n    }",
        "error_msg": "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitCollectionType --> junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>"
      },
      "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testPOJOSubType": {
        "path": "com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java",
        "function_name": "testPOJOSubType",
        "src": "@SuppressWarnings(\"deprecation\")\n    public void testPOJOSubType() throws Exception\n    {\n        JavaType elem = SimpleType.construct(Point3D.class);\n\n        Point3D p = MAPPER.readValue(aposToQuotes(\"{'x':1,'z':3,'y':2}\"), elem);\n        assertNotNull(p);\n        assertEquals(1, p.x);\n        assertEquals(2, p.getY());\n        assertEquals(3, p.z);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testPOJOSubType --> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field x (class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point3D), not marked as ignorable (one known property: z])",
        "clean_error_msg": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field x (class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point3D), not marked as ignorable (one known property: z])"
      }
    }
  },
  "JacksonDatabind-48": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java",
        "start_loc": 770,
        "end_loc": 784,
        "buggy_function": "    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }",
        "fixed_function": "    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java",
        "start_loc": 860,
        "end_loc": 875,
        "buggy_function": "    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        // then global overrides (disabling)\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }",
        "fixed_function": "    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        // then global overrides (disabling)\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.ser.TestFeatures::testVisibilityFeatures": {
        "path": "com/fasterxml/jackson/databind/ser/TestFeatures.java",
        "function_name": "testVisibilityFeatures",
        "src": "public void testVisibilityFeatures() throws Exception\n    {\n        ObjectMapper om = new ObjectMapper();\n        // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).\n        om.configure(MapperFeature.AUTO_DETECT_FIELDS, false);\n        om.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_SETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n        om.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n        om.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);\n        om.configure(MapperFeature.INFER_PROPERTY_MUTATORS, false);\n        om.configure(MapperFeature.USE_ANNOTATIONS, true);\n\n        JavaType javaType = om.getTypeFactory().constructType(TCls.class);        \n        BeanDescription desc = (BeanDescription) om.getSerializationConfig().introspect(javaType);\n        List<BeanPropertyDefinition> props = desc.findProperties();\n        if (props.size() != 1) {\n            fail(\"Should find 1 property, not \"+props.size()+\"; properties = \"+props);\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.TestFeatures::testVisibilityFeatures --> junit.framework.AssertionFailedError: Should find 1 property, not 2; properties = [[Property 'name'; ctors: null, field(s): null, getter(s): null, setter(s): [method com.fasterxml.jackson.databind.ser.TestFeatures$TCls#setName(1 params)][visible=true,ignore=false,explicitName=false]], [Property 'groupname'; ctors: null, field(s): [field com.fasterxml.jackson.databind.ser.TestFeatures$TCls#groupname][visible=true,ignore=false,explicitName=true], getter(s): null, setter(s): null]]",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should find 1 property, not 2; properties = [[Property 'name'; ctors: null, field(s): null, getter(s): null, setter(s): [method com.fasterxml.jackson.databind.ser.TestFeatures$TCls#setName(1 params)][visible=true,ignore=false,explicitName=false]], [Property 'groupname'; ctors: null, field(s): [field com.fasterxml.jackson.databind.ser.TestFeatures$TCls#groupname][visible=true,ignore=false,explicitName=true], getter(s): null, setter(s): null]]"
      }
    }
  },
  "JacksonDatabind-53": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "start_loc": 312,
        "end_loc": 454,
        "buggy_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n            \n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                TypeBindings tb = null;\n                if (baseType.containedTypeCount() == typeParamCount) {\n                    if (typeParamCount == 1) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n                    } else if (typeParamCount == 2) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n                                baseType.containedType(1));\n                    }\n                }\n                newType = _fromClass(null, subclass,\n                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }",
        "fixed_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n            \n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }",
        "comment": "/**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "start_loc": 1152,
        "end_loc": 1229,
        "buggy_function": "    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // Very first thing: small set of core types we know well:\n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        // Barring that, we may have recently constructed an instance\n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType);\n        if (result != null) {\n            return result;\n            }\n        }\n\n        // 15-Oct-2015, tatu: recursive reference?\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Self-reference: needs special handling, then...\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // no, but need to update context to allow for proper cycle resolution\n            context = context.child(rawType);\n        }\n\n        // First: do we have an array type?\n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            // If not, need to proceed by first resolving parent type hierarchy\n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                // Note: even Enums can implement interfaces, so can not drop those\n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            // And then check what flavor of type we got. Start by asking resolved\n            // super-type if refinement is all that is needed?\n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            // if not, perhaps we are now resolving a well-known class or interface?\n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        // but if nothing else, \"simple\" class for now:\n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result);\n        }\n        return result;\n    }",
        "fixed_function": "    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)\n    {\n        // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n        // (hopefully passing null Class for root is ok)\n        int baseCount = baseType.containedTypeCount();\n        if (baseCount == typeParamCount) {\n            if (typeParamCount == 1) {\n                return TypeBindings.create(subclass, baseType.containedType(0));\n            }\n            if (typeParamCount == 2) {\n                return TypeBindings.create(subclass, baseType.containedType(0),\n                        baseType.containedType(1));\n            }\n            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n            for (int i = 0; i < baseCount; ++i) {\n                types.add(baseType.containedType(i));\n            }\n            return TypeBindings.create(subclass, types);\n        }\n        // Otherwise, two choices: match N first, or empty. Do latter, for now\n        return TypeBindings.emptyBindings();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test::testMapRefinement": {
        "path": "com/fasterxml/jackson/databind/jsontype/TypeRefinementForMap1215Test.java",
        "function_name": "testMapRefinement",
        "src": "public void testMapRefinement() throws Exception\n    {\n        String ID1 = \"3a6383d4-8123-4c43-8b8d-7cedf3e59404\";\n        String ID2 = \"81c3d978-90c4-4b00-8da1-1c39ffcab02c\";\n        String json = aposToQuotes(\n\"{'id':'\"+ID1+\"','items':[{'id':'\"+ID2+\"','property':'value'}]}\");\n\n        ObjectMapper m = new ObjectMapper();\n        Data data = m.readValue(json, Data.class);\n\n        assertEquals(ID1, data.id);\n        assertNotNull(data.items);\n        assertEquals(1, data.items.size());\n        Item value = data.items.get(ID2);\n        assertNotNull(value);\n        assertEquals(\"value\", value.property);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test::testMapRefinement --> com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test$HasUniqueId, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test$HasUniqueId, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information"
      }
    }
  },
  "JacksonDatabind-59": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java",
        "start_loc": 129,
        "end_loc": 134,
        "buggy_function": "    @Override\n    public CollectionLikeType withContentValueHandler(Object h) {\n        return new CollectionLikeType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }",
        "fixed_function": "    @Override\n    public JavaType withHandlersFrom(JavaType src) {\n        JavaType type = super.withHandlersFrom(src);\n        JavaType srcCt = src.getContentType();\n        if (srcCt != null) {\n            JavaType ct = _elementType.withHandlersFrom(srcCt);\n            if (ct != _elementType) {\n                type = type.withContentType(ct);\n            }\n        }\n        return type;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java",
        "start_loc": 141,
        "end_loc": 146,
        "buggy_function": "    @Override\n    public MapLikeType withContentValueHandler(Object h) {\n        return new MapLikeType(_class, _bindings, _superClass,\n                _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }",
        "fixed_function": "    @Override\n    public JavaType withHandlersFrom(JavaType src) {\n        JavaType type = super.withHandlersFrom(src);\n        JavaType srcKeyType = src.getKeyType();\n        // \"withKeyType()\" not part of JavaType, hence must verify:\n        if (type instanceof MapLikeType) {\n            if (srcKeyType != null) {\n                JavaType ct = _keyType.withHandlersFrom(srcKeyType);\n                if (ct != _keyType) {\n                    type = ((MapLikeType) type).withKeyType(ct);\n                }\n            }\n        }\n        JavaType srcCt = src.getContentType();\n        if (srcCt != null) {\n            JavaType ct = _valueType.withHandlersFrom(srcCt);\n            if (ct != _valueType) {\n                type = type.withContentType(ct);\n            }\n        }\n        return type;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "start_loc": 342,
        "end_loc": 474,
        "buggy_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n\n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }",
        "fixed_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n\n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }",
        "comment": "/**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest::testMapKeyRefinement1384": {
        "path": "com/fasterxml/jackson/databind/jsontype/TypeRefinementForMapTest.java",
        "function_name": "testMapKeyRefinement1384",
        "src": "public void testMapKeyRefinement1384() throws Exception\n    {\n        final String TEST_INSTANCE_SERIALIZED =\n                \"{\\\"mapProperty\\\":[\\\"java.util.HashMap\\\",{\\\"Compound|Key\\\":\\\"Value\\\"}]}\";\n        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);\n        assertEquals(1, testInstance.mapProperty.size());\n        Object key = testInstance.mapProperty.keySet().iterator().next();\n        assertEquals(CompoundKey.class, key.getClass());\n        String testInstanceSerialized = mapper.writeValueAsString(testInstance);\n        assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest::testMapKeyRefinement1384 --> com.fasterxml.jackson.databind.JsonMappingException: Can not find a (Map) Key deserializer for type [simple type, class com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest$CompoundKey]",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not find a (Map) Key deserializer for type [simple type, class com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest$CompoundKey]"
      }
    }
  },
  "JacksonDatabind-61": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "start_loc": 228,
        "end_loc": 263,
        "buggy_function": "        public boolean useForType(JavaType t)\n        {\n            // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n            //  primitive types too, regardless\n\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                // [databind#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n                return t.isJavaLangObject();\n            }\n        }",
        "fixed_function": "        public boolean useForType(JavaType t)\n        {\n            // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n            //  primitive types too, regardless\n            if (t.isPrimitive()) {\n                return false;\n            }\n\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n                while (t.isReferenceType()) {\n                    t = t.getReferencedType();\n                }\n                // [databind#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n                return t.isJavaLangObject();\n            }\n        }",
        "comment": "/**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java",
        "start_loc": 67,
        "end_loc": 89,
        "buggy_function": "    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes)\n    {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n        //    regardless of setting\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeSerializer(idRes, null);\n        case PROPERTY:\n            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeSerializer(idRes, null);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n        case EXISTING_PROPERTY:\n        \t// as per [#528]\n        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }",
        "fixed_function": "    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes)\n    {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n        //    regardless of setting\n        if (baseType.isPrimitive()) {\n            return null;\n        }\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeSerializer(idRes, null);\n        case PROPERTY:\n            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeSerializer(idRes, null);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n        case EXISTING_PROPERTY:\n        \t// as per [#528]\n        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java",
        "start_loc": 97,
        "end_loc": 144,
        "buggy_function": "    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes)\n    {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n        //    regardless of setting\n\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n        JavaType defaultImpl;\n\n        if (_defaultImpl == null) {\n            defaultImpl = null;\n        } else {\n            // 20-Mar-2016, tatu: It is important to do specialization go through\n            //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n            //   call to JavaType was used, but that can not work reliably with 2.7\n            // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n            //   if so, need to add explicit checks for marker types. Not ideal, but\n            //   seems like a reasonable compromise.\n            if ((_defaultImpl == Void.class)\n                     || (_defaultImpl == NoClass.class)) {\n                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n            } else {\n                defaultImpl = config.getTypeFactory()\n                    .constructSpecializedType(baseType, _defaultImpl);\n            }\n        }\n\n        // First, method for converting type info to type id:\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY\n            return new AsPropertyTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }",
        "fixed_function": "    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes)\n    {\n        if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n        //    regardless of setting\n        if (baseType.isPrimitive()) {\n            return null;\n        }\n\n        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n\n        JavaType defaultImpl;\n\n        if (_defaultImpl == null) {\n            defaultImpl = null;\n        } else {\n            // 20-Mar-2016, tatu: It is important to do specialization go through\n            //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n            //   call to JavaType was used, but that can not work reliably with 2.7\n            // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n            //   if so, need to add explicit checks for marker types. Not ideal, but\n            //   seems like a reasonable compromise.\n            if ((_defaultImpl == Void.class)\n                     || (_defaultImpl == NoClass.class)) {\n                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n            } else {\n                defaultImpl = config.getTypeFactory()\n                    .constructSpecializedType(baseType, _defaultImpl);\n            }\n        }\n\n        // First, method for converting type info to type id:\n        switch (_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY\n            return new AsPropertyTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes,\n                    _typeProperty, _typeIdVisible, defaultImpl);\n        }\n        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest::testDefaultTypingWithLong": {
        "path": "com/fasterxml/jackson/databind/jsontype/DefaultTypingWithPrimitivesTest.java",
        "function_name": "testDefaultTypingWithLong",
        "src": "public void testDefaultTypingWithLong() throws Exception\n    {\n        Data data = new Data();\n        data.key = 1L;\n        Map<String, Object> mapData = new HashMap<String, Object>();\n        mapData.put(\"longInMap\", 2L);\n        mapData.put(\"longAsField\", data);\n\n        // Configure Jackson to preserve types\n        ObjectMapper mapper = new ObjectMapper();\n        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n        resolver.init(JsonTypeInfo.Id.CLASS, null);\n        resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n        resolver.typeProperty(\"__t\");\n        mapper.setDefaultTyping(resolver);\n        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n        // Serialize\n        String json = mapper.writeValueAsString(mapData);\n\n        // Deserialize\n        Map<?,?> result = mapper.readValue(json, Map.class);\n        assertNotNull(result);\n        assertEquals(2, result.size());\n    }",
        "error_msg": "com.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest::testDefaultTypingWithLong --> com.fasterxml.jackson.databind.JsonMappingException: Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[longAsField]->com.fasterxml.jackson.databind.jsontype.Data[key])",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[longAsField]->com.fasterxml.jackson.databind.jsontype.Data[key])"
      }
    }
  },
  "JacksonDatabind-65": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "start_loc": 115,
        "end_loc": 134,
        "buggy_function": "    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "fixed_function": "    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(), re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "start_loc": 519,
        "end_loc": 537,
        "buggy_function": "    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }",
        "fixed_function": "    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "start_loc": 539,
        "end_loc": 570,
        "buggy_function": "    protected boolean isFactoryMethod(AnnotatedMethod am)\n    {\n        /* First: return type must be compatible with the introspected class\n         * (i.e. allowed to be sub-class, although usually is the same class)\n         */\n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        /* Also: must be a recognized factory method, meaning:\n         * (a) marked with @JsonCreator annotation, or\n         * (b) \"valueOf\" (at this point, need not be public)\n         */\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n            return true;\n        }\n        final String name = am.getName();\n        // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n        if (\"valueOf\".equals(name)) {\n                return true;\n        }\n        // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
        "fixed_function": "    protected boolean isFactoryMethod(AnnotatedMethod am)\n    {\n        /* First: return type must be compatible with the introspected class\n         * (i.e. allowed to be sub-class, although usually is the same class)\n         */\n        Class<?> rt = am.getRawReturnType();\n        if (!getBeanClass().isAssignableFrom(rt)) {\n            return false;\n        }\n        /* Also: must be a recognized factory method, meaning:\n         * (a) marked with @JsonCreator annotation, or\n         * (b) \"valueOf\" (at this point, need not be public)\n         */\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n            return true;\n        }\n        final String name = am.getName();\n        // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n        if (\"valueOf\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                return true;\n            }\n        }\n        // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n        if (\"fromString\".equals(name)) {\n            if (am.getParameterCount() == 1) {\n                Class<?> cls = am.getRawParameterType(0);\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.deser.KeyDeser1429Test::testDeserializeKeyViaFactory": {
        "path": "com/fasterxml/jackson/databind/deser/KeyDeser1429Test.java",
        "function_name": "testDeserializeKeyViaFactory",
        "src": "public void testDeserializeKeyViaFactory() throws Exception\n    {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\",\n                    new TypeReference<Map<FullName, Double>>() { });\n        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();\n        FullName key = entry.getKey();\n        assertEquals(key._firstname, \"first\");\n        assertEquals(key._lastname, \"last\");\n        assertEquals(entry.getValue().doubleValue(), 42, 0);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.deser.KeyDeser1429Test::testDeserializeKeyViaFactory --> com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.deser.KeyDeser1429Test$FullName from String first.last: not a valid representation, problem: wrong number of arguments",
        "clean_error_msg": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.deser.KeyDeser1429Test$FullName from String first.last: not a valid representation, problem: wrong number of arguments"
      }
    }
  },
  "JacksonDatabind-73": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java",
        "start_loc": 723,
        "end_loc": 733,
        "buggy_function": "    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)\n    {\n        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n            // 26-Jan-2017, tatu: [databind#935]: need to denote removal of\n            prop.removeNonVisible(inferMutators);\n        }\n    }",
        "fixed_function": "    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)\n    {\n        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n        Iterator<POJOPropertyBuilder> it = props.values().iterator();\n\n        while (it.hasNext()) {\n            POJOPropertyBuilder prop = it.next();\n            // 26-Jan-2017, tatu: [databind#935]: need to denote removal of\n            Access acc = prop.removeNonVisible(inferMutators);\n            if (!_forSerialization && (acc == Access.READ_ONLY)) {\n                _collectIgnorals(prop.getName());\n            }\n        }\n    }",
        "comment": "/**\n     * Method called to further get rid of unwanted individual accessors,\n     * based on read/write settings and rules for \"pulling in\" accessors\n     * (or not).\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java",
        "start_loc": 644,
        "end_loc": 683,
        "buggy_function": "    public void removeNonVisible(boolean inferMutators)\n    {\n        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition\n         *  of explicit access type for property; if not \"AUTO\", it will\n         *  dictate how visibility checks are applied.\n         */\n        JsonProperty.Access acc = findAccess();\n        if (acc == null) {\n            acc = JsonProperty.Access.AUTO;\n        }\n        switch (acc) {\n        case READ_ONLY:\n            // Remove setters, creators for sure, but fields too if deserializing\n            _setters = null;\n            _ctorParameters = null;\n            if (!_forSerialization) {\n                _fields = null;\n            }\n            break;\n        case READ_WRITE:\n            // no trimming whatsoever?\n            break;\n        case WRITE_ONLY:\n            // remove getters, definitely, but also fields if serializing\n            _getters = null;\n            if (_forSerialization) {\n                _fields = null;\n            }\n            break;\n        default:\n        case AUTO: // the default case: base it on visibility\n            _getters = _removeNonVisible(_getters);\n            _ctorParameters = _removeNonVisible(_ctorParameters);\n    \n            if (!inferMutators || (_getters == null)) {\n                _fields = _removeNonVisible(_fields);\n                _setters = _removeNonVisible(_setters);\n            }\n        }\n    }",
        "fixed_function": "    public JsonProperty.Access removeNonVisible(boolean inferMutators)\n    {\n        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition\n         *  of explicit access type for property; if not \"AUTO\", it will\n         *  dictate how visibility checks are applied.\n         */\n        JsonProperty.Access acc = findAccess();\n        if (acc == null) {\n            acc = JsonProperty.Access.AUTO;\n        }\n        switch (acc) {\n        case READ_ONLY:\n            // Remove setters, creators for sure, but fields too if deserializing\n            _setters = null;\n            _ctorParameters = null;\n            if (!_forSerialization) {\n                _fields = null;\n            }\n            break;\n        case READ_WRITE:\n            // no trimming whatsoever?\n            break;\n        case WRITE_ONLY:\n            // remove getters, definitely, but also fields if serializing\n            _getters = null;\n            if (_forSerialization) {\n                _fields = null;\n            }\n            break;\n        default:\n        case AUTO: // the default case: base it on visibility\n            _getters = _removeNonVisible(_getters);\n            _ctorParameters = _removeNonVisible(_ctorParameters);\n    \n            if (!inferMutators || (_getters == null)) {\n                _fields = _removeNonVisible(_fields);\n                _setters = _removeNonVisible(_setters);\n            }\n        }\n        return acc;\n    }",
        "comment": "/**\n     * @param inferMutators Whether mutators can be \"pulled in\" by visible\n     *    accessors or not. \n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnlyAndWriteOnly": {
        "path": "com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java",
        "function_name": "testReadOnlyAndWriteOnly",
        "src": "public void testReadOnlyAndWriteOnly() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReadXWriteY());\n        assertEquals(\"{\\\"x\\\":1}\", json);\n\n        ReadXWriteY result = MAPPER.readValue(\"{\\\"x\\\":5, \\\"y\\\":6}\", ReadXWriteY.class);\n        assertNotNull(result);\n        assertEquals(1, result.x);\n        assertEquals(6, result.y);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnlyAndWriteOnly --> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field x (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$ReadXWriteY), not marked as ignorable (one known property: y])",
        "clean_error_msg": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field x (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$ReadXWriteY), not marked as ignorable (one known property: y])"
      },
      "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnly935": {
        "path": "com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java",
        "function_name": "testReadOnly935",
        "src": "public void testReadOnly935() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new Pojo935());\n        Pojo935 result = MAPPER.readValue(json, Pojo935.class);\n        assertNotNull(result);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnly935 --> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field fullName (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$Pojo935), not marked as ignorable (2 known properties: lastName, firstName])",
        "clean_error_msg": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field fullName (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$Pojo935), not marked as ignorable (2 known properties: lastName, firstName])"
      }
    }
  },
  "JacksonDatabind-79": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java",
        "start_loc": 576,
        "end_loc": 583,
        "buggy_function": "    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }",
        "fixed_function": "    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref == null) {\n            return objectIdInfo;\n        }\n        if (objectIdInfo == null) {\n            objectIdInfo = ObjectIdInfo.empty();\n        }\n        return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java",
        "start_loc": 50,
        "end_loc": 61,
        "buggy_function": "    protected ObjectIdInfo(PropertyName prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n            boolean alwaysAsId, Class<? extends ObjectIdResolver> resolver)\n    {\n        _propertyName = prop;\n        _scope = scope;\n        _generator = gen;\n        _alwaysAsId = alwaysAsId;\n        if (resolver == null) {\n            resolver = SimpleObjectIdResolver.class;\n        }\n        _resolver = resolver;\n    }",
        "fixed_function": "    public static ObjectIdInfo empty() {\n        return EMPTY;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java",
        "start_loc": 383,
        "end_loc": 516,
        "buggy_function": "    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        final SerializationConfig config = provider.getConfig();\n        \n        // Let's start with one big transmutation: Enums that are annotated\n        // to serialize as Objects may want to revert\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n                // or, alternatively, asked to revert \"back to\" other representations...\n                if (shape != _serializationShape) {\n                    if (_handledType.isEnum()) {\n                        switch (shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n                                    provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        }\n                    }\n                }\n            }\n        }\n\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        Object newFilterId = null;\n        \n        // Then we may have an override for Object Id\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor, true);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo == null) {\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor,\n                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                        oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n                // to be able to move to SerializerProvider (where it really belongs)\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName().getSimpleName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n            \n            // Or change Filter Id in use?\n            Object filterId = intr.findFilterId(accessor);\n            if (filterId != null) {\n                // but only consider case of adding a new filter id (no removal via annotation)\n                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                    newFilterId = filterId;\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        if (newFilterId != null) {\n            contextual = contextual.withFilterId(newFilterId);\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            return contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
        "fixed_function": "    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        final SerializationConfig config = provider.getConfig();\n        \n        // Let's start with one big transmutation: Enums that are annotated\n        // to serialize as Objects may want to revert\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n                // or, alternatively, asked to revert \"back to\" other representations...\n                if (shape != _serializationShape) {\n                    if (_handledType.isEnum()) {\n                        switch (shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n                                    provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        }\n                    }\n                }\n            }\n        }\n\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        Object newFilterId = null;\n        \n        // Then we may have an override for Object Id\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor, true);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo == null) {\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, null);\n                    if (objectIdInfo != null) {\n                        oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                    }\n                }\n            } else {\n                // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n                // to be able to move to SerializerProvider (where it really belongs)\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName().getSimpleName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n            \n            // Or change Filter Id in use?\n            Object filterId = intr.findFilterId(accessor);\n            if (filterId != null) {\n                // but only consider case of adding a new filter id (no removal via annotation)\n                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                    newFilterId = filterId;\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        if (newFilterId != null) {\n            contextual = contextual.withFilterId(newFilterId);\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            return contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1607": {
        "path": "com/fasterxml/jackson/databind/objectid/AlwaysAsReferenceFirstTest.java",
        "function_name": "testIssue1607",
        "src": "public void testIssue1607() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer());\n        assertEquals(aposToQuotes(\"{'alwaysClass':1,'alwaysProp':2}\"), json);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1607 --> junit.framework.ComparisonFailure: expected:<{alwaysClass:[1],alwaysProp:2}> but was:<{alwaysClass:[{id:1,value:13}],alwaysProp:2}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<{alwaysClass:[1],alwaysProp:2}> but was:<{alwaysClass:[{id:1,value:13}],alwaysProp:2}>"
      }
    }
  },
  "JacksonDatabind-90": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java",
        "start_loc": 70,
        "end_loc": 76,
        "buggy_function": "    public boolean canInstantiate() {\n        return canCreateUsingDefault()\n                || canCreateUsingDelegate() \n                || canCreateFromObjectWith() || canCreateFromString()\n                || canCreateFromInt() || canCreateFromLong()\n                || canCreateFromDouble() || canCreateFromBoolean();\n    }",
        "fixed_function": "    public boolean canInstantiate() {\n        return canCreateUsingDefault()\n                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n                || canCreateFromObjectWith() || canCreateFromString()\n                || canCreateFromInt() || canCreateFromLong()\n                || canCreateFromDouble() || canCreateFromBoolean();\n    }",
        "comment": "/**\n     * Method that will return true if any of <code>canCreateXxx</code> method\n     * returns true: that is, if there is any way that an instance could\n     * be created.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java",
        "start_loc": 227,
        "end_loc": 230,
        "buggy_function": "    @Override\n    public boolean canCreateFromObjectWith() {\n        return (_withArgsCreator != null);\n    }",
        "fixed_function": "    @Override\n    public boolean canInstantiate() {\n        return canCreateUsingDefault()\n                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n                || canCreateFromObjectWith() || canCreateFromString()\n                || canCreateFromInt() || canCreateFromLong()\n                || canCreateFromDouble() || canCreateFromBoolean();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test::testDelegatingArray1804": {
        "path": "com/fasterxml/jackson/databind/creators/DelegatingArrayCreator1804Test.java",
        "function_name": "testDelegatingArray1804",
        "src": "public void testDelegatingArray1804() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        MyType thing = mapper.readValue(\"[]\", MyType.class);\n        assertNotNull(thing);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test::testDelegatingArray1804 --> com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test$MyType: abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test$MyType: abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information"
      }
    }
  },
  "JacksonDatabind-95": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "start_loc": 342,
        "end_loc": 412,
        "buggy_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (4) If all else fails, do the full traversal using placeholders\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            newType = _fromClass(null, subclass, tb);\n\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n    }",
        "fixed_function": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, EMPTY_BINDINGS);\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (4) If all else fails, do the full traversal using placeholders\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            newType = _fromClass(null, subclass, tb);\n\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n    }",
        "comment": "/**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "start_loc": 892,
        "end_loc": 899,
        "buggy_function": "    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }",
        "fixed_function": "    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);\n        }\n        return constructParametricType(parametrized, pt);\n    }",
        "comment": "/**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java",
        "start_loc": 40,
        "end_loc": 60,
        "buggy_function": "    protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException\n    {\n        if (!tokens.hasMoreTokens()) {\n            throw _problem(tokens, \"Unexpected end-of-string\");\n        }\n        Class<?> base = findClass(tokens.nextToken(), tokens);\n\n        // either end (ok, non generic type), or generics\n        if (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n            if (\"<\".equals(token)) {\n                List<JavaType> parameterTypes = parseTypes(tokens);\n                TypeBindings b = TypeBindings.create(base, parameterTypes);\n                return _factory._fromClass(null, base, b);\n            }\n            // can be comma that separates types, or closing '>'\n            tokens.pushBack(token);\n        }\n        return _factory._fromClass(null, base, null);\n    }",
        "fixed_function": "    protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException\n    {\n        if (!tokens.hasMoreTokens()) {\n            throw _problem(tokens, \"Unexpected end-of-string\");\n        }\n        Class<?> base = findClass(tokens.nextToken(), tokens);\n\n        // either end (ok, non generic type), or generics\n        if (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n            if (\"<\".equals(token)) {\n                List<JavaType> parameterTypes = parseTypes(tokens);\n                TypeBindings b = TypeBindings.create(base, parameterTypes);\n                return _factory._fromClass(null, base, b);\n            }\n            // can be comma that separates types, or closing '>'\n            tokens.pushBack(token);\n        }\n        return _factory._fromClass(null, base, TypeBindings.emptyBindings());\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames": {
        "path": "com/fasterxml/jackson/databind/type/TestTypeFactory.java",
        "function_name": "testCanonicalNames",
        "src": "public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        assertEquals(\"java.util.Calendar\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        assertEquals(List.class, t.getRawClass());\n        assertEquals(CollectionType.class, t.getClass());\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        assertEquals(Object.class, t.getContentType().getRawClass());\n        can = t.toCanonical();\n        assertEquals(\"java.util.List<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n    }",
        "error_msg": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "JacksonDatabind-103": {
    "function_num": 22,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/DatabindContext.java",
        "start_loc": 170,
        "end_loc": 202,
        "buggy_function": "    public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException\n    {\n        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n        //    check if any generics info is added; and only then ask factory\n        //    to do translation when necessary\n        if (subClass.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { // let caller handle this problem\n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        e.getMessage()));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }",
        "fixed_function": "    public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException\n    {\n        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n        //    check if any generics info is added; and only then ask factory\n        //    to do translation when necessary\n        if (subClass.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { // let caller handle this problem\n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        ClassUtil.exceptionMessage(e)));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }",
        "comment": "/**\n     * Lookup method called when code needs to resolve class name from input;\n     * usually simple lookup\n     *\n     * @since 2.9\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
        "start_loc": 706,
        "end_loc": 716,
        "buggy_function": "    public Date parseDate(String dateStr) throws IllegalArgumentException\n    {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    e.getMessage()));\n        }\n    }",
        "fixed_function": "    public Date parseDate(String dateStr) throws IllegalArgumentException\n    {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    ClassUtil.exceptionMessage(e)));\n        }\n    }",
        "comment": "/**\n     * Convenience method for parsing a Date from given String, using\n     * currently configured date format (accessed using\n     * {@link DeserializationConfig#getDateFormat()}).\n     *<p>\n     * Implementation will handle thread-safety issues related to\n     * date formats such that first time this method is called,\n     * date format is cloned, and cloned instance will be retained\n     * for use during this deserialization round.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
        "start_loc": 1597,
        "end_loc": 1611,
        "buggy_function": "    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        // Most likely problem with Creator definition, right?\n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = cause.getMessage()) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }",
        "fixed_function": "    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        // Most likely problem with Creator definition, right?\n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }",
        "comment": "/**\n     * Helper method for constructing instantiation exception for specified type,\n     * to indicate problem with physically constructing instance of\n     * specified class (missing constructor, exception from constructor)\n     *<p>\n     * Note that most of the time this method should NOT be called directly; instead,\n     * {@link #handleInstantiationProblem} should be called which will call this method\n     * if necessary.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
        "start_loc": 335,
        "end_loc": 340,
        "buggy_function": "    public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        src.getMessage()));\n    }",
        "fixed_function": "    public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        ClassUtil.exceptionMessage(src)));\n    }",
        "comment": "/**\n     * Factory method used when \"upgrading\" an {@link IOException} into\n     * {@link JsonMappingException}: usually only needed to comply with\n     * a signature.\n     *<p>\n     * NOTE: since 2.9 should usually NOT be used on input-side (deserialization)\n     *    exceptions; instead use method(s) of <code>InputMismatchException</code>\n     * \n     * @since 2.1\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
        "start_loc": 372,
        "end_loc": 397,
        "buggy_function": "    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n    {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            // [databind#2128]: try to avoid duplication\n            String msg = src.getMessage();\n            // Let's use a more meaningful placeholder if all we have is null\n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along\n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }",
        "fixed_function": "    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n    {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            // [databind#2128]: try to avoid duplication\n            String msg = ClassUtil.exceptionMessage(src);\n            // Let's use a more meaningful placeholder if all we have is null\n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along\n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }",
        "comment": "/**\n     * Method that can be called to either create a new JsonMappingException\n     * (if underlying exception is not a JsonMappingException), or augment\n     * given exception with given path/reference information.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java",
        "start_loc": 1330,
        "end_loc": 1349,
        "buggy_function": "    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException\n    {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null; // doesn't matter but compiler whines otherwise\n            reportMappingProblem(iae, iae.getMessage());\n        }\n\n        if (ser != null) {\n            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key\n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException\n    {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null; // doesn't matter but compiler whines otherwise\n            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n        }\n\n        if (ser != null) {\n            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key\n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }",
        "comment": "/**\n     * Method that will try to construct a value serializer; and if\n     * one is successfully created, cache it for reuse.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java",
        "start_loc": 1351,
        "end_loc": 1369,
        "buggy_function": "    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException\n    {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null;\n            reportMappingProblem(iae, iae.getMessage());\n        }\n    \n        if (ser != null) {\n            // 21-Dec-2015, tatu: Should we also cache using raw key?\n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }",
        "fixed_function": "    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException\n    {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null;\n            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n        }\n    \n        if (ser != null) {\n            // 21-Dec-2015, tatu: Should we also cache using raw key?\n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
        "start_loc": 1554,
        "end_loc": 1593,
        "buggy_function": "    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }",
        "fixed_function": "    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    ClassUtil.exceptionMessage(e0), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }",
        "comment": "/*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): type deserializers\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
        "start_loc": 201,
        "end_loc": 256,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    ClassUtil.exceptionMessage(e),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "comment": "/**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
        "start_loc": 265,
        "end_loc": 323,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n        // Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n        // Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    ClassUtil.exceptionMessage(e),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "comment": "/**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
        "start_loc": 258,
        "end_loc": 300,
        "buggy_function": "    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }",
        "fixed_function": "    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }",
        "comment": "/**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java",
        "start_loc": 194,
        "end_loc": 215,
        "buggy_function": "    protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, t.getMessage(), t);\n    }",
        "fixed_function": "    protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = ClassUtil.exceptionMessage(e);\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);\n    }",
        "comment": "/**\n     * @param e Exception to re-throw or wrap\n     * @param propName Name of property (from Json input) to set\n     * @param value Value of the property\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java",
        "start_loc": 580,
        "end_loc": 600,
        "buggy_function": "    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }",
        "fixed_function": "    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = ClassUtil.exceptionMessage(e);\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }",
        "comment": "/**\n     * Method that takes in exception of any type, and casts or wraps it\n     * to an IOException or its subclass.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java",
        "start_loc": 605,
        "end_loc": 612,
        "buggy_function": "    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException\n    {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, th.getMessage(), th);\n    }",
        "fixed_function": "    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException\n    {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);\n    }",
        "comment": "/**\n     * @since 2.7\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java",
        "start_loc": 514,
        "end_loc": 528,
        "buggy_function": "    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException\n    {\n        try {\n            // Take empty Strings to mean 'empty' Value, usually 'null':\n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    iae.getMessage());\n        }\n    }",
        "fixed_function": "    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException\n    {\n        try {\n            // Take empty Strings to mean 'empty' Value, usually 'null':\n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    ClassUtil.exceptionMessage(iae));\n        }\n    }",
        "comment": "/**\n     * @since 2.8\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "start_loc": 120,
        "end_loc": 141,
        "buggy_function": "    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "fixed_function": "    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    ClassUtil.exceptionMessage(re));\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "start_loc": 260,
        "end_loc": 263,
        "buggy_function": "    protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                e.getMessage());\n    }",
        "fixed_function": "    protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                ClassUtil.exceptionMessage(e));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java",
        "start_loc": 445,
        "end_loc": 457,
        "buggy_function": "    @Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t)\n    {\n        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n        //   does so if and until `JsonMappingException` is found.\n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n    }",
        "fixed_function": "    @Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t)\n    {\n        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n        //   does so if and until `JsonMappingException` is found.\n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+ClassUtil.exceptionMessage(t), t);\n    }",
        "comment": "/**\n     * @deprecated Since 2.7 call either {@link #unwrapAndWrapException} or\n     *  {@link #wrapAsJsonMappingException}\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "start_loc": 344,
        "end_loc": 366,
        "buggy_function": "    @Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +t.getMessage(), t);\n        }\n    }",
        "fixed_function": "    @Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +ClassUtil.exceptionMessage(t), t);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java",
        "start_loc": 158,
        "end_loc": 175,
        "buggy_function": "    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException\n    {\n        if (filter == null) {\n            return true;\n        }\n        // should let filter decide what to do with nulls:\n        // But just case, let's handle unexpected (from our perspective) problems explicitly\n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; // never gets here\n        }\n    }",
        "fixed_function": "    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException\n    {\n        if (filter == null) {\n            return true;\n        }\n        // should let filter decide what to do with nulls:\n        // But just case, let's handle unexpected (from our perspective) problems explicitly\n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; // never gets here\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java",
        "start_loc": 501,
        "end_loc": 510,
        "buggy_function": "    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }",
        "fixed_function": "    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = ClassUtil.exceptionMessage(e);\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
        "start_loc": 91,
        "end_loc": 244,
        "buggy_function": "    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, e.getMessage());\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n            //    type information for contents. Should work well (for JAXB case); can be\n            //    revisited if this causes problems.\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Mar-2017: [databind#1522] Allow config override per property type\n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            // neither Setter nor ConstructorParameter are expected here\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we cannot for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: // new with 2.9\n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { // is this legal?\n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }",
        "fixed_function": "    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e));\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n            //    type information for contents. Should work well (for JAXB case); can be\n            //    revisited if this causes problems.\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Mar-2017: [databind#1522] Allow config override per property type\n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            // neither Setter nor ConstructorParameter are expected here\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we cannot for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: // new with 2.9\n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { // is this legal?\n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }",
        "comment": "/**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition": {
        "path": "com/fasterxml/jackson/databind/exc/BasicExceptionTest.java",
        "function_name": "testLocationAddition",
        "src": "public void testLocationAddition() throws Exception\n    {\n        try {\n            /*Map<?,?> map =*/ MAPPER.readValue(\"{\\\"value\\\":\\\"foo\\\"}\",\n                    new TypeReference<Map<ABC, Integer>>() { });\n            fail(\"Should not pass\");\n        } catch (MismatchedInputException e) {\n            String msg = e.getMessage();\n            String[] str = msg.split(\" at \\\\[\");\n            if (str.length != 2) {\n                fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n            }\n        }\n    }",
        "error_msg": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition --> junit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String value: not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String value: not one of values excepted for Enum class: [A, B, C]",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String value: not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String value: not one of values excepted for Enum class: [A, B, C]"
      }
    }
  },
  "JacksonDatabind-109": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java",
        "start_loc": 49,
        "end_loc": 63,
        "buggy_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        JsonFormat.Value format = findFormatOverrides(prov, property, handledType());\n        if (format != null) {\n            switch (format.getShape()) {\n            case STRING:\n                // [databind#2264]: Need special handling for `BigDecimal`\n                return ToStringSerializer.instance;\n            default:\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        JsonFormat.Value format = findFormatOverrides(prov, property, handledType());\n        if (format != null) {\n            switch (format.getShape()) {\n            case STRING:\n                // [databind#2264]: Need special handling for `BigDecimal`\n                if (((Class<?>) handledType()) == BigDecimal.class) {\n                    return bigDecimalAsStringSerializer();\n                }\n                return ToStringSerializer.instance;\n            default:\n            }\n        }\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java",
        "start_loc": 92,
        "end_loc": 105,
        "buggy_function": "        @Override\n        public JsonSerializer<?> createContextual(SerializerProvider prov,\n                BeanProperty property) throws JsonMappingException\n        {\n            JsonFormat.Value format = findFormatOverrides(prov, property, handledType());\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    return ToStringSerializer.instance;\n                default:\n                }\n            }\n            return this;\n        }",
        "fixed_function": "        @Override\n        public JsonSerializer<?> createContextual(SerializerProvider prov,\n                BeanProperty property) throws JsonMappingException\n        {\n            JsonFormat.Value format = findFormatOverrides(prov, property, handledType());\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    if (((Class<?>) handledType()) == BigDecimal.class) {\n                        return NumberSerializer.bigDecimalAsStringSerializer();\n                    }\n                    return ToStringSerializer.instance;\n                default:\n                }\n            }\n            return this;\n        }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.ser.jdk.BigDecimalPlain2230Test::testBigIntegerAsPlainTest": {
        "path": "com/fasterxml/jackson/databind/ser/jdk/BigDecimalPlain2230Test.java",
        "function_name": "testBigIntegerAsPlainTest",
        "src": "public void testBigIntegerAsPlainTest() throws Exception\n    {\n        final String NORM_VALUE = \"0.0000000005\";\n        final BigDecimal BD_VALUE = new BigDecimal(NORM_VALUE);\n        final BigDecimalAsString INPUT = new BigDecimalAsString(BD_VALUE);\n        // by default, use the default `toString()`\n        assertEquals(\"{\\\"value\\\":\\\"\"+BD_VALUE.toString()+\"\\\"}\", MAPPER.writeValueAsString(INPUT));\n\n        // but can force to \"plain\" notation\n        final ObjectMapper m = jsonMapperBuilder()\n            .enable(StreamWriteFeature.WRITE_BIGDECIMAL_AS_PLAIN)\n            .build();\n        assertEquals(\"{\\\"value\\\":\\\"\"+NORM_VALUE+\"\\\"}\", m.writeValueAsString(INPUT));\n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.jdk.BigDecimalPlain2230Test::testBigIntegerAsPlainTest --> junit.framework.ComparisonFailure: expected:<{value:[0.0000000005]}> but was:<{value:[5E-10]}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<{value:[0.0000000005]}> but was:<{value:[5E-10]}>"
      }
    }
  },
  "JacksonDatabind-111": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java",
        "start_loc": 129,
        "end_loc": 136,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new CreatorProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new CreatorProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java",
        "start_loc": 87,
        "end_loc": 94,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new FieldProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new FieldProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java",
        "start_loc": 78,
        "end_loc": 85,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new MethodProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new MethodProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java",
        "start_loc": 48,
        "end_loc": 55,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new ObjectIdReferenceProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new ObjectIdReferenceProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java",
        "start_loc": 49,
        "end_loc": 56,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new ObjectIdValueProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new ObjectIdValueProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java",
        "start_loc": 62,
        "end_loc": 69,
        "buggy_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        return new SetterlessProperty(this, deser, _nullProvider);\n    }",
        "fixed_function": "    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        if (_valueDeserializer == deser) {\n            return this;\n        }\n        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n        return new SetterlessProperty(this, deser, nvp);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java",
        "start_loc": 41,
        "end_loc": 44,
        "buggy_function": "    @Override\n    public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n        return new AtomicReference<Object>();\n    }",
        "fixed_function": "    @Override\n    public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n        return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt));\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.deser.jdk.JDKAtomicTypesDeserTest::testNullWithinNested": {
        "path": "com/fasterxml/jackson/databind/deser/jdk/JDKAtomicTypesDeserTest.java",
        "function_name": "testNullWithinNested",
        "src": "public void testNullWithinNested() throws Exception\n    {\n        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);\n        MyBean2303 intRef = r.readValue(\" {\\\"refRef\\\": 2 } \");\n        assertNotNull(intRef.refRef);\n        assertNotNull(intRef.refRef.get());\n        assertEquals(intRef.refRef.get().get(), new Integer(2));\n\n        MyBean2303 nullRef = r.readValue(\" {\\\"refRef\\\": null } \");\n        assertNotNull(nullRef.refRef);\n        assertNotNull(nullRef.refRef.get());\n        assertNull(nullRef.refRef.get().get());\n    }",
        "error_msg": "com.fasterxml.jackson.databind.deser.jdk.JDKAtomicTypesDeserTest::testNullWithinNested --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "JacksonDatabind-128": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
        "start_loc": 1849,
        "end_loc": 1904,
        "buggy_function": "    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        \n        // Also need to handle keyUsing, contentUsing\n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n        }\n\n        if (type.getContentType() != null) { // container type or reference type\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n             *    information to use for polymorphic members; and specifically types for\n             *    collection values (contents).\n             *    ... but only applies to members (fields, methods), not classes\n             */\n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { // classes just have Jackson annotations\n            // probably only occurs if 'property' is null anyway\n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }",
        "fixed_function": "    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n        \n        // Also need to handle keyUsing, contentUsing\n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n        }\n\n        if (type.isContainerType() || type.isReferenceType()) {\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n             *    information to use for polymorphic members; and specifically types for\n             *    collection values (contents).\n             *    ... but only applies to members (fields, methods), not classes\n             */\n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { // classes just have Jackson annotations\n            // probably only occurs if 'property' is null anyway\n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }",
        "comment": "/**\n     * Helper method used to resolve method return types and field\n     * types. The main trick here is that the containing bean may\n     * have type variable binding information (when deserializing\n     * using generic type passed as type reference), which is\n     * needed in some cases.\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java",
        "start_loc": 463,
        "end_loc": 474,
        "buggy_function": "    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        // 17-Apr-2016, tatu: For 2.7.4 make sure ReferenceType also included\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }",
        "fixed_function": "    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        // 17-Apr-2016, tatu: For 2.7.4 make sure ReferenceType also included\n        if (baseType.isContainerType() || baseType.isReferenceType()) {\n            return null;\n        }\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
        "start_loc": 774,
        "end_loc": 809,
        "buggy_function": "    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess(prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        JavaType type = accessor.getType();\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        // Unlike most other code paths, serializer produced\n        // here will NOT be resolved or contextualized, unless done here, so:\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())\n                || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }",
        "fixed_function": "    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess(prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        JavaType type = accessor.getType();\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        // Unlike most other code paths, serializer produced\n        // here will NOT be resolved or contextualized, unless done here, so:\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (type.isContainerType() || type.isReferenceType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }",
        "comment": "/**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.jsontype.PolymorphicViaRefTypeTest::testOptionalWithAtomic": {
        "path": "com/fasterxml/jackson/databind/jsontype/PolymorphicViaRefTypeTest.java",
        "function_name": "testOptionalWithAtomic",
        "src": "public void testOptionalWithAtomic() throws Exception\n    {\n        TypeInfoAtomic data = new TypeInfoAtomic();\n        data.value = new AtomicReference<BaseForAtomic>(new ImplForAtomic(42));\n        String json = MAPPER.writeValueAsString(data);\nSystem.err.println(\"JSON = \"+json);\n        TypeInfoAtomic result = MAPPER.readValue(json, TypeInfoAtomic.class);\n        assertNotNull(result);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.jsontype.PolymorphicViaRefTypeTest::testOptionalWithAtomic --> com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (END_OBJECT), expected FIELD_NAME: missing property '$type' that is to contain type id  (for class com.fasterxml.jackson.databind.jsontype.PolymorphicViaRefTypeTest$BaseForAtomic)",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (END_OBJECT), expected FIELD_NAME: missing property '$type' that is to contain type id  (for class com.fasterxml.jackson.databind.jsontype.PolymorphicViaRefTypeTest$BaseForAtomic)"
      }
    }
  },
  "JacksonDatabind-133": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
        "start_loc": 87,
        "end_loc": 93,
        "buggy_function": "    @Override\n    public boolean isEmpty(SerializerProvider serializers, T value) {\n        // 09-Mar-2017, tatu: as per [databind#1550] timestamp 0 is NOT \"empty\"; but\n        //   with versions up to 2.8.x this was the case. Fixed for 2.9.\n//        return _timestamp(value) == 0L;\n        return _timestamp(value) == 0L;\n    }",
        "fixed_function": "    @Override\n    public boolean isEmpty(SerializerProvider serializers, T value) {\n        // 09-Mar-2017, tatu: as per [databind#1550] timestamp 0 is NOT \"empty\"; but\n        //   with versions up to 2.8.x this was the case. Fixed for 2.9.\n//        return _timestamp(value) == 0L;\n        return false;\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java",
        "start_loc": 127,
        "end_loc": 148,
        "buggy_function": "    public static Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        // 30-Sep-2016, tatu: Also works for Wrappers, so both `Integer.TYPE` and `Integer.class`\n        //    would return `Integer.TYPE`\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        // 09-Mar-2016, tatu: Not sure how far this path we want to go but for now\n        //   let's add `java.util.Date` and `java.util.Calendar`, as per [databind#1550]\n        return null;\n    }",
        "fixed_function": "    public static Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        // 30-Sep-2016, tatu: Also works for Wrappers, so both `Integer.TYPE` and `Integer.class`\n        //    would return `Integer.TYPE`\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        // 09-Mar-2016, tatu: Not sure how far this path we want to go but for now\n        //   let's add `java.util.Date` and `java.util.Calendar`, as per [databind#1550]\n        if (type.isTypeOrSubTypeOf(Date.class)) {\n            return new Date(0L);\n        }\n        if (type.isTypeOrSubTypeOf(Calendar.class)) {\n            Calendar c = new GregorianCalendar();\n            c.setTimeInMillis(0L);\n            return c;\n        }\n        return null;\n    }",
        "comment": "/**\n     * Accessor used to find out \"default value\" to use for comparing values to\n     * serialize, to determine whether to exclude value from serialization with\n     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.\n     *<p>\n     * Default logic is such that for primitives and wrapper types for primitives, expected\n     * defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,\n     * and for structured (Maps, Collections, arrays) and reference types, criteria\n     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}\n     * is used.\n     *\n     * @since 2.7\n     */"
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.ser.filter.JsonIncludeTest::testInclusionOfCalendar": {
        "path": "com/fasterxml/jackson/databind/ser/filter/JsonIncludeTest.java",
        "function_name": "testInclusionOfCalendar",
        "src": "public void testInclusionOfCalendar() throws Exception\n    {\n        final Calendar input = new GregorianCalendar();\n        input.setTimeInMillis(0L);\n        assertEquals(aposToQuotes(\"{'value':0}\"), \n                MAPPER.writeValueAsString(new NonEmptyCalendar(input)));\n        assertEquals(\"{}\", \n                MAPPER.writeValueAsString(new NonDefaultCalendar(input)));\n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.filter.JsonIncludeTest::testInclusionOfCalendar --> junit.framework.ComparisonFailure: expected:<{[value:0]}> but was:<{[]}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<{[value:0]}> but was:<{[]}>"
      },
      "com.fasterxml.jackson.databind.ser.filter.JsonIncludeTest::testInclusionOfDate": {
        "path": "com/fasterxml/jackson/databind/ser/filter/JsonIncludeTest.java",
        "function_name": "testInclusionOfDate",
        "src": "public void testInclusionOfDate() throws Exception\n    {\n        final Date input = new Date(0L);\n        assertEquals(aposToQuotes(\"{'value':0}\"), \n                MAPPER.writeValueAsString(new NonEmptyDate(input)));\n        assertEquals(\"{}\", \n                MAPPER.writeValueAsString(new NonDefaultDate(input)));\n\n    \n    }",
        "error_msg": "com.fasterxml.jackson.databind.ser.filter.JsonIncludeTest::testInclusionOfDate --> junit.framework.ComparisonFailure: expected:<{[value:0]}> but was:<{[]}>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<{[value:0]}> but was:<{[]}>"
      }
    }
  },
  "JacksonDatabind-142": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
        "start_loc": 1140,
        "end_loc": 1145,
        "buggy_function": "    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        // 05-Dec-2017, tatu: Important! Must clear \"valueToUpdate\" since we do not\n        //    want update to be applied here, as a side effect\n        return new TreeTraversingParser((JsonNode) n, this);\n    }",
        "fixed_function": "    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        // 05-Dec-2017, tatu: Important! Must clear \"valueToUpdate\" since we do not\n        //    want update to be applied here, as a side effect\n        ObjectReader codec = withValueToUpdate(null);\n        return new TreeTraversingParser((JsonNode) n, codec);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
        "start_loc": 1287,
        "end_loc": 1295,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));\n    }",
        "fixed_function": "    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T> T readValue(JsonNode src)\n        throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));\n    }",
        "comment": "/**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/databind/type/PlaceholderForType.java",
        "start_loc": 81,
        "end_loc": 84,
        "buggy_function": "    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return _unsupported();\n    }",
        "fixed_function": "    @SuppressWarnings(\"deprecation\")\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return _unsupported();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.databind.convert.TestUpdateViaObjectReader::test1831UsingNode": {
        "path": "com/fasterxml/jackson/databind/convert/TestUpdateViaObjectReader.java",
        "function_name": "test1831UsingNode",
        "src": "public void test1831UsingNode() throws IOException {\n        String catJson = MAPPER.writeValueAsString(new Cat());\n        JsonNode jsonNode = MAPPER.readTree(catJson);\n        AnimalWrapper optionalCat = new AnimalWrapper();\n        ObjectReader r = MAPPER.readerForUpdating(optionalCat);\n        AnimalWrapper result = r.readValue(jsonNode);\n        assertSame(optionalCat, result);\n    }",
        "error_msg": "com.fasterxml.jackson.databind.convert.TestUpdateViaObjectReader::test1831UsingNode --> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.fasterxml.jackson.databind.convert.TestUpdateViaObjectReader$AbstractAnimal` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information",
        "clean_error_msg": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.fasterxml.jackson.databind.convert.TestUpdateViaObjectReader$AbstractAnimal` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information"
      }
    }
  },
  "James_mime4j_core-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "/src/main/java/org/apache/james/mime4j/io/MimeBoundaryInputStream.java",
        "start_loc": 57,
        "end_loc": 84,
        "buggy_function": "    public MimeBoundaryInputStream(BufferedLineReaderInputStream inbuffer, String boundary) \n            throws IOException {\n        super(inbuffer);\n\n        if (inbuffer.capacity() < boundary.length() * 2) {\n            throw new IllegalArgumentException(\"Boundary is too long\");\n        }\n        this.buffer = inbuffer;\n        this.eof = false;\n        this.limit = -1;\n        this.atBoundary = false;\n        this.boundaryLen = 0;\n        this.lastPart = false;\n        this.completed = false;\n        \n        this.boundary = new byte[boundary.length() + 2];\n        this.boundary[0] = (byte) '-';\n        this.boundary[1] = (byte) '-';\n        for (int i = 0; i < boundary.length(); i++) {\n            byte ch = (byte) boundary.charAt(i);\n            if (ch == '\\r' || ch == '\\n') {\n                throw new IllegalArgumentException(\"Boundary may not contain CR or LF\");\n            }\n            this.boundary[i + 2] = ch;\n        }\n        \n        fillBuffer();\n    }",
        "fixed_function": "    public MimeBoundaryInputStream(BufferedLineReaderInputStream inbuffer, String boundary) \n            throws IOException {\n        super(inbuffer);\n\n        if (inbuffer.capacity() < boundary.length() * 2) {\n            throw new IllegalArgumentException(\"Boundary is too long\");\n        }\n        this.buffer = inbuffer;\n        this.eof = false;\n        this.limit = -1;\n        this.atBoundary = false;\n        this.boundaryLen = 0;\n        this.lastPart = false;\n        this.initialLength = -1;\n        this.completed = false;\n        \n        this.boundary = new byte[boundary.length() + 2];\n        this.boundary[0] = (byte) '-';\n        this.boundary[1] = (byte) '-';\n        for (int i = 0; i < boundary.length(); i++) {\n            byte ch = (byte) boundary.charAt(i);\n            if (ch == '\\r' || ch == '\\n') {\n                throw new IllegalArgumentException(\"Boundary may not contain CR or LF\");\n            }\n            this.boundary[i + 2] = ch;\n        }\n        \n        fillBuffer();\n    }",
        "comment": "/**\n     * Creates a new MimeBoundaryInputStream.\n     * \n     * @param inbuffer The underlying stream.\n     * @param boundary Boundary string (not including leading hyphens).\n     * @throws IllegalArgumentException when boundary is too long\n     */"
      },
      {
        "path": "/src/main/java/org/apache/james/mime4j/io/MimeBoundaryInputStream.java",
        "start_loc": 192,
        "end_loc": 229,
        "buggy_function": "    private int fillBuffer() throws IOException {\n        if (eof) {\n            return -1;\n        }\n        int bytesRead;\n        if (!hasData()) {\n            bytesRead = buffer.fillBuffer();\n            if (bytesRead == -1) {\n            \teof = true;\n            }\n        } else {\n            bytesRead = 0;\n        }\n        \n        \n        int i = buffer.indexOf(boundary);\n        // NOTE this currently check only for LF. It doesn't check for canonical CRLF\n        // and neither for isolated CR. This will require updates according to MIME4J-60\n        while (i > buffer.pos() && buffer.charAt(i-1) != '\\n') {\n            // skip the \"fake\" boundary (it does not contain LF or CR so we cannot have\n            // another boundary starting before this is complete.\n            i = i + boundary.length;\n            i = buffer.indexOf(boundary, i, buffer.limit() - i);\n        }\n        if (i != -1) {\n            limit = i;\n            atBoundary = true;\n            calculateBoundaryLen();\n        } else {\n            if (eof) {\n                limit = buffer.limit();\n            } else {\n                limit = buffer.limit() - (boundary.length + 1); \n                                          // \\r\\n + (boundary - one char)\n            }\n        }\n        return bytesRead;\n    }",
        "fixed_function": "    public boolean isEmptyStream() {\n        return initialLength == 0;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/james/mime4j/io/MimeBoundaryInputStream.java",
        "start_loc": 232,
        "end_loc": 247,
        "buggy_function": "    private void calculateBoundaryLen() throws IOException {\n        boundaryLen = boundary.length;\n        int len = limit - buffer.pos();\n        if (len > 0) {\n            if (buffer.charAt(limit - 1) == '\\n') {\n                boundaryLen++;\n                limit--;\n            }\n        }\n        if (len > 1) {\n            if (buffer.charAt(limit - 1) == '\\r') {\n                boundaryLen++;\n                limit--;\n            }\n        }\n    }",
        "fixed_function": "    private void calculateBoundaryLen() throws IOException {\n        boundaryLen = boundary.length;\n        int len = limit - buffer.pos();\n        if (len >= 0 && initialLength == -1) initialLength = len;\n        if (len > 0) {\n            if (buffer.charAt(limit - 1) == '\\n') {\n                boundaryLen++;\n                limit--;\n            }\n        }\n        if (len > 1) {\n            if (buffer.charAt(limit - 1) == '\\r') {\n                boundaryLen++;\n                limit--;\n            }\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.james.mime4j.stream.MimeTokenNoRecurseTest::testWhenRecurseShouldRecurseInnerMail": {
        "path": "org/apache/james/mime4j/stream/MimeTokenNoRecurseTest.java",
        "function_name": "testWhenRecurseShouldRecurseInnerMail",
        "src": "public void testWhenRecurseShouldRecurseInnerMail() throws Exception {\n        stream.setRecursionMode(MimeTokenStream.M_RECURSE);\n        nextIs(MimeTokenStream.T_START_HEADER);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_END_HEADER);\n        \n        nextIs(MimeTokenStream.T_START_MULTIPART);\n        nextIs(MimeTokenStream.T_PREAMBLE);\n        nextShouldBeStandardPart(false);\n        \n        nextShouldBeStandardPart(true);\n        \n        nextIs(MimeTokenStream.T_START_BODYPART);\n        nextIs(MimeTokenStream.T_START_HEADER);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_END_HEADER);\n        nextIs(MimeTokenStream.T_START_MESSAGE);\n        nextIs(MimeTokenStream.T_START_HEADER);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_FIELD);\n        nextIs(MimeTokenStream.T_END_HEADER);\n        nextIs(MimeTokenStream.T_START_MULTIPART);\n        // an empty preamble should not raise a T_PREAMBLE event\n        // nextIs(MimeTokenStream.T_PREAMBLE);\n        nextShouldBeStandardPart(true);\n        nextShouldBeStandardPart(true);\n        nextIs(MimeTokenStream.T_EPILOGUE);\n        nextIs(MimeTokenStream.T_END_MULTIPART);\n        nextIs(MimeTokenStream.T_END_MESSAGE);\n        nextIs(MimeTokenStream.T_END_BODYPART);\n        nextShouldBeStandardPart(true);\n        nextIs(MimeTokenStream.T_EPILOGUE);\n        nextIs(MimeTokenStream.T_END_MULTIPART);\n    }",
        "error_msg": "org.apache.james.mime4j.stream.MimeTokenNoRecurseTest::testWhenRecurseShouldRecurseInnerMail --> junit.framework.ComparisonFailure: expected:<[Start bodypart]> but was:<[Preamble]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Start bodypart]> but was:<[Preamble]>"
      },
      "org.apache.james.mime4j.stream.MultipartTokensTest::testShouldParseMoreComplexMessage": {
        "path": "org/apache/james/mime4j/stream/MultipartTokensTest.java",
        "function_name": "testShouldParseMoreComplexMessage",
        "src": "public void testShouldParseMoreComplexMessage() throws Exception {\n        String message = \n            \"Content-Type: multipart/alternative; boundary=\\\"outer-boundary\\\"\\r\\n\" +\n            \"\\r\\n\" +\n            \"--outer-boundary\\r\\n\" +\n            \"Content-Type: multipart/alternative; boundary=\\\"inner-boundary\\\"\\r\\n\" +\n            \"\\r\\n\" +\n            \"--inner-boundary\\r\\n\" +\n            \"Content-Type: text/plain\\r\\n\" +\n            \"\\r\\n\" +\n            \"Some text\\r\\n\" +\n            \"--inner-boundary--\\r\\n\" +\n            \"\\r\\n\" +\n            \"foo\\r\\n\" +\n            \"--outer-boundary--\\r\\n\";\n        \n        parser.parse(new ByteArrayInputStream(US_ASCII.encode(message).array()));\n        checkState(MimeTokenStream.T_START_HEADER);\n        checkState(MimeTokenStream.T_FIELD);\n        checkState(MimeTokenStream.T_END_HEADER);\n        checkState(MimeTokenStream.T_START_MULTIPART);\n        // an empty preamble should not rais a T_PREAMBLE event\n        // checkState(MimeTokenStream.T_PREAMBLE);\n        checkState(MimeTokenStream.T_START_BODYPART);\n        checkState(MimeTokenStream.T_START_HEADER);\n        checkState(MimeTokenStream.T_FIELD);\n        checkState(MimeTokenStream.T_END_HEADER);\n        checkState(MimeTokenStream.T_START_MULTIPART);\n        // an empty preamble should not rais a T_PREAMBLE event\n        // checkState(MimeTokenStream.T_PREAMBLE);\n        checkState(MimeTokenStream.T_START_BODYPART);\n        checkState(MimeTokenStream.T_START_HEADER);\n        checkState(MimeTokenStream.T_FIELD);\n        checkState(MimeTokenStream.T_END_HEADER);\n        checkState(MimeTokenStream.T_BODY);\n        checkState(MimeTokenStream.T_END_BODYPART);\n        checkState(MimeTokenStream.T_EPILOGUE);\n        checkState(MimeTokenStream.T_END_MULTIPART);\n        checkState(MimeTokenStream.T_END_BODYPART);\n        checkState(MimeTokenStream.T_EPILOGUE);\n        checkState(MimeTokenStream.T_END_MULTIPART);\n        checkState(MimeTokenStream.T_END_MESSAGE);\n        checkState(MimeTokenStream.T_END_OF_STREAM);\n    }",
        "error_msg": "org.apache.james.mime4j.stream.MultipartTokensTest::testShouldParseMoreComplexMessage --> junit.framework.ComparisonFailure: expected:<[Start bodypart]> but was:<[Preamble]>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Start bodypart]> but was:<[Preamble]>"
      }
    }
  },
  "Math-27": {
    "function_num": 3,
    "functions": [
      {
        "path": "./src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java",
        "start_loc": 289,
        "end_loc": 293,
        "buggy_function": "    public double getNumericalVariance() {\n        final double s = shape;\n        final double ss = s * s;\n        return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\n    }",
        "fixed_function": "    public double getNumericalVariance() {\n        final double s = shape;\n        final double ss = s * s;\n        return (FastMath.expm1(ss)) * FastMath.exp(2 * scale + ss);\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     *\n     * For scale {@code m} and shape {@code s}, the variance is\n     * {@code (exp(s^2) - 1) * exp(2 * m + s^2)}.\n     */"
      },
      {
        "path": "./src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java",
        "start_loc": 214,
        "end_loc": 227,
        "buggy_function": "    @Override\n    public double inverseCumulativeProbability(double p) {\n        double ret;\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0.0, 1.0);\n        } else if (p == 0) {\n            ret = 0.0;\n        } else  if (p == 1) {\n            ret = Double.POSITIVE_INFINITY;\n        } else {\n            ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n        }\n        return ret;\n    }",
        "fixed_function": "    @Override\n    public double inverseCumulativeProbability(double p) {\n        double ret;\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0.0, 1.0);\n        } else if (p == 0) {\n            ret = 0.0;\n        } else  if (p == 1) {\n            ret = Double.POSITIVE_INFINITY;\n        } else {\n            ret = scale * FastMath.pow(-FastMath.log1p(-p), 1.0 / shape);\n        }\n        return ret;\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     *\n     * Returns {@code 0} when {@code p == 0} and\n     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n     */"
      },
      {
        "path": "./src/main/java/org/apache/commons/math3/special/Beta.java",
        "start_loc": 182,
        "end_loc": 227,
        "buggy_function": "    public static double regularizedBeta(double x,\n                                         final double a, final double b,\n                                         double epsilon, int maxIterations) {\n        double ret;\n\n        if (Double.isNaN(x) ||\n            Double.isNaN(a) ||\n            Double.isNaN(b) ||\n            x < 0 ||\n            x > 1 ||\n            a <= 0.0 ||\n            b <= 0.0) {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\n                FastMath.log(a) - logBeta(a, b)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }",
        "fixed_function": "    public static double regularizedBeta(double x,\n                                         final double a, final double b,\n                                         double epsilon, int maxIterations) {\n        double ret;\n\n        if (Double.isNaN(x) ||\n            Double.isNaN(a) ||\n            Double.isNaN(b) ||\n            x < 0 ||\n            x > 1 ||\n            a <= 0.0 ||\n            b <= 0.0) {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) -\n                FastMath.log(a) - logBeta(a, b)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }",
        "comment": "/**\n     * Returns the regularized beta function I(x, a, b).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n     * Regularized Beta Function</a>.</li>\n     * <li>\n     * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n     * Regularized Beta Function</a>.</li>\n     * </ul>\n     *\n     * @param x the value.\n     * @param a Parameter {@code a}.\n     * @param b Parameter {@code b}.\n     * @param epsilon When the absolute value of the nth item in the\n     * series is less than epsilon the approximation ceases to calculate\n     * further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete.\n     * @return the regularized beta function I(x, a, b)\n     * @throws org.apache.commons.math3.exception.MaxCountExceededException\n     * if the algorithm fails to converge.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.distribution.LogNormalDistributionTest::testTinyVariance": {
        "path": "org/apache/commons/math3/distribution/LogNormalDistributionTest.java",
        "function_name": "testTinyVariance",
        "src": "@Test\n    public void testTinyVariance() {\n        LogNormalDistribution dist = new LogNormalDistribution(0, 1e-9);\n        double t = dist.getNumericalVariance();\n        Assert.assertEquals(1e-18, t, 1e-20);\n    }",
        "error_msg": "org.apache.commons.math3.distribution.LogNormalDistributionTest::testTinyVariance --> junit.framework.AssertionFailedError: expected:<1.0E-18> but was:<0.0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1.0E-18> but was:<0.0>"
      },
      "org.apache.commons.math3.distribution.WeibullDistributionTest::testInverseCumulativeProbabilitySmallPAccuracy": {
        "path": "org/apache/commons/math3/distribution/WeibullDistributionTest.java",
        "function_name": "testInverseCumulativeProbabilitySmallPAccuracy",
        "src": "@Test\n    public void testInverseCumulativeProbabilitySmallPAccuracy() {\n        WeibullDistribution dist = new WeibullDistribution(2, 3);\n        double t = dist.inverseCumulativeProbability(1e-17);\n        // Analytically, answer is solution to 1e-17 = 1-exp(-(x/3)^2)\n        // x = sqrt(-9*log(1-1e-17))\n        // If we're not careful, answer will be 0. Answer below is computed with care in Octave:\n        Assert.assertEquals(9.48683298050514e-9, t, 1e-17);\n    }",
        "error_msg": "org.apache.commons.math3.distribution.WeibullDistributionTest::testInverseCumulativeProbabilitySmallPAccuracy --> junit.framework.AssertionFailedError: expected:<9.48683298050514E-9> but was:<0.0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<9.48683298050514E-9> but was:<0.0>"
      },
      "org.apache.commons.math3.special.BetaTest::testRegularizedBetaTinyArgument": {
        "path": "org/apache/commons/math3/special/BetaTest.java",
        "function_name": "testRegularizedBetaTinyArgument",
        "src": "@Test\n    public void testRegularizedBetaTinyArgument() {\n        double actual = Beta.regularizedBeta(1e-17, 1.0, 1e12);\n        // This value is from R: pbeta(1e-17,1,1e12)\n        TestUtils.assertEquals(9.999950000166648e-6, actual, 1e-16);\n    }",
        "error_msg": "org.apache.commons.math3.special.BetaTest::testRegularizedBetaTinyArgument --> junit.framework.AssertionFailedError: expected:<9.999950000166648E-6> but was:<1.0000050000166648E-5>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<9.999950000166648E-6> but was:<1.0000050000166648E-5>"
      }
    }
  },
  "Mockito-14": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/org/mockito/internal/MockHandler.java",
        "start_loc": 57,
        "end_loc": 101,
        "buggy_function": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
        "fixed_function": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/MockitoCore.java",
        "start_loc": 67,
        "end_loc": 75,
        "buggy_function": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }",
        "fixed_function": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest::shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine": {
        "path": "org/mockitousage/bugs/VerifyingWithAnExtraCallToADifferentMockTest.java",
        "function_name": "shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine",
        "src": "@Test \n    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n        //given\n        when(mock.otherMethod()).thenReturn(\"foo\");\n        \n        //when\n        mockTwo.simpleMethod(\"foo\");\n        \n        //then\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n    }",
        "error_msg": "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest::shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Mockito-16": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/org/mockito/internal/MockitoCore.java",
        "start_loc": 32,
        "end_loc": 32,
        "buggy_function": "    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }",
        "fixed_function": "    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {\n        mockingProgress.validateState();\n        if (shouldResetOngoingStubbing) {\n            mockingProgress.resetOngoingStubbing();\n        }\n        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/Mockito.java",
        "start_loc": 826,
        "end_loc": 828,
        "buggy_function": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
        "fixed_function": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings, true);\n    }",
        "comment": "/**\n     * Creates a mock with some non-standard settings.\n     * <p>\n     * The number of configuration points for a mock grows \n     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \n     * Hence {@link MockSettings}.\n     * <pre>\n     *   Listener mock = mock(Listener.class, withSettings()\n     *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n     *   );  \n     * </pre>\n     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \n     * Is the code under test so complicated that it requires non-standard mocks? \n     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n     * <p>\n     * See also {@link Mockito#withSettings()}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @param mockSettings additional mock settings\n     * @return mock object\n     */"
      },
      {
        "path": "src/org/mockito/Mockito.java",
        "start_loc": 896,
        "end_loc": 900,
        "buggy_function": "    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS)); \n    }",
        "fixed_function": "    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS), true); \n    }",
        "comment": "/**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     * \n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     * \n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     * \n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     * \n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     * \n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     * \n     * <h4>Important gotcha on spying real objects!</h4>\n     * \n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Watch out for final methods. \n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */"
      }
    ],
    "trigger_test": {
      "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest::shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS": {
        "path": "org/mockitousage/bugs/StubbingMocksThatAreConfiguredToReturnMocksTest.java",
        "function_name": "shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS",
        "src": "@Test\n    public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\n        IMethods mock = mock(IMethods.class, RETURNS_MOCKS);\n        when(mock.objectReturningMethodNoArgs()).thenReturn(null);\n    }",
        "error_msg": "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest::shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS --> org.mockito.exceptions.misusing.MissingMethodInvocationException: ",
        "clean_error_msg": "org.mockito.exceptions.misusing.MissingMethodInvocationException:"
      }
    }
  },
  "Mockito-17": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "start_loc": 21,
        "end_loc": 23,
        "buggy_function": "    public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n    }",
        "fixed_function": "    public MockSettings serializable() {\n        this.serializable = true;\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "start_loc": 73,
        "end_loc": 75,
        "buggy_function": "    public boolean isSerializable() {\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n    }",
        "fixed_function": "    public boolean isSerializable() {\n        return serializable;\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/util/MockUtil.java",
        "start_loc": 33,
        "end_loc": 56,
        "buggy_function": "    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
        "fixed_function": "    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.mockitousage.basicapi.MocksSerializationTest::shouldBeSerializeAndHaveExtraInterfaces": {
        "path": "org/mockitousage/basicapi/MocksSerializationTest.java",
        "function_name": "shouldBeSerializeAndHaveExtraInterfaces",
        "src": "@Test\n    public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n        //when\n        IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n        IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n\n        //then\n        serializeAndBack((List) mock);\n        serializeAndBack((List) mockTwo);\n    }",
        "error_msg": "org.mockitousage.basicapi.MocksSerializationTest::shouldBeSerializeAndHaveExtraInterfaces --> java.io.NotSerializableException: org.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$a155cf16",
        "clean_error_msg": "java.io.NotSerializableException: org.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$a155cf16"
      }
    }
  },
  "Mockito-19": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
        "start_loc": 23,
        "end_loc": 47,
        "buggy_function": "    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }",
        "fixed_function": "    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java",
        "start_loc": 22,
        "end_loc": 44,
        "buggy_function": "\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance) {\n\t\tList<Object> mockNameMatches = new ArrayList<Object>();\n\t\tif (mocks.size() > 1) {\n\t\t\tfor (Object mock : mocks) {\n\t\t\t\tif (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n\t\t\t\t\tmockNameMatches.add(mock);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field,\n\t\t\t\t\tfieldInstance);\n\t\t\t/*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n\t\t}\n\t\treturn next.filterCandidate(mocks, field, fieldInstance);\n\t}",
        "fixed_function": "\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, List<Field> fields, Object fieldInstance) {\n\t\tList<Object> mockNameMatches = new ArrayList<Object>();\n\t\tif (mocks.size() > 1) {\n\t\t\tfor (Object mock : mocks) {\n\t\t\t\tif (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n\t\t\t\t\tmockNameMatches.add(mock);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n\t\t\t\t\tfieldInstance);\n\t\t\t/*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n\t\t} else if (mocks.size() == 1) {\n\t\t\tString mockName = mockUtil.getMockName(mocks.iterator().next())\n\t\t\t\t\t.toString();\n\n\t\t\tfor (Field otherField : fields) {\n\t\t\t\tif (!otherField.equals(field)\n\t\t\t\t\t\t&& otherField.getType().equals(field.getType())\n\t\t\t\t\t\t&& otherField.getName().equals(mockName)) {\n\n\t\t\t\t\treturn new OngoingInjecter() {\n\t\t\t\t\t\tpublic Object thenInject() {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next.filterCandidate(mocks, field, fields, fieldInstance);\n\t}",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java",
        "start_loc": 20,
        "end_loc": 29,
        "buggy_function": "    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n    }",
        "fixed_function": "    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "start_loc": 111,
        "end_loc": 122,
        "buggy_function": "    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n            if (injected != null) {\n                injectionOccurred |= true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }",
        "fixed_function": "    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();\n            if (injected != null) {\n                injectionOccurred |= true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.mockitousage.annotation.MockInjectionUsingSetterOrPropertyTest::shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable": {
        "path": "org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java",
        "function_name": "shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable",
        "src": "@Test\n\tpublic void shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable() {\n\t\tMockitoAnnotations.initMocks(this);\n\t\tassertNull(otherSuperUnderTesting.candidate1);\n\t\tassertNotNull(otherSuperUnderTesting.candidate2);\n\t}",
        "error_msg": "org.mockitousage.annotation.MockInjectionUsingSetterOrPropertyTest::shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable --> junit.framework.AssertionFailedError: Expected: <null> but was: candidate2",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected: <null> but was: candidate2"
      }
    }
  },
  "Mockito-30": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/org/mockito/exceptions/Reporter.java",
        "start_loc": 438,
        "end_loc": 446,
        "buggy_function": "    public void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }",
        "fixed_function": "    public void smartNullPointerException(Object obj, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n                obj,\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }",
        "comment": ""
      },
      {
        "path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "start_loc": 51,
        "end_loc": 58,
        "buggy_function": "        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(location);\n            return null;\n        }",
        "fixed_function": "        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(obj, location);\n            return null;\n        }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest::shouldPrintTheParametersOnSmartNullPointerExceptionMessage": {
        "path": "org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java",
        "function_name": "shouldPrintTheParametersOnSmartNullPointerExceptionMessage",
        "src": "@Test\n\tpublic void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\n\n        Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n\n        try {\n            smartNull.get();\n            fail();\n        } catch (SmartNullPointerException ex) {\n        \tString message = ex.getMessage();\n        \tassertTrue(\"Exception message should include oompa and lumpa, but was: \" + message,\n        \t\t\tmessage.contains(\"oompa, lumpa\"));\n        }\n\t}",
        "error_msg": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest::shouldPrintTheParametersOnSmartNullPointerExceptionMessage --> junit.framework.AssertionFailedError: Exception message should include oompa and lumpa, but was: ",
        "clean_error_msg": "junit.framework.AssertionFailedError: Exception message should include oompa and lumpa, but was:"
      }
    }
  },
  "Time-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "start_loc": 226,
        "end_loc": 231,
        "buggy_function": "    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }",
        "fixed_function": "    public int compareTo(DurationField durationField) {\n        return 0;\n    }",
        "comment": "/**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/Partial.java",
        "start_loc": 189,
        "end_loc": 251,
        "buggy_function": "    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "fixed_function": "    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "comment": "/**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */"
      }
    ],
    "trigger_test": {
      "org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray": {
        "path": "org/joda/time/TestPartial_Constructors.java",
        "function_name": "testConstructorEx7_TypeArray_intArray",
        "src": "public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {1, 1, 1};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n    }",
        "error_msg": "org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Time-2": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "start_loc": 226,
        "end_loc": 228,
        "buggy_function": "    public int compareTo(DurationField durationField) {\n        return 0;\n    }",
        "fixed_function": "    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }",
        "comment": "/**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/Partial.java",
        "start_loc": 189,
        "end_loc": 251,
        "buggy_function": "    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "fixed_function": "    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
        "comment": "/**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/Partial.java",
        "start_loc": 428,
        "end_loc": 476,
        "buggy_function": "    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }",
        "fixed_function": "    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }",
        "comment": "/**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"
      }
    ],
    "trigger_test": {
      "org.joda.time.TestPartial_Basics::testWith_baseAndArgHaveNoRange": {
        "path": "org/joda/time/TestPartial_Basics.java",
        "function_name": "testWith_baseAndArgHaveNoRange",
        "src": "public void testWith_baseAndArgHaveNoRange() {\n        Partial test = new Partial(DateTimeFieldType.year(), 1);\n        Partial result = test.with(DateTimeFieldType.era(), 1);\n        assertEquals(2, result.size());\n        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n        assertEquals(1, result.indexOf(DateTimeFieldType.year()));\n    }",
        "error_msg": "org.joda.time.TestPartial_Basics::testWith_baseAndArgHaveNoRange --> java.lang.IllegalArgumentException: Types array must not contain duplicate: era and year",
        "clean_error_msg": "java.lang.IllegalArgumentException: Types array must not contain duplicate: era and year"
      }
    }
  },
  "Time-12": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/joda/time/LocalDate.java",
        "start_loc": 206,
        "end_loc": 216,
        "buggy_function": "    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }",
        "fixed_function": "    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }",
        "comment": "/**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/LocalDate.java",
        "start_loc": 238,
        "end_loc": 249,
        "buggy_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }",
        "fixed_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }",
        "comment": "/**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/LocalDateTime.java",
        "start_loc": 195,
        "end_loc": 209,
        "buggy_function": "    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }",
        "fixed_function": "    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }",
        "comment": "/**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"
      },
      {
        "path": "src/main/java/org/joda/time/LocalDateTime.java",
        "start_loc": 231,
        "end_loc": 246,
        "buggy_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }",
        "fixed_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }",
        "comment": "/**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"
      }
    ],
    "trigger_test": {
      "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero1": {
        "path": "org/joda/time/TestLocalDateTime_Constructors.java",
        "function_name": "testFactory_fromDateFields_beforeYearZero1",
        "src": "public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }",
        "error_msg": "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero1 --> junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"
      },
      "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero3": {
        "path": "org/joda/time/TestLocalDateTime_Constructors.java",
        "function_name": "testFactory_fromDateFields_beforeYearZero3",
        "src": "public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }",
        "error_msg": "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero3 --> junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"
      },
      "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero1": {
        "path": "org/joda/time/TestLocalDateTime_Constructors.java",
        "function_name": "testFactory_fromCalendarFields_beforeYearZero1",
        "src": "public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }",
        "error_msg": "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero1 --> junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"
      },
      "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero3": {
        "path": "org/joda/time/TestLocalDateTime_Constructors.java",
        "function_name": "testFactory_fromCalendarFields_beforeYearZero3",
        "src": "public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }",
        "error_msg": "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero3 --> junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"
      },
      "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero1": {
        "path": "org/joda/time/TestLocalDate_Constructors.java",
        "function_name": "testFactory_fromDateFields_beforeYearZero1",
        "src": "public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }",
        "error_msg": "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero1 --> junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>"
      },
      "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero3": {
        "path": "org/joda/time/TestLocalDate_Constructors.java",
        "function_name": "testFactory_fromDateFields_beforeYearZero3",
        "src": "public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }",
        "error_msg": "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero3 --> junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>"
      },
      "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero1": {
        "path": "org/joda/time/TestLocalDate_Constructors.java",
        "function_name": "testFactory_fromCalendarFields_beforeYearZero1",
        "src": "public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }",
        "error_msg": "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero1 --> junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>"
      },
      "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero3": {
        "path": "org/joda/time/TestLocalDate_Constructors.java",
        "function_name": "testFactory_fromCalendarFields_beforeYearZero3",
        "src": "public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }",
        "error_msg": "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero3 --> junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>"
      }
    }
  },
  "Time-26": {
    "function_num": 8,
    "functions": [
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 428,
        "end_loc": 438,
        "buggy_function": "        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }",
        "fixed_function": "        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 440,
        "end_loc": 450,
        "buggy_function": "        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }",
        "fixed_function": "        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 452,
        "end_loc": 462,
        "buggy_function": "        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }",
        "fixed_function": "        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 464,
        "end_loc": 475,
        "buggy_function": "        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }",
        "fixed_function": "        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 477,
        "end_loc": 482,
        "buggy_function": "        public long set(long instant, String text, Locale locale) {\n            // cannot verify that new value stuck because set may be lenient\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false);\n        }",
        "fixed_function": "        public long set(long instant, String text, Locale locale) {\n            // cannot verify that new value stuck because set may be lenient\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false, instant);\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 520,
        "end_loc": 530,
        "buggy_function": "        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }",
        "fixed_function": "        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "start_loc": 532,
        "end_loc": 542,
        "buggy_function": "        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }",
        "fixed_function": "        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/joda/time/field/LenientDateTimeField.java",
        "start_loc": 69,
        "end_loc": 76,
        "buggy_function": "    public long set(long instant, int value) {\n        // lenient needs to handle time zone chronologies\n        // so we do the calculation using local milliseconds\n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false);\n    }",
        "fixed_function": "    public long set(long instant, int value) {\n        // lenient needs to handle time zone chronologies\n        // so we do the calculation using local milliseconds\n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n    }",
        "comment": "/**\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     */"
      }
    ],
    "trigger_test": {
      "org.joda.time.TestDateTimeZoneCutover::testWithSecondOfMinuteInDstChange": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithSecondOfMinuteInDstChange",
        "src": "public void testWithSecondOfMinuteInDstChange() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withSecondOfMinute(0);\n        assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithSecondOfMinuteInDstChange --> junit.framework.ComparisonFailure: expected:<...10-31T02:30:00.123+0[2]:00> but was:<...10-31T02:30:00.123+0[1]:00>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:00.123+0[2]:00> but was:<...10-31T02:30:00.123+0[1]:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithMinuteOfHourInDstChange",
        "src": "public void testWithMinuteOfHourInDstChange_mockZone() {\n        DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n        assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n        DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n        DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n        assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n        DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n        assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n        \n        DateTime testPre1 = pre.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n        DateTime testPre2 = pre.withMinuteOfHour(50);\n        assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n        \n        DateTime testPost1 = post.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n        DateTime testPost2 = post.withMinuteOfHour(10);\n        assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange --> junit.framework.ComparisonFailure: expected:<...10-31T02:00:10.123+0[2]:00> but was:<...10-31T02:00:10.123+0[1]:00>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...10-31T02:00:10.123+0[2]:00> but was:<...10-31T02:00:10.123+0[1]:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_mockZone": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithMinuteOfHourInDstChange_mockZone",
        "src": "public void testWithMinuteOfHourInDstChange_mockZone() {\n        DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n        assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n        DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n        DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n        assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n        DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n        assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n        \n        DateTime testPre1 = pre.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n        DateTime testPre2 = pre.withMinuteOfHour(50);\n        assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n        \n        DateTime testPost1 = post.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n        DateTime testPost2 = post.withMinuteOfHour(10);\n        assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_mockZone --> junit.framework.ComparisonFailure: expected:<...10-31T01:30:00.000+0[1:0]0> but was:<...10-31T01:30:00.000+0[0:3]0>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...10-31T01:30:00.000+0[1:0]0> but was:<...10-31T01:30:00.000+0[0:3]0>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testBug2182444_usCentral": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testBug2182444_usCentral",
        "src": "public void testBug2182444_usCentral() {\n        Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n        DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\n        DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\n        assertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\n        assertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\n        \n        DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\n        DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\n        assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\n        assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\n        assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\n        assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\n        assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\n        assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\n        assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testBug2182444_usCentral --> junit.framework.AssertionFailedError: expected:<2008-11-02T01:00:00.000-06:00> but was:<2008-11-02T01:00:00.000-05:00>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2008-11-02T01:00:00.000-06:00> but was:<2008-11-02T01:00:00.000-05:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_Paris_summer": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithMillisOfSecondInDstChange_Paris_summer",
        "src": "public void testWithMillisOfSecondInDstChange_Paris_summer() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withMillisOfSecond(0);\n        assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_Paris_summer --> junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.000+0[2]:00> but was:<...10-31T02:30:10.000+0[1]:00>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.000+0[2]:00> but was:<...10-31T02:30:10.000+0[1]:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testWithHourOfDayInDstChange": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithHourOfDayInDstChange",
        "src": "public void testWithHourOfDayInDstChange() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withHourOfDay(2);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithHourOfDayInDstChange --> junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.123+0[2]:00> but was:<...10-31T02:30:10.123+0[1]:00>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:10.123+0[2]:00> but was:<...10-31T02:30:10.123+0[1]:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_NewYork_winter": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testWithMillisOfSecondInDstChange_NewYork_winter",
        "src": "public void testWithMillisOfSecondInDstChange_NewYork_winter() {\n        DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-05:00\", ZONE_NEW_YORK);\n        assertEquals(\"2007-11-04T01:30:00.123-05:00\", dateTime.toString());\n        DateTime test = dateTime.withMillisOfSecond(0);\n        assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_NewYork_winter --> junit.framework.ComparisonFailure: expected:<...11-04T01:30:00.000-0[5]:00> but was:<...11-04T01:30:00.000-0[4]:00>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<...11-04T01:30:00.000-0[5]:00> but was:<...11-04T01:30:00.000-0[4]:00>"
      },
      "org.joda.time.TestDateTimeZoneCutover::testBug2182444_ausNSW": {
        "path": "org/joda/time/TestDateTimeZoneCutover.java",
        "function_name": "testBug2182444_ausNSW",
        "src": "public void testBug2182444_ausNSW() {\n        Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n        DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n        DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n        assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n        assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n        \n        DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n        DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n        assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n        assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n        assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n        assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n        assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n        assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n        assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());\n    }",
        "error_msg": "org.joda.time.TestDateTimeZoneCutover::testBug2182444_ausNSW --> junit.framework.AssertionFailedError: expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2008-04-06T02:00:00.000+11:00> but was:<2008-04-06T02:00:00.000+10:00>"
      }
    }
  },
  "Hilbert_curve-3": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/davidmoten/hilbert/Ranges.java",
        "start_loc": 48,
        "end_loc": 103,
        "buggy_function": "    public Ranges add(Range r) {\n        Preconditions.checkArgument(ranges == null || ranges.value.high() < r.low(),\n                \"ranges must be added in increasing order and without overlap\");\n        Node node = new Node(r);\n        count++;\n        if (ranges == null) {\n            ranges = node;\n            last = ranges;\n        } else if (bufferSize == 0) {\n            node.setNext(ranges);\n        } else {\n            // and set new head and recalculate distance for ranges\n            node.setNext(ranges);\n\n            // add old head to set (now that the distanceToPrevious has been calculated)\n            set.add(ranges);\n\n            ranges = node;\n\n            if (count > bufferSize) {\n                // remove node from set with least distance to next node\n                Node first = set.pollFirst();\n\n                // replace that node in linked list (ranges) with a new Node\n                // that has the concatenation of that node with previous node's range\n                // also remove its predecessor\n\n                // first.previous will not be null because distance was present to be in set\n                Range joined = first.value.join(first.previous().value);\n\n                Node n = new Node(joined);\n                // link and recalculate distance (won't change because the lower bound of the\n                // new ranges is the same as the lower bound of the range of first)\n                if (first.next() != null) {\n                    n.setNext(first.next());\n                } else {\n                    last = n;\n                }\n                // link and calculate the distance for n\n                Node firstPrevious = first.previous();\n                if (firstPrevious == ranges) {\n                    ranges = n;\n                } else {\n                    first.previous().previous().setNext(n);\n                }\n\n                // clear pointers from first to help gc out\n                // there new gen to old gen promotion can cause problems\n                first.clearForGc();\n\n                // we have reduced number of nodes in list so reduce count\n                count--;\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    public Ranges add(Range r) {\n        Preconditions.checkArgument(ranges == null || ranges.value.high() < r.low(),\n                \"ranges must be added in increasing order and without overlap\");\n        Node node = new Node(r);\n        count++;\n        if (ranges == null) {\n            ranges = node;\n        } else if (bufferSize == 0) {\n            node.setNext(ranges);\n        } else {\n            // and set new head and recalculate distance for ranges\n            node.setNext(ranges);\n\n            // add old head to set (now that the distanceToPrevious has been calculated)\n            set.add(ranges);\n\n            ranges = node;\n\n            if (count > bufferSize) {\n                // remove node from set with least distance to next node\n                Node first = set.pollFirst();\n\n                // replace that node in linked list (ranges) with a new Node\n                // that has the concatenation of that node with previous node's range\n                // also remove its predecessor\n\n                // first.previous will not be null because distance was present to be in set\n                Range joined = first.value.join(first.previous().value);\n\n                Node n = new Node(joined);\n                // link and recalculate distance (won't change because the lower bound of the\n                // new ranges is the same as the lower bound of the range of first)\n                if (first.next() != null) {\n                    n.setNext(first.next());\n                }\n                // link and calculate the distance for n\n                Node firstPrevious = first.previous();\n                if (firstPrevious == ranges) {\n                    ranges = n;\n                } else {\n                    first.previous().previous().setNext(n);\n                }\n\n                // clear pointers from first to help gc out\n                // there new gen to old gen promotion can cause problems\n                first.clearForGc();\n\n                // we have reduced number of nodes in list so reduce count\n                count--;\n            }\n        }\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/davidmoten/hilbert/Ranges.java",
        "start_loc": 105,
        "end_loc": 124,
        "buggy_function": "    @Override\n    public Iterator<Range> iterator() {\n        return new Iterator<Range>() {\n\n            Node r = last;\n\n            @Override\n            public boolean hasNext() {\n                return r != null;\n            }\n\n            @Override\n            public Range next() {\n                Range v = r.value;\n                r = r.previous();\n                return v;\n            }\n\n        };\n    }",
        "fixed_function": "    @Override\n    public Iterator<Range> iterator() {\n        return new Iterator<Range>() {\n\n            Node r = ranges;\n\n            @Override\n            public boolean hasNext() {\n                return r != null;\n            }\n\n            @Override\n            public Range next() {\n                Range v = r.value;\n                r = r.next();\n                return v;\n            }\n\n        };\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/davidmoten/hilbert/SmallHilbertCurve.java",
        "start_loc": 128,
        "end_loc": 134,
        "buggy_function": "    public Ranges query(long[] a, long[] b, int maxRanges) {\n        if (maxRanges == 0) {\n            return query(a, b, 0, 0);\n        } else {\n            return query(a, b, maxRanges, Math.max(DEFAULT_BUFFER_SIZE, maxRanges));\n        }\n    }",
        "fixed_function": "    public Ranges query(long[] a, long[] b, int maxRanges) {\n        if (maxRanges == 0) {\n            return query(a, b, 0, 0);\n        } else {\n            return query(a, b, maxRanges, Math.min(DEFAULT_BUFFER_SIZE, maxRanges));\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.davidmoten.hilbert.RangesTest::testMaxSizeNotExceededWhenMaxIs2": {
        "path": "org/davidmoten/hilbert/RangesTest.java",
        "function_name": "testMaxSizeNotExceededWhenMaxIs2",
        "src": "@Test\n    public void testMaxSizeNotExceededWhenMaxIs2() {\n        Ranges r = new Ranges(2);\n        r.add(Range.create(1));\n        r.add(Range.create(10));\n        checkIs(r, 10, 10, 1, 1);\n    }",
        "error_msg": "org.davidmoten.hilbert.RangesTest::testMaxSizeNotExceededWhenMaxIs2 --> junit.framework.AssertionFailedError: expected:<[Range [low=10, high=10], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=10]]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[Range [low=10, high=10], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=10]]>"
      },
      "org.davidmoten.hilbert.RangesTest::testMaxSizeExceededWhenMaxIs2": {
        "path": "org/davidmoten/hilbert/RangesTest.java",
        "function_name": "testMaxSizeExceededWhenMaxIs2",
        "src": "@Test\n    public void testMaxSizeExceededWhenMaxIs2() {\n        Ranges r = new Ranges(2);\n        r.add(Range.create(1));\n        r.add(Range.create(10));\n        r.add(Range.create(12));\n        checkIs(r, 10, 12, 1, 1);\n    }",
        "error_msg": "org.davidmoten.hilbert.RangesTest::testMaxSizeExceededWhenMaxIs2 --> junit.framework.AssertionFailedError: expected:<[Range [low=10, high=12], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=12]]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[Range [low=10, high=12], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=12]]>"
      },
      "org.davidmoten.hilbert.RangesTest::testMaxSizeExceededWhenMaxIs3": {
        "path": "org/davidmoten/hilbert/RangesTest.java",
        "function_name": "testMaxSizeExceededWhenMaxIs3",
        "src": "@Test\n    public void testMaxSizeExceededWhenMaxIs3() {\n        Ranges r = new Ranges(3);\n        r.add(Range.create(1));\n        r.add(Range.create(10));\n        r.add(Range.create(12));\n        r.add(Range.create(18));\n        r.println();\n        checkIs(r, 18, 18, 10, 12, 1, 1);\n    }",
        "error_msg": "org.davidmoten.hilbert.RangesTest::testMaxSizeExceededWhenMaxIs3 --> junit.framework.AssertionFailedError: expected:<[Range [low=18, high=18], Range [low=10, high=12], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=12], Range [low=18, high=18]]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[Range [low=18, high=18], Range [low=10, high=12], Range [low=1, high=1]]> but was:<[Range [low=1, high=1], Range [low=10, high=12], Range [low=18, high=18]]>"
      }
    }
  },
  "Jsoup-3": {
    "function_num": 10,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 267,
        "end_loc": 276,
        "buggy_function": "    public Element append(String html) {\n        Validate.notNull(html);\n        \n        Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n        for (Node node : fragment.childNodes()) {\n            node.parentNode = null;\n            appendChild(node);\n        }\n        return this;\n    }",
        "fixed_function": "    public Element append(String html) {\n        Validate.notNull(html);\n        \n        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n        for (Node node : fragment.childNodes()) {\n            node.parentNode = null;\n            appendChild(node);\n        }\n        return this;\n    }",
        "comment": "/**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 284,
        "end_loc": 295,
        "buggy_function": "    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n        List<Node> nodes = fragment.childNodes();\n        for (int i = nodes.size() - 1; i >= 0; i--) {\n            Node node = nodes.get(i);\n            node.parentNode = null;\n            prependChild(node);\n        }\n        return this;\n    }",
        "fixed_function": "    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n        List<Node> nodes = fragment.childNodes();\n        for (int i = nodes.size() - 1; i >= 0; i--) {\n            Node node = nodes.get(i);\n            node.parentNode = null;\n            prependChild(node);\n        }\n        return this;\n    }",
        "comment": "/**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node prepended to the start of the children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 311,
        "end_loc": 333,
        "buggy_function": "    public Element wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();\n        Elements wrapChildren = wrapBody.children();\n        Element wrap = wrapChildren.first();\n        if (wrap == null) // nothing to wrap with; noop\n            return null;\n\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChild(this);\n\n        // remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 1) {\n            for (int i = 1; i < wrapChildren.size(); i++) { // skip first\n                Element remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    public Element wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();\n        Elements wrapChildren = wrapBody.children();\n        Element wrap = wrapChildren.first();\n        if (wrap == null) // nothing to wrap with; noop\n            return null;\n\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChild(this);\n\n        // remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 1) {\n            for (int i = 1; i < wrapChildren.size(); i++) { // skip first\n                Element remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }",
        "comment": "/**\n     Wrap the supplied HTML around this element.\n     @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitralily deep.\n     @return this element, for chaining.\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/Parser.java",
        "start_loc": 219,
        "end_loc": 247,
        "buggy_function": "    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }",
        "fixed_function": "    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        Parser parser = new Parser(bodyHtml, baseUri, true);\n        parser.relaxed = true;\n        return parser.parse();\n    }",
        "comment": "/**\n     Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this\n     context, means that implicit tags are not automatically created when missing.\n     @param bodyHtml fragment of HTML\n     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     @return Document, with empty head, and HTML parsed into body\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/Parser.java",
        "start_loc": 249,
        "end_loc": 263,
        "buggy_function": "    private boolean stackHasValidParent(Tag childTag) {\n        if (stack.size() == 1 && childTag.equals(htmlTag))\n            return true; // root is valid for html node\n\n\n        // otherwise, look up the stack for valid ancestors\n        for (int i = stack.size() -1; i >= 0; i--) {\n            Element el = stack.get(i);\n            Tag parent2 = el.tag();\n            if (parent2.isValidParent(childTag)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "fixed_function": "    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor && !relaxed) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 67,
        "end_loc": 101,
        "buggy_function": "    boolean canContain(Tag child) {\n        Validate.notNull(child);\n\n        if (child.isBlock && !this.canContainBlock)\n            return false;\n\n        if (!child.isBlock && !this.canContainInline) // not block == inline\n            return false;\n\n        if (this.optionalClosing && this.equals(child))\n            return false;\n\n        if (this.empty || this.isData())\n            return false;\n\n        // head can only contain a few. if more than head in here, modify to have a list of valids\n        // TODO: (could solve this with walk for ancestor)\n        if (this.tagName.equals(\"head\")) {\n            if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") ||\n                    child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) {\n                return true;\n            }\n            return false;\n        }\n        \n        // dt and dd (in dl)\n        if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\"))\n            return false;\n        if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))\n            return false;\n\n        // don't allow children to contain their parent (directly)\n        \n        return true;\n    }",
        "fixed_function": "    boolean canContain(Tag child) {\n        Validate.notNull(child);\n\n        if (child.isBlock && !this.canContainBlock)\n            return false;\n\n        if (!child.isBlock && !this.canContainInline) // not block == inline\n            return false;\n\n        if (this.optionalClosing && this.equals(child))\n            return false;\n\n        if (this.empty || this.isData())\n            return false;\n\n        // head can only contain a few. if more than head in here, modify to have a list of valids\n        // TODO: (could solve this with walk for ancestor)\n        if (this.tagName.equals(\"head\")) {\n            if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") ||\n                    child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) {\n                return true;\n            }\n            return false;\n        }\n        \n        // dt and dd (in dl)\n        if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\"))\n            return false;\n        if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))\n            return false;\n\n        // don't allow children to contain their parent (directly)\n        if (this.requiresSpecificParent() && this.getImplicitParent().equals(child))\n            return false;\n        \n        return true;\n    }",
        "comment": "/**\n     Test if this tag, the prospective parent, can accept the proposed child.\n     @param child potential child tag.\n     @return true if this can contain child.\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 151,
        "end_loc": 153,
        "buggy_function": "    Tag getImplicitParent() {\n        return (!ancestors.isEmpty()) ? ancestors.get(0) : null;\n    }",
        "fixed_function": "    boolean requiresSpecificParent() {\n        return this.parent != null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 156,
        "end_loc": 166,
        "buggy_function": "    boolean isValidParent(Tag child) {\n\n        if (child.ancestors.isEmpty())\n            return true; // HTML tag\n\n        for (Tag tag : child.ancestors) {\n            if (this.equals(tag))\n                return true;\n        }\n        return false;\n    }",
        "fixed_function": "    boolean isValidParent(Tag child) {\n        return this.equals(child.parent);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 202,
        "end_loc": 316,
        "buggy_function": "    static {\n        // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline\n        // tags are set here in uppercase for legibility, but internally held as lowercase.\n        // TODO[must]: incorporate html 5 as appropriate\n\n        // document\n        createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl\n        createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT\n        createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl\n        createBlock(\"FRAMESET\").setAncestor(\"HTML\");\n\n        // head\n        // all ancestors set to (head, body): so implicitly create head, but allow in body\n        createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\");\n        createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n        createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head\n        createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param\n        createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n\n        createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty();\n        createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly();\n\n\n\n        // fontstyle\n        createInline(\"FONT\");\n        createInline(\"TT\");\n        createInline(\"I\");\n        createInline(\"B\");\n        createInline(\"BIG\");\n        createInline(\"SMALL\");\n\n        // phrase\n        createInline(\"EM\");\n        createInline(\"STRONG\");\n        createInline(\"DFN\");\n        createInline(\"CODE\");\n        createInline(\"SAMP\");\n        createInline(\"KBD\");\n        createInline(\"VAR\");\n        createInline(\"CITE\");\n        createInline(\"ABBR\");\n        createInline(\"ACRONYM\");\n\n        // special\n        createInline(\"A\").setOptionalClosing(); // cannot contain self\n        createInline(\"IMG\").setEmpty();\n        createInline(\"BR\").setEmpty();\n        createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.\n        createInline(\"Q\");\n        createInline(\"SUB\");\n        createInline(\"SUP\");\n        createInline(\"SPAN\");\n        createInline(\"BDO\");\n\n        // things past this point aren't really blocks or inline. I'm using them because they can hold block or inline,\n        // but per the spec, only specific elements can hold this. if this becomes a real-world parsing problem,\n        // will need to have another non block/inline type, and explicit include & exclude rules. should be right though\n\n        // block\n        createBlock(\"P\").setContainInlineOnly(); // emasculated block?\n        createBlock(\"H1\").setContainInlineOnly();\n        createBlock(\"H2\").setContainInlineOnly();\n        createBlock(\"H3\").setContainInlineOnly();\n        createBlock(\"H4\").setContainInlineOnly();\n        createBlock(\"H5\").setContainInlineOnly();\n        createBlock(\"H6\").setContainInlineOnly();\n        createBlock(\"UL\");\n        createBlock(\"OL\");\n        createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace();\n        createBlock(\"DIV\");\n        createBlock(\"BLOCKQUOTE\");\n        createBlock(\"HR\").setEmpty();\n        createBlock(\"ADDRESS\").setContainInlineOnly();\n\n\n        // formctrl\n        createBlock(\"FORM\").setOptionalClosing(); // can't contian self\n        createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty();\n        createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option\n        createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();\n        createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n        createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n        createInline(\"OPTGROUP\").setAncestor(\"SELECT\");\n        createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly();\n        createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n        createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n\n        // other\n        createInline(\"AREA\").setEmpty(); // not an inline per-se\n        createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty();\n        createBlock(\"INS\"); // only within body\n        createBlock(\"DEL\"); // only within body\n\n        createBlock(\"DL\");\n        createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing();\n        createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing();\n\n        createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL.\n\n        // tables\n        createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n        createBlock(\"CAPTION\").setAncestor(\"TABLE\");\n        createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing();\n        createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing();\n        createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing();\n        createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing();\n        createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty();\n        createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing();\n        createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing();\n        createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing();\n    }",
        "fixed_function": "    boolean isValidAncestor(Tag child) {\n        if (child.ancestors.isEmpty())\n            return true; // HTML tag\n\n        for (Tag tag : child.ancestors) {\n            if (this.equals(tag))\n                return true;\n        }\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 367,
        "end_loc": 377,
        "buggy_function": "    private Tag setAncestor(String... tagNames) {\n        if (tagNames == null) {\n            ancestors = Collections.emptyList();\n        } else {\n            ancestors = new ArrayList<Tag>(tagNames.length);\n            for (String name : tagNames) {\n                ancestors.add(Tag.valueOf(name));\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    static {\n        // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline\n        // tags are set here in uppercase for legibility, but internally held as lowercase.\n        // TODO[must]: incorporate html 5 as appropriate\n\n        // document\n        createBlock(\"HTML\").setAncestor(new String[0]); // specific includes not impl\n        createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT\n        createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl\n        createBlock(\"FRAMESET\").setAncestor(\"HTML\");\n\n        // head\n        // all ancestors set to (head, body): so implicitly create head, but allow in body\n        createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\");\n        createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n        createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head\n        createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param\n        createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n        createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n\n        createBlock(\"FRAME\").setParent(\"FRAMESET\").setEmpty();\n        createBlock(\"NOFRAMES\").setParent(\"FRAMESET\").setContainDataOnly();\n\n\n\n        // fontstyle\n        createInline(\"FONT\");\n        createInline(\"TT\");\n        createInline(\"I\");\n        createInline(\"B\");\n        createInline(\"BIG\");\n        createInline(\"SMALL\");\n\n        // phrase\n        createInline(\"EM\");\n        createInline(\"STRONG\");\n        createInline(\"DFN\");\n        createInline(\"CODE\");\n        createInline(\"SAMP\");\n        createInline(\"KBD\");\n        createInline(\"VAR\");\n        createInline(\"CITE\");\n        createInline(\"ABBR\");\n        createInline(\"ACRONYM\");\n\n        // special\n        createInline(\"A\").setOptionalClosing(); // cannot contain self\n        createInline(\"IMG\").setEmpty();\n        createInline(\"BR\").setEmpty();\n        createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.\n        createInline(\"Q\");\n        createInline(\"SUB\");\n        createInline(\"SUP\");\n        createInline(\"SPAN\");\n        createInline(\"BDO\");\n\n        // things past this point aren't really blocks or inline. I'm using them because they can hold block or inline,\n        // but per the spec, only specific elements can hold this. if this becomes a real-world parsing problem,\n        // will need to have another non block/inline type, and explicit include & exclude rules. should be right though\n\n        // block\n        createBlock(\"P\").setContainInlineOnly(); // emasculated block?\n        createBlock(\"H1\").setContainInlineOnly();\n        createBlock(\"H2\").setContainInlineOnly();\n        createBlock(\"H3\").setContainInlineOnly();\n        createBlock(\"H4\").setContainInlineOnly();\n        createBlock(\"H5\").setContainInlineOnly();\n        createBlock(\"H6\").setContainInlineOnly();\n        createBlock(\"UL\");\n        createBlock(\"OL\");\n        createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace();\n        createBlock(\"DIV\");\n        createBlock(\"BLOCKQUOTE\");\n        createBlock(\"HR\").setEmpty();\n        createBlock(\"ADDRESS\").setContainInlineOnly();\n\n\n        // formctrl\n        createBlock(\"FORM\").setOptionalClosing(); // can't contian self\n        createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty();\n        createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option\n        createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();\n        createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n        createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n        createInline(\"OPTGROUP\").setParent(\"SELECT\"); //  only contain option\n        createInline(\"OPTION\").setParent(\"SELECT\").setContainDataOnly();\n        createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n        createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n\n        // other\n        createInline(\"AREA\").setEmpty(); // not an inline per-se\n        createInline(\"PARAM\").setParent(\"OBJECT\").setEmpty();\n        createBlock(\"INS\"); // only within body\n        createBlock(\"DEL\"); // only within body\n\n        createBlock(\"DL\");\n        createInline(\"DT\").setParent(\"DL\").setOptionalClosing(); // only within DL.\n        createInline(\"DD\").setParent(\"DL\").setOptionalClosing(); // only within DL.\n\n        createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL.\n\n        // tables\n        createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n        createBlock(\"CAPTION\").setParent(\"TABLE\");\n        createBlock(\"THEAD\").setParent(\"TABLE\").setOptionalClosing(); // just TR\n        createBlock(\"TFOOT\").setParent(\"TABLE\").setOptionalClosing(); // just TR\n        createBlock(\"TBODY\").setParent(\"TABLE\").setOptionalClosing(); // optional / implicit open too. just TR\n        createBlock(\"COLGROUP\").setParent(\"TABLE\").setOptionalClosing(); // just COL\n        createBlock(\"COL\").setParent(\"COLGROUP\").setEmpty();\n        createBlock(\"TR\").setParent(\"TABLE\").setOptionalClosing(); // just TH, TD\n        createBlock(\"TH\").setParent(\"TR\").setOptionalClosing();\n        createBlock(\"TD\").setParent(\"TR\").setOptionalClosing();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.nodes.ElementTest::testAppendRowToTable": {
        "path": "org/jsoup/nodes/ElementTest.java",
        "function_name": "testAppendRowToTable",
        "src": "@Test public void testAppendRowToTable() {\n        Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n        Element table = doc.select(\"table\").first();\n        table.append(\"<tr><td>2</td></tr>\");\n\n        assertEquals(\"<table><tr><td>1</td></tr><tr><td>2</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n    }",
        "error_msg": "org.jsoup.nodes.ElementTest::testAppendRowToTable --> junit.framework.AssertionFailedError: expected:<...tr><td>1</td></tr><t[r><td>2</td></tr]></table>> but was:<...tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...tr><td>1</td></tr><t[r><td>2</td></tr]></table>> but was:<...tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>"
      },
      "org.jsoup.nodes.ElementTest::testPrependRowToTable": {
        "path": "org/jsoup/nodes/ElementTest.java",
        "function_name": "testPrependRowToTable",
        "src": "@Test public void testPrependRowToTable() {\n        Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n        Element table = doc.select(\"table\").first();\n        table.prepend(\"<tr><td>2</td></tr>\");\n\n        assertEquals(\"<table><tr><td>2</td></tr><tr><td>1</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n    }",
        "error_msg": "org.jsoup.nodes.ElementTest::testPrependRowToTable --> junit.framework.AssertionFailedError: expected:<<table><t[r><td>2</td></tr]><tr><td>1</td></tr>...> but was:<<table><t[able><tr><td>2</td></tr></table]><tr><td>1</td></tr>...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<table><t[r><td>2</td></tr]><tr><td>1</td></tr>...> but was:<<table><t[able><tr><td>2</td></tr></table]><tr><td>1</td></tr>...>"
      },
      "org.jsoup.parser.ParserTest::handlesNestedImplicitTable": {
        "path": "org/jsoup/parser/ParserTest.java",
        "function_name": "handlesNestedImplicitTable",
        "src": "@Test public void handlesNestedImplicitTable() {\n        Document doc = Jsoup.parse(\"<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>\");\n        assertEquals(\"<table><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tr><td>3</td> <td>4</td></tr></table> </td></tr><tr><td>5</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n    }",
        "error_msg": "org.jsoup.parser.ParserTest::handlesNestedImplicitTable --> junit.framework.AssertionFailedError: expected:<...> <tr><td> <table><t[r><td>3</td> <td>4</td></tr></table> </td></tr><tr><td>5]</td></tr></table>> but was:<...> <tr><td> <table><t[d>3</td> <td>4</td></table> <tr><td>5</td></tr>]</td></tr></table>>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...> <tr><td> <table><t[r><td>3</td> <td>4</td></tr></table> </td></tr><tr><td>5]</td></tr></table>> but was:<...> <tr><td> <table><t[d>3</td> <td>4</td></table> <tr><td>5</td></tr>]</td></tr></table>>"
      }
    }
  },
  "Jsoup-21": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "start_loc": 56,
        "end_loc": 62,
        "buggy_function": "        Or(Collection<Evaluator> evaluators) {\n            super();\n            if (evaluators.size() > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n        }",
        "fixed_function": "        Or() {\n            super();\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/select/QueryParser.java",
        "start_loc": 44,
        "end_loc": 79,
        "buggy_function": "    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "fixed_function": "    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "comment": "/**\n     * Parse the query\n     * @return Evaluator\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/select/QueryParser.java",
        "start_loc": 81,
        "end_loc": 103,
        "buggy_function": "    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n        Evaluator e;\n\n        if (evals.size() == 1)\n            e = evals.get(0);\n        else\n            e = new CombiningEvaluator.And(evals);\n        evals.clear();\n        Evaluator f = parse(subQuery);\n\n        if (combinator == '>')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n        else if (combinator == ' ')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n        else if (combinator == '+')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n        else if (combinator == '~')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n    }",
        "fixed_function": "    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n        Evaluator e;\n\n        if (evals.size() == 1)\n            e = evals.get(0);\n        else\n            e = new CombiningEvaluator.And(evals);\n        evals.clear();\n        Evaluator f = parse(subQuery);\n\n        if (combinator == '>')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n        else if (combinator == ' ')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n        else if (combinator == '+')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n        else if (combinator == '~')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n        else if (combinator == ',') { // group or\n            CombiningEvaluator.Or or;\n            if (e instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) e;\n                or.add(f);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(e);\n                or.add(f);\n            }\n            evals.add(or);\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.select.SelectorTest::handlesCommasInSelector": {
        "path": "org/jsoup/select/SelectorTest.java",
        "function_name": "handlesCommasInSelector",
        "src": "@Test public void handlesCommasInSelector() {\n        Document doc = Jsoup.parse(\"<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>\");\n\n        Elements ps = doc.select(\"[name=1,2]\");\n        assertEquals(1, ps.size());\n\n        Elements containers = doc.select(\"div, li:matches([0-9,]+)\");\n        assertEquals(2, containers.size());\n        assertEquals(\"div\", containers.get(0).tagName());\n        assertEquals(\"li\", containers.get(1).tagName());\n        assertEquals(\"123\", containers.get(1).text());\n    }",
        "error_msg": "org.jsoup.select.SelectorTest::handlesCommasInSelector --> java.util.regex.PatternSyntaxException: Unclosed character class near index 3",
        "clean_error_msg": "java.util.regex.PatternSyntaxException: Unclosed character class near index 3"
      },
      "org.jsoup.select.SelectorTest::mixCombinatorGroup": {
        "path": "org/jsoup/select/SelectorTest.java",
        "function_name": "mixCombinatorGroup",
        "src": "@Test public void mixCombinatorGroup() {\n        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n        Document doc = Jsoup.parse(h);\n        Elements els = doc.select(\".foo > ol, ol > li + li\");\n\n        assertEquals(2, els.size());\n        assertEquals(\"li\", els.get(0).tagName());\n        assertEquals(\"Three\", els.get(1).text());\n    }",
        "error_msg": "org.jsoup.select.SelectorTest::mixCombinatorGroup --> junit.framework.AssertionFailedError: expected:<2> but was:<3>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      }
    }
  },
  "Jsoup-22": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 433,
        "end_loc": 436,
        "buggy_function": "    public Elements siblingElements() {\n\n        return parent().children();\n    }",
        "fixed_function": "    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().children();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }",
        "comment": "/**\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 446,
        "end_loc": 454,
        "buggy_function": "    public Element nextElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }",
        "fixed_function": "    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }",
        "comment": "/**\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p/>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Element.java",
        "start_loc": 461,
        "end_loc": 469,
        "buggy_function": "    public Element previousElementSibling() {\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "fixed_function": "    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "comment": "/**\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Node.java",
        "start_loc": 443,
        "end_loc": 446,
        "buggy_function": "    public List<Node> siblingNodes() {\n\n        return parent().childNodes();\n    }",
        "fixed_function": "    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }",
        "comment": "/**\n     Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n     include this node (a node is not a sibling of itself).\n     @return node siblings. If the node has no parent, returns an empty list.\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/Node.java",
        "start_loc": 469,
        "end_loc": 478,
        "buggy_function": "    public Node previousSibling() {\n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "fixed_function": "    public Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "comment": "/**\n     Get this node's previous sibling.\n     @return the previous sibling, or null if this is the first sibling\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/select/Elements.java",
        "start_loc": 18,
        "end_loc": 20,
        "buggy_function": "    public Elements() {\n        contents = new ArrayList<Element>();\n    }",
        "fixed_function": "    public Elements(int initialCapacity) {\n        contents = new ArrayList<Element>(initialCapacity);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.nodes.ElementTest::elementIsNotASiblingOfItself": {
        "path": "org/jsoup/nodes/ElementTest.java",
        "function_name": "elementIsNotASiblingOfItself",
        "src": "@Test public void elementIsNotASiblingOfItself() {\n        Document doc = Jsoup.parse(\"<div><p>One<p>Two<p>Three</div>\");\n        Element p2 = doc.select(\"p\").get(1);\n\n        assertEquals(\"Two\", p2.text());\n        Elements els = p2.siblingElements();\n        assertEquals(2, els.size());\n        assertEquals(\"<p>One</p>\", els.get(0).outerHtml());\n        assertEquals(\"<p>Three</p>\", els.get(1).outerHtml());\n    }",
        "error_msg": "org.jsoup.nodes.ElementTest::elementIsNotASiblingOfItself --> junit.framework.AssertionFailedError: expected:<2> but was:<3>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      },
      "org.jsoup.nodes.NodeTest::nodeIsNotASiblingOfItself": {
        "path": "org/jsoup/nodes/NodeTest.java",
        "function_name": "nodeIsNotASiblingOfItself",
        "src": "@Test public void nodeIsNotASiblingOfItself() {\n        Document doc = Jsoup.parse(\"<div><p>One<p>Two<p>Three</div>\");\n        Element p2 = doc.select(\"p\").get(1);\n\n        assertEquals(\"Two\", p2.text());\n        List<Node> nodes = p2.siblingNodes();\n        assertEquals(2, nodes.size());\n        assertEquals(\"<p>One</p>\", nodes.get(0).outerHtml());\n        assertEquals(\"<p>Three</p>\", nodes.get(1).outerHtml());\n    }",
        "error_msg": "org.jsoup.nodes.NodeTest::nodeIsNotASiblingOfItself --> junit.framework.AssertionFailedError: expected:<2> but was:<3>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<3>"
      },
      "org.jsoup.nodes.NodeTest::orphanNodeReturnsNullForSiblingElements": {
        "path": "org/jsoup/nodes/NodeTest.java",
        "function_name": "orphanNodeReturnsNullForSiblingElements",
        "src": "@Test public void orphanNodeReturnsNullForSiblingElements() {\n        Node node = new Element(Tag.valueOf(\"p\"), \"\");\n        Element el = new Element(Tag.valueOf(\"p\"), \"\");\n\n        assertEquals(0, node.siblingIndex());\n        assertEquals(0, node.siblingNodes().size());\n\n        assertNull(node.previousSibling());\n        assertNull(node.nextSibling());\n\n        assertEquals(0, el.siblingElements().size());\n        assertNull(el.previousElementSibling());\n        assertNull(el.nextElementSibling());\n    }",
        "error_msg": "org.jsoup.nodes.NodeTest::orphanNodeReturnsNullForSiblingElements --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Jsoup-28": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/nodes/Entities.java",
        "start_loc": 102,
        "end_loc": 130,
        "buggy_function": "    static String unescape(String string, boolean strict) {\n        if (!string.contains(\"&\"))\n            return string;\n        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);\n        StringBuffer accum = new StringBuffer(string.length());\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10;\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                }\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n            if (charval != -1 || charval > 0xFFFF) {\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }",
        "fixed_function": "    public static boolean isBaseNamedEntity(String name) {\n        return base.containsKey(name);\n    }",
        "comment": "/**\n     * Check if the input is a known named entity in the base entity set.\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "start_loc": 100,
        "end_loc": 164,
        "buggy_function": "    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            String origNameRef = new String(nameRef);\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }",
        "fixed_function": "    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.nodes.EntitiesTest::unescape": {
        "path": "org/jsoup/nodes/EntitiesTest.java",
        "function_name": "unescape",
        "src": "@Test public void unescape() {\n        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n\n        assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));\n    }",
        "error_msg": "org.jsoup.nodes.EntitiesTest::unescape --> junit.framework.AssertionFailedError: expected:<Hello &<> \u00ae \u00c5 [&angst] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...> but was:<Hello &<> \u00ae \u00c5 [\u00c5] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<Hello &<> \u00ae \u00c5 [&angst] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...> but was:<Hello &<> \u00ae \u00c5 [\u00c5] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...>"
      },
      "org.jsoup.nodes.EntitiesTest::noSpuriousDecodes": {
        "path": "org/jsoup/nodes/EntitiesTest.java",
        "function_name": "noSpuriousDecodes",
        "src": "@Test public void noSpuriousDecodes() {\n        String string = \"http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\";\n        assertEquals(string, Entities.unescape(string));\n    }",
        "error_msg": "org.jsoup.nodes.EntitiesTest::noSpuriousDecodes --> junit.framework.AssertionFailedError: expected:<...tp://www.foo.com?a=1[&num_rooms=1&children=0&int]=VA&b=2> but was:<...tp://www.foo.com?a=1[#_rooms=1&children=0\u222b]=VA&b=2>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...tp://www.foo.com?a=1[&num_rooms=1&children=0&int]=VA&b=2> but was:<...tp://www.foo.com?a=1[#_rooms=1&children=0\u222b]=VA&b=2>"
      },
      "org.jsoup.parser.AttributeParseTest::moreAttributeUnescapes": {
        "path": "org/jsoup/parser/AttributeParseTest.java",
        "function_name": "moreAttributeUnescapes",
        "src": "@Test public void moreAttributeUnescapes() {\n        String html = \"<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>\";\n        Elements els = Jsoup.parse(html).select(\"a\");\n        assertEquals(\"&wr_id=123&mid-size=true&ok=&wr\", els.first().attr(\"href\"));\n    }",
        "error_msg": "org.jsoup.parser.AttributeParseTest::moreAttributeUnescapes --> junit.framework.AssertionFailedError: expected:<...23&mid-size=true&ok=[&wr]> but was:<...23&mid-size=true&ok=[\u2240]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...23&mid-size=true&ok=[&wr]> but was:<...23&mid-size=true&ok=[\u2240]>"
      },
      "org.jsoup.parser.AttributeParseTest::strictAttributeUnescapes": {
        "path": "org/jsoup/parser/AttributeParseTest.java",
        "function_name": "strictAttributeUnescapes",
        "src": "@Test public void strictAttributeUnescapes() {\n        String html = \"<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>\";\n        Elements els = Jsoup.parse(html).select(\"a\");\n        assertEquals(\"?foo=bar&mid&lt=true\", els.first().attr(\"href\"));\n        assertEquals(\"?foo=bar<qux&lg=1\", els.last().attr(\"href\"));\n    }",
        "error_msg": "org.jsoup.parser.AttributeParseTest::strictAttributeUnescapes --> junit.framework.AssertionFailedError: expected:<?foo=bar[&mid]&lt=true> but was:<?foo=bar[\u2223]&lt=true>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<?foo=bar[&mid]&lt=true> but was:<?foo=bar[\u2223]&lt=true>"
      },
      "org.jsoup.parser.HtmlParserTest::doesNotFindShortestMatchingEntity": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "doesNotFindShortestMatchingEntity",
        "src": "@Test public void doesNotFindShortestMatchingEntity() {\n        // previous behaviour was to identify a possible entity, then chomp down the string until a match was found.\n        // (as defined in html5.) However in practise that lead to spurious matches against the author's intent.\n        String html = \"One &clubsuite; &clubsuit;\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(StringUtil.normaliseWhitespace(\"One &amp;clubsuite; \u2663\"), doc.body().html());\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::doesNotFindShortestMatchingEntity --> junit.framework.AssertionFailedError: expected:<One [&amp;clubsuit]e; \u2663> but was:<One [\u2663]e; \u2663>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<One [&amp;clubsuit]e; \u2663> but was:<One [\u2663]e; \u2663>"
      },
      "org.jsoup.parser.HtmlParserTest::relaxedBaseEntityMatchAndStrictExtendedMatch": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "relaxedBaseEntityMatchAndStrictExtendedMatch",
        "src": "@Test public void relaxedBaseEntityMatchAndStrictExtendedMatch() {\n        // extended entities need a ; at the end to match, base does not\n        String html = \"&amp &quot &reg &icy &hopf &icy; &hopf;\";\n        Document doc = Jsoup.parse(html);\n        doc.outputSettings().escapeMode(Entities.EscapeMode.extended); // modifies output only to clarify test\n        assertEquals(StringUtil.normaliseWhitespace(\"&amp; &quot; &reg; &amp;icy &amp;hopf &icy; &hopf;\"), doc.body().html());\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::relaxedBaseEntityMatchAndStrictExtendedMatch --> junit.framework.AssertionFailedError: expected:<&amp; &quot; &reg; &[amp;icy &amp;hopf] &icy; &hopf;> but was:<&amp; &quot; &reg; &[icy; &hopf;] &icy; &hopf;>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<&amp; &quot; &reg; &[amp;icy &amp;hopf] &icy; &hopf;> but was:<&amp; &quot; &reg; &[icy; &hopf;] &icy; &hopf;>"
      }
    }
  },
  "Jsoup-52": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "start_loc": 94,
        "end_loc": 146,
        "buggy_function": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n        charsetName = detectCharsetFromBom(byteData, charsetName);\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            if (meta != null) {\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                    foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n            }\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n                if (prolog.name().equals(\"xml\")) {\n                    foundCharset = prolog.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n\n            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
        "fixed_function": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n        charsetName = detectCharsetFromBom(byteData, charsetName);\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            if (meta != null) {\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n            }\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n                if (prolog.name().equals(\"xml\")) {\n                    foundCharset = prolog.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n\n            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "start_loc": 45,
        "end_loc": 62,
        "buggy_function": "    public String getWholeDeclaration() {\n        final String decl = this.name;\n        if(decl.equals(\"xml\") && attributes.size() > 1 ) {\n            StringBuilder sb = new StringBuilder(decl);\n            final String version = attributes.get(\"version\");\n            if( version != null ) {\n                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n            }\n            final String encoding = attributes.get(\"encoding\");\n            if( encoding != null ) {\n                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n            }\n            return sb.toString();\n        }\n        else {\n            return this.name;\n        }\n    }",
        "fixed_function": "    public String getWholeDeclaration() {\n        return attributes.html().trim(); // attr html starts with a \" \"\n    }",
        "comment": "/**\n     Get the unencoded XML declaration.\n     @return XML declaration\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "start_loc": 64,
        "end_loc": 70,
        "buggy_function": "\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<\")\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n                .append(getWholeDeclaration())\n            .append(\">\");\n    }",
        "fixed_function": "\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<\")\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(name);\n        attributes.html(accum, out);\n        accum\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(\">\");\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "start_loc": 69,
        "end_loc": 81,
        "buggy_function": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                String declaration = data.substring(1);\n                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n            }\n        }\n        insertNode(insert);\n    }",
        "fixed_function": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlNoCharset": {
        "path": "org/jsoup/nodes/DocumentTest.java",
        "function_name": "testMetaCharsetUpdateXmlNoCharset",
        "src": "@Test\n    public void testMetaCharsetUpdateXmlNoCharset() {\n        final Document doc = createXmlDocument(\"1.0\", \"none\", false);\n        doc.updateMetaCharsetElement(true);\n        doc.charset(Charset.forName(charsetUtf8));\n        \n        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\"?>\\n\" +\n                                        \"<root>\\n\" +\n                                        \" node\\n\" +\n                                        \"</root>\";\n        assertEquals(xmlCharsetUTF8, doc.toString());\n        \n        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n    }",
        "error_msg": "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlNoCharset --> junit.framework.AssertionFailedError: expected:<....0 encoding=UTF-8[?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<....0 encoding=UTF-8[?]>"
      },
      "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlIso8859": {
        "path": "org/jsoup/nodes/DocumentTest.java",
        "function_name": "testMetaCharsetUpdateXmlIso8859",
        "src": "@Test\n    public void testMetaCharsetUpdateXmlIso8859() {\n        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n        doc.updateMetaCharsetElement(true);\n        doc.charset(Charset.forName(charsetIso8859));\n        \n        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\"?>\\n\" +\n                                        \"<root>\\n\" +\n                                        \" node\\n\" +\n                                        \"</root>\";\n        assertEquals(xmlCharsetISO, doc.toString());\n        \n        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n        assertEquals(charsetIso8859, doc.charset().name());\n        assertEquals(charsetIso8859, selectedNode.attr(\"encoding\"));\n        assertEquals(doc.charset(), doc.outputSettings().charset());\n    }",
        "error_msg": "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlIso8859 --> junit.framework.AssertionFailedError: expected:<...ncoding=ISO-8859-1[?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...ncoding=ISO-8859-1[?]>"
      },
      "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlUtf8": {
        "path": "org/jsoup/nodes/DocumentTest.java",
        "function_name": "testMetaCharsetUpdateXmlUtf8",
        "src": "@Test\n    public void testMetaCharsetUpdateXmlUtf8() {\n        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n        doc.updateMetaCharsetElement(true);\n        doc.charset(Charset.forName(charsetUtf8));\n        \n        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\"?>\\n\" +\n                                        \"<root>\\n\" +\n                                        \" node\\n\" +\n                                        \"</root>\";\n        assertEquals(xmlCharsetUTF8, doc.toString());\n\n        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n        assertEquals(charsetUtf8, doc.charset().name());\n        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n        assertEquals(doc.charset(), doc.outputSettings().charset());\n    }",
        "error_msg": "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlUtf8 --> junit.framework.AssertionFailedError: expected:<....0 encoding=UTF-8[?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<....0 encoding=UTF-8[?]>"
      },
      "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlDisabledNoChanges": {
        "path": "org/jsoup/nodes/DocumentTest.java",
        "function_name": "testMetaCharsetUpdateXmlDisabledNoChanges",
        "src": "@Test\n    public void testMetaCharsetUpdateXmlDisabledNoChanges() {\n        final Document doc = createXmlDocument(\"dontTouch\", \"dontTouch\", true);\n        \n        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\"?>\\n\" +\n                                    \"<root>\\n\" +\n                                    \" node\\n\" +\n                                    \"</root>\";\n        assertEquals(xmlCharset, doc.toString());\n        \n        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n        assertEquals(\"dontTouch\", selectedNode.attr(\"encoding\"));\n        assertEquals(\"dontTouch\", selectedNode.attr(\"version\"));\n    }",
        "error_msg": "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlDisabledNoChanges --> junit.framework.AssertionFailedError: expected:<...encoding=dontTouch[?]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...encoding=dontTouch[?]>"
      },
      "org.jsoup.parser.XmlTreeBuilderTest::handlesXmlDeclarationAsDeclaration": {
        "path": "org/jsoup/parser/XmlTreeBuilderTest.java",
        "function_name": "handlesXmlDeclarationAsDeclaration",
        "src": "@Test public void handlesXmlDeclarationAsDeclaration() {\n        String html = \"<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->\";\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n        assertEquals(\"<?xml encoding=\\\"UTF-8\\\"?> <body> One </body> <!-- comment -->\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n        assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n        assertEquals(\"#comment\", doc.childNode(2).nodeName());\n    }",
        "error_msg": "org.jsoup.parser.XmlTreeBuilderTest::handlesXmlDeclarationAsDeclaration --> junit.framework.AssertionFailedError: expected:<<?xml encoding=[UTF-8]?> <body> One </body...> but was:<<?xml encoding=['UTF-8' ]?> <body> One </body...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<?xml encoding=[UTF-8]?> <body> One </body...> but was:<<?xml encoding=['UTF-8' ]?> <body> One </body...>"
      },
      "org.jsoup.parser.XmlTreeBuilderTest::testDetectCharsetEncodingDeclaration": {
        "path": "org/jsoup/parser/XmlTreeBuilderTest.java",
        "function_name": "testDetectCharsetEncodingDeclaration",
        "src": "@Test\n    public void testDetectCharsetEncodingDeclaration() throws IOException, URISyntaxException {\n        File xmlFile = new File(XmlTreeBuilder.class.getResource(\"/htmltests/xml-charset.xml\").toURI());\n        InputStream inStream = new FileInputStream(xmlFile);\n        Document doc = Jsoup.parse(inStream, null, \"http://example.com/\", Parser.xmlParser());\n        assertEquals(\"ISO-8859-1\", doc.charset().name());\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?> <data>\u00e4\u00f6\u00e5\u00e9\u00fc</data>\",\n            TextUtil.stripNewlines(doc.html()));\n    }",
        "error_msg": "org.jsoup.parser.XmlTreeBuilderTest::testDetectCharsetEncodingDeclaration --> junit.framework.AssertionFailedError: expected:<[ISO-8859-1]> but was:<[UTF-8]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[ISO-8859-1]> but was:<[UTF-8]>"
      },
      "org.jsoup.parser.XmlTreeBuilderTest::testParseDeclarationAttributes": {
        "path": "org/jsoup/parser/XmlTreeBuilderTest.java",
        "function_name": "testParseDeclarationAttributes",
        "src": "@Test\n    public void testParseDeclarationAttributes() {\n        String xml = \"<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>\";\n        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);\n        assertEquals(\"1\", decl.attr(\"version\"));\n        assertEquals(\"UTF-8\", decl.attr(\"encoding\"));\n        assertEquals(\"else\", decl.attr(\"something\"));\n        assertEquals(\"version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"\", decl.getWholeDeclaration());\n        assertEquals(\"<?xml version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"?>\", decl.outerHtml());\n    }",
        "error_msg": "org.jsoup.parser.XmlTreeBuilderTest::testParseDeclarationAttributes --> junit.framework.AssertionFailedError: expected:<[1]> but was:<[]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[1]> but was:<[]>"
      }
    }
  },
  "Jsoup-56": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "start_loc": 26,
        "end_loc": 32,
        "buggy_function": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        attr(SYSTEM_ID, systemId);\n    }",
        "fixed_function": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        if (has(PUBLIC_ID)) {\n            attr(PUB_SYS_KEY, PUBLIC_KEY);\n        }\n        attr(SYSTEM_ID, systemId);\n    }",
        "comment": "/**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "start_loc": 48,
        "end_loc": 63,
        "buggy_function": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n            // looks like a html5 doctype, go lowercase for aesthetics\n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(NAME))\n            accum.append(\" \").append(attr(NAME));\n        if (has(PUBLIC_ID))\n            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n        if (has(SYSTEM_ID))\n            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n        accum.append('>');\n    }",
        "fixed_function": "    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(NAME, name);\n        if (pubSysKey != null) {\n            attr(PUB_SYS_KEY, pubSysKey);\n        }\n        attr(PUBLIC_ID, publicId);\n        attr(SYSTEM_ID, systemId);\n    }",
        "comment": "/**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/Token.java",
        "start_loc": 43,
        "end_loc": 50,
        "buggy_function": "        @Override\n        Token reset() {\n            reset(name);\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }",
        "fixed_function": "        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Token.java",
        "start_loc": 52,
        "end_loc": 54,
        "buggy_function": "        String getName() {\n            return name.toString();\n        }",
        "fixed_function": "        String getPubSysKey() {\n            return pubSysKey;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "start_loc": 99,
        "end_loc": 102,
        "buggy_function": "    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }",
        "fixed_function": "    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.nodes.DocumentTypeTest::testRoundTrip": {
        "path": "org/jsoup/nodes/DocumentTypeTest.java",
        "function_name": "testRoundTrip",
        "src": "@Test public void testRoundTrip() {\n        String base = \"<!DOCTYPE html>\";\n        assertEquals(\"<!doctype html>\", htmlOutput(base));\n        assertEquals(base, xmlOutput(base));\n\n        String publicDoc = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\";\n        assertEquals(publicDoc, htmlOutput(publicDoc));\n        assertEquals(publicDoc, xmlOutput(publicDoc));\n\n        String systemDoc = \"<!DOCTYPE html SYSTEM \\\"exampledtdfile.dtd\\\">\";\n        assertEquals(systemDoc, htmlOutput(systemDoc));\n        assertEquals(systemDoc, xmlOutput(systemDoc));\n\n        String legacyDoc = \"<!DOCTYPE html SYSTEM \\\"about:legacy-compat\\\">\";\n        assertEquals(legacyDoc, htmlOutput(legacyDoc));\n        assertEquals(legacyDoc, xmlOutput(legacyDoc));\n    }",
        "error_msg": "org.jsoup.nodes.DocumentTypeTest::testRoundTrip --> junit.framework.AssertionFailedError: expected:<<!DOCTYPE html [SYSTEM ]exampledtdfile.dtd...> but was:<<!DOCTYPE html []exampledtdfile.dtd...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<!DOCTYPE html [SYSTEM ]exampledtdfile.dtd...> but was:<<!DOCTYPE html []exampledtdfile.dtd...>"
      }
    }
  },
  "Jsoup-58": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/Jsoup.java",
        "start_loc": 249,
        "end_loc": 251,
        "buggy_function": "    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n    }",
        "fixed_function": "    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n    }",
        "comment": "/**\n     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n     @param bodyHtml HTML to test\n     @param whitelist whitelist to test against\n     @return true if no tags or attributes were removed; false otherwise\n     @see #clean(String, org.jsoup.safety.Whitelist) \n     */"
      },
      {
        "path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "start_loc": 73,
        "end_loc": 79,
        "buggy_function": "    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }",
        "fixed_function": "    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0\n            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n    }",
        "comment": "/**\n     Determines if the input document <b>body</b>is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist, and that there is no content in the <code>head</code>.\n     <p>\n     This method can be used as a validator for user input. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     </p>\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */"
      }
    ],
    "trigger_test": {
      "org.jsoup.safety.CleanerTest::testIsValidBodyHtml": {
        "path": "org/jsoup/safety/CleanerTest.java",
        "function_name": "testIsValidBodyHtml",
        "src": "@Test public void testIsValidBodyHtml() {\n        String ok = \"<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>\";\n        String ok1 = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\"; // missing enforced is OK because still needs run thru cleaner\n        String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n        String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n        String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n        String nok4 = \"<html><head>Foo</head><body><b>OK</b></body></html>\"; // not body html\n        String nok5 = \"<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>\";\n        String nok6 = \"<p>Test <b><a href='http://example.com/'>OK</b></p>\"; // missing close tag\n        String nok7 = \"</div>What\";\n        assertTrue(Jsoup.isValid(ok, Whitelist.basic()));\n        assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));\n        assertFalse(Jsoup.isValid(ok, Whitelist.none()));\n        assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));\n    }",
        "error_msg": "org.jsoup.safety.CleanerTest::testIsValidBodyHtml --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.jsoup.safety.CleanerTest::testIsValidDocument": {
        "path": "org/jsoup/safety/CleanerTest.java",
        "function_name": "testIsValidDocument",
        "src": "@Test public void testIsValidDocument() {\n        String ok = \"<html><head></head><body><p>Hello</p></body><html>\";\n        String nok = \"<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>\";\n\n        Whitelist relaxed = Whitelist.relaxed();\n        Cleaner cleaner = new Cleaner(relaxed);\n        Document okDoc = Jsoup.parse(ok);\n        assertTrue(cleaner.isValid(okDoc));\n        assertFalse(cleaner.isValid(Jsoup.parse(nok)));\n        assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));\n    }",
        "error_msg": "org.jsoup.safety.CleanerTest::testIsValidDocument --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jsoup-60": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "start_loc": 260,
        "end_loc": 290,
        "buggy_function": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        return out;\n    }",
        "fixed_function": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced maker at \" + out);\n        }\n        return out;\n    }",
        "comment": "/**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/select/QueryParser.java",
        "start_loc": 37,
        "end_loc": 40,
        "buggy_function": "    public static Evaluator parse(String query) {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n    }",
        "fixed_function": "    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }",
        "comment": "/**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     */"
      }
    ],
    "trigger_test": {
      "org.jsoup.select.QueryParserTest::testParsesSingleQuoteInContains": {
        "path": "org/jsoup/select/QueryParserTest.java",
        "function_name": "testParsesSingleQuoteInContains",
        "src": "@Test(expected = Selector.SelectorParseException.class)  public void testParsesSingleQuoteInContains() {\n        Evaluator parse = QueryParser.parse(\"p:contains(One \\\" One)\");\n    }",
        "error_msg": "org.jsoup.select.QueryParserTest::testParsesSingleQuoteInContains --> junit.framework.AssertionFailedError: Expected exception: org.jsoup.select.Selector$SelectorParseException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: org.jsoup.select.Selector$SelectorParseException"
      },
      "org.jsoup.select.QueryParserTest::exceptionOnUncloseAttribute": {
        "path": "org/jsoup/select/QueryParserTest.java",
        "function_name": "exceptionOnUncloseAttribute",
        "src": "@Test(expected = Selector.SelectorParseException.class) public void exceptionOnUncloseAttribute() {\n        Evaluator parse = QueryParser.parse(\"section > a[href=\\\"]\");\n    }",
        "error_msg": "org.jsoup.select.QueryParserTest::exceptionOnUncloseAttribute --> java.lang.Exception: Unexpected exception, expected<org.jsoup.select.Selector$SelectorParseException> but was<java.lang.IllegalArgumentException>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<org.jsoup.select.Selector$SelectorParseException> but was<java.lang.IllegalArgumentException>"
      }
    }
  },
  "Jsoup-63": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 221,
        "end_loc": 235,
        "buggy_function": "    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n            }\n            else {\n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag();\n            }\n        }\n        return el;\n    }",
        "fixed_function": "    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "start_loc": 43,
        "end_loc": 65,
        "buggy_function": "    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charsBuilder.length() > 0) {\n            String str = charsBuilder.toString();\n            charsBuilder.delete(0, charsBuilder.length());\n            charsString = null;\n            return charPending.data(str);\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }",
        "fixed_function": "    Token read() {\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charsBuilder.length() > 0) {\n            String str = charsBuilder.toString();\n            charsBuilder.delete(0, charsBuilder.length());\n            charsString = null;\n            return charPending.data(str);\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "start_loc": 67,
        "end_loc": 83,
        "buggy_function": "    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }",
        "fixed_function": "    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "start_loc": 124,
        "end_loc": 126,
        "buggy_function": "    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }",
        "fixed_function": "    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "selfClosingOnNonvoidIsError",
        "src": "@Test public void selfClosingOnNonvoidIsError() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(1, parser.getErrors().size());\n        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());\n\n        assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError --> junit.framework.AssertionFailedError: expected:<18: [Tag cannot be self closing; not a void tag]> but was:<18: [Self closing flag not acknowledged]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<18: [Tag cannot be self closing; not a void tag]> but was:<18: [Self closing flag not acknowledged]>"
      },
      "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "selfClosingVoidIsNotAnError",
        "src": "@Test public void selfClosingVoidIsNotAnError() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(0, parser.getErrors().size());\n\n        assertTrue(Jsoup.isValid(html, Whitelist.basic()));\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        assertEquals(\"<p>test<br>test<br></p>\", clean);\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError --> junit.framework.AssertionFailedError: expected:<0> but was:<2>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0> but was:<2>"
      },
      "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "tracksErrorsWhenRequested",
        "src": "@Test public void tracksErrorsWhenRequested() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        assertEquals(5, errors.size());\n        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n        assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());\n        assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested --> junit.framework.AssertionFailedError: expected:<50: [Tag cannot be self closing; not a void tag]> but was:<50: [Self closing flag not acknowledged]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<50: [Tag cannot be self closing; not a void tag]> but was:<50: [Self closing flag not acknowledged]>"
      }
    }
  },
  "Jsoup-65": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 359,
        "end_loc": 361,
        "buggy_function": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }",
        "fixed_function": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 363,
        "end_loc": 365,
        "buggy_function": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }",
        "fixed_function": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.parser.HtmlParserTest::testTemplateInsideTable": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "testTemplateInsideTable",
        "src": "@Test public void testTemplateInsideTable() throws IOException {\n        File in = ParseTest.getFile(\"/htmltests/table-polymer-template.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\");\n        doc.outputSettings().prettyPrint(true);\n\n        Elements templates = doc.body().getElementsByTag(\"template\");\n        for (Element template : templates) {\n            assertTrue(template.childNodes().size() > 1);\n        }\n  }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::testTemplateInsideTable --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jsoup-87": {
    "function_num": 14,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 312,
        "end_loc": 320,
        "buggy_function": "    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }",
        "fixed_function": "    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 333,
        "end_loc": 340,
        "buggy_function": "    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }",
        "fixed_function": "    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.normalName().equals(elName))\n                break;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 343,
        "end_loc": 350,
        "buggy_function": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.nodeName(), elNames))\n                break;\n        }\n    }",
        "fixed_function": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 352,
        "end_loc": 361,
        "buggy_function": "    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }",
        "fixed_function": "    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 375,
        "end_loc": 383,
        "buggy_function": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }",
        "fixed_function": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 412,
        "end_loc": 459,
        "buggy_function": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }",
        "fixed_function": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.normalName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 469,
        "end_loc": 486,
        "buggy_function": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }",
        "fixed_function": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 514,
        "end_loc": 525,
        "buggy_function": "    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }",
        "fixed_function": "    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 568,
        "end_loc": 572,
        "buggy_function": "    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                inSorted(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }",
        "fixed_function": "    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n                inSorted(currentElement().normalName(), TagSearchEndTags))\n            pop();\n    }",
        "comment": "/**\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 578,
        "end_loc": 583,
        "buggy_function": "    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return inSorted(name, TagSearchSpecial);\n    }",
        "fixed_function": "    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 616,
        "end_loc": 622,
        "buggy_function": "    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }",
        "fixed_function": "    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.normalName().equals(b.normalName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 624,
        "end_loc": 660,
        "buggy_function": "    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName());\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }",
        "fixed_function": "    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 684,
        "end_loc": 693,
        "buggy_function": "    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }",
        "fixed_function": "    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.normalName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Tag.java",
        "start_loc": 26,
        "end_loc": 28,
        "buggy_function": "    private Tag(String tagName) {\n        this.tagName = tagName;\n    }",
        "fixed_function": "    private Tag(String tagName) {\n        this.tagName = tagName;\n        normalName = Normalizer.lowerCase(tagName);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.parser.HtmlParserTest::preservedCaseLinksCantNest": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "preservedCaseLinksCantNest",
        "src": "@Test public void preservedCaseLinksCantNest() {\n        String html = \"<A>ONE <A>Two</A></A>\";\n        Document doc = Parser.htmlParser()\n            .settings(ParseSettings.preserveCase)\n            .parseInput(html, \"\");\n        assertEquals(\"<A> ONE </A> <A> Two </A>\", StringUtil.normaliseWhitespace(doc.body().html()));\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::preservedCaseLinksCantNest --> junit.framework.AssertionFailedError: expected:<<A> ONE <[/A> <A> Two] </A>> but was:<<A> ONE <[A> Two </A>] </A>>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<A> ONE <[/A> <A> Two] </A>> but was:<<A> ONE <[A> Two </A>] </A>>"
      }
    }
  },
  "Jsoup-91": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/UncheckedIOException.java",
        "start_loc": 6,
        "end_loc": 8,
        "buggy_function": "    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }",
        "fixed_function": "    public UncheckedIOException(String message) {\n        super(new IOException(message));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "start_loc": 30,
        "end_loc": 37,
        "buggy_function": "    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n\n    }",
        "fixed_function": "    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n\n        if (isBinary()) {\n            throw new UncheckedIOException(\"Input is binary and unsupported\");\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "start_loc": 445,
        "end_loc": 450,
        "buggy_function": "    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }",
        "fixed_function": "    boolean isBinary() {\n        int nullsSeen = 0;\n\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\0')\n                nullsSeen++;\n        }\n\n        return nullsSeen >= numNullsConsideredBinary;\n    }",
        "comment": "/**\n     *  Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be\n     *  decoded correctly, so a bunch of NULLs indicates a binary file\n     */"
      }
    ],
    "trigger_test": {
      "org.jsoup.integration.ConnectTest::testBinaryThrowsExceptionWhenTypeIgnored": {
        "path": "org/jsoup/integration/ConnectTest.java",
        "function_name": "testBinaryThrowsExceptionWhenTypeIgnored",
        "src": "@Test\n    public void testBinaryThrowsExceptionWhenTypeIgnored() {\n        Connection con = Jsoup.connect(FileServlet.Url);\n        con.data(FileServlet.LocationParam, \"/htmltests/thumb.jpg\");\n        con.data(FileServlet.ContentTypeParam, \"image/jpeg\");\n        con.ignoreContentType(true);\n\n        boolean threw = false;\n        try {\n            con.execute();\n            Document doc = con.response().parse();\n        } catch (IOException e) {\n            threw = true;\n            assertEquals(\"Input is binary and unsupported\", e.getMessage());\n        }\n        assertTrue(threw);\n    }",
        "error_msg": "org.jsoup.integration.ConnectTest::testBinaryThrowsExceptionWhenTypeIgnored --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.jsoup.integration.ConnectTest::testBinaryResultThrows": {
        "path": "org/jsoup/integration/ConnectTest.java",
        "function_name": "testBinaryResultThrows",
        "src": "@Test\n    public void testBinaryResultThrows() {\n        Connection con = Jsoup.connect(FileServlet.Url);\n        con.data(FileServlet.LocationParam, \"/htmltests/thumb.jpg\");\n        con.data(FileServlet.ContentTypeParam, \"text/html\");\n\n        boolean threw = false;\n        try {\n            con.execute();\n            Document doc = con.response().parse();\n        } catch (IOException e) {\n            threw = true;\n            assertEquals(\"Input is binary and unsupported\", e.getMessage());\n        }\n        assertTrue(threw);\n    }",
        "error_msg": "org.jsoup.integration.ConnectTest::testBinaryResultThrows --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.jsoup.integration.ParseTest::testBinaryThrowsException": {
        "path": "org/jsoup/integration/ParseTest.java",
        "function_name": "testBinaryThrowsException",
        "src": "@Test\n    public void testBinaryThrowsException() throws IOException {\n        File in = getFile(\"/htmltests/thumb.jpg\");\n\n        boolean threw = false;\n        try {\n            Document doc = Jsoup.parse(in, \"UTF-8\");\n        } catch (IOException e) {\n            threw = true;\n            assertEquals(\"Input is binary and unsupported\", e.getMessage());\n        }\n        assertTrue(threw);\n    }",
        "error_msg": "org.jsoup.integration.ParseTest::testBinaryThrowsException --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jsoup-92": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "start_loc": 118,
        "end_loc": 123,
        "buggy_function": "    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }",
        "fixed_function": "    public Attributes add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n        return this;\n    }",
        "comment": "/**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */"
      },
      {
        "path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "start_loc": 197,
        "end_loc": 213,
        "buggy_function": "    Element insert(final Token.StartTag startTag) {\n        // cleanup duplicate attributes:\n\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n\n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }",
        "fixed_function": "    Element insert(final Token.StartTag startTag) {\n        // cleanup duplicate attributes:\n        if (!startTag.attributes.isEmpty()) {\n            int dupes = startTag.attributes.deduplicate(settings);\n            if (dupes > 0) {\n                error(\"Duplicate attribute\");\n            }\n        }\n\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n\n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/Token.java",
        "start_loc": 100,
        "end_loc": 124,
        "buggy_function": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).\n                    attributes.put(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }",
        "fixed_function": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).\n                    attributes.add(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "start_loc": 75,
        "end_loc": 88,
        "buggy_function": "    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }",
        "fixed_function": "    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n        startTag.attributes.deduplicate(settings);\n\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jsoup.parser.HtmlParserTest::retainsAttributesOfDifferentCaseIfSensitive": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "retainsAttributesOfDifferentCaseIfSensitive",
        "src": "@Test public void retainsAttributesOfDifferentCaseIfSensitive() {\n        String html = \"<p One=One One=Two one=Three two=Four two=Five Two=Six>Text</p>\";\n        Parser parser = Parser.htmlParser().settings(ParseSettings.preserveCase);\n        Document doc = parser.parseInput(html, \"\");\n        assertEquals(\"<p One=\\\"One\\\" one=\\\"Three\\\" two=\\\"Four\\\" Two=\\\"Six\\\">Text</p>\", doc.selectFirst(\"p\").outerHtml());\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::retainsAttributesOfDifferentCaseIfSensitive --> junit.framework.AssertionFailedError: expected:<<p One=[One one=Three two=Four] Two=Six>Text</p>> but was:<<p One=[Two one=Three two=Five] Two=Six>Text</p>>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p One=[One one=Three two=Four] Two=Six>Text</p>> but was:<<p One=[Two one=Three two=Five] Two=Six>Text</p>>"
      },
      "org.jsoup.parser.HtmlParserTest::dropsDuplicateAttributes": {
        "path": "org/jsoup/parser/HtmlParserTest.java",
        "function_name": "dropsDuplicateAttributes",
        "src": "@Test public void dropsDuplicateAttributes() {\n        String html = \"<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(10);\n        Document doc = parser.parseInput(html, \"\");\n\n        Element p = doc.selectFirst(\"p\");\n        assertEquals(\"<p one=\\\"One\\\" two=\\\"two\\\">Text</p>\", p.outerHtml()); // normalized names due to lower casing\n\n        assertEquals(1, parser.getErrors().size());\n        assertEquals(\"Duplicate attribute\", parser.getErrors().get(0).getErrorMessage());\n    }",
        "error_msg": "org.jsoup.parser.HtmlParserTest::dropsDuplicateAttributes --> junit.framework.AssertionFailedError: expected:<<p one=[One two=two]>Text</p>> but was:<<p one=[Four one=Two two=two one=Three two=Five]>Text</p>>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p one=[One two=two]>Text</p>> but was:<<p one=[Four one=Two two=two one=Three two=Five]>Text</p>>"
      },
      "org.jsoup.parser.XmlTreeBuilderTest::dropsDuplicateAttributes": {
        "path": "org/jsoup/parser/XmlTreeBuilderTest.java",
        "function_name": "dropsDuplicateAttributes",
        "src": "@Test public void dropsDuplicateAttributes() {\n        // case sensitive, so should drop Four and Five\n        String html = \"<p One=One ONE=Two one=Three One=Four ONE=Five two=Six two=Seven Two=Eight>Text</p>\";\n        Parser parser = Parser.xmlParser().setTrackErrors(10);\n        Document doc = parser.parseInput(html, \"\");\n\n        assertEquals(\"<p One=\\\"One\\\" ONE=\\\"Two\\\" one=\\\"Three\\\" two=\\\"Six\\\" Two=\\\"Eight\\\">Text</p>\", doc.selectFirst(\"p\").outerHtml());\n    }",
        "error_msg": "org.jsoup.parser.XmlTreeBuilderTest::dropsDuplicateAttributes --> junit.framework.AssertionFailedError: expected:<<p One=[One ONE=Two one=Three two=Six] Two=Eight>Text</...> but was:<<p One=[Four ONE=Five one=Three two=Seven] Two=Eight>Text</...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p One=[One ONE=Two one=Three two=Six] Two=Eight>Text</...> but was:<<p One=[Four ONE=Five one=Three two=Seven] Two=Eight>Text</...>"
      }
    }
  },
  "Math_4j-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math3/fraction/BigFraction.java",
        "start_loc": 269,
        "end_loc": 335,
        "buggy_function": "    private BigFraction(final double value, final double epsilon,\n                        final int maxDenominator, int maxIterations)\n        throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long) FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            numerator = BigInteger.valueOf(a0);\n            denominator = BigInteger.ONE;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r1 = 1.0 / (r0 - a0);\n            final long a1 = (long) FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                // in maxDenominator mode, if the last fraction was very close to the actual value\n                // q2 may overflow in the next iteration; in this case return the last one.\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            final double convergent = (double) p2 / (double) q2;\n            if ((n < maxIterations) &&\n                (FastMath.abs(convergent - value) > epsilon) &&\n                (q2 < maxDenominator)) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            numerator   = BigInteger.valueOf(p2);\n            denominator = BigInteger.valueOf(q2);\n        } else {\n            numerator   = BigInteger.valueOf(p1);\n            denominator = BigInteger.valueOf(q1);\n        }\n    }",
        "fixed_function": "    private BigFraction(final double value, final double epsilon,\n                        final int maxDenominator, int maxIterations)\n        throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long) FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            numerator = BigInteger.valueOf(a0);\n            denominator = BigInteger.ONE;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r1 = 1.0 / (r0 - a0);\n            final long a1 = (long) FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                // in maxDenominator mode, if the last fraction was very close to the actual value\n                // q2 may overflow in the next iteration; in this case return the last one.\n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            final double convergent = (double) p2 / (double) q2;\n            if ((n < maxIterations) &&\n                (FastMath.abs(convergent - value) > epsilon) &&\n                (q2 < maxDenominator)) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            numerator   = BigInteger.valueOf(p2);\n            denominator = BigInteger.valueOf(q2);\n        } else {\n            numerator   = BigInteger.valueOf(p1);\n            denominator = BigInteger.valueOf(q1);\n        }\n    }",
        "comment": "/**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER - a valid epsilon value and\n     * the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator\n     * has no effect). OR - a valid maxDenominator value and the epsilon value\n     * set to zero (that way epsilon only has effect if there is an exact match\n     * before the maxDenominator value is reached).\n     * </p>\n     * <p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     * https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value\n     *            the double value to convert to a fraction.\n     * @param epsilon\n     *            maximum error allowed. The resulting fraction is within\n     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n     * @param maxDenominator\n     *            maximum denominator value allowed.\n     * @param maxIterations\n     *            maximum number of convergents.\n     * @throws FractionConversionException\n     *             if the continued fraction failed to converge.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/fraction/Fraction.java",
        "start_loc": 178,
        "end_loc": 243,
        "buggy_function": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                // in maxDenominator mode, if the last fraction was very close to the actual value\n                // q2 may overflow in the next iteration; in this case return the last one.\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
        "fixed_function": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                // in maxDenominator mode, if the last fraction was very close to the actual value\n                // q2 may overflow in the next iteration; in this case return the last one.\n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }",
        "comment": "/**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.fraction.BigFractionTest::testDigitLimitConstructor": {
        "path": "org/apache/commons/math3/fraction/BigFractionTest.java",
        "function_name": "testDigitLimitConstructor",
        "src": "@Test\n    public void testDigitLimitConstructor() throws ConvergenceException {\n        assertFraction(2, 5, new BigFraction(0.4, 9));\n        assertFraction(2, 5, new BigFraction(0.4, 99));\n        assertFraction(2, 5, new BigFraction(0.4, 999));\n\n        assertFraction(3, 5, new BigFraction(0.6152, 9));\n        assertFraction(8, 13, new BigFraction(0.6152, 99));\n        assertFraction(510, 829, new BigFraction(0.6152, 999));\n        assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n        \n        // MATH-996\n        assertFraction(1, 2, new BigFraction(0.5000000001, 10));\n    }",
        "error_msg": "org.apache.commons.math3.fraction.BigFractionTest::testDigitLimitConstructor --> org.apache.commons.math3.fraction.FractionConversionException: illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)",
        "clean_error_msg": "org.apache.commons.math3.fraction.FractionConversionException: illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)"
      },
      "org.apache.commons.math3.fraction.FractionTest::testDigitLimitConstructor": {
        "path": "org/apache/commons/math3/fraction/FractionTest.java",
        "function_name": "testDigitLimitConstructor",
        "src": "@Test\n    public void testDigitLimitConstructor() throws ConvergenceException  {\n        assertFraction(2, 5, new Fraction(0.4,   9));\n        assertFraction(2, 5, new Fraction(0.4,  99));\n        assertFraction(2, 5, new Fraction(0.4, 999));\n\n        assertFraction(3, 5,      new Fraction(0.6152,    9));\n        assertFraction(8, 13,     new Fraction(0.6152,   99));\n        assertFraction(510, 829,  new Fraction(0.6152,  999));\n        assertFraction(769, 1250, new Fraction(0.6152, 9999));\n\n        // MATH-996\n        assertFraction(1, 2, new Fraction(0.5000000001, 10));\n    }",
        "error_msg": "org.apache.commons.math3.fraction.FractionTest::testDigitLimitConstructor --> org.apache.commons.math3.fraction.FractionConversionException: illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)",
        "clean_error_msg": "org.apache.commons.math3.fraction.FractionConversionException: illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)"
      }
    }
  },
  "Math_4j-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "start_loc": 110,
        "end_loc": 127,
        "buggy_function": "    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n\n        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }",
        "fixed_function": "    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n        if (v1D == null) {\n            return null;\n        }\n\n        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }",
        "comment": "/** Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "start_loc": 110,
        "end_loc": 131,
        "buggy_function": "    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // retrieve the underlying lines\n        Line line1 = (Line) getHyperplane();\n        Line line2 = (Line) subLine.getHyperplane();\n\n        // compute the intersection on infinite line\n        Vector2D v2D = line1.intersection(line2);\n\n        // check location of point with respect to first sub-line\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n        }\n\n    }",
        "fixed_function": "    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // retrieve the underlying lines\n        Line line1 = (Line) getHyperplane();\n        Line line2 = (Line) subLine.getHyperplane();\n\n        // compute the intersection on infinite line\n        Vector2D v2D = line1.intersection(line2);\n        if (v2D == null) {\n            return null;\n        }\n\n        // check location of point with respect to first sub-line\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n        }\n\n    }",
        "comment": "/** Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest::testIntersectionNotIntersecting": {
        "path": "org/apache/commons/math3/geometry/euclidean/threed/SubLineTest.java",
        "function_name": "testIntersectionNotIntersecting",
        "src": "@Test\n    public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\n        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n        SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\n        Assert.assertNull(sub1.intersection(sub2, true));\n        Assert.assertNull(sub1.intersection(sub2, false));\n    }",
        "error_msg": "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest::testIntersectionNotIntersecting --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.commons.math3.geometry.euclidean.twod.SubLineTest::testIntersectionParallel": {
        "path": "org/apache/commons/math3/geometry/euclidean/twod/SubLineTest.java",
        "function_name": "testIntersectionParallel",
        "src": "@Test\n    public void testIntersectionParallel() {\n        final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2));\n        final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4));\n        Assert.assertNull(sub1.intersection(sub2, true));\n        Assert.assertNull(sub1.intersection(sub2, false));\n    }",
        "error_msg": "org.apache.commons.math3.geometry.euclidean.twod.SubLineTest::testIntersectionParallel --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Math_4j-6": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "start_loc": 47,
        "end_loc": 52,
        "buggy_function": "    protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n    }",
        "fixed_function": "    protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n    }",
        "comment": "/**\n     * @param checker Convergence checker.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "start_loc": 191,
        "end_loc": 288,
        "buggy_function": "    @Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n            if (iter % n == 0 ||\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }",
        "fixed_function": "    @Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            incrementIterationCount();\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n            if (getIterations() % n == 0 ||\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "start_loc": 367,
        "end_loc": 515,
        "buggy_function": "    @Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }",
        "fixed_function": "    @Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n            incrementIterationCount();\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "start_loc": 172,
        "end_loc": 268,
        "buggy_function": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }",
        "fixed_function": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        while (true) {\n            incrementIterationCount();\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n                    stop = checker.converged(getIterations(), previous, current);\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "start_loc": 126,
        "end_loc": 177,
        "buggy_function": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n            if (iteration > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n\t\t\t++iteration;\n        }\n    }",
        "fixed_function": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n            if (getIterations() > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n            incrementIterationCount();\n        }\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "start_loc": 79,
        "end_loc": 169,
        "buggy_function": "    @Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
        "fixed_function": "    @Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "start_loc": 283,
        "end_loc": 534,
        "buggy_function": "    @Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n                        if (checker.converged(iter, previous, current)) {\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }",
        "fixed_function": "    @Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            incrementIterationCount();\n\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n                        if (checker.converged(getIterations(), previous, current)) {\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }",
        "comment": "/** {@inheritDoc} */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest::testTrivial": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java",
        "function_name": "testTrivial",
        "src": "@Test\n    public void testTrivial() {\n        LinearProblem problem\n            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        NonLinearConjugateGradientOptimizer optimizer\n            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\n                                                      new SimpleValueChecker(1e-6, 1e-6));\n        PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 problem.getObjectiveFunction(),\n                                 problem.getObjectiveFunctionGradient(),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 0 }));\n        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest::testTrivial --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testConstrainedRosen": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testConstrainedRosen",
        "src": "@Test\n    public void testConstrainedRosen() {\n        double[] startPoint = point(DIM, 0.1);\n        double[] insigma = point(DIM, 0.1);\n        double[][] boundaries = boundaries(DIM, -1, 2);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testConstrainedRosen --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testElliRotated": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testElliRotated",
        "src": "@Test\n    public void testElliRotated() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testElliRotated --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testEllipse": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testEllipse",
        "src": "@Test\n    public void testEllipse() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testEllipse --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testTwoAxes": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testTwoAxes",
        "src": "@Test\n    public void testTwoAxes() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-8, 1e-3, 200000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testTwoAxes --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigar": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testCigar",
        "src": "@Test\n    public void testCigar() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigar --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testRosen": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testRosen",
        "src": "",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testRosen --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testRastrigin": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testRastrigin",
        "src": "@Test\n    public void testRastrigin() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testRastrigin --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testDiagonalRosen": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testDiagonalRosen",
        "src": "@Test\n    public void testDiagonalRosen() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,\n                1e-10, 1e-4, 1000000, expected);\n     }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testDiagonalRosen --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testSsDiffPow": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testSsDiffPow",
        "src": "@Test\n    public void testSsDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testSsDiffPow --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testMaximize": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testMaximize",
        "src": "",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testMaximize --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testAckley": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testAckley",
        "src": "@Test\n    public void testAckley() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,1.0);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testAckley --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigTab": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testCigTab",
        "src": "@Test\n    public void testCigTab() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.3);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigTab --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testDiffPow": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testDiffPow",
        "src": "@Test\n    public void testDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-8, 1e-1, 100000, expected);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-8, 2e-1, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testDiffPow --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testSphere": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testSphere",
        "src": "@Test\n    public void testSphere() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testSphere --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testTablet": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testTablet",
        "src": "@Test\n    public void testTablet() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testTablet --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigarWithBoundaries": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java",
        "function_name": "testCigarWithBoundaries",
        "src": "@Test\n    public void testCigarWithBoundaries() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest::testCigarWithBoundaries --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest::testSumSinc": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java",
        "function_name": "testSumSinc",
        "src": "@Test\n    public void testSumSinc() {\n        final MultivariateFunction func = new SumSincFunction(-1);\n\n        int dim = 2;\n        final double[] minPoint = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            minPoint[i] = 0;\n        }\n\n        double[] init = new double[dim];\n\n        // Initial is minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i];\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);\n\n        // Initial is far from minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i] + 3;\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);\n        // More stringent line search tolerance enhances the precision\n        // of the result.\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest::testSumSinc --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMaximize1": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java",
        "function_name": "testMaximize1",
        "src": "@Test\n    public void testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3.0, 0.0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMaximize1 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMaximize2": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java",
        "function_name": "testMaximize2",
        "src": "@Test\n    public void testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 180);\n        Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMaximize2 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMinimize1": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java",
        "function_name": "testMinimize1",
        "src": "@Test\n    public void testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMinimize1 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMinimize2": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java",
        "function_name": "testMinimize2",
        "src": "@Test\n    public void testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest::testMinimize2 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMaximize1": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java",
        "function_name": "testMaximize1",
        "src": "@Test\n    public void testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMaximize1 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMaximize2": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java",
        "function_name": "testMaximize2",
        "src": "@Test\n    public void testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMaximize2 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMinimize1": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java",
        "function_name": "testMinimize1",
        "src": "@Test\n    public void testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMinimize1 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMinimize2": {
        "path": "org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java",
        "function_name": "testMinimize2",
        "src": "@Test\n    public void testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest::testMinimize2 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest::testGetIterations": {
        "path": "org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java",
        "function_name": "testGetIterations",
        "src": "",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest::testGetIterations --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest::testGetIterations": {
        "path": "org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java",
        "function_name": "testGetIterations",
        "src": "",
        "error_msg": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest::testGetIterations --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Math_4j-14": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "start_loc": 266,
        "end_loc": 269,
        "buggy_function": "    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }",
        "fixed_function": "    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }",
        "comment": "/**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "start_loc": 41,
        "end_loc": 47,
        "buggy_function": "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }",
        "fixed_function": "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = new DiagonalMatrix(weight);\n    }",
        "comment": "/**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample": {
        "path": "org/apache/commons/math3/fitting/PolynomialFitterTest.java",
        "function_name": "testLargeSample",
        "src": "@Test\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }",
        "error_msg": "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample --> java.lang.OutOfMemoryError: Java heap space",
        "clean_error_msg": "java.lang.OutOfMemoryError: Java heap space"
      }
    }
  },
  "Math_4j-22": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "start_loc": 274,
        "end_loc": 276,
        "buggy_function": "    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }",
        "fixed_function": "    public boolean isSupportLowerBoundInclusive() {\n        return false;\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java",
        "start_loc": 183,
        "end_loc": 185,
        "buggy_function": "    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }",
        "fixed_function": "    public boolean isSupportUpperBoundInclusive() {\n        return true;\n    }",
        "comment": "/** {@inheritDoc} */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math3.distribution.FDistributionTest::testIsSupportLowerBoundInclusive": {
        "path": "org/apache/commons/math3/distribution/FDistributionTest.java",
        "function_name": "testIsSupportLowerBoundInclusive",
        "src": "",
        "error_msg": "org.apache.commons.math3.distribution.FDistributionTest::testIsSupportLowerBoundInclusive --> junit.framework.AssertionFailedError: expected:<false> but was:<true>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<false> but was:<true>"
      },
      "org.apache.commons.math3.distribution.UniformRealDistributionTest::testIsSupportUpperBoundInclusive": {
        "path": "org/apache/commons/math3/distribution/UniformRealDistributionTest.java",
        "function_name": "testIsSupportUpperBoundInclusive",
        "src": "",
        "error_msg": "org.apache.commons.math3.distribution.UniformRealDistributionTest::testIsSupportUpperBoundInclusive --> junit.framework.AssertionFailedError: expected:<true> but was:<false>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<true> but was:<false>"
      }
    }
  },
  "Math_4j-71": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "start_loc": 191,
        "end_loc": 366,
        "buggy_function": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
        "fixed_function": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  interpolator.storeTime(stepStart);\n                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n                  hNew     = 0;\n                  stepSize = 0;\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java",
        "start_loc": 95,
        "end_loc": 220,
        "buggy_function": "  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }",
        "fixed_function": "  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                interpolator.storeTime(stepStart);\n                System.arraycopy(y, 0, yTmp, 0, y0.length);\n                stepSize = 0;\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }",
        "comment": "/** {@inheritDoc} */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest::testMissedEndEvent": {
        "path": "org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java",
        "function_name": "testMissedEndEvent",
        "src": "public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }",
        "error_msg": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest::testMissedEndEvent --> junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>"
      },
      "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testMissedEndEvent": {
        "path": "org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java",
        "function_name": "testMissedEndEvent",
        "src": "public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n                                                                             1.0e-10, 1.0e-10);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      integrator.setInitialStepSize(60.0);\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.setInitialStepSize(60.0);\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }",
        "error_msg": "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testMissedEndEvent --> junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>"
      }
    }
  },
  "Math_4j-77": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
        "start_loc": 717,
        "end_loc": 724,
        "buggy_function": "    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n        }\n        return max;\n    }",
        "fixed_function": "    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }",
        "comment": "/** {@inheritDoc} */"
      },
      {
        "path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "start_loc": 498,
        "end_loc": 506,
        "buggy_function": "    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }",
        "fixed_function": "    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }",
        "comment": "/** {@inheritDoc} */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math.linear.ArrayRealVectorTest::testBasicFunctions": {
        "path": "org/apache/commons/math/linear/ArrayRealVectorTest.java",
        "function_name": "testBasicFunctions",
        "src": "public void testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_3 = v1.getDistance((RealVector) v2);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n        //octave =  v1 + v2\n        ArrayRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        ArrayRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n        double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n        // octave v1 ./ v2\n        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n        RealVector v_projection_3 = v1.projection(v2.getData());\n        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n    }",
        "error_msg": "org.apache.commons.math.linear.ArrayRealVectorTest::testBasicFunctions --> junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>"
      },
      "org.apache.commons.math.linear.SparseRealVectorTest::testBasicFunctions": {
        "path": "org/apache/commons/math/linear/SparseRealVectorTest.java",
        "function_name": "testBasicFunctions",
        "src": "public void testBasicFunctions() {\n        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n        OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        //octave =  v1 + v2\n        OpenMapRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        OpenMapRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        // octave v1 ./ v2\n        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        OpenMapRealVector v_unitize = v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        RealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n    }",
        "error_msg": "org.apache.commons.math.linear.SparseRealVectorTest::testBasicFunctions --> junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>"
      }
    }
  },
  "Math_4j-98": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/java/org/apache/commons/math/linear/BigMatrixImpl.java",
        "start_loc": 985,
        "end_loc": 1000,
        "buggy_function": "    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length != this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[v.length];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nCols; i++) {\n                sum = sum.add(data[row][i].multiply(v[i]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }",
        "fixed_function": "    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length != this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = ZERO;\n            for (int i = 0; i < nCols; i++) {\n                sum = sum.add(data[row][i].multiply(v[i]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }",
        "comment": "/**\n     * Returns the result of multiplying this by the vector <code>v</code>.\n     *\n     * @param v the vector to operate on\n     * @return this*v\n     * @throws IllegalArgumentException if columnDimension != v.size()\n     */"
      },
      {
        "path": "src/java/org/apache/commons/math/linear/RealMatrixImpl.java",
        "start_loc": 773,
        "end_loc": 789,
        "buggy_function": "    public double[] operate(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length != nCols) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final double[] out = new double[v.length];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            double sum = 0;\n            for (int i = 0; i < nCols; i++) {\n                sum += dataRow[i] * v[i];\n            }\n            out[row] = sum;\n        }\n        return out;\n    }",
        "fixed_function": "    public double[] operate(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length != nCols) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            double sum = 0;\n            for (int i = 0; i < nCols; i++) {\n                sum += dataRow[i] * v[i];\n            }\n            out[row] = sum;\n        }\n        return out;\n    }",
        "comment": "/**\n     * @param v vector to operate on\n     * @throws IllegalArgumentException if columnDimension != v.length\n     * @return resulting vector\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.math.linear.BigMatrixImplTest::testMath209": {
        "path": "org/apache/commons/math/linear/BigMatrixImplTest.java",
        "function_name": "testMath209",
        "src": "public void testMath209() {\n        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n                { new BigDecimal(1), new BigDecimal(2) },\n                { new BigDecimal(3), new BigDecimal(4) },\n                { new BigDecimal(5), new BigDecimal(6) }\n        }, false);\n        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });\n        assertEquals(a.getRowDimension(), b.length);\n        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);\n        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n    }",
        "error_msg": "org.apache.commons.math.linear.BigMatrixImplTest::testMath209 --> java.lang.ArrayIndexOutOfBoundsException: 2",
        "clean_error_msg": "java.lang.ArrayIndexOutOfBoundsException: 2"
      },
      "org.apache.commons.math.linear.RealMatrixImplTest::testMath209": {
        "path": "org/apache/commons/math/linear/RealMatrixImplTest.java",
        "function_name": "testMath209",
        "src": "public void testMath209() {\n        RealMatrix a = new RealMatrixImpl(new double[][] {\n                { 1, 2 }, { 3, 4 }, { 5, 6 }\n        }, false);\n        double[] b = a.operate(new double[] { 1, 1 });\n        assertEquals(a.getRowDimension(), b.length);\n        assertEquals( 3.0, b[0], 1.0e-12);\n        assertEquals( 7.0, b[1], 1.0e-12);\n        assertEquals(11.0, b[2], 1.0e-12);\n    }",
        "error_msg": "org.apache.commons.math.linear.RealMatrixImplTest::testMath209 --> java.lang.ArrayIndexOutOfBoundsException: 2",
        "clean_error_msg": "java.lang.ArrayIndexOutOfBoundsException: 2"
      }
    }
  },
  "MShade-1": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/DefaultShader.java",
        "start_loc": 275,
        "end_loc": 281,
        "buggy_function": "        public Object mapValue( Object object )\n        {\n\n\n\n            return object;\n        }",
        "fixed_function": "        public Object mapValue( Object object )\n        {\n            if ( object instanceof String )\n            {\n                String name = (String) object;\n                String value = name;\n                for ( Iterator i = relocators.iterator(); i.hasNext(); )\n                {\n                    Relocator r = (Relocator) i.next();\n\n                    if ( r.canRelocatePath( name ) )\n                    {\n                        value = r.relocatePath( name );\n                        break;\n                    }\n\n                    if ( r.canRelocateClass( name ) )\n                    {\n                        value = r.relocateClass( name );\n                        break;\n                    }\n                }\n\n                return value;\n            }\n            return object;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/DefaultShader.java",
        "start_loc": 283,
        "end_loc": 296,
        "buggy_function": "        public String map( String name )\n        {\n            for ( Iterator i = relocators.iterator(); i.hasNext(); )\n            {\n                Relocator r = (Relocator) i.next();\n\n                if ( r.canRelocate( name ) )\n                {\n                    return r.relocate( name );\n                }\n            }\n\n            return name;\n        }",
        "fixed_function": "        public String map( String name )\n        {\n            String value = name;\n            for ( Iterator i = relocators.iterator(); i.hasNext(); )\n            {\n                Relocator r = (Relocator) i.next();\n\n                if ( r.canRelocatePath( name ) )\n                {\n                    value = r.relocatePath( name );\n                    break;\n                }\n            }\n\n            return value;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/relocation/SimpleRelocator.java",
        "start_loc": 41,
        "end_loc": 64,
        "buggy_function": "    public SimpleRelocator(String patt, String shadedPattern, List excludes)\n    {\n        this.pattern = patt.replace('.', '/');\n\n        if ( shadedPattern != null )\n        {\n            this.shadedPattern = shadedPattern.replace('.', '/');\n        } else\n        {\n            this.shadedPattern = \"hidden/\" + this.pattern;\n        }\n\n        if (excludes != null)\n        {\n            this.excludes = new ArrayList();\n\n            for (Iterator i = excludes.iterator(); i.hasNext();)\n            {\n                String e = (String) i.next();\n\n                this.excludes.add(e.replace('.', '/'));\n            }\n        }\n    }",
        "fixed_function": "    public SimpleRelocator(String patt, String shadedPattern, List excludes)\n    {\n        this.pattern = patt;\n        this.pathPattern = patt.replace('.', '/');\n\n        if ( shadedPattern != null )\n        {\n            this.shadedPattern = shadedPattern;\n            this.shadedPathPattern = shadedPattern.replace('.', '/');\n        } else\n        {\n            this.shadedPattern = \"hidden.\" + this.pattern;\n            this.shadedPathPattern = \"hidden/\" + this.pathPattern;\n        }\n\n        if (excludes != null)\n        {\n            this.excludes = new ArrayList();\n\n            for (Iterator i = excludes.iterator(); i.hasNext();)\n            {\n                String e = (String) i.next();\n\n                this.excludes.add(e.replace('.', '/'));\n            }\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/relocation/SimpleRelocator.java",
        "start_loc": 66,
        "end_loc": 90,
        "buggy_function": "    public boolean canRelocate( String clazz )\n    {\n        if ( excludes != null )\n        {\n            for ( Iterator i = excludes.iterator(); i.hasNext(); )\n            {\n                String exclude = (String) i.next();\n\n                // Remember we have converted \".\" -> \"/\" in the constructor. So \".*\" is really \"/*\"\n                if ( exclude.endsWith( \"/*\" ) && clazz.startsWith( exclude.substring( 0, exclude.length() - 2 ) ) )\n                {\n                    return false;\n                }\n                else if ( clazz.equals( exclude ) )\n                {\n                    return false;\n                }\n            }\n        }\n\n\n\n\n        return clazz.startsWith( pattern );\n    }",
        "fixed_function": "    public boolean canRelocatePath( String clazz )\n    {\n        if ( excludes != null )\n        {\n            for ( Iterator i = excludes.iterator(); i.hasNext(); )\n            {\n                String exclude = (String) i.next();\n\n                // Remember we have converted \".\" -> \"/\" in the constructor. So \".*\" is really \"/*\"\n                if ( exclude.endsWith( \"/*\" ) && clazz.startsWith( exclude.substring( 0, exclude.length() - 2 ) ) )\n                {\n                    return false;\n                }\n                else if ( clazz.equals( exclude ) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return clazz.startsWith( pathPattern );\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/relocation/SimpleRelocator.java",
        "start_loc": 93,
        "end_loc": 96,
        "buggy_function": "    public String relocate( String clazz )\n    {\n        return clazz.replaceFirst(pattern, shadedPattern);\n    }",
        "fixed_function": "    public boolean canRelocateClass( String clazz )\n    {\n        if ( excludes != null )\n        {\n            for ( Iterator i = excludes.iterator(); i.hasNext(); )\n            {\n                String exclude = (String) i.next();\n\n                exclude = exclude.replace( '/', '.' );\n                if ( exclude.endsWith( \".*\" ) && clazz.startsWith( exclude.substring( 0, exclude.length() - 2 ) ) )\n                {\n                    return false;\n                }\n                else if ( clazz.equals( exclude ) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return clazz.startsWith( pattern );\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.maven.plugins.shade.DefaultShaderTest::testShaderWithStaticInitializedClass": {
        "path": "org/apache/maven/plugins/shade/DefaultShaderTest.java",
        "function_name": "testShaderWithStaticInitializedClass",
        "src": "public void testShaderWithStaticInitializedClass()\n        throws Exception\n    {\n        Shader s = new DefaultShader();\n\n        Set set = new HashSet();\n\n        set.add( new File( \"src/test/jars/test-artifact-1.0-SNAPSHOT.jar\" ) );\n\n        List relocators = new ArrayList();\n\n        relocators.add( new SimpleRelocator( \"org.apache.maven.plugins.shade\", null, null ) );\n\n        List resourceTransformers = new ArrayList();\n\n        List filters = new ArrayList();\n\n        File file = new File( \"target/testShaderWithStaticInitializedClass.jar\" );\n        s.shade( set, file, filters, relocators, resourceTransformers );\n\n        URLClassLoader cl = new URLClassLoader( new URL[]{file.toURL()} );\n        Class c = cl.loadClass( \"hidden.org.apache.maven.plugins.shade.Lib\" );\n        Object o = c.newInstance();\n        assertEquals( \"foo.bar/baz\", c.getDeclaredField( \"CONSTANT\" ).get( o ) );\n    }",
        "error_msg": "org.apache.maven.plugins.shade.DefaultShaderTest::testShaderWithStaticInitializedClass --> java.lang.NoClassDefFoundError: org.apache.maven.plugins.shade.Lib",
        "clean_error_msg": "java.lang.NoClassDefFoundError: org.apache.maven.plugins.shade.Lib"
      }
    }
  },
  "MShade-2": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/resource/ApacheLicenseResourceTransformer.java",
        "start_loc": 39,
        "end_loc": 48,
        "buggy_function": "    public boolean canTransformResource( String resource )\n    {\n        String s = resource.toLowerCase();\n        if ( s.startsWith( \"meta-inf/license.txt\" ) || s.equals( \"meta-inf/license\" ))\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "fixed_function": "    public boolean canTransformResource( String resource )\n    {\n        if ( LICENSE_PATH.equalsIgnoreCase( resource )\n            || LICENSE_TXT_PATH.regionMatches( true, 0, resource, 0, LICENSE_TXT_PATH.length() ) )\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/resource/ApacheNoticeResourceTransformer.java",
        "start_loc": 66,
        "end_loc": 75,
        "buggy_function": "    public boolean canTransformResource( String resource )\n    {\n        String s = resource.toLowerCase();\n        if (s.equals( \"meta-inf/notice.txt\" ) || s.equals( \"meta-inf/notice\" ) )\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "fixed_function": "    public boolean canTransformResource( String resource )\n    {\n        if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) )\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/resource/AppendingTransformer.java",
        "start_loc": 37,
        "end_loc": 46,
        "buggy_function": "    public boolean canTransformResource( String r )\n    {\n        r = r.toLowerCase();\n        if (resource != null && resource.toLowerCase().equals(r))\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "fixed_function": "    public boolean canTransformResource( String r )\n    {\n        if ( resource != null && resource.equalsIgnoreCase( r ) )\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/maven/plugins/shade/resource/XmlAppendingTransformer.java",
        "start_loc": 45,
        "end_loc": 54,
        "buggy_function": "    public boolean canTransformResource( String r )\n    {\n        r = r.toLowerCase();\n        if (resource != null && resource.toLowerCase().equals(r))\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "fixed_function": "    public boolean canTransformResource( String r )\n    {\n        if ( resource != null && resource.equalsIgnoreCase( r ) )\n        {\n            return true;\n        }\n\n        return false;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformerTest::testCanTransformResource": {
        "path": "org/apache/maven/plugins/shade/resource/ApacheLicenseResourceTransformerTest.java",
        "function_name": "testCanTransformResource",
        "src": "public void testCanTransformResource()\n    {\n        assertTrue( this.transformer.canTransformResource( \"META-INF/LICENSE\" ) );\n        assertTrue( this.transformer.canTransformResource( \"META-INF/LICENSE.TXT\" ) );\n        assertTrue( this.transformer.canTransformResource( \"META-INF/License.txt\" ) );\n        assertFalse( this.transformer.canTransformResource( \"META-INF/MANIFEST.MF\" ) );\n    }",
        "error_msg": "org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformerTest::testCanTransformResource --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformerTest::testCanTransformResource": {
        "path": "org/apache/maven/plugins/shade/resource/ApacheNoticeResourceTransformerTest.java",
        "function_name": "testCanTransformResource",
        "src": "public void testCanTransformResource()\n    {\n        assertTrue( this.transformer.canTransformResource( \"META-INF/NOTICE\" ) );\n        assertTrue( this.transformer.canTransformResource( \"META-INF/NOTICE.TXT\" ) );\n        assertTrue( this.transformer.canTransformResource( \"META-INF/Notice.txt\" ) );\n        assertFalse( this.transformer.canTransformResource( \"META-INF/MANIFEST.MF\" ) );\n    }",
        "error_msg": "org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformerTest::testCanTransformResource --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.maven.plugins.shade.resource.AppendingTransformerTest::testCanTransformResource": {
        "path": "org/apache/maven/plugins/shade/resource/AppendingTransformerTest.java",
        "function_name": "testCanTransformResource",
        "src": "public void testCanTransformResource()\n    {\n        this.transformer.resource = \"abcdefghijklmnopqrstuvwxyz\";\n\n        assertTrue( this.transformer.canTransformResource( \"abcdefghijklmnopqrstuvwxyz\" ) );\n        assertTrue( this.transformer.canTransformResource( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ) );\n        assertFalse( this.transformer.canTransformResource( \"META-INF/MANIFEST.MF\" ) );\n    }",
        "error_msg": "org.apache.maven.plugins.shade.resource.AppendingTransformerTest::testCanTransformResource --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.maven.plugins.shade.resource.XmlAppendingTransformerTest::testCanTransformResource": {
        "path": "org/apache/maven/plugins/shade/resource/XmlAppendingTransformerTest.java",
        "function_name": "testCanTransformResource",
        "src": "public void testCanTransformResource()\n    {\n        this.transformer.resource = \"abcdefghijklmnopqrstuvwxyz\";\n\n        assertTrue( this.transformer.canTransformResource( \"abcdefghijklmnopqrstuvwxyz\" ) );\n        assertTrue( this.transformer.canTransformResource( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ) );\n        assertFalse( this.transformer.canTransformResource( \"META-INF/MANIFEST.MF\" ) );\n    }",
        "error_msg": "org.apache.maven.plugins.shade.resource.XmlAppendingTransformerTest::testCanTransformResource --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Tika-2": {
    "function_num": 10,
    "functions": [
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 48,
        "end_loc": 67,
        "buggy_function": "    public static boolean isValid(String name) {\n        assert name != null;\n\n        boolean slash = false;\n        for (int i = 0; i < name.length(); i++) {\n            char ch = name.charAt(i);\n            if (ch <= ' ' || ch >= 127 || ch == '(' || ch == ')' ||\n                    ch == '<' || ch == '>' || ch == '@' || ch == ',' ||\n                    ch == ';' || ch == ':' || ch == '\\\\' || ch == '\"' ||\n                    ch == '[' || ch == ']' || ch == '?' || ch == '=') {\n                return false;\n            } else if (ch == '/') {\n                if (slash || i == 0 || i + 1 == name.length()) {\n                    return false;\n                }\n                slash = true;\n            }\n        }\n        return slash;\n    }",
        "fixed_function": "    public static boolean isValid(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Name is missing\");\n        }\n\n        boolean slash = false;\n        for (int i = 0; i < name.length(); i++) {\n            char ch = name.charAt(i);\n            if (ch <= ' ' || ch >= 127 || ch == '(' || ch == ')' ||\n                    ch == '<' || ch == '>' || ch == '@' || ch == ',' ||\n                    ch == ';' || ch == ':' || ch == '\\\\' || ch == '\"' ||\n                    ch == '[' || ch == ']' || ch == '?' || ch == '=') {\n                return false;\n            } else if (ch == '/') {\n                if (slash || i == 0 || i + 1 == name.length()) {\n                    return false;\n                }\n                slash = true;\n            }\n        }\n        return slash;\n    }",
        "comment": "/**\n     * Checks that the given string is a valid Internet media type name\n     * based on rules from RFC 2054 section 5.3. For validation purposes the\n     * rules can be simplified to the following:\n     * <pre>\n     * name := token \"/\" token\n     * token := 1*&lt;any (US-ASCII) CHAR except SPACE, CTLs, or tspecials&gt;\n     * tspecials :=  \"(\" / \")\" / \"&lt;\" / \"&gt;\" / \"@\" / \",\" / \";\" / \":\" /\n     *               \"\\\" / <\"> / \"/\" / \"[\" / \"]\" / \"?\" / \"=\"\n     * </pre>\n     *\n     * @param name name string\n     * @return <code>true</code> if the string is a valid media type name,\n     *         <code>false</code> otherwise\n     */"
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 119,
        "end_loc": 124,
        "buggy_function": "    MimeType(MimeTypes registry, String name) {\n        assert registry != null;\n        assert isValid(name) && name.equals(name.toLowerCase());\n        this.registry = registry;\n        this.name = name;\n    }",
        "fixed_function": "    MimeType(MimeTypes registry, String name) {\n        if (registry == null) {\n            throw new IllegalArgumentException(\"Registry is missing\");\n        }\n        if (!MimeType.isValid(name) || !name.equals(name.toLowerCase())) {\n            throw new IllegalArgumentException(\"Media type name is invalid\");\n        }\n        this.registry = registry;\n        this.name = name;\n    }",
        "comment": "/**\n     * Creates a media type with the give name and containing media type\n     * registry. The name is expected to be valid and normalized to lower\n     * case. This constructor should only be called by\n     * {@link MimeTypes#forName(String)} to keep the media type registry\n     * up to date.\n     *\n     * @param registry the media type registry that contains this type\n     * @param name media type name\n     */"
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 144,
        "end_loc": 165,
        "buggy_function": "    public void setSuperType(MimeType type) throws MimeTypeException {\n        assert type != null && type.registry == registry;\n        if (this.isDescendantOf(type)) {\n            // ignore, already a descendant of the given type\n        } else if (this == type) {\n            throw new MimeTypeException(\n                    \"Media type can not inherit itself: \" + type);\n        } else if (type.isDescendantOf(this)) {\n            throw new MimeTypeException(\n                    \"Media type can not inherit its descendant: \" + type);\n        } else if (superType == null) {\n            superType = type;\n            superType.subTypes.add(this);\n        } else if (type.isDescendantOf(superType)) {\n            superType.subTypes.remove(this);\n            superType = type;\n            superType.subTypes.add(this);\n        } else {\n            throw new MimeTypeException(\n                    \"Conflicting media type inheritance: \" + type);\n        }\n    }",
        "fixed_function": "    public void setSuperType(MimeType type) throws MimeTypeException {\n        if (type == null) {\n            throw new IllegalArgumentException(\"MimeType is missing\");\n        }\n        if (type.registry != registry) {\n            throw new IllegalArgumentException(\"MimeType is from a different registry\");\n        }\n        if (this.isDescendantOf(type)) {\n            // ignore, already a descendant of the given type\n        } else if (this == type) {\n            throw new MimeTypeException(\n                    \"Media type can not inherit itself: \" + type);\n        } else if (type.isDescendantOf(this)) {\n            throw new MimeTypeException(\n                    \"Media type can not inherit its descendant: \" + type);\n        } else if (superType == null) {\n            superType = type;\n            superType.subTypes.add(this);\n        } else if (type.isDescendantOf(superType)) {\n            superType.subTypes.remove(this);\n            superType = type;\n            superType.subTypes.add(this);\n        } else {\n            throw new MimeTypeException(\n                    \"Conflicting media type inheritance: \" + type);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 171,
        "end_loc": 181,
        "buggy_function": "    public boolean isDescendantOf(MimeType type) {\n        assert type != null;\n        synchronized (registry) {\n            for (MimeType t = superType; t != null; t = t.superType) {\n                if (t == type) {\n                    return true;\n                }\n            }\n            return false; \n        }\n    }",
        "fixed_function": "    public boolean isDescendantOf(MimeType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"MimeType is missing\");\n        }\n        synchronized (registry) {\n            for (MimeType t = superType; t != null; t = t.superType) {\n                if (t == type) {\n                    return true;\n                }\n            }\n            return false; \n        }\n    }",
        "comment": ""
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 197,
        "end_loc": 200,
        "buggy_function": "    public void setDescription(String description) {\n        assert description != null;\n        this.description = description;\n    }",
        "fixed_function": "    public void setDescription(String description) {\n        if (description == null) {\n            throw new IllegalArgumentException(\"Description is missing\");\n        }\n        this.description = description;\n    }",
        "comment": "/**\n     * Set the description of this media type.\n     * \n     * @param description media type description\n     */"
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeType.java",
        "start_loc": 362,
        "end_loc": 377,
        "buggy_function": "    public int compareTo(MimeType type) {\n        assert type != null;\n        if (type == this) {\n            return 0;\n        } else if (this.isDescendantOf(type)) {\n            return 1;\n        } else if (type.isDescendantOf(this)) {\n            return -1;\n        } else if (superType != null) {\n            return superType.compareTo(type);\n        } else if (type.superType != null) {\n            return compareTo(type.superType);\n        } else {\n            return name.compareTo(type.name);\n        }\n    }",
        "fixed_function": "    public int compareTo(MimeType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"MimeType is missing\");\n        }\n        if (type == this) {\n            return 0;\n        } else if (this.isDescendantOf(type)) {\n            return 1;\n        } else if (type.isDescendantOf(this)) {\n            return -1;\n        } else if (superType != null) {\n            return superType.compareTo(type);\n        } else if (type.superType != null) {\n            return compareTo(type.superType);\n        } else {\n            return name.compareTo(type.name);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeTypes.java",
        "start_loc": 122,
        "end_loc": 140,
        "buggy_function": "    public MimeType getMimeType(byte[] data) {\n        assert data != null;\n\n        // First, check for XML descriptions (level by level)\n        for (MimeType type : xmls) {\n            if (type.matchesXML(data)) {\n                return type;\n            }\n        }\n\n        // Then, check for magic bytes\n        for (Magic magic : magics) {\n            if (magic.eval(data)) {\n                return magic.getType();\n            }\n        }\n\n        return null;\n    }",
        "fixed_function": "    public MimeType getMimeType(byte[] data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Data is missing\");\n        }\n\n        // First, check for XML descriptions (level by level)\n        for (MimeType type : xmls) {\n            if (type.matchesXML(data)) {\n                return type;\n            }\n        }\n\n        // Then, check for magic bytes\n        for (Magic magic : magics) {\n            if (magic.eval(data)) {\n                return magic.getType();\n            }\n        }\n\n        return null;\n    }",
        "comment": "/**\n     * Returns the MIME type that best matches the given first few bytes\n     * of a document stream.\n     * <p>\n     * The given byte array is expected to be at least {@link #getMinLength()}\n     * long, or shorter only if the document stream itself is shorter.\n     *\n     * @param data first few bytes of a document stream\n     * @return matching MIME type, or <code>null</code> if no match is found\n     */"
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/MimeTypes.java",
        "start_loc": 168,
        "end_loc": 186,
        "buggy_function": "    private byte[] readMagicHeader(InputStream stream) throws IOException {\n        assert stream != null;\n\n        byte[] bytes = new byte[getMinLength()];\n        int totalRead = 0;\n\n        int lastRead = stream.read(bytes);\n        while (lastRead != -1) {\n            totalRead += lastRead;\n            if (totalRead == bytes.length) {\n                return bytes;\n            }\n            lastRead = stream.read(bytes, totalRead, bytes.length - totalRead);\n        }\n\n        byte[] shorter = new byte[totalRead];\n        System.arraycopy(bytes, 0, shorter, 0, totalRead);\n        return shorter;\n    }",
        "fixed_function": "    private byte[] readMagicHeader(InputStream stream) throws IOException {\n        if (stream == null) {\n            throw new IllegalArgumentException(\"InputStream is missing\");\n        }\n\n        byte[] bytes = new byte[getMinLength()];\n        int totalRead = 0;\n\n        int lastRead = stream.read(bytes);\n        while (lastRead != -1) {\n            totalRead += lastRead;\n            if (totalRead == bytes.length) {\n                return bytes;\n            }\n            lastRead = stream.read(bytes, totalRead, bytes.length - totalRead);\n        }\n\n        byte[] shorter = new byte[totalRead];\n        System.arraycopy(bytes, 0, shorter, 0, totalRead);\n        return shorter;\n    }",
        "comment": "/**\n     * Reads the first {@link #getMinLength()} bytes from the given stream.\n     * If the stream is shorter, then the entire content of the stream is\n     * returned.\n     * <p>\n     * The given stream is never {@link InputStream#close() closed},\n     * {@link InputStream#mark(int) marked}, or\n     * {@link InputStream#reset() reset} by this method.\n     *\n     * @param stream stream to be read\n     * @return first {@link #getMinLength()} (or fewer) bytes of the stream\n     * @throws IOException if the stream can not be read\n     */"
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/Patterns.java",
        "start_loc": 60,
        "end_loc": 75,
        "buggy_function": "    public void add(String pattern, MimeType type) throws MimeTypeException {\n        assert pattern != null && type != null;\n\n        if (pattern.indexOf('*') == -1\n                && pattern.indexOf('?') == -1\n                && pattern.indexOf('[') == -1) {\n            addName(pattern, type);\n        } else if (pattern.startsWith(\"*\")\n                && pattern.indexOf('*', 1) == -1\n                && pattern.indexOf('?') == -1\n                && pattern.indexOf('[') == -1) {\n            addExtension(pattern.substring(1), type);\n        } else {\n            addGlob(compile(pattern), type);\n        }\n    }",
        "fixed_function": "    public void add(String pattern, MimeType type) throws MimeTypeException {\n        if (pattern == null || type == null) {\n            throw new IllegalArgumentException(\"Pattern and/or mime type is missing\");\n        }\n\n        if (pattern.indexOf('*') == -1\n                && pattern.indexOf('?') == -1\n                && pattern.indexOf('[') == -1) {\n            addName(pattern, type);\n        } else if (pattern.startsWith(\"*\")\n                && pattern.indexOf('*', 1) == -1\n                && pattern.indexOf('?') == -1\n                && pattern.indexOf('[') == -1) {\n            addExtension(pattern.substring(1), type);\n        } else {\n            addGlob(compile(pattern), type);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "./src/main/java/org/apache/tika/mime/Patterns.java",
        "start_loc": 130,
        "end_loc": 155,
        "buggy_function": "    public MimeType matches(String name) {\n        assert name != null;\n\n        // First, try exact match of the provided resource name\n        if (names.containsKey(name)) {\n            return names.get(name);\n        }\n\n        // Then try \"extension\" (*.xxx) matching\n        int maxLength = Math.min(maxExtensionLength, name.length());\n        for (int n = maxLength; n >= minExtensionLength; n--) {\n            String extension = name.substring(name.length() - n);\n            if (extensions.containsKey(extension)) {\n                return extensions.get(extension);\n            }\n        }\n\n        // And finally, try complex regexp matching\n        for (Map.Entry<String, MimeType> entry : globs.entrySet()) {\n            if (name.matches(entry.getKey())) {\n                return entry.getValue();\n            }\n        }\n\n        return null;\n    }",
        "fixed_function": "    public MimeType matches(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Name is missing\");\n        }\n\n        // First, try exact match of the provided resource name\n        if (names.containsKey(name)) {\n            return names.get(name);\n        }\n\n        // Then try \"extension\" (*.xxx) matching\n        int maxLength = Math.min(maxExtensionLength, name.length());\n        for (int n = maxLength; n >= minExtensionLength; n--) {\n            String extension = name.substring(name.length() - n);\n            if (extensions.containsKey(extension)) {\n                return extensions.get(extension);\n            }\n        }\n\n        // And finally, try complex regexp matching\n        for (Map.Entry<String, MimeType> entry : globs.entrySet()) {\n            if (name.matches(entry.getKey())) {\n                return entry.getValue();\n            }\n        }\n\n        return null;\n    }",
        "comment": "/**\n     * Find the MimeType corresponding to a resource name.\n     * \n     * It applies the recommendations detailed in FreeDesktop Shared MIME-info\n     * Database for guessing MimeType from a resource name: It first tries a\n     * case-sensitive match, then try again with the resource name converted to\n     * lower-case if that fails. If several patterns match then the longest\n     * pattern is used. In particular, files with multiple extensions (such as\n     * Data.tar.gz) match the longest sequence of extensions (eg '*.tar.gz' in\n     * preference to '*.gz'). Literal patterns (eg, 'Makefile') are matched\n     * before all others. Patterns beginning with `*.' and containing no other\n     * special characters (`*?[') are matched before other wildcarded patterns\n     * (since this covers the majority of the patterns).\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.tika.mime.MimeTypeTest::testSetSuperType": {
        "path": "org/apache/tika/mime/MimeTypeTest.java",
        "function_name": "testSetSuperType",
        "src": "public void testSetSuperType() throws MimeTypeException {\n        try {\n            text.setSuperType(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypeTest::testSetSuperType --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.tika.mime.MimeTypeTest::testSetDescription": {
        "path": "org/apache/tika/mime/MimeTypeTest.java",
        "function_name": "testSetDescription",
        "src": "public void testSetDescription() {\n        try {\n            text.setDescription(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypeTest::testSetDescription --> junit.framework.AssertionFailedError: Expected IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected IllegalArgumentException"
      },
      "org.apache.tika.mime.MimeTypeTest::testConstrctor": {
        "path": "org/apache/tika/mime/MimeTypeTest.java",
        "function_name": "testConstrctor",
        "src": "public void testConstrctor() {\n\n        // Missing registry\n        try {\n            new MimeType(null, \"text/plain\");\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n\n        // Missing name\n        try {\n            new MimeType(types, null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n\n        // Invalid name (no slash)\n        try {\n            new MimeType(types, \"application\");\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n\n        // Invalid name (not lower case)\n        try {\n            new MimeType(types, \"TEXT/PLAIN\");\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypeTest::testConstrctor --> junit.framework.AssertionFailedError: Expected IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected IllegalArgumentException"
      },
      "org.apache.tika.mime.MimeTypeTest::testIsValidName": {
        "path": "org/apache/tika/mime/MimeTypeTest.java",
        "function_name": "testIsValidName",
        "src": "public void testIsValidName() {\n        assertTrue(MimeType.isValid(\"application/octet-stream\"));\n        assertTrue(MimeType.isValid(\"text/plain\"));\n        assertTrue(MimeType.isValid(\"foo/bar\"));\n        assertTrue(MimeType.isValid(\"a/b\"));\n\n        assertFalse(MimeType.isValid(\"application\"));\n        assertFalse(MimeType.isValid(\"application/\"));\n        assertFalse(MimeType.isValid(\"/\"));\n        assertFalse(MimeType.isValid(\"/octet-stream\"));\n        assertFalse(MimeType.isValid(\"application//octet-stream\"));\n        assertFalse(MimeType.isValid(\"application/octet=stream\"));\n        assertFalse(MimeType.isValid(\"application/\\u00f6ctet-stream\"));\n        assertFalse(MimeType.isValid(\"text/plain;\"));\n        assertFalse(MimeType.isValid(\"text/plain; charset=UTF-8\"));\n        try {\n            MimeType.isValid(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypeTest::testIsValidName --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.tika.mime.MimeTypesTest::testGetMimeType_byteArray": {
        "path": "org/apache/tika/mime/MimeTypesTest.java",
        "function_name": "testGetMimeType_byteArray",
        "src": "public void testGetMimeType_byteArray() {\n        try {\n            types.getMimeType((byte[])null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypesTest::testGetMimeType_byteArray --> junit.framework.AssertionFailedError: Expected IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected IllegalArgumentException"
      },
      "org.apache.tika.mime.MimeTypesTest::testGetMimeType_InputStream": {
        "path": "org/apache/tika/mime/MimeTypesTest.java",
        "function_name": "testGetMimeType_InputStream",
        "src": "public void testGetMimeType_InputStream() throws IOException {\n        try {\n            types.getMimeType((InputStream)null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypesTest::testGetMimeType_InputStream --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.tika.mime.MimeTypesTest::testIsDescendantOf": {
        "path": "org/apache/tika/mime/MimeTypesTest.java",
        "function_name": "testIsDescendantOf",
        "src": "public void testIsDescendantOf() {\n        assertFalse(binary.isDescendantOf(binary));\n        assertFalse(text.isDescendantOf(text));\n        assertFalse(html.isDescendantOf(html));\n\n        assertTrue(text.isDescendantOf(binary));\n        assertFalse(binary.isDescendantOf(text));\n        \n        assertTrue(html.isDescendantOf(binary));\n        assertFalse(binary.isDescendantOf(html));\n\n        assertTrue(html.isDescendantOf(text));\n        assertFalse(text.isDescendantOf(html));\n\n        try {\n            binary.isDescendantOf(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypesTest::testIsDescendantOf --> junit.framework.AssertionFailedError: Expected IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected IllegalArgumentException"
      },
      "org.apache.tika.mime.MimeTypesTest::testCompareTo": {
        "path": "org/apache/tika/mime/MimeTypesTest.java",
        "function_name": "testCompareTo",
        "src": "public void testCompareTo() {\n        assertTrue(binary.compareTo(binary) == 0);\n        assertTrue(binary.compareTo(text) < 0);\n        assertTrue(binary.compareTo(html) < 0);\n\n        assertTrue(text.compareTo(binary) > 0);\n        assertTrue(text.compareTo(text) == 0);\n        assertTrue(text.compareTo(html) < 0);\n\n        assertTrue(html.compareTo(binary) > 0);\n        assertTrue(html.compareTo(text) > 0);\n        assertTrue(html.compareTo(html) == 0);\n\n        try {\n            binary.compareTo(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.MimeTypesTest::testCompareTo --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.tika.mime.PatternsTest::testAdd": {
        "path": "org/apache/tika/mime/PatternsTest.java",
        "function_name": "testAdd",
        "src": "public void testAdd() throws MimeTypeException {\n        try {\n            patterns.add(null, text);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n        try {\n            patterns.add(\"\", null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n        try {\n            patterns.add(null, null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.PatternsTest::testAdd --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "org.apache.tika.mime.PatternsTest::testMatches": {
        "path": "org/apache/tika/mime/PatternsTest.java",
        "function_name": "testMatches",
        "src": "public void testMatches() {\n        try {\n            patterns.matches(null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected result\n        }\n    }",
        "error_msg": "org.apache.tika.mime.PatternsTest::testMatches --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Validator-1": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java",
        "start_loc": 187,
        "end_loc": 205,
        "buggy_function": "    @Override\n    protected Format getFormat(String pattern, Locale locale) {\n\n        NumberFormat formatter = null;\n        boolean usePattern = (pattern != null && pattern.length() > 0);\n        if (!usePattern) {\n            formatter = (NumberFormat)getFormat(locale);\n        } else if (locale == null) {\n            formatter =  new DecimalFormat(pattern);\n        } else {\n            DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n            formatter = new DecimalFormat(pattern, symbols);\n        }\n\n        if (determineScale(formatter) == 0) {\n            formatter.setParseIntegerOnly(true);\n        }\n        return formatter;\n    }",
        "fixed_function": "    @Override\n    protected Format getFormat(String pattern, Locale locale) {\n\n        NumberFormat formatter = null;\n        boolean usePattern = (pattern != null && pattern.length() > 0);\n        if (!usePattern) {\n            formatter = (NumberFormat)getFormat(locale);\n        } else if (locale == null) {\n            formatter =  new DecimalFormat(pattern);\n        } else {\n            DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n            formatter = new DecimalFormat(pattern, symbols);\n        }\n\n        if (!isAllowFractions()) {\n            formatter.setParseIntegerOnly(true);\n        }\n        return formatter;\n    }",
        "comment": "/**\n     * <p>Returns a <code>NumberFormat</code> for the specified <i>pattern</i>\n     *    and/or <code>Locale</code>.</p>\n     *\n     * @param pattern The pattern used to validate the value against or\n     *        <code>null</code> to use the default for the <code>Locale</code>.\n     * @param locale The locale to use for the currency format, system default if null.\n     * @return The <code>NumberFormat</code> to created.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java",
        "start_loc": 247,
        "end_loc": 273,
        "buggy_function": "    protected Format getFormat(Locale locale) {\n        NumberFormat formatter = null;\n        switch (formatType) {\n        case CURRENCY_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getCurrencyInstance();\n            } else {\n                formatter = NumberFormat.getCurrencyInstance(locale);\n            }\n            break;\n        case PERCENT_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getPercentInstance();\n            } else {\n                formatter = NumberFormat.getPercentInstance(locale);\n            }\n            break;\n        default:\n            if (locale == null) {\n                formatter = NumberFormat.getInstance();\n            } else {\n                formatter = NumberFormat.getInstance(locale);\n            }\n            break;\n        }\n        return formatter;\n    }",
        "fixed_function": "    protected Format getFormat(Locale locale) {\n        NumberFormat formatter = null;\n        switch (formatType) {\n        case CURRENCY_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getCurrencyInstance();\n            } else {\n                formatter = NumberFormat.getCurrencyInstance(locale);\n            }\n            break;\n        case PERCENT_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getPercentInstance();\n            } else {\n                formatter = NumberFormat.getPercentInstance(locale);\n            }\n            break;\n        default:\n            if (locale == null) {\n                formatter = NumberFormat.getInstance();\n            } else {\n                formatter = NumberFormat.getInstance(locale);\n            }\n            if (!isAllowFractions()) {\n                formatter.setParseIntegerOnly(true);\n            }\n            break;\n        }\n        return formatter;\n    }",
        "comment": "/**\n     * <p>Returns a <code>NumberFormat</code> for the specified Locale.</p>\n     *\n     * @param locale The locale a <code>NumberFormat</code> is required for,\n     *   system default if null.\n     * @return The <code>NumberFormat</code> to created.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/validator/routines/ByteValidator.java",
        "start_loc": 244,
        "end_loc": 254,
        "buggy_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        long longValue = ((Number)value).longValue();\n        if (longValue < Byte.MIN_VALUE ||\n            longValue > Byte.MAX_VALUE) {\n            return null;\n        }\n        return Byte.valueOf((byte)longValue);\n    }",
        "fixed_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        if (value instanceof Long) {\n            long longValue = ((Long)value).longValue();\n            if (longValue >= Byte.MIN_VALUE && \n                longValue <= Byte.MAX_VALUE) {\n                return Byte.valueOf((byte)longValue);\n            }\n        }\n        return null;\n    }",
        "comment": "/**\n     * <p>Perform further validation and convert the <code>Number</code> to\n     * a <code>Byte</code>.</p>\n     *\n     * @param value The parsed <code>Number</code> object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed <code>Number</code> converted to a\n     *   <code>Byte</code> if valid or <code>null</code> if invalid.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/validator/routines/IntegerValidator.java",
        "start_loc": 244,
        "end_loc": 254,
        "buggy_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        long longValue = ((Number)value).longValue();\n        if (longValue < Integer.MIN_VALUE ||\n            longValue > Integer.MAX_VALUE) {\n            return null;\n        }\n        return Integer.valueOf((int)longValue);\n    }",
        "fixed_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        if (value instanceof Long) {\n            long longValue = ((Long)value).longValue();\n            if (longValue >= Integer.MIN_VALUE && \n                longValue <= Integer.MAX_VALUE) {\n                return Integer.valueOf((int)longValue);\n            }\n        }\n        return null;\n    }",
        "comment": "/**\n     * <p>Perform further validation and convert the <code>Number</code> to\n     * an <code>Integer</code>.</p>\n     *\n     * @param value The parsed <code>Number</code> object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed <code>Number</code> converted to an\n     *   <code>Integer</code> if valid or <code>null</code> if invalid.\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/validator/routines/LongValidator.java",
        "start_loc": 242,
        "end_loc": 251,
        "buggy_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        if (value instanceof Long) {\n            return value;\n        }\n        return Long.valueOf(((Number)value).longValue());\n\n    }",
        "fixed_function": "    @Override\n    protected Object processParsedValue(Object value, Format formatter) {\n\n        // Parsed value will be Long if it fits in a long and is not fractional\n        if (value instanceof Long) {\n            return value;\n        }\n        return null;\n\n    }",
        "comment": "/**\n     * Convert the parsed value to a <code>Long</code>.\n     *\n     * @param value The parsed <code>Number</code> object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed <code>Number</code> converted to a\n     *         <code>Long</code>.\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.validator.routines.ByteValidatorTest::testValidNotStrict": {
        "path": "org/apache/commons/validator/routines/ByteValidatorTest.java",
        "function_name": "testValidNotStrict",
        "src": "",
        "error_msg": "org.apache.commons.validator.routines.ByteValidatorTest::testValidNotStrict --> junit.framework.AssertionFailedError: (A) idx=[7] value=[127] expected:<127> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: (A) idx=[7] value=[127] expected:<127> but was:<null>"
      },
      "org.apache.commons.validator.routines.IntegerValidatorTest::testValidNotStrict": {
        "path": "org/apache/commons/validator/routines/IntegerValidatorTest.java",
        "function_name": "testValidNotStrict",
        "src": "",
        "error_msg": "org.apache.commons.validator.routines.IntegerValidatorTest::testValidNotStrict --> junit.framework.AssertionFailedError: (A) idx=[7] value=[2147483647] expected:<2147483647> but was:<null>",
        "clean_error_msg": "junit.framework.AssertionFailedError: (A) idx=[7] value=[2147483647] expected:<2147483647> but was:<null>"
      },
      "org.apache.commons.validator.routines.LongValidatorTest::testInvalidNotStrict": {
        "path": "org/apache/commons/validator/routines/LongValidatorTest.java",
        "function_name": "testInvalidNotStrict",
        "src": "",
        "error_msg": "org.apache.commons.validator.routines.LongValidatorTest::testInvalidNotStrict --> junit.framework.AssertionFailedError: (A) idx=[5] value=[9223372036854775808]",
        "clean_error_msg": "junit.framework.AssertionFailedError: (A) idx=[5] value=[9223372036854775808]"
      },
      "org.apache.commons.validator.routines.LongValidatorTest::testInvalidStrict": {
        "path": "org/apache/commons/validator/routines/LongValidatorTest.java",
        "function_name": "testInvalidStrict",
        "src": "",
        "error_msg": "org.apache.commons.validator.routines.LongValidatorTest::testInvalidStrict --> junit.framework.AssertionFailedError: (A) idx=[7] value=[9223372036854775808]",
        "clean_error_msg": "junit.framework.AssertionFailedError: (A) idx=[7] value=[9223372036854775808]"
      }
    }
  },
  "Pool-6": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java",
        "start_loc": 1183,
        "end_loc": 1211,
        "buggy_function": "     @Override\n    public void close() throws Exception {\n         if (isClosed()) {\n             return;\n         }\n\n         synchronized (closeLock) {\n             if (isClosed()) {\n                 return;\n             }\n\n             // Stop the evictor before the pool is closed since evict() calls\n             // assertOpen()\n             startEvictor(-1L);\n\n             closed = true;\n             // This clear removes any idle objects\n             clear();\n             if (oname != null) {\n                 ManagementFactory.getPlatformMBeanServer().unregisterMBean(\n                         oname);\n             }\n\n             // Release any threads that were waiting for an object\n             // This clear cleans up the keys now any waiting threads have been\n             // interrupted\n         }\n\n     }",
        "fixed_function": "     @Override\n    public void close() throws Exception {\n         if (isClosed()) {\n             return;\n         }\n\n         synchronized (closeLock) {\n             if (isClosed()) {\n                 return;\n             }\n\n             // Stop the evictor before the pool is closed since evict() calls\n             // assertOpen()\n             startEvictor(-1L);\n\n             closed = true;\n             // This clear removes any idle objects\n             clear();\n             if (oname != null) {\n                 ManagementFactory.getPlatformMBeanServer().unregisterMBean(\n                         oname);\n             }\n\n             // Release any threads that were waiting for an object\n             Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();\n             while (iter.hasNext()) {\n                 iter.next().getIdleObjects().interuptTakeWaiters();\n             }\n             // This clear cleans up the keys now any waiting threads have been\n             // interrupted\n             clear();\n         }\n\n     }",
        "comment": "/**\n      * <p>Closes the keyed object pool.  Once the pool is closed, {@link #borrowObject(Object)}\n      * will fail with IllegalStateException, but {@link #returnObject(Object, Object)} and\n      * {@link #invalidateObject(Object, Object)} will continue to work, with returned objects\n      * destroyed on return.</p>\n      *\n      * <p>Destroys idle instances in the pool by invoking {@link #clear()}.</p>\n      *\n      * @throws Exception\n      */"
      },
      {
        "path": "src/java/org/apache/commons/pool2/impl/GenericObjectPool.java",
        "start_loc": 1044,
        "end_loc": 1068,
        "buggy_function": "    @Override\n    public void close() throws Exception {\n        if (isClosed()) {\n            return;\n        }\n\n        synchronized (closeLock) {\n            if (isClosed()) {\n                return;\n            }\n\n            // Stop the evictor before the pool is closed since evict() calls\n            // assertOpen()\n            startEvictor(-1L);\n\n            super.close();\n            clear();\n            if (oname != null) {\n                ManagementFactory.getPlatformMBeanServer().unregisterMBean(\n                        oname);\n            }\n\n            // Release any threads that were waiting for an object\n        }\n    }",
        "fixed_function": "    @Override\n    public void close() throws Exception {\n        if (isClosed()) {\n            return;\n        }\n\n        synchronized (closeLock) {\n            if (isClosed()) {\n                return;\n            }\n\n            // Stop the evictor before the pool is closed since evict() calls\n            // assertOpen()\n            startEvictor(-1L);\n\n            super.close();\n            clear();\n            if (oname != null) {\n                ManagementFactory.getPlatformMBeanServer().unregisterMBean(\n                        oname);\n            }\n\n            // Release any threads that were waiting for an object\n            idleObjects.interuptTakeWaiters();\n        }\n    }",
        "comment": "/**\n     * <p>\n     * Closes the pool. Once the pool is closed, {@link #borrowObject()} will\n     * fail with IllegalStateException, but {@link #returnObject(Object)} and\n     * {@link #invalidateObject(Object)} will continue to work, with returned\n     * objects destroyed on return.\n     * </p>\n     * <p>\n     * Destroys idle instances in the pool by invoking {@link #clear()}.\n     * </p>\n     *\n     * @throws Exception\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testWhenExhaustedBlockClosePool": {
        "path": "org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java",
        "function_name": "testWhenExhaustedBlockClosePool",
        "src": "@Test(timeout=60000)\n    public void testWhenExhaustedBlockClosePool() throws Exception {\n        SimpleFactory<String> factory = new SimpleFactory<String>();\n        GenericKeyedObjectPool<String,String> pool =\n            new GenericKeyedObjectPool<String,String>(factory);\n        pool.setMaxTotalPerKey(1);\n        pool.setBlockWhenExhausted(true);\n        pool.setMaxWait(-1);\n        String obj1 = pool.borrowObject(\"a\");\n\n        // Make sure an object was obtained\n        assertNotNull(obj1);\n\n        // Create a separate thread to try and borrow another object\n        WaitingTestThread wtt = new WaitingTestThread(pool, \"a\", 200);\n        wtt.start();\n        // Give wtt time to start\n        Thread.sleep(200);\n\n        // close the pool (Bug POOL-189)\n        pool.close();\n\n        // Give interrupt time to take effect\n        Thread.sleep(200);\n\n        // Check thread was interrupted\n        assertTrue(wtt._thrown instanceof InterruptedException);\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testWhenExhaustedBlockClosePool --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.pool2.impl.TestGenericObjectPool::testWhenExhaustedBlockClosePool": {
        "path": "org/apache/commons/pool2/impl/TestGenericObjectPool.java",
        "function_name": "testWhenExhaustedBlockClosePool",
        "src": "@Test(timeout=60000)\n    public void testWhenExhaustedBlockClosePool() throws Exception {\n        pool.setMaxTotal(1);\n        pool.setBlockWhenExhausted(true);\n        pool.setMaxWait(-1);\n        Object obj1 = pool.borrowObject();\n\n        // Make sure an object was obtained\n        assertNotNull(obj1);\n\n        // Create a separate thread to try and borrow another object\n        WaitingTestThread wtt = new WaitingTestThread(pool, 200);\n        wtt.start();\n        // Give wtt time to start\n        Thread.sleep(200);\n\n        // close the pool (Bug POOL-189)\n        pool.close();\n\n        // Give interrupt time to take effect\n        Thread.sleep(200);\n\n        // Check thread was interrupted\n        assertTrue(wtt._thrown instanceof InterruptedException);\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericObjectPool::testWhenExhaustedBlockClosePool --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Pool-7": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java",
        "start_loc": 544,
        "end_loc": 555,
        "buggy_function": "    @Override\n    public void invalidateObject(K key, T obj) throws Exception {\n\n        ObjectDeque<T> objectDeque = poolMap.get(key);\n\n        PooledObject<T> p = objectDeque.getAllObjects().get(obj);\n        if (p == null) {\n            throw new IllegalStateException(\n                    \"Object not currently part of this pool\");\n        }\n                destroy(key, p, true);\n    }",
        "fixed_function": "    @Override\n    public void invalidateObject(K key, T obj) throws Exception {\n\n        ObjectDeque<T> objectDeque = poolMap.get(key);\n\n        PooledObject<T> p = objectDeque.getAllObjects().get(obj);\n        if (p == null) {\n            throw new IllegalStateException(\n                    \"Object not currently part of this pool\");\n        }\n        synchronized (p) {\n            if (p.getState() != PooledObjectState.INVALID) { \n                destroy(key, p, true);\n            }\n        }\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     * <p>\n     * Activation of this method decrements the active count associated with\n     * the given keyed pool and attempts to destroy <code>obj.</code>\n     *\n     * @param key pool key\n     * @param obj instance to invalidate\n     *\n     * @throws Exception             if an exception occurs destroying the\n     *                               object\n     * @throws IllegalStateException if obj does not belong to the pool\n     *                               under the given key\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericObjectPool.java",
        "start_loc": 576,
        "end_loc": 588,
        "buggy_function": "    @Override\n    public void invalidateObject(T obj) throws Exception {\n        PooledObject<T> p = allObjects.get(obj);\n        if (p == null) {\n            if (isAbandonedConfig()) {\n                return;\n            } else {\n                throw new IllegalStateException(\n                        \"Returned object not currently part of this pool\");\n            }\n        }   \n                destroy(p);\n    }",
        "fixed_function": "    @Override\n    public void invalidateObject(T obj) throws Exception {\n        PooledObject<T> p = allObjects.get(obj);\n        if (p == null) {\n            if (isAbandonedConfig()) {\n                return;\n            } else {\n                throw new IllegalStateException(\n                        \"Invalidated object not currently part of this pool\");\n            }\n        }   \n        synchronized (p) {\n            if (p.getState() != PooledObjectState.INVALID) { \n                destroy(p);\n            }\n        }\n    }",
        "comment": "/**\n     * {@inheritDoc}\n     * <p>\n     * Activation of this method decrements the active count and attempts to\n     * destroy the instance.\n     *\n     * @throws Exception             if an exception occurs destroying the\n     *                               object\n     * @throws IllegalStateException if obj does not belong to this pool\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testConcurrentInvalidate": {
        "path": "org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java",
        "function_name": "testConcurrentInvalidate",
        "src": "@Test\n    public void testConcurrentInvalidate() {}",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testConcurrentInvalidate --> junit.framework.AssertionFailedError: expected:<60> but was:<63>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<60> but was:<63>"
      },
      "org.apache.commons.pool2.impl.TestGenericObjectPool::testConcurrentInvalidate": {
        "path": "org/apache/commons/pool2/impl/TestGenericObjectPool.java",
        "function_name": "testConcurrentInvalidate",
        "src": "@Test\n    public void testConcurrentInvalidate() throws Exception {\n        // Get allObjects and idleObjects loaded with some instances\n        final int nObjects = 1000;\n        pool.setMaxTotal(nObjects);\n        pool.setMaxIdle(nObjects);\n        final Object[] obj = new Object[nObjects];\n        for (int i = 0; i < nObjects; i++) {\n            obj[i] = pool.borrowObject();\n        }\n        for (int i = 0; i < nObjects; i++) {\n            if (i % 2 == 0) {\n                pool.returnObject(obj[i]);\n            }\n        }\n        final int nThreads = 20;\n        final int nIterations = 60;\n        final InvalidateThread[] threads = new InvalidateThread[nThreads];\n        // Randomly generated list of distinct invalidation targets\n        final ArrayList<Integer> targets = new ArrayList<Integer>();\n        final Random random = new Random();\n        for (int j = 0; j < nIterations; j++) {\n            // Get a random invalidation target\n            Integer targ = new Integer(random.nextInt(nObjects));\n            while (targets.contains(targ)) {\n                targ = new Integer(random.nextInt(nObjects));\n            }\n            targets.add(targ);\n            // Launch nThreads threads all trying to invalidate the target\n            for (int i = 0; i < nThreads; i++) {\n                threads[i] = new InvalidateThread(pool, obj[targ]);\n            }\n            for (int i = 0; i < nThreads; i++) {\n                new Thread(threads[i]).start();\n            }\n            boolean done = false;\n            while (!done) {\n                done = true;\n                for (int i = 0; i < nThreads; i++) {\n                    done = done && threads[i].complete();\n                }\n                Thread.sleep(100);\n            }\n        }\n        Assert.assertEquals(nIterations, pool.getDestroyedCount());\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericObjectPool::testConcurrentInvalidate --> junit.framework.AssertionFailedError: expected:<60> but was:<63>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<60> but was:<63>"
      }
    }
  },
  "Pool-12": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java",
        "start_loc": 336,
        "end_loc": 440,
        "buggy_function": "    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n        ObjectDeque<T> objectDeque = register(key);\n\n        try {\n            while (p == null) {\n                create = false;\n                if (blockWhenExhausted) {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        if (borrowMaxWaitMillis < 0) {\n                            p = objectDeque.getIdleObjects().takeFirst();\n                        } else {\n                            waitTime = System.currentTimeMillis();\n                            p = objectDeque.getIdleObjects().pollFirst(\n                                    borrowMaxWaitMillis, TimeUnit.MILLISECONDS);\n                            waitTime = System.currentTimeMillis() - waitTime;\n                        }\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\n                                \"Timeout waiting for idle object\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                } else {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\"Pool exhausted\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                }\n\n                if (p != null) {\n                    try {\n                        factory.activateObject(key, p);\n                    } catch (Exception e) {\n                        try {\n                            destroy(key, p, true);\n                        } catch (Exception e1) {\n                            // Ignore - activation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to activate object\");\n                            nsee.initCause(e);\n                            throw nsee;\n                        }\n                    }\n                    if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                        boolean validate = false;\n                        Throwable validationThrowable = null;\n                        try {\n                            validate = factory.validateObject(key, p);\n                        } catch (Throwable t) {\n                            PoolUtils.checkRethrow(t);\n                            validationThrowable = t;\n                        }\n                        if (!validate) {\n                            try {\n                                destroy(key, p, true);\n                                destroyedByBorrowValidationCount.incrementAndGet();\n                            } catch (Exception e) {\n                                // Ignore - validation failure is more important\n                            }\n                            p = null;\n                            if (create) {\n                                NoSuchElementException nsee = new NoSuchElementException(\n                                        \"Unable to validate object\");\n                                nsee.initCause(validationThrowable);\n                                throw nsee;\n                            }\n                        }\n                    }\n                }\n            }\n        } finally {\n            deregister(key);\n        }\n\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }",
        "fixed_function": "    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n        ObjectDeque<T> objectDeque = register(key);\n\n        try {\n            while (p == null) {\n                create = false;\n                if (blockWhenExhausted) {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        if (borrowMaxWaitMillis < 0) {\n                            p = objectDeque.getIdleObjects().takeFirst();\n                        } else {\n                            p = objectDeque.getIdleObjects().pollFirst(\n                                    borrowMaxWaitMillis, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\n                                \"Timeout waiting for idle object\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                } else {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\"Pool exhausted\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                }\n\n                if (p != null) {\n                    try {\n                        factory.activateObject(key, p);\n                    } catch (Exception e) {\n                        try {\n                            destroy(key, p, true);\n                        } catch (Exception e1) {\n                            // Ignore - activation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to activate object\");\n                            nsee.initCause(e);\n                            throw nsee;\n                        }\n                    }\n                    if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                        boolean validate = false;\n                        Throwable validationThrowable = null;\n                        try {\n                            validate = factory.validateObject(key, p);\n                        } catch (Throwable t) {\n                            PoolUtils.checkRethrow(t);\n                            validationThrowable = t;\n                        }\n                        if (!validate) {\n                            try {\n                                destroy(key, p, true);\n                                destroyedByBorrowValidationCount.incrementAndGet();\n                            } catch (Exception e) {\n                                // Ignore - validation failure is more important\n                            }\n                            p = null;\n                            if (create) {\n                                NoSuchElementException nsee = new NoSuchElementException(\n                                        \"Unable to validate object\");\n                                nsee.initCause(validationThrowable);\n                                throw nsee;\n                            }\n                        }\n                    }\n                }\n            }\n        } finally {\n            deregister(key);\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "comment": "/**\n     * Borrows an object from the sub-pool associated with the given key using\n     * the specified waiting time which only applies if\n     * {@link #getBlockWhenExhausted()} is true.\n     * <p>\n     * If there is one or more idle instances available in the sub-pool\n     * associated with the given key, then an idle instance will be selected\n     * based on the value of {@link #getLifo()}, activated and returned.  If\n     * activation fails, or {@link #getTestOnBorrow() testOnBorrow} is set to\n     * <code>true</code> and validation fails, the instance is destroyed and the\n     * next available instance is examined.  This continues until either a valid\n     * instance is returned or there are no more idle instances available.\n     * <p>\n     * If there are no idle instances available in the sub-pool associated with\n     * the given key, behavior depends on the {@link #getMaxTotalPerKey()\n     * maxTotalPerKey}, {@link #getMaxTotal() maxTotal}, and (if applicable)\n     * {@link #getBlockWhenExhausted()} and the value passed in to the\n     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances checked\n     * out from the sub-pool under the given key is less than\n     * <code>maxTotalPerKey</code> and the total number of instances in\n     * circulation (under all keys) is less than <code>maxTotal</code>, a new\n     * instance is created, activated and (if applicable) validated and returned\n     * to the caller. If validation fails, a <code>NoSuchElementException</code>\n     * will be thrown.\n     * <p>\n     * If the associated sub-pool is exhausted (no available idle instances and\n     * no capacity to create new ones), this method will either block\n     * ({@link #getBlockWhenExhausted()} is true) or throw a\n     * <code>NoSuchElementException</code>\n     * ({@link #getBlockWhenExhausted()} is false).\n     * The length of time that this method will block when\n     * {@link #getBlockWhenExhausted()} is true is determined by the value\n     * passed in to the <code>borrowMaxWait</code> parameter.\n     * <p>\n     * When <code>maxTotal</code> is set to a positive value and this method is\n     * invoked when at the limit with no idle instances available under the requested\n     * key, an attempt is made to create room by clearing the oldest 15% of the\n     * elements from the keyed sub-pools.\n     * <p>\n     * When the pool is exhausted, multiple calling threads may be\n     * simultaneously blocked waiting for instances to become available. A\n     * \"fairness\" algorithm has been implemented to ensure that threads receive\n     * available instances in request arrival order.\n     *\n     * @param key pool key\n     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object\n     *                            to become available\n     *\n     * @return object instance from the keyed pool\n     *\n     * @throws NoSuchElementException if a keyed object instance cannot be\n     *                                returned because the pool is exhausted.\n     *\n     * @throws Exception if a keyed object instance cannot be returned due to an\n     *                   error\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericObjectPool.java",
        "start_loc": 409,
        "end_loc": 515,
        "buggy_function": "    public T borrowObject(long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n\n        while (p == null) {\n            create = false;\n            if (blockWhenExhausted) {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        p = idleObjects.takeFirst();\n                    } else {\n                        waitTime = System.currentTimeMillis();\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n                        waitTime = System.currentTimeMillis() - waitTime;\n                    }\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n\n            if (p != null) {\n                try {\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                        // Ignore - activation failure is more important\n                    }\n                    p = null;\n                    if (create) {\n                        NoSuchElementException nsee = new NoSuchElementException(\n                                \"Unable to activate object\");\n                        nsee.initCause(e);\n                        throw nsee;\n                    }\n                }\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                        try {\n                            destroy(p);\n                            destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                            // Ignore - validation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to validate object\");\n                            nsee.initCause(validationThrowable);\n                            throw nsee;\n                        }\n                    }\n                }\n            }\n        }\n\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }",
        "fixed_function": "    public T borrowObject(long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n\n        while (p == null) {\n            create = false;\n            if (blockWhenExhausted) {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        p = idleObjects.takeFirst();\n                    } else {\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n                    }\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n\n            if (p != null) {\n                try {\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                        // Ignore - activation failure is more important\n                    }\n                    p = null;\n                    if (create) {\n                        NoSuchElementException nsee = new NoSuchElementException(\n                                \"Unable to activate object\");\n                        nsee.initCause(e);\n                        throw nsee;\n                    }\n                }\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                        try {\n                            destroy(p);\n                            destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                            // Ignore - validation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to validate object\");\n                            nsee.initCause(validationThrowable);\n                            throw nsee;\n                        }\n                    }\n                }\n            }\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "comment": "/**\n     * Borrow an object from the pool using the specific waiting time which only\n     * applies if {@link #getBlockWhenExhausted()} is true.\n     * <p>\n     * If there is one or more idle instance available in the pool, then an\n     * idle instance will be selected based on the value of {@link #getLifo()},\n     * activated and returned. If activation fails, or {@link #getTestOnBorrow()\n     * testOnBorrow} is set to <code>true</code> and validation fails, the\n     * instance is destroyed and the next available instance is examined. This\n     * continues until either a valid instance is returned or there are no more\n     * idle instances available.\n     * <p>\n     * If there are no idle instances available in the pool, behavior depends on\n     * the {@link #getMaxTotal() maxTotal}, (if applicable)\n     * {@link #getBlockWhenExhausted()} and the value passed in to the\n     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances\n     * checked out from the pool is less than <code>maxTotal,</code> a new\n     * instance is created, activated and (if applicable) validated and returned\n     * to the caller. If validation fails, a <code>NoSuchElementException</code>\n     * is thrown.\n     * <p>\n     * If the pool is exhausted (no available idle instances and no capacity to\n     * create new ones), this method will either block (if\n     * {@link #getBlockWhenExhausted()} is true) or throw a\n     * <code>NoSuchElementException</code> (if\n     * {@link #getBlockWhenExhausted()} is false). The length of time that this\n     * method will block when {@link #getBlockWhenExhausted()} is true is\n     * determined by the value passed in to the <code>borrowMaxWaitMillis</code>\n     * parameter.\n     * <p>\n     * When the pool is exhausted, multiple calling threads may be\n     * simultaneously blocked waiting for instances to become available. A\n     * \"fairness\" algorithm has been implemented to ensure that threads receive\n     * available instances in request arrival order.\n     *\n     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object\n     *                            to become available\n     *\n     * @return object instance from the pool\n     *\n     * @throws NoSuchElementException if an instance cannot be returned\n     *\n     * @throws Exception if an object instance cannot be returned due to an\n     *                   error\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testClientWaitStats": {
        "path": "org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java",
        "function_name": "testClientWaitStats",
        "src": "@Test\n    public void testClientWaitStats() throws Exception {\n        SimpleFactory<String> factory = new SimpleFactory<String>();\n        // Give makeObject a little latency\n        factory.setMakeLatency(100);\n        final GenericKeyedObjectPool<String, String> pool = new GenericKeyedObjectPool<String, String>(\n                factory, new GenericKeyedObjectPoolConfig());\n        String s = pool.borrowObject(\"one\");\n        // First borrow waits on create, so wait time should be at least 100 ms\n        Assert.assertTrue(pool.getMaxBorrowWaitTimeMillis() >= 100);\n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() >= 100);\n        pool.returnObject(\"one\", s);\n        pool.borrowObject(\"one\");\n        // Second borrow does not have to wait on create, average should be about 50\n        Assert.assertTrue(pool.getMaxBorrowWaitTimeMillis() >= 100);\n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() < 60);  \n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() > 40);  \n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testClientWaitStats --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.apache.commons.pool2.impl.TestGenericObjectPool::testClientWaitStats": {
        "path": "org/apache/commons/pool2/impl/TestGenericObjectPool.java",
        "function_name": "testClientWaitStats",
        "src": "@Test\n    public void testClientWaitStats() throws Exception {\n        SimpleFactory factory = new SimpleFactory();\n        // Give makeObject a little latency\n        factory.setMakeLatency(100);\n        final GenericObjectPool<String> pool = new GenericObjectPool<String>(\n                factory, new GenericObjectPoolConfig());\n        String s = pool.borrowObject();\n        // First borrow waits on create, so wait time should be at least 100 ms\n        Assert.assertTrue(pool.getMaxBorrowWaitTimeMillis() >= 100);\n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() >= 100);\n        pool.returnObject(s);\n        pool.borrowObject();\n        // Second borrow does not have to wait on create, average should be about 50\n        Assert.assertTrue(pool.getMaxBorrowWaitTimeMillis() >= 100);\n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() < 60);  \n        Assert.assertTrue(pool.getMeanBorrowWaitTimeMillis() > 40);  \n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericObjectPool::testClientWaitStats --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Pool-14": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java",
        "start_loc": 337,
        "end_loc": 439,
        "buggy_function": "    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n        ObjectDeque<T> objectDeque = register(key);\n\n        try {\n            while (p == null) {\n                create = false;\n                if (blockWhenExhausted) {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        if (borrowMaxWaitMillis < 0) {\n                            p = objectDeque.getIdleObjects().takeFirst();\n                        } else {\n                            p = objectDeque.getIdleObjects().pollFirst(\n                                    borrowMaxWaitMillis, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\n                                \"Timeout waiting for idle object\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                } else {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        create = true;\n                        p = create(key);\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\"Pool exhausted\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                }\n\n                if (p != null) {\n                    try {\n                        factory.activateObject(key, p);\n                    } catch (Exception e) {\n                        try {\n                            destroy(key, p, true);\n                        } catch (Exception e1) {\n                            // Ignore - activation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to activate object\");\n                            nsee.initCause(e);\n                            throw nsee;\n                        }\n                    }\n                    if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                        boolean validate = false;\n                        Throwable validationThrowable = null;\n                        try {\n                            validate = factory.validateObject(key, p);\n                        } catch (Throwable t) {\n                            PoolUtils.checkRethrow(t);\n                            validationThrowable = t;\n                        }\n                        if (!validate) {\n                            try {\n                                destroy(key, p, true);\n                                destroyedByBorrowValidationCount.incrementAndGet();\n                            } catch (Exception e) {\n                                // Ignore - validation failure is more important\n                            }\n                            p = null;\n                            if (create) {\n                                NoSuchElementException nsee = new NoSuchElementException(\n                                        \"Unable to validate object\");\n                                nsee.initCause(validationThrowable);\n                                throw nsee;\n                            }\n                        }\n                    }\n                }\n            }\n        } finally {\n            deregister(key);\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "fixed_function": "    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n        ObjectDeque<T> objectDeque = register(key);\n\n        try {\n            while (p == null) {\n                create = false;\n                if (blockWhenExhausted) {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        p = create(key);\n                        if (p != null) {\n                            create = true;\n                        }\n                    }\n                    if (p == null) {\n                        if (borrowMaxWaitMillis < 0) {\n                            p = objectDeque.getIdleObjects().takeFirst();\n                        } else {\n                            p = objectDeque.getIdleObjects().pollFirst(\n                                    borrowMaxWaitMillis, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\n                                \"Timeout waiting for idle object\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                } else {\n                    p = objectDeque.getIdleObjects().pollFirst();\n                    if (p == null) {\n                        p = create(key);\n                        if (p != null) {\n                            create = true;\n                        }\n                    }\n                    if (p == null) {\n                        throw new NoSuchElementException(\"Pool exhausted\");\n                    }\n                    if (!p.allocate()) {\n                        p = null;\n                    }\n                }\n\n                if (p != null) {\n                    try {\n                        factory.activateObject(key, p);\n                    } catch (Exception e) {\n                        try {\n                            destroy(key, p, true);\n                        } catch (Exception e1) {\n                            // Ignore - activation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to activate object\");\n                            nsee.initCause(e);\n                            throw nsee;\n                        }\n                    }\n                    if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                        boolean validate = false;\n                        Throwable validationThrowable = null;\n                        try {\n                            validate = factory.validateObject(key, p);\n                        } catch (Throwable t) {\n                            PoolUtils.checkRethrow(t);\n                            validationThrowable = t;\n                        }\n                        if (!validate) {\n                            try {\n                                destroy(key, p, true);\n                                destroyedByBorrowValidationCount.incrementAndGet();\n                            } catch (Exception e) {\n                                // Ignore - validation failure is more important\n                            }\n                            p = null;\n                            if (create) {\n                                NoSuchElementException nsee = new NoSuchElementException(\n                                        \"Unable to validate object\");\n                                nsee.initCause(validationThrowable);\n                                throw nsee;\n                            }\n                        }\n                    }\n                }\n            }\n        } finally {\n            deregister(key);\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "comment": "/**\n     * Borrows an object from the sub-pool associated with the given key using\n     * the specified waiting time which only applies if\n     * {@link #getBlockWhenExhausted()} is true.\n     * <p>\n     * If there is one or more idle instances available in the sub-pool\n     * associated with the given key, then an idle instance will be selected\n     * based on the value of {@link #getLifo()}, activated and returned.  If\n     * activation fails, or {@link #getTestOnBorrow() testOnBorrow} is set to\n     * <code>true</code> and validation fails, the instance is destroyed and the\n     * next available instance is examined.  This continues until either a valid\n     * instance is returned or there are no more idle instances available.\n     * <p>\n     * If there are no idle instances available in the sub-pool associated with\n     * the given key, behavior depends on the {@link #getMaxTotalPerKey()\n     * maxTotalPerKey}, {@link #getMaxTotal() maxTotal}, and (if applicable)\n     * {@link #getBlockWhenExhausted()} and the value passed in to the\n     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances checked\n     * out from the sub-pool under the given key is less than\n     * <code>maxTotalPerKey</code> and the total number of instances in\n     * circulation (under all keys) is less than <code>maxTotal</code>, a new\n     * instance is created, activated and (if applicable) validated and returned\n     * to the caller. If validation fails, a <code>NoSuchElementException</code>\n     * will be thrown.\n     * <p>\n     * If the associated sub-pool is exhausted (no available idle instances and\n     * no capacity to create new ones), this method will either block\n     * ({@link #getBlockWhenExhausted()} is true) or throw a\n     * <code>NoSuchElementException</code>\n     * ({@link #getBlockWhenExhausted()} is false).\n     * The length of time that this method will block when\n     * {@link #getBlockWhenExhausted()} is true is determined by the value\n     * passed in to the <code>borrowMaxWait</code> parameter.\n     * <p>\n     * When <code>maxTotal</code> is set to a positive value and this method is\n     * invoked when at the limit with no idle instances available under the requested\n     * key, an attempt is made to create room by clearing the oldest 15% of the\n     * elements from the keyed sub-pools.\n     * <p>\n     * When the pool is exhausted, multiple calling threads may be\n     * simultaneously blocked waiting for instances to become available. A\n     * \"fairness\" algorithm has been implemented to ensure that threads receive\n     * available instances in request arrival order.\n     *\n     * @param key pool key\n     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object\n     *                            to become available\n     *\n     * @return object instance from the keyed pool\n     *\n     * @throws NoSuchElementException if a keyed object instance cannot be\n     *                                returned because the pool is exhausted.\n     *\n     * @throws Exception if a keyed object instance cannot be returned due to an\n     *                   error\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericObjectPool.java",
        "start_loc": 411,
        "end_loc": 515,
        "buggy_function": "    public T borrowObject(long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n\n        while (p == null) {\n            create = false;\n            if (blockWhenExhausted) {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        p = idleObjects.takeFirst();\n                    } else {\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n                    }\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n\n            if (p != null) {\n                try {\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                        // Ignore - activation failure is more important\n                    }\n                    p = null;\n                    if (create) {\n                        NoSuchElementException nsee = new NoSuchElementException(\n                                \"Unable to activate object\");\n                        nsee.initCause(e);\n                        throw nsee;\n                    }\n                }\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                        try {\n                            destroy(p);\n                            destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                            // Ignore - validation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to validate object\");\n                            nsee.initCause(validationThrowable);\n                            throw nsee;\n                        }\n                    }\n                }\n            }\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "fixed_function": "    public T borrowObject(long borrowMaxWaitMillis) throws Exception {\n        assertOpen();\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n\n        // Get local copy of current config so it is consistent for entire\n        // method execution\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = System.currentTimeMillis();\n\n        while (p == null) {\n            create = false;\n            if (blockWhenExhausted) {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    p = create();\n                    if (p != null) {\n                        create = true;\n                    }\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        p = idleObjects.takeFirst();\n                    } else {\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n                    }\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    p = create();\n                    if (p != null) {\n                        create = true;\n                    }\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n\n            if (p != null) {\n                try {\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                        // Ignore - activation failure is more important\n                    }\n                    p = null;\n                    if (create) {\n                        NoSuchElementException nsee = new NoSuchElementException(\n                                \"Unable to activate object\");\n                        nsee.initCause(e);\n                        throw nsee;\n                    }\n                }\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                        try {\n                            destroy(p);\n                            destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                            // Ignore - validation failure is more important\n                        }\n                        p = null;\n                        if (create) {\n                            NoSuchElementException nsee = new NoSuchElementException(\n                                    \"Unable to validate object\");\n                            nsee.initCause(validationThrowable);\n                            throw nsee;\n                        }\n                    }\n                }\n            }\n        }\n\n        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);\n\n        return p.getObject();\n    }",
        "comment": "/**\n     * Borrow an object from the pool using the specific waiting time which only\n     * applies if {@link #getBlockWhenExhausted()} is true.\n     * <p>\n     * If there is one or more idle instance available in the pool, then an\n     * idle instance will be selected based on the value of {@link #getLifo()},\n     * activated and returned. If activation fails, or {@link #getTestOnBorrow()\n     * testOnBorrow} is set to <code>true</code> and validation fails, the\n     * instance is destroyed and the next available instance is examined. This\n     * continues until either a valid instance is returned or there are no more\n     * idle instances available.\n     * <p>\n     * If there are no idle instances available in the pool, behavior depends on\n     * the {@link #getMaxTotal() maxTotal}, (if applicable)\n     * {@link #getBlockWhenExhausted()} and the value passed in to the\n     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances\n     * checked out from the pool is less than <code>maxTotal,</code> a new\n     * instance is created, activated and (if applicable) validated and returned\n     * to the caller. If validation fails, a <code>NoSuchElementException</code>\n     * is thrown.\n     * <p>\n     * If the pool is exhausted (no available idle instances and no capacity to\n     * create new ones), this method will either block (if\n     * {@link #getBlockWhenExhausted()} is true) or throw a\n     * <code>NoSuchElementException</code> (if\n     * {@link #getBlockWhenExhausted()} is false). The length of time that this\n     * method will block when {@link #getBlockWhenExhausted()} is true is\n     * determined by the value passed in to the <code>borrowMaxWaitMillis</code>\n     * parameter.\n     * <p>\n     * When the pool is exhausted, multiple calling threads may be\n     * simultaneously blocked waiting for instances to become available. A\n     * \"fairness\" algorithm has been implemented to ensure that threads receive\n     * available instances in request arrival order.\n     *\n     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object\n     *                            to become available\n     *\n     * @return object instance from the pool\n     *\n     * @throws NoSuchElementException if an instance cannot be returned\n     *\n     * @throws Exception if an object instance cannot be returned due to an\n     *                   error\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testValidationOnCreateOnly": {
        "path": "org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java",
        "function_name": "testValidationOnCreateOnly",
        "src": "@Test\n    public void testValidationOnCreateOnly() throws Exception {\n        factory.enableValidation = true;\n\n        pool.setMaxTotal(1);\n        pool.setTestOnCreate(true);\n        pool.setTestOnBorrow(false);\n        pool.setTestOnReturn(false);\n        pool.setTestWhileIdle(false);\n\n        final String o1 = pool.borrowObject(\"KEY\");\n        Assert.assertEquals(\"KEY0\", o1);\n        Timer t = new Timer();\n        t.schedule(\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        pool.returnObject(\"KEY\", o1);\n                    }\n                }, 3000);\n\n        String o2 = pool.borrowObject(\"KEY\");\n        Assert.assertEquals(\"KEY0\", o2);\n\n        Assert.assertEquals(1, factory.validateCounter);\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericKeyedObjectPool::testValidationOnCreateOnly --> junit.framework.AssertionFailedError: expected:<1> but was:<2>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1> but was:<2>"
      },
      "org.apache.commons.pool2.impl.TestGenericObjectPool::testValidationOnCreateOnly": {
        "path": "org/apache/commons/pool2/impl/TestGenericObjectPool.java",
        "function_name": "testValidationOnCreateOnly",
        "src": "@Test\n    public void testValidationOnCreateOnly() throws Exception {\n        pool.setMaxTotal(1);\n        pool.setTestOnCreate(true);\n        pool.setTestOnBorrow(false);\n        pool.setTestOnReturn(false);\n        pool.setTestWhileIdle(false);\n\n        final String o1 = pool.borrowObject();\n        Assert.assertEquals(\"0\", o1);\n        Timer t = new Timer();\n        t.schedule(\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        pool.returnObject(o1);\n                    }\n                }, 3000);\n\n        String o2 = pool.borrowObject();\n        Assert.assertEquals(\"0\", o2);\n\n        Assert.assertEquals(1, factory.validateCounter);\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericObjectPool::testValidationOnCreateOnly --> junit.framework.AssertionFailedError: expected:<1> but was:<2>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1> but was:<2>"
      }
    }
  },
  "Pool-21": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java",
        "start_loc": 1003,
        "end_loc": 1048,
        "buggy_function": "    private PooledObject<T> create(final K key) throws Exception {\n        final int maxTotalPerKeySave = getMaxTotalPerKey(); // Per key\n        final int maxTotal = getMaxTotal();   // All keys\n\n\n        // Check against the overall limit\n        boolean loop = true;\n\n        while (loop) {\n            final int newNumTotal = numTotal.incrementAndGet();\n            if (maxTotal > -1 && newNumTotal > maxTotal) {\n                numTotal.decrementAndGet();\n                if (getNumIdle() == 0) {\n                    return null;\n                }\n                clearOldest();\n            } else {\n                loop = false;\n            }\n        }\n\n        final ObjectDeque<T> objectDeque = poolMap.get(key);\n        final long newCreateCount = objectDeque.getCreateCount().incrementAndGet();\n\n        // Check against the per key limit\n        if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave ||\n                newCreateCount > Integer.MAX_VALUE) {\n            numTotal.decrementAndGet();\n            objectDeque.getCreateCount().decrementAndGet();\n            return null;\n        }\n\n\n        PooledObject<T> p = null;\n        try {\n            p = factory.makeObject(key);\n        } catch (final Exception e) {\n            numTotal.decrementAndGet();\n            objectDeque.getCreateCount().decrementAndGet();\n            throw e;\n        }\n\n        createdCount.incrementAndGet();\n        objectDeque.getAllObjects().put(new IdentityWrapper<T>(p.getObject()), p);\n        return p;\n    }",
        "fixed_function": "    private PooledObject<T> create(final K key) throws Exception {\n        final int maxTotalPerKeySave = getMaxTotalPerKey(); // Per key\n        final int maxTotal = getMaxTotal();   // All keys\n\n        final ObjectDeque<T> objectDeque = poolMap.get(key);\n\n        // Check against the overall limit\n        boolean loop = true;\n\n        while (loop) {\n            final int newNumTotal = numTotal.incrementAndGet();\n            if (maxTotal > -1 && newNumTotal > maxTotal) {\n                numTotal.decrementAndGet();\n                if (getNumIdle() == 0) {\n                    // POOL-303. There may be threads waiting on an object\n                    // return that isn't going to happen. Unblock them.\n                    objectDeque.idleObjects.interuptTakeWaiters();\n                    return null;\n                }\n                clearOldest();\n            } else {\n                loop = false;\n            }\n        }\n\n        final long newCreateCount = objectDeque.getCreateCount().incrementAndGet();\n\n        // Check against the per key limit\n        if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave ||\n                newCreateCount > Integer.MAX_VALUE) {\n            numTotal.decrementAndGet();\n            objectDeque.getCreateCount().decrementAndGet();\n            // POOL-303. There may be threads waiting on an object return that\n            // isn't going to happen. Unblock them.\n            objectDeque.idleObjects.interuptTakeWaiters();\n            return null;\n        }\n\n\n        PooledObject<T> p = null;\n        try {\n            p = factory.makeObject(key);\n        } catch (final Exception e) {\n            numTotal.decrementAndGet();\n            objectDeque.getCreateCount().decrementAndGet();\n            // POOL-303. There may be threads waiting on an object return that\n            // isn't going to happen. Unblock them.\n            objectDeque.idleObjects.interuptTakeWaiters();\n            throw e;\n        }\n\n        createdCount.incrementAndGet();\n        objectDeque.getAllObjects().put(new IdentityWrapper<T>(p.getObject()), p);\n        return p;\n    }",
        "comment": "/**\n     * Create a new pooled object.\n     *\n     * @param key Key associated with new pooled object\n     *\n     * @return The new, wrapped pooled object\n     *\n     * @throws Exception If the objection creation fails\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/pool2/impl/GenericObjectPool.java",
        "start_loc": 853,
        "end_loc": 878,
        "buggy_function": "    private PooledObject<T> create() throws Exception {\n        final int localMaxTotal = getMaxTotal();\n        final long newCreateCount = createCount.incrementAndGet();\n        if (localMaxTotal > -1 && newCreateCount > localMaxTotal ||\n                newCreateCount > Integer.MAX_VALUE) {\n            createCount.decrementAndGet();\n            return null;\n        }\n\n        final PooledObject<T> p;\n        try {\n            p = factory.makeObject();\n        } catch (final Exception e) {\n            createCount.decrementAndGet();\n            throw e;\n        }\n\n        final AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getLogAbandoned()) {\n            p.setLogAbandoned(true);\n        }\n\n        createdCount.incrementAndGet();\n        allObjects.put(new IdentityWrapper<T>(p.getObject()), p);\n        return p;\n    }",
        "fixed_function": "    private PooledObject<T> create() throws Exception {\n        final int localMaxTotal = getMaxTotal();\n        final long newCreateCount = createCount.incrementAndGet();\n        if (localMaxTotal > -1 && newCreateCount > localMaxTotal ||\n                newCreateCount > Integer.MAX_VALUE) {\n            createCount.decrementAndGet();\n            // POOL-303. There may be threads waiting on an object return that\n            // isn't going to happen. Unblock them.\n            idleObjects.interuptTakeWaiters();\n            return null;\n        }\n\n        final PooledObject<T> p;\n        try {\n            p = factory.makeObject();\n        } catch (final Exception e) {\n            createCount.decrementAndGet();\n            // POOL-303. There may be threads waiting on an object return that\n            // isn't going to happen. Unblock them.\n            idleObjects.interuptTakeWaiters();\n            throw e;\n        }\n\n        final AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getLogAbandoned()) {\n            p.setLogAbandoned(true);\n        }\n\n        createdCount.incrementAndGet();\n        allObjects.put(new IdentityWrapper<T>(p.getObject()), p);\n        return p;\n    }",
        "comment": "/**\n     * Attempts to create a new wrapped pooled object.\n     * <p>\n     * If there are {@link #getMaxTotal()} objects already in circulation\n     * or in process of being created, this method returns null.\n     *\n     * @return The new wrapped pooled object\n     *\n     * @throws Exception if the object factory's {@code makeObject} fails\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.pool2.impl.TestGenericObjectPool::testFailingFactoryDoesNotBlockThreads": {
        "path": "org/apache/commons/pool2/impl/TestGenericObjectPool.java",
        "function_name": "testFailingFactoryDoesNotBlockThreads",
        "src": "@Test\n    public void testFailingFactoryDoesNotBlockThreads() throws Exception {\n\n        final CreateFailFactory factory = new CreateFailFactory();\n        final GenericObjectPool<String> createFailFactoryPool =\n                new GenericObjectPool<String>(factory);\n\n        createFailFactoryPool.setMaxTotal(1);\n\n        // Try and borrow the first object from the pool\n        final WaitingTestThread thread1 = new WaitingTestThread(createFailFactoryPool, 0);\n        thread1.start();\n\n        // Wait for thread to reach semaphore\n        while(!factory.hasQueuedThreads()) {\n            Thread.sleep(200);\n        }\n\n        // Try and borrow the second object from the pool\n        final WaitingTestThread thread2 = new WaitingTestThread(createFailFactoryPool, 0);\n        thread2.start();\n        // Pool will not call factory since maximum number of object creations\n        // are already queued.\n\n        // Thread 2 will wait on an object being returned to the pool\n        // Give thread 2 a chance to reach this state\n        Thread.sleep(1000);\n\n        // Release thread1\n        factory.release();\n        // Pre-release thread2\n        factory.release();\n\n        // Both threads should now complete.\n        boolean threadRunning = true;\n        int count = 0;\n        while (threadRunning && count < 15) {\n            threadRunning = thread1.isAlive();\n            threadRunning = thread2.isAlive();\n            Thread.sleep(200);\n            count++;\n        }\n        Assert.assertFalse(thread1.isAlive());\n        Assert.assertFalse(thread2.isAlive());\n    }",
        "error_msg": "org.apache.commons.pool2.impl.TestGenericObjectPool::testFailingFactoryDoesNotBlockThreads --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Net-20": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/apache/commons/net/ftp/parser/DefaultFTPFileEntryParserFactory.java",
        "start_loc": 99,
        "end_loc": 174,
        "buggy_function": "    private FTPFileEntryParser createFileEntryParser(String key, FTPClientConfig config) {\n        FTPFileEntryParser parser = null;\n\n        // Is the key a possible class name?\n        if (JAVA_QUALIFIED_NAME_PATTERN.matcher(key).matches()) {\n            try\n            {\n                Class<?> parserClass = Class.forName(key);\n                try {\n                    parser = (FTPFileEntryParser) parserClass.newInstance();\n                } catch (ClassCastException e) {\n                    throw new ParserInitializationException(parserClass.getName()\n                        + \" does not implement the interface \"\n                        + \"org.apache.commons.net.ftp.FTPFileEntryParser.\", e);\n                } catch (Exception e) {\n                    throw new ParserInitializationException(\"Error initializing parser\", e);\n                } catch (ExceptionInInitializerError e) {\n                    throw new ParserInitializationException(\"Error initializing parser\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // OK, assume it is an alias\n            }\n        }\n\n        if (parser == null) { // Now try for aliases\n            String ukey = key.toUpperCase(java.util.Locale.ENGLISH);\n            if (ukey.indexOf(FTPClientConfig.SYST_UNIX) >= 0)\n            {\n                parser = new UnixFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_VMS) >= 0)\n            {\n                parser = new VMSVersioningFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_NT) >= 0)\n            {\n                parser = createNTFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_OS2) >= 0)\n            {\n                parser = new OS2FTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_OS400) >= 0 ||\n                    ukey.indexOf(FTPClientConfig.SYST_AS400) >= 0)\n            {\n                parser = createOS400FTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_MVS) >= 0)\n            {\n                parser = new MVSFTPEntryParser(); // Does not currently support config parameter\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_NETWARE) >= 0)\n            {\n                parser = new NetwareFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_MACOS_PETER) >= 0)\n            {\n                parser = new MacOsPeterFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_L8) >= 0)\n            {\n                // L8 normally means Unix, but move it to the end for some L8 systems that aren't.\n                // This check should be last!\n                parser = new UnixFTPEntryParser(config);\n            }\n            else\n            {\n                throw new ParserInitializationException(\"Unknown parser type: \" + key);\n            }\n        }\n\n        if (parser instanceof Configurable) {\n            ((Configurable)parser).configure(config);\n        }\n        return parser;\n    }",
        "fixed_function": "    private FTPFileEntryParser createFileEntryParser(String key, FTPClientConfig config) {\n        FTPFileEntryParser parser = null;\n\n        // Is the key a possible class name?\n        if (JAVA_QUALIFIED_NAME_PATTERN.matcher(key).matches()) {\n            try\n            {\n                Class<?> parserClass = Class.forName(key);\n                try {\n                    parser = (FTPFileEntryParser) parserClass.newInstance();\n                } catch (ClassCastException e) {\n                    throw new ParserInitializationException(parserClass.getName()\n                        + \" does not implement the interface \"\n                        + \"org.apache.commons.net.ftp.FTPFileEntryParser.\", e);\n                } catch (Exception e) {\n                    throw new ParserInitializationException(\"Error initializing parser\", e);\n                } catch (ExceptionInInitializerError e) {\n                    throw new ParserInitializationException(\"Error initializing parser\", e);\n                }\n            } catch (ClassNotFoundException e) {\n                // OK, assume it is an alias\n            }\n        }\n\n        if (parser == null) { // Now try for aliases\n            String ukey = key.toUpperCase(java.util.Locale.ENGLISH);\n            if (ukey.indexOf(FTPClientConfig.SYST_UNIX) >= 0)\n            {\n                parser = new UnixFTPEntryParser(config, false);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_UNIX_TRIM_LEADING) >= 0)\n            {\n                parser = new UnixFTPEntryParser(config, true);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_VMS) >= 0)\n            {\n                parser = new VMSVersioningFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_NT) >= 0)\n            {\n                parser = createNTFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_OS2) >= 0)\n            {\n                parser = new OS2FTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_OS400) >= 0 ||\n                    ukey.indexOf(FTPClientConfig.SYST_AS400) >= 0)\n            {\n                parser = createOS400FTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_MVS) >= 0)\n            {\n                parser = new MVSFTPEntryParser(); // Does not currently support config parameter\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_NETWARE) >= 0)\n            {\n                parser = new NetwareFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_MACOS_PETER) >= 0)\n            {\n                parser = new MacOsPeterFTPEntryParser(config);\n            }\n            else if (ukey.indexOf(FTPClientConfig.SYST_L8) >= 0)\n            {\n                // L8 normally means Unix, but move it to the end for some L8 systems that aren't.\n                // This check should be last!\n                parser = new UnixFTPEntryParser(config);\n            }\n            else\n            {\n                throw new ParserInitializationException(\"Unknown parser type: \" + key);\n            }\n        }\n\n        if (parser instanceof Configurable) {\n            ((Configurable)parser).configure(config);\n        }\n        return parser;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/apache/commons/net/ftp/parser/DefaultFTPFileEntryParserFactory.java",
        "start_loc": 232,
        "end_loc": 245,
        "buggy_function": "    private FTPFileEntryParser createNTFTPEntryParser(FTPClientConfig config)\n    {\n        if (config != null && FTPClientConfig.SYST_NT.equals(\n                config.getServerSystemKey()))\n        {\n            return new NTFTPEntryParser(config);\n        } else {\n            return new CompositeFileEntryParser(new FTPFileEntryParser[]\n                   {\n                       new NTFTPEntryParser(config),\n                       new UnixFTPEntryParser(config)\n                   });\n        }\n    }",
        "fixed_function": "    private FTPFileEntryParser createNTFTPEntryParser(FTPClientConfig config)\n    {\n        if (config != null && FTPClientConfig.SYST_NT.equals(\n                config.getServerSystemKey()))\n        {\n            return new NTFTPEntryParser(config);\n        } else {\n            return new CompositeFileEntryParser(new FTPFileEntryParser[]\n                   {\n                       new NTFTPEntryParser(config),\n                       new UnixFTPEntryParser(config, \n                               config != null && FTPClientConfig.SYST_UNIX_TRIM_LEADING.equals(config.getServerSystemKey()))\n                   });\n        }\n    }",
        "comment": "/**\n     * Creates an NT FTP parser: if the config exists, and the system key equals\n     * {@link FTPClientConfig.SYST_NT} then a plain {@link NTFTPEntryParser} is used,\n     * otherwise a composite of {@link NTFTPEntryParser} and {@link UnixFTPEntryParser} is used.\n     * @param config the config to use, may be {@code null}\n     * @return the parser\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/net/ftp/parser/DefaultFTPFileEntryParserFactory.java",
        "start_loc": 264,
        "end_loc": 277,
        "buggy_function": "    private FTPFileEntryParser createOS400FTPEntryParser(FTPClientConfig config)\n        {\n        if (config != null &&\n                FTPClientConfig.SYST_OS400.equals(config.getServerSystemKey()))\n        {\n            return new OS400FTPEntryParser(config);\n        } else {\n            return new CompositeFileEntryParser(new FTPFileEntryParser[]\n                {\n                    new OS400FTPEntryParser(config),\n                    new UnixFTPEntryParser(config)\n                });\n        }\n    }",
        "fixed_function": "    private FTPFileEntryParser createOS400FTPEntryParser(FTPClientConfig config)\n        {\n        if (config != null &&\n                FTPClientConfig.SYST_OS400.equals(config.getServerSystemKey()))\n        {\n            return new OS400FTPEntryParser(config);\n        } else {\n            return new CompositeFileEntryParser(new FTPFileEntryParser[]\n                {\n                    new OS400FTPEntryParser(config),\n                    new UnixFTPEntryParser(config,\n                            config != null && FTPClientConfig.SYST_UNIX_TRIM_LEADING.equals(config.getServerSystemKey()))\n                });\n        }\n    }",
        "comment": "/**\n     * Creates an OS400 FTP parser: if the config exists, and the system key equals\n     * {@link FTPClientConfig.SYST_OS400} then a plain {@link OS400FTPEntryParser} is used,\n     * otherwise a composite of {@link OS400FTPEntryParser} and {@link UnixFTPEntryParser} is used.\n     * @param config the config to use, may be {@code null}\n     * @return the parser\n     */"
      },
      {
        "path": "src/main/java/org/apache/commons/net/ftp/parser/UnixFTPEntryParser.java",
        "start_loc": 159,
        "end_loc": 162,
        "buggy_function": "    public UnixFTPEntryParser(FTPClientConfig config)\n    {\n        this(config, true); // retain original behaviour (for now)\n    }",
        "fixed_function": "    public UnixFTPEntryParser(FTPClientConfig config)\n    {\n        this(config, false);\n    }",
        "comment": "/**\n     * This constructor allows the creation of a UnixFTPEntryParser object with\n     * something other than the default configuration.\n     *\n     * @param config The {@link FTPClientConfig configuration} object used to\n     * configure this parser.\n     * @exception IllegalArgumentException\n     * Thrown if the regular expression is unparseable.  Should not be seen\n     * under normal conditions.  It it is seen, this is a sign that\n     * <code>REGEX</code> is  not a valid regular expression.\n     * @since 1.4\n     */"
      }
    ],
    "trigger_test": {
      "org.apache.commons.net.ftp.parser.UnixFTPEntryParserTest::testLeadingSpacesDefault": {
        "path": "org/apache/commons/net/ftp/parser/UnixFTPEntryParserTest.java",
        "function_name": "testLeadingSpacesDefault",
        "src": "public void testLeadingSpacesDefault() { // the default has been changed to keep spaces\n        FTPFile f = getParser().parseFTPEntry(\"drwxr-xr-x   2 john smith     group         4096 Mar  2 15:13   zxbox\");\n        assertNotNull(f);\n        assertEquals(\"  zxbox\", f.getName() ); // leading spaces retained\n    }",
        "error_msg": "org.apache.commons.net.ftp.parser.UnixFTPEntryParserTest::testLeadingSpacesDefault --> junit.framework.ComparisonFailure: expected:<[  ]zxbox> but was:<[]zxbox>",
        "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[  ]zxbox> but was:<[]zxbox>"
      }
    }
  },
  "Tika_core-31": {
    "function_num": 4,
    "functions": [
      {
        "path": "/src/main/java/org/apache/tika/config/TikaConfig.java",
        "start_loc": 59,
        "end_loc": 61,
        "buggy_function": "    private static MimeTypes getDefaultMimeTypes() {\n        return MimeTypes.getDefaultMimeTypes();\n    }",
        "fixed_function": "    private static MimeTypes getDefaultMimeTypes(ClassLoader loader) {\n        return MimeTypes.getDefaultMimeTypes(loader);\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/tika/config/TikaConfig.java",
        "start_loc": 135,
        "end_loc": 141,
        "buggy_function": "    public TikaConfig(ClassLoader loader)\n            throws MimeTypeException, IOException {\n        ServiceLoader serviceLoader = new ServiceLoader(loader);\n        this.mimeTypes = getDefaultMimeTypes();\n        this.detector = getDefaultDetector(mimeTypes, serviceLoader);\n        this.parser = getDefaultParser(mimeTypes, serviceLoader);\n    }",
        "fixed_function": "    public TikaConfig(ClassLoader loader)\n            throws MimeTypeException, IOException {\n        ServiceLoader serviceLoader = new ServiceLoader(loader);\n        this.mimeTypes = getDefaultMimeTypes(loader);\n        this.detector = getDefaultDetector(mimeTypes, serviceLoader);\n        this.parser = getDefaultParser(mimeTypes, serviceLoader);\n    }",
        "comment": "/**\n     * Creates a Tika configuration from the built-in media type rules\n     * and all the {@link Parser} implementations available through the\n     * {@link ServiceRegistry service provider mechanism} in the given\n     * class loader.\n     *\n     * @since Apache Tika 0.8\n     * @param loader the class loader through which parser implementations\n     *               are loaded, or <code>null</code> for no parsers\n     * @throws MimeTypeException if the built-in media type rules are broken\n     * @throws IOException  if the built-in media type rules can not be read\n     */"
      },
      {
        "path": "/src/main/java/org/apache/tika/config/TikaConfig.java",
        "start_loc": 160,
        "end_loc": 209,
        "buggy_function": "    public TikaConfig() throws TikaException, IOException {\n        ServiceLoader loader = new ServiceLoader();\n\n        String config = System.getProperty(\"tika.config\");\n        if (config == null) {\n            config = System.getenv(\"TIKA_CONFIG\");\n        }\n\n        if (config == null) {\n            this.mimeTypes = getDefaultMimeTypes();\n            this.parser = getDefaultParser(mimeTypes, loader);\n            this.detector = getDefaultDetector(mimeTypes, loader);\n        } else {\n            // Locate the given configuration file\n            InputStream stream = null;\n            File file = new File(config);\n            if (file.isFile()) {\n                stream = new FileInputStream(file);\n            }\n            if (stream == null) {\n                try {\n                    stream = new URL(config).openStream();\n                } catch (IOException ignore) {\n                }\n            }\n            if (stream == null) {\n                stream = loader.getResourceAsStream(config);\n            }\n            if (stream == null) {\n                throw new TikaException(\n                        \"Specified Tika configuration not found: \" + config);\n            }\n\n            try {\n                Element element =\n                        getBuilder().parse(stream).getDocumentElement();\n                this.mimeTypes = typesFromDomElement(element);\n                this.parser =\n                        parserFromDomElement(element, mimeTypes, loader);\n                this.detector =\n                        detectorFromDomElement(element, mimeTypes, loader);\n            } catch (SAXException e) {\n                throw new TikaException(\n                        \"Specified Tika configuration has syntax errors: \"\n                                + config, e);\n            } finally {\n                stream.close();\n            }\n        }\n    }",
        "fixed_function": "    public TikaConfig() throws TikaException, IOException {\n        ServiceLoader loader = new ServiceLoader();\n\n        String config = System.getProperty(\"tika.config\");\n        if (config == null) {\n            config = System.getenv(\"TIKA_CONFIG\");\n        }\n\n        if (config == null) {\n            this.mimeTypes = getDefaultMimeTypes(ServiceLoader.getContextClassLoader());\n            this.parser = getDefaultParser(mimeTypes, loader);\n            this.detector = getDefaultDetector(mimeTypes, loader);\n        } else {\n            // Locate the given configuration file\n            InputStream stream = null;\n            File file = new File(config);\n            if (file.isFile()) {\n                stream = new FileInputStream(file);\n            }\n            if (stream == null) {\n                try {\n                    stream = new URL(config).openStream();\n                } catch (IOException ignore) {\n                }\n            }\n            if (stream == null) {\n                stream = loader.getResourceAsStream(config);\n            }\n            if (stream == null) {\n                throw new TikaException(\n                        \"Specified Tika configuration not found: \" + config);\n            }\n\n            try {\n                Element element =\n                        getBuilder().parse(stream).getDocumentElement();\n                this.mimeTypes = typesFromDomElement(element);\n                this.parser =\n                        parserFromDomElement(element, mimeTypes, loader);\n                this.detector =\n                        detectorFromDomElement(element, mimeTypes, loader);\n            } catch (SAXException e) {\n                throw new TikaException(\n                        \"Specified Tika configuration has syntax errors: \"\n                                + config, e);\n            } finally {\n                stream.close();\n            }\n        }\n    }",
        "comment": "/**\n     * Creates a default Tika configuration.\n     * First checks whether an XML config file is specified, either in\n     * <ol>\n     * <li>System property \"tika.config\", or</li>\n     * <li>Environment variable TIKA_CONFIG</li>\n     * </ol>\n     * <p>If one of these have a value, try to resolve it relative to file\n     * system or classpath.</p>\n     * <p>If XML config is not specified, initialize from the built-in media\n     * type rules and all the {@link Parser} implementations available through\n     * the {@link ServiceRegistry service provider mechanism} in the context\n     * class loader of the current thread.</p>\n     *\n     * @throws IOException if the configuration can not be read\n     * @throws TikaException if problem with MimeTypes or parsing XML config\n     */"
      },
      {
        "path": "/src/main/java/org/apache/tika/config/TikaConfig.java",
        "start_loc": 298,
        "end_loc": 306,
        "buggy_function": "    private static MimeTypes typesFromDomElement(Element element)\n            throws TikaException, IOException {\n        Element mtr = getChild(element, \"mimeTypeRepository\");\n        if (mtr != null && mtr.hasAttribute(\"resource\")) {\n            return MimeTypesFactory.create(mtr.getAttribute(\"resource\"));\n        } else {\n            return getDefaultMimeTypes();\n        }\n    }",
        "fixed_function": "    private static MimeTypes typesFromDomElement(Element element)\n            throws TikaException, IOException {\n        Element mtr = getChild(element, \"mimeTypeRepository\");\n        if (mtr != null && mtr.hasAttribute(\"resource\")) {\n            return MimeTypesFactory.create(mtr.getAttribute(\"resource\"));\n        } else {\n            return getDefaultMimeTypes(null);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.tika.config.TikaConfigTest::testClassLoaderUsedEverywhere": {
        "path": "org/apache/tika/config/TikaConfigTest.java",
        "function_name": "testClassLoaderUsedEverywhere",
        "src": "public void testClassLoaderUsedEverywhere() throws Exception {\n        ResourceLoggingClassLoader customLoader = \n                new ResourceLoggingClassLoader(getClass().getClassLoader());\n        TikaConfig config;\n        \n        // Without a classloader set, normal one will be used\n        config = new TikaConfig();\n        config.getMediaTypeRegistry();\n        config.getParser();\n        assertEquals(0, customLoader.getLoadedResources().size());\n        \n        // With a classloader set, resources will come through it\n        config = new TikaConfig(customLoader);\n        config.getMediaTypeRegistry();\n        config.getParser();\n        \n        Map<String,List<URL>> resources = customLoader.getLoadedResources();\n        int resourcesCount = resources.size();\n        assertTrue(\n                \"Not enough things used the classloader, found only \" + resourcesCount,\n                resourcesCount > 3\n        );\n        \n        // Ensure everything that should do, did use it\n        // - Parsers\n        assertNotNull(resources.get(\"META-INF/services/org.apache.tika.parser.Parser\"));\n        // - Detectors\n        assertNotNull(resources.get(\"META-INF/services/org.apache.tika.detect.Detector\"));\n        // - Built-In Mimetypes\n        assertNotNull(resources.get(\"org/apache/tika/mime/tika-mimetypes.xml\"));\n        // - Custom Mimetypes\n        assertNotNull(resources.get(\"org/apache/tika/mime/custom-mimetypes.xml\"));\n    }",
        "error_msg": "org.apache.tika.config.TikaConfigTest::testClassLoaderUsedEverywhere --> junit.framework.AssertionFailedError: Not enough things used the classloader, found only 2",
        "clean_error_msg": "junit.framework.AssertionFailedError: Not enough things used the classloader, found only 2"
      }
    }
  },
  "JacksonDatatypeJoda-2": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/deser/DateTimeDeserializer.java",
        "start_loc": 31,
        "end_loc": 36,
        "buggy_function": "    @SuppressWarnings(\"unchecked\")\n    public static <T extends ReadableInstant> JsonDeserializer<T> forType(Class<T> cls)\n    {\n        return (JsonDeserializer<T>) new DateTimeDeserializer(cls,\n                FormatConfig.DEFAULT_DATETIME_FORMAT);\n    }",
        "fixed_function": "    @SuppressWarnings(\"unchecked\")\n    public static <T extends ReadableInstant> JsonDeserializer<T> forType(Class<T> cls)\n    {\n        return (JsonDeserializer<T>) new DateTimeDeserializer(cls,\n                FormatConfig.DEFAULT_DATETIME_PARSER);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/deser/IntervalDeserializer.java",
        "start_loc": 19,
        "end_loc": 22,
        "buggy_function": "    public IntervalDeserializer() {\n        // NOTE: not currently used, but must pass something\n        this(FormatConfig.DEFAULT_DATETIME_FORMAT);\n    }",
        "fixed_function": "    public IntervalDeserializer() {\n        // NOTE: not currently used, but must pass something\n        this(FormatConfig.DEFAULT_DATETIME_PARSER);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/ser/DateTimeSerializer.java",
        "start_loc": 18,
        "end_loc": 18,
        "buggy_function": "    public DateTimeSerializer() { this(FormatConfig.DEFAULT_DATETIME_FORMAT); }",
        "fixed_function": "    public DateTimeSerializer() { this(FormatConfig.DEFAULT_DATETIME_PRINTER); }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/ser/IntervalSerializer.java",
        "start_loc": 19,
        "end_loc": 19,
        "buggy_function": "    public IntervalSerializer() { this(FormatConfig.DEFAULT_DATETIME_FORMAT); }",
        "fixed_function": "    public IntervalSerializer() { this(FormatConfig.DEFAULT_DATETIME_PRINTER); }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.datatype.joda.DateTimeTest::testAsTextNoMilliseconds": {
        "path": "com/fasterxml/jackson/datatype/joda/DateTimeTest.java",
        "function_name": "testAsTextNoMilliseconds",
        "src": "public void testAsTextNoMilliseconds() throws Exception\n    {\n    \tDateTime value = MAPPER.readValue(quote(\"2015-07-27T08:11:07-07:00\"), DateTime.class);\n    \tassertNotNull(value);\n    }",
        "error_msg": "com.fasterxml.jackson.datatype.joda.DateTimeTest::testAsTextNoMilliseconds --> java.lang.IllegalArgumentException: Invalid format: 2015-07-27T08:11:07-07:00 is malformed at -07:00",
        "clean_error_msg": "java.lang.IllegalArgumentException: Invalid format: 2015-07-27T08:11:07-07:00 is malformed at -07:00"
      }
    }
  },
  "JacksonDatatypeJoda-3": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/cfg/JacksonJodaDateFormat.java",
        "start_loc": 119,
        "end_loc": 131,
        "buggy_function": "    public JacksonJodaDateFormat with(JsonFormat.Value ann) {\n        JacksonJodaDateFormat format = this;\n        format = format.withLocale(ann.getLocale());\n        format = format.withTimeZone(ann.getTimeZone());\n        format = format.withFormat(ann.getPattern().trim());\n        Boolean adjustTZ = ann.getFeature(JsonFormat.Feature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);\n        Boolean writeZoneId = ann.getFeature(JsonFormat.Feature.WRITE_DATES_WITH_ZONE_ID);\n        if ((adjustTZ != _adjustToContextTZOverride)\n                || (writeZoneId != _writeZoneId)) {\n            format = new JacksonJodaDateFormat(format, adjustTZ, writeZoneId);\n        }\n        return format;\n    }",
        "fixed_function": "    public JacksonJodaDateFormat with(JsonFormat.Value ann) {\n        JacksonJodaDateFormat format = this;\n        format = format.withLocale(ann.getLocale());\n        format = format.withTimeZone(ann.getTimeZone());\n        format = format.withFormat(ann.getPattern());\n        Boolean adjustTZ = ann.getFeature(JsonFormat.Feature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);\n        Boolean writeZoneId = ann.getFeature(JsonFormat.Feature.WRITE_DATES_WITH_ZONE_ID);\n        if ((adjustTZ != _adjustToContextTZOverride)\n                || (writeZoneId != _writeZoneId)) {\n            format = new JacksonJodaDateFormat(format, adjustTZ, writeZoneId);\n        }\n        return format;\n    }",
        "comment": "/*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */"
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/joda/ser/PeriodSerializer.java",
        "start_loc": 48,
        "end_loc": 83,
        "buggy_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value ann = findFormatOverrides(prov, property, handledType());\n            if (ann != null) {\n                JacksonJodaPeriodFormat format = _format;\n\n                Boolean useTimestamp;\n\n                // Simple case first: serialize as numeric timestamp?\n                if (ann.getShape().isNumeric()) {\n                    useTimestamp = Boolean.TRUE;\n                } else if (ann.getShape() == JsonFormat.Shape.STRING) {\n                    useTimestamp = Boolean.FALSE;\n                } else if (ann.getShape() == JsonFormat.Shape.ARRAY) {\n                    // 17-Nov-2014, tatu: also, arrays typically contain non-string representation\n                    useTimestamp = Boolean.TRUE;\n                } else  {\n                    useTimestamp = null;\n                }\n                // must not call if flag defined, to rely on defaults:\n                if (useTimestamp != null) {\n                    format = format.withUseTimestamp(useTimestamp);\n                }\n                // for others, safe to call, null/empty just ignored\n                format = format.withFormat(ann.getPattern().trim());\n                format = format.withLocale(ann.getLocale());\n                if (format != _format) {\n                    return new PeriodSerializer(format);\n                }\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value ann = findFormatOverrides(prov, property, handledType());\n            if (ann != null) {\n                JacksonJodaPeriodFormat format = _format;\n\n                Boolean useTimestamp;\n\n                // Simple case first: serialize as numeric timestamp?\n                if (ann.getShape().isNumeric()) {\n                    useTimestamp = Boolean.TRUE;\n                } else if (ann.getShape() == JsonFormat.Shape.STRING) {\n                    useTimestamp = Boolean.FALSE;\n                } else if (ann.getShape() == JsonFormat.Shape.ARRAY) {\n                    // 17-Nov-2014, tatu: also, arrays typically contain non-string representation\n                    useTimestamp = Boolean.TRUE;\n                } else  {\n                    useTimestamp = null;\n                }\n                // must not call if flag defined, to rely on defaults:\n                if (useTimestamp != null) {\n                    format = format.withUseTimestamp(useTimestamp);\n                }\n                // for others, safe to call, null/empty just ignored\n                format = format.withFormat(ann.getPattern());\n                format = format.withLocale(ann.getLocale());\n                if (format != _format) {\n                    return new PeriodSerializer(format);\n                }\n            }\n        }\n        return this;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.datatype.joda.DateTimeTest::testWithoutLeniency": {
        "path": "com/fasterxml/jackson/datatype/joda/DateTimeTest.java",
        "function_name": "testWithoutLeniency",
        "src": "public void testWithoutLeniency() throws Exception\n    {\n        ObjectMapper mapper = mapperWithModuleBuilder()\n                .defaultLeniency(false)\n                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                .build();\n        String json = mapper.writeValueAsString(DATE_JAN_1_1970_UTC);\n        assertEquals(quote(\"1970-01-01T00:00:00.000Z\"), json);\n    }",
        "error_msg": "com.fasterxml.jackson.datatype.joda.DateTimeTest::testWithoutLeniency --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "JacksonDatatypeJsr310-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java",
        "start_loc": 29,
        "end_loc": 53,
        "buggy_function": "    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n            if (format != null) {\n                if (format.hasPattern()) {\n                    final String pattern = format.getPattern();\n                    final Locale locale = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    DateTimeFormatter df;\n                    if (locale == null) {\n                        df = DateTimeFormatter.ofPattern(pattern);\n                    } else {\n                        df = DateTimeFormatter.ofPattern(pattern, locale);\n                    }\n                    //Issue #69: For instant serializers/deserializers we need to configure the formatter with\n                    //a time zone picked up from JsonFormat annotation, otherwise serialization might not work\n                    return withDateFormat(df);\n                }\n                // any use for TimeZone?\n            }\n        }\n        return this;\n   }",
        "fixed_function": "    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n            if (format != null) {\n                if (format.hasPattern()) {\n                    final String pattern = format.getPattern();\n                    final Locale locale = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    DateTimeFormatter df;\n                    if (locale == null) {\n                        df = DateTimeFormatter.ofPattern(pattern);\n                    } else {\n                        df = DateTimeFormatter.ofPattern(pattern, locale);\n                    }\n                    //Issue #69: For instant serializers/deserializers we need to configure the formatter with\n                    //a time zone picked up from JsonFormat annotation, otherwise serialization might not work\n                    if (format.hasTimeZone()) {\n                        df = df.withZone(format.getTimeZone().toZoneId());\n                    }\n                    return withDateFormat(df);\n                }\n                // any use for TimeZone?\n            }\n        }\n        return this;\n   }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/JSR310FormattedSerializerBase.java",
        "start_loc": 87,
        "end_loc": 123,
        "buggy_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n                Boolean useTimestamp = null;\n\n               // Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape == JsonFormat.Shape.ARRAY || shape.isNumeric() ) {\n                    useTimestamp = Boolean.TRUE;\n                } else {\n                    useTimestamp = (shape == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;\n                }\n                DateTimeFormatter dtf = _formatter;\n\n                // If not, do we have a pattern?\n                if (format.hasPattern()) {\n                    final String pattern = format.getPattern();\n                    final Locale locale = format.hasLocale() ? format.getLocale() : prov.getLocale();\n                    if (locale == null) {\n                        dtf = DateTimeFormatter.ofPattern(pattern);\n                    } else {\n                        dtf = DateTimeFormatter.ofPattern(pattern, locale);\n                    }\n                    //Issue #69: For instant serializers/deserializers we need to configure the formatter with\n                    //a time zone picked up from JsonFormat annotation, otherwise serialization might not work\n                }\n                if (useTimestamp != _useTimestamp || dtf != _formatter) {\n                    return withFormat(useTimestamp, dtf);\n                }\n            }\n        }\n        return this;\n    }",
        "fixed_function": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n                Boolean useTimestamp = null;\n\n               // Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape == JsonFormat.Shape.ARRAY || shape.isNumeric() ) {\n                    useTimestamp = Boolean.TRUE;\n                } else {\n                    useTimestamp = (shape == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;\n                }\n                DateTimeFormatter dtf = _formatter;\n\n                // If not, do we have a pattern?\n                if (format.hasPattern()) {\n                    final String pattern = format.getPattern();\n                    final Locale locale = format.hasLocale() ? format.getLocale() : prov.getLocale();\n                    if (locale == null) {\n                        dtf = DateTimeFormatter.ofPattern(pattern);\n                    } else {\n                        dtf = DateTimeFormatter.ofPattern(pattern, locale);\n                    }\n                    //Issue #69: For instant serializers/deserializers we need to configure the formatter with\n                    //a time zone picked up from JsonFormat annotation, otherwise serialization might not work\n                    if (format.hasTimeZone()) {\n                        dtf = dtf.withZone(format.getTimeZone().toZoneId());\n                    }\n                }\n                if (useTimestamp != _useTimestamp || dtf != _formatter) {\n                    return withFormat(useTimestamp, dtf);\n                }\n            }\n        }\n        return this;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.fasterxml.jackson.datatype.jsr310.TestInstantSerialization::testCustomPatternWithAnnotations02": {
        "path": "com/fasterxml/jackson/datatype/jsr310/TestInstantSerialization.java",
        "function_name": "testCustomPatternWithAnnotations02",
        "src": "@Test\n    public void testCustomPatternWithAnnotations02() throws Exception\n    {\n        //Test date is pushed one year after start of the epoch just to avoid possible issues with UTC-X TZs which could\n        //push the instant before tha start of the epoch\n        final Instant instant = ZonedDateTime.ofInstant(Instant.ofEpochMilli(0), ZoneId.of(\"UTC\")).plusYears(1).toInstant();\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(CUSTOM_PATTERN);\n        final String valueInUTC = formatter.withZone(ZoneId.of(\"UTC\")).format(instant);\n\n        final WrapperWithCustomPattern input = new WrapperWithCustomPattern(instant);\n        String json = mapper.writeValueAsString(input);\n\n        assertTrue(\"Instant in UTC timezone was not serialized as expected.\", json.contains(aposToQuotes(\"'valueInUTC':'\" + valueInUTC + \"'\")));\n\n        WrapperWithCustomPattern result = mapper.readValue(json, WrapperWithCustomPattern.class);\n        assertEquals(\"Instant in UTC timezone was not deserialized as expected.\", input.valueInUTC, result.valueInUTC);\n    }",
        "error_msg": "com.fasterxml.jackson.datatype.jsr310.TestInstantSerialization::testCustomPatternWithAnnotations02 --> com.fasterxml.jackson.databind.JsonMappingException: Unsupported field: YearOfEra (through reference chain: com.fasterxml.jackson.datatype.jsr310.WrapperWithCustomPattern[valueInUTC])",
        "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Unsupported field: YearOfEra (through reference chain: com.fasterxml.jackson.datatype.jsr310.WrapperWithCustomPattern[valueInUTC])"
      }
    }
  },
  "Woodstox-2": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/ctc/wstx/evt/CompactStartElement.java",
        "start_loc": 76,
        "end_loc": 87,
        "buggy_function": "    @Override\n    public Attribute getAttributeByName(QName name)\n    {\n        if (mAttrs == null) {\n            return null;\n        }\n        int ix = mAttrs.findIndex(name);\n        if (ix < 0) {\n            return null;\n        }\n        return constructAttr(mRawAttrs, ix, !mAttrs.isDefault(ix));\n    }",
        "fixed_function": "    @Override\n    public Attribute getAttributeByName(QName name)\n    {\n        if (mAttrs == null) {\n            return null;\n        }\n        int ix = mAttrs.findIndex(name);\n        if (ix < 0) {\n            return null;\n        }\n        return constructAttr(mRawAttrs, ix, mAttrs.isDefault(ix));\n    }",
        "comment": "/*\n    ////////////////////////////////////////////////////////////\n    // StartElement implementation\n    ////////////////////////////////////////////////////////////\n     */"
      },
      {
        "path": "src/main/java/com/ctc/wstx/evt/CompactStartElement.java",
        "start_loc": 158,
        "end_loc": 162,
        "buggy_function": "    public Attribute constructAttr(String[] raw, int rawIndex, boolean isDef)\n    {\n        return new AttributeEventImpl(getLocation(), raw[rawIndex], raw[rawIndex+1],\n                raw[rawIndex+2], raw[rawIndex+3], isDef);\n    }",
        "fixed_function": "    protected Attribute constructAttr(String[] raw, int rawIndex, boolean isDef)\n    {\n        return new AttributeEventImpl(getLocation(), raw[rawIndex], raw[rawIndex+1],\n                raw[rawIndex+2], raw[rawIndex+3], !isDef);\n    }",
        "comment": "/*\n    ////////////////////////////////////////////////////////////\n    // Internal methods\n    ////////////////////////////////////////////////////////////\n     */"
      },
      {
        "path": "src/main/java/com/ctc/wstx/evt/DefaultEventAllocator.java",
        "start_loc": 283,
        "end_loc": 289,
        "buggy_function": "    @Override\n    public Object withStartElement(Location loc, QName name,\n                                   BaseNsContext nsCtxt, ElemAttrs attrs,\n                                   boolean wasEmpty)\n    {\n        return new CompactStartElement(loc, name, nsCtxt, attrs);\n    }",
        "fixed_function": "    @Override\n    public Object withStartElement(Location loc, QName name,\n            BaseNsContext nsCtxt, ElemAttrs attrs, boolean wasEmpty)\n    {\n        return new CompactStartElement(loc, name, nsCtxt, attrs);\n    }",
        "comment": "/*\n    ///////////////////////////////////////////////////////////\n    // ElemCallback implementation\n    ///////////////////////////////////////////////////////////\n     */"
      }
    ],
    "trigger_test": {
      "stax2.evt.TestStartElementEvent::testIsDefaultAttr": {
        "path": "stax2/evt/TestStartElementEvent.java",
        "function_name": "testIsDefaultAttr",
        "src": "public void testIsDefaultAttr() throws Exception\n    {\n        String DOC = \"<a b='c'></a>\";\n        XMLStreamReader stream = XML_F.createXMLStreamReader(new StringReader(DOC));\n        DefaultEventAllocator allocator = DefaultEventAllocator.getDefaultInstance();\n        XMLEventFactory eventFactory = getNewEventFactory();\n\n        assertTokenType(START_ELEMENT, stream.next());\n        XMLEvent event = allocator.allocate(stream);\n        assertTrue(event.isStartElement());\n\n        StartElement startOrig = event.asStartElement();\n        Attribute attr = startOrig.getAttributeByName(new QName(\"b\"));\n        assertNotNull(attr);\n        assertTrue(attr.isSpecified());\n        StartElement startAlloc = eventFactory.createStartElement(startOrig.getName(),\n                startOrig.getAttributes(), startOrig.getNamespaces());\n\n        attr = startAlloc.getAttributeByName(new QName(\"b\"));\n        assertNotNull(attr);\n        assertTrue(attr.isSpecified());\n    }",
        "error_msg": "stax2.evt.TestStartElementEvent::testIsDefaultAttr --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Woodstox-6": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/ctc/wstx/sr/AttributeCollector.java",
        "start_loc": 204,
        "end_loc": 217,
        "buggy_function": "    protected AttributeCollector(ReaderConfig cfg, boolean nsAware)\n    {\n        mXmlIdAttrIndex = cfg.willDoXmlIdTyping() ? XMLID_IX_NONE : XMLID_IX_DISABLED;\n        if (nsAware) {\n            mXmlIdPrefix = \"xml\";\n            mXmlIdLocalName = \"id\";\n        } else {\n            mXmlIdPrefix = null;\n            mXmlIdLocalName = \"xml:id\";\n        }\n        mMaxAttributesPerElement = cfg.getMaxAttributesPerElement();\n//        mMaxAttributeSize = cfg.getMaxAttributeSize();\n        mMaxAttributeSize = cfg.getMaxAttributeSize();\n    }",
        "fixed_function": "    protected AttributeCollector(ReaderConfig cfg, boolean nsAware)\n    {\n        mXmlIdAttrIndex = cfg.willDoXmlIdTyping() ? XMLID_IX_NONE : XMLID_IX_DISABLED;\n        if (nsAware) {\n            mXmlIdPrefix = \"xml\";\n            mXmlIdLocalName = \"id\";\n        } else {\n            mXmlIdPrefix = null;\n            mXmlIdLocalName = \"xml:id\";\n        }\n        mMaxAttributesPerElement = cfg.getMaxAttributesPerElement();\n//        mMaxAttributeSize = cfg.getMaxAttributeSize();\n    }",
        "comment": "/*\n    ///////////////////////////////////////////////\n    // Life-cycle:\n    ///////////////////////////////////////////////\n     */"
      },
      {
        "path": "src/main/java/com/ctc/wstx/sr/BasicStreamReader.java",
        "start_loc": 1963,
        "end_loc": 2046,
        "buggy_function": "    private final void parseAttrValue(char openingQuote, TextBuilder tb)\n        throws XMLStreamException\n    {\n        char[] outBuf = tb.getCharBuffer();\n        int outPtr = tb.getCharSize();\n        // important! Underlying buffer may be shared, does not necessarily start from 0\n        final int startingOffset = outPtr;\n        final int maxAttrSize = mConfig.getMaxAttributeSize();\n        int outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);\n        final WstxInputSource currScope = mInput;\n\n        while (true) {\n            char c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]\n                : getNextChar(SUFFIX_IN_ATTR_VALUE);\n            // Let's do a quick for most attribute content chars:\n            if (c <= '\\'') {\n                if (c < CHAR_SPACE) {\n                    if (c == '\\n') {\n                        markLF();\n                    } else if (c == '\\r') {\n                        // 04-Mar-2006, TSa: Linefeed normalization only done if enabled -\n                        //   specifically, 2-char lfs from int. entities are not coalesced.\n                        //   Now... whether to try to count them as one or not... easier not to;\n                        //   esp. since we may not be able to distinguish char entity originated ones\n                        //   from real ones.\n                        if (mNormalizeLFs) {\n                            c = getNextChar(SUFFIX_IN_ATTR_VALUE);\n                            if (c != '\\n') { // nope, not 2-char lf (Mac?)\n                                --mInputPtr;\n                            }\n                        }\n                        markLF();\n                    } else if (c != '\\t') {\n                        throwInvalidSpace(c);\n                    }\n                    // Whatever it was, it'll be 'normal' space now.\n                    c = CHAR_SPACE;\n                } else if (c == openingQuote) {\n                    // 06-Aug-2004, TSa: Can get these via entities; only \"real\" end quotes in same\n                    //    scope count. Note, too, that since  this will only be done at root level,\n                    //    there's no need  to check for \"runaway\" values; they'll hit EOF\n                    if (mInput == currScope) {\n                        break;\n                    }\n                } else if (c == '&') { // an entity of some sort...\n                    int ch;\n                    if (inputInBuffer() >= 3\n                        && (ch = resolveSimpleEntity(true)) != 0) {\n                        // Ok, fine, c is whatever it is\n                        ;\n                    } else { // full entity just changes buffer...\n                        ch = fullyResolveEntity(false);\n                        if (ch == 0) {\n                            // need to skip output, thusly (expanded to new input source)\n                            continue;\n                        }\n                    }\n                    if (ch <= 0xFFFF) {\n                        c = (char) ch;\n                    } else {\n                        ch -= 0x10000;\n                        if (outPtr >= outLimit) {\n                            outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);\n                            outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);\n                        }\n                        outBuf[outPtr++] = (char) ((ch >> 10)  + 0xD800);\n                        c = (char) ((ch & 0x3FF)  + 0xDC00);\n                    }\n                }\n            } else if (c == '<') {\n                throwUnexpectedChar(c, SUFFIX_IN_ATTR_VALUE);\n            }\n\n            // Ok, let's just add char in, whatever it was\n            if (outPtr >= outLimit) {\n                outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);\n                outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);\n            }\n            outBuf[outPtr++] = c;\n        }\n\n        // Fine; let's tell TextBuild we're done:\n        tb.setBufferSize(outPtr);\n    }",
        "fixed_function": "    private final void parseAttrValue(char openingQuote, TextBuilder tb)\n        throws XMLStreamException\n    {\n        char[] outBuf = tb.getCharBuffer();\n        int outPtr = tb.getCharSize();\n        // important! Underlying buffer may be shared, does not necessarily start from 0\n        final int startingOffset = outPtr;\n        final int maxAttrSize = mConfig.getMaxAttributeSize();\n        int outLimit = _outputLimit(outBuf, startingOffset, maxAttrSize);\n        final WstxInputSource currScope = mInput;\n\n        while (true) {\n            char c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]\n                : getNextChar(SUFFIX_IN_ATTR_VALUE);\n            // Let's do a quick for most attribute content chars:\n            if (c <= '\\'') {\n                if (c < CHAR_SPACE) {\n                    if (c == '\\n') {\n                        markLF();\n                    } else if (c == '\\r') {\n                        // 04-Mar-2006, TSa: Linefeed normalization only done if enabled -\n                        //   specifically, 2-char lfs from int. entities are not coalesced.\n                        //   Now... whether to try to count them as one or not... easier not to;\n                        //   esp. since we may not be able to distinguish char entity originated ones\n                        //   from real ones.\n                        if (mNormalizeLFs) {\n                            c = getNextChar(SUFFIX_IN_ATTR_VALUE);\n                            if (c != '\\n') { // nope, not 2-char lf (Mac?)\n                                --mInputPtr;\n                            }\n                        }\n                        markLF();\n                    } else if (c != '\\t') {\n                        throwInvalidSpace(c);\n                    }\n                    // Whatever it was, it'll be 'normal' space now.\n                    c = CHAR_SPACE;\n                } else if (c == openingQuote) {\n                    // 06-Aug-2004, TSa: Can get these via entities; only \"real\" end quotes in same\n                    //    scope count. Note, too, that since  this will only be done at root level,\n                    //    there's no need  to check for \"runaway\" values; they'll hit EOF\n                    if (mInput == currScope) {\n                        break;\n                    }\n                } else if (c == '&') { // an entity of some sort...\n                    int ch;\n                    if (inputInBuffer() >= 3\n                        && (ch = resolveSimpleEntity(true)) != 0) {\n                        // Ok, fine, c is whatever it is\n                        ;\n                    } else { // full entity just changes buffer...\n                        ch = fullyResolveEntity(false);\n                        if (ch == 0) {\n                            // need to skip output, thusly (expanded to new input source)\n                            continue;\n                        }\n                    }\n                    if (ch <= 0xFFFF) {\n                        c = (char) ch;\n                    } else {\n                        ch -= 0x10000;\n                        if (outPtr >= outLimit) {\n                            outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);\n                            outLimit = _outputLimit(outBuf, startingOffset, maxAttrSize);\n                        }\n                        outBuf[outPtr++] = (char) ((ch >> 10)  + 0xD800);\n                        c = (char) ((ch & 0x3FF)  + 0xDC00);\n                    }\n                }\n            } else if (c == '<') {\n                throwUnexpectedChar(c, SUFFIX_IN_ATTR_VALUE);\n            }\n\n            // Ok, let's just add char in, whatever it was\n            if (outPtr >= outLimit) {\n                outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);\n                outLimit = _outputLimit(outBuf, startingOffset, maxAttrSize);\n            }\n            outBuf[outPtr++] = c;\n        }\n\n        // Fine; let's tell TextBuild we're done:\n        tb.setBufferSize(outPtr);\n    }",
        "comment": "/**\n     * Method that will parse an attribute value enclosed in quotes, using\n     * an {@link TextBuilder} instance. Will normalize white space inside\n     * attribute value using default XML rules (change linefeeds to spaces\n     * etc.; but won't use DTD information for further coalescing).\n     *\n     * @param openingQuote Quote character (single or double quote) for\n     *   this attribute value\n     * @param tb TextBuilder into which attribute value will be added\n     */"
      },
      {
        "path": "src/main/java/com/ctc/wstx/sr/BasicStreamReader.java",
        "start_loc": 2050,
        "end_loc": 2062,
        "buggy_function": "    private final char[] _checkAttributeLimit(TextBuilder tb,\n            char[] outBuf, int outPtr, int currAttrSize, int maxAttrSize)\n        throws XMLStreamException\n    {\n        // Add +1 since we are at point where we are to append (at least) one more character\n        verifyLimit(\"Maximum attribute size\", maxAttrSize , currAttrSize+1);\n        // just sanity check\n        if (outPtr < outBuf.length) {\n            ExceptionUtil.throwInternal(\"Expected either attr limit (\"+maxAttrSize\n                    +\") >= currAttrSize (\"+currAttrSize+\") OR >= outBuf.length (\"+outBuf.length+\")\");\n        }\n        return tb.bufferFull(1);\n    }",
        "fixed_function": "    private final int _outputLimit(char[] outBuf, int offset, int maxAttrLen) {\n        // [woodstox-core#122]: make sure \"offset + max-size\" does not overflow:\n        return Math.min(outBuf.length, Math.max(maxAttrLen, offset+maxAttrLen));\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "wstxtest.stream.TestAttributeLimits::testMaxAttrMaxIntValue": {
        "path": "wstxtest/stream/TestAttributeLimits.java",
        "function_name": "testMaxAttrMaxIntValue",
        "src": "public void testMaxAttrMaxIntValue() throws Exception\n    {\n        XMLInputFactory factory = getNewInputFactory();\n        factory.setProperty(WstxInputProperties.P_MAX_ATTRIBUTE_SIZE, Integer.MAX_VALUE);\n\n        // First: ok document\n        XMLStreamReader r = factory.createXMLStreamReader(new StringReader(\n                \"<root attr='1234' other='ab' x='foobar' />\"));\n        assertTokenType(START_ELEMENT, r.next());\n        assertEquals(3, r.getAttributeCount());\n        assertEquals(\"foobar\", r.getAttributeValue(2));\n        assertTokenType(END_ELEMENT, r.next());\n        r.close();\n    }",
        "error_msg": "wstxtest.stream.TestAttributeLimits::testMaxAttrMaxIntValue --> java.lang.RuntimeException: Internal error: Expected either attr limit (2147483647) >= currAttrSize (0) OR >= outBuf.length (120)",
        "clean_error_msg": "java.lang.RuntimeException: Internal error: Expected either attr limit (2147483647) >= currAttrSize (0) OR >= outBuf.length (120)"
      }
    }
  },
  "Johnzon_mapper-4": {
    "function_num": 3,
    "functions": [
      {
        "path": "/src/main/java/org/apache/johnzon/mapper/Mapper.java",
        "start_loc": 311,
        "end_loc": 333,
        "buggy_function": "    private JsonGenerator doWriteObject(final JsonGenerator generator, final Object object) {\n        try {\n            JsonGenerator gen = generator;\n            if (object == null) {\n                return generator;\n            }\n\n            if (Map.class.isInstance(object)) {\n                gen = gen.writeStartObject();\n                gen = writeMapBody((Map<?, ?>) object, gen);\n                gen = gen.writeEnd();\n                return gen;\n            }\n\n            gen = gen.writeStartObject();\n            gen = doWriteObjectBody(gen, object);\n            return gen.writeEnd();\n        } catch (final InvocationTargetException e) {\n            throw new MapperException(e);\n        } catch (final IllegalAccessException e) {\n            throw new MapperException(e);\n        }\n    }",
        "fixed_function": "    private JsonGenerator doWriteObject(final JsonGenerator generator, final Object object) {\n        try {\n            JsonGenerator gen = generator;\n            if (object == null) {\n                return generator;\n            }\n\n            if (Map.class.isInstance(object)) {\n                gen = gen.writeStartObject();\n                gen = writeMapBody((Map<?, ?>) object, gen, null);\n                gen = gen.writeEnd();\n                return gen;\n            }\n\n            gen = gen.writeStartObject();\n            gen = doWriteObjectBody(gen, object);\n            return gen.writeEnd();\n        } catch (final InvocationTargetException e) {\n            throw new MapperException(e);\n        } catch (final IllegalAccessException e) {\n            throw new MapperException(e);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/johnzon/mapper/Mapper.java",
        "start_loc": 371,
        "end_loc": 397,
        "buggy_function": "    private JsonGenerator writeMapBody(final Map<?, ?> object, final JsonGenerator gen) throws InvocationTargetException, IllegalAccessException {\n        JsonGenerator generator = gen;\n        for (final Map.Entry<?, ?> entry : ((Map<?, ?>) object).entrySet()) {\n            final Object value = entry.getValue();\n            final Object key = entry.getKey();\n\n            if (value == null) {\n                if (skipNull) {\n                    continue;\n                } else {\n                    gen.writeNull(key == null ? \"null\" : key.toString());\n                    continue;\n                }\n            }\n\n            final Class<?> valueClass = value.getClass();\n            final boolean primitive = Mappings.isPrimitive(valueClass);\n            final boolean clazz = mappings.getClassMapping(valueClass) != null;\n            final boolean array = clazz || primitive ? false : valueClass.isArray();\n            final boolean collection = clazz || primitive || array ? false : Collection.class.isAssignableFrom(valueClass);\n            final boolean map = clazz || primitive || array || collection ? false : Map.class.isAssignableFrom(valueClass);\n            generator = writeValue(generator, valueClass,\n                    primitive, array, collection, map, null /* TODO? */,\n                    key == null ? \"null\" : key.toString(), value);\n        }\n        return generator;\n    }",
        "fixed_function": "    private JsonGenerator writeMapBody(final Map<?, ?> object, final JsonGenerator gen, final Converter itemConverter) throws InvocationTargetException, IllegalAccessException {\n        JsonGenerator generator = gen;\n        for (final Map.Entry<?, ?> entry : ((Map<?, ?>) object).entrySet()) {\n            final Object value = entry.getValue();\n            final Object key = entry.getKey();\n\n            if (value == null) {\n                if (skipNull) {\n                    continue;\n                } else {\n                    gen.writeNull(key == null ? \"null\" : key.toString());\n                    continue;\n                }\n            }\n\n            final Class<?> valueClass = value.getClass();\n            final boolean primitive = Mappings.isPrimitive(valueClass);\n            final boolean clazz = mappings.getClassMapping(valueClass) != null;\n            final boolean array = clazz || primitive ? false : valueClass.isArray();\n            final boolean collection = clazz || primitive || array ? false : Collection.class.isAssignableFrom(valueClass);\n            final boolean map = clazz || primitive || array || collection ? false : Map.class.isAssignableFrom(valueClass);\n            generator = writeValue(generator, valueClass,\n                    primitive, array, collection, map, itemConverter,\n                    key == null ? \"null\" : key.toString(), value);\n        }\n        return generator;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/johnzon/mapper/Mapper.java",
        "start_loc": 399,
        "end_loc": 442,
        "buggy_function": "    private JsonGenerator writeValue(final JsonGenerator generator, final Class<?> type,\n                                     final boolean primitive, final boolean array,\n                                     final boolean collection, final boolean map,\n                                     final Converter itemConverter,\n                                     final String key, final Object value) throws InvocationTargetException, IllegalAccessException {\n        if (array) {\n            final int length = Array.getLength(value);\n            if (length == 0 && skipEmptyArray) {\n                return generator;\n            }\n            \n            if(treatByteArrayAsBase64 && (type == byte[].class /*|| type == Byte[].class*/)) {\n                String base64EncodedByteArray = DatatypeConverter.printBase64Binary((byte[]) value);\n                generator.write(key, base64EncodedByteArray);\n                return generator;\n            }\n\n            JsonGenerator gen = generator.writeStartArray(key);\n            for (int i = 0; i < length; i++) {\n                final Object o = Array.get(value, i);\n                gen = writeItem(gen, itemConverter != null ? itemConverter.toString(o) : o);\n            }\n            return gen.writeEnd();\n        } else if (collection) {\n            JsonGenerator gen = generator.writeStartArray(key);\n            for (final Object o : Collection.class.cast(value)) {\n                gen = writeItem(gen, itemConverter != null ? itemConverter.toString(o) : o);\n            }\n            return gen.writeEnd();\n        } else if (map) {\n            JsonGenerator gen = generator.writeStartObject(key);\n            gen = writeMapBody((Map<?, ?>) value, gen);\n            return gen.writeEnd();\n        } else if (primitive) {\n            return writePrimitives(generator, key, type, value);\n        } else {\n            final Converter<?> converter = findConverter(type);\n            if (converter != null) {\n                return writeValue(generator, String.class, true, false, false, false, null, key,\n                        doConvertFrom(value, (Converter<Object>) converter));\n            }\n            return doWriteObjectBody(generator.writeStartObject(key), value).writeEnd();\n        }\n    }",
        "fixed_function": "    private JsonGenerator writeValue(final JsonGenerator generator, final Class<?> type,\n                                     final boolean primitive, final boolean array,\n                                     final boolean collection, final boolean map,\n                                     final Converter itemConverter,\n                                     final String key, final Object value) throws InvocationTargetException, IllegalAccessException {\n        if (array) {\n            final int length = Array.getLength(value);\n            if (length == 0 && skipEmptyArray) {\n                return generator;\n            }\n            \n            if(treatByteArrayAsBase64 && (type == byte[].class /*|| type == Byte[].class*/)) {\n                String base64EncodedByteArray = DatatypeConverter.printBase64Binary((byte[]) value);\n                generator.write(key, base64EncodedByteArray);\n                return generator;\n            }\n\n            JsonGenerator gen = generator.writeStartArray(key);\n            for (int i = 0; i < length; i++) {\n                final Object o = Array.get(value, i);\n                gen = writeItem(gen, itemConverter != null ? itemConverter.toString(o) : o);\n            }\n            return gen.writeEnd();\n        } else if (collection) {\n            JsonGenerator gen = generator.writeStartArray(key);\n            for (final Object o : Collection.class.cast(value)) {\n                gen = writeItem(gen, itemConverter != null ? itemConverter.toString(o) : o);\n            }\n            return gen.writeEnd();\n        } else if (map) {\n            JsonGenerator gen = generator.writeStartObject(key);\n            gen = writeMapBody((Map<?, ?>) value, gen, itemConverter);\n            return gen.writeEnd();\n        } else if (primitive) {\n            return writePrimitives(generator, key, type, value);\n        } else {\n            final Converter<?> converter = findConverter(type);\n            if (converter != null) {\n                return writeValue(generator, String.class, true, false, false, false, null, key,\n                        doConvertFrom(value, (Converter<Object>) converter));\n            }\n            return doWriteObjectBody(generator.writeStartObject(key), value).writeEnd();\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.johnzon.mapper.ObjectConverterTest::testObjectConverter": {
        "path": "org/apache/johnzon/mapper/ObjectConverterTest.java",
        "function_name": "testObjectConverter",
        "src": "@Test\n    public void testObjectConverter() {\n        Contact contact = new Contact();\n        contact.linkedPersons.addAll(Arrays.asList(new Person(\"f1\", \"l1\"), new Person(\"f2\", \"l2\")));\n        contact.linkedPersonsArray = new Person[] { new Person(\"f3\", \"l3\"), new Person(\"f4\", \"l4\") };\n        contact.personMap.put(\"cinq\", new Person(\"f5\", \"l5\"));\n        contact.personMap.put(\"six\", new Person(\"f6\", \"l6\"));\n\n        MapperBuilder mapperBuilder = new MapperBuilder();\n        mapperBuilder.addConverter(Person.class, new PersonConverter());\n        Mapper mapper = mapperBuilder.setAccessModeName(\"both\").setAttributeOrder(new Comparator<String>() {\n            @Override\n            public int compare(final String o1, final String o2) {\n                return o1.compareTo(o2);\n            }\n        }).build();\n\n        String s = mapper.writeObjectAsString(contact);\n        Contact c = mapper.readObject(s, Contact.class);\n        String expected = \"{\\\"linkedPersons\\\":[\\\"f1|l1\\\",\\\"f2|l2\\\"],\\\"linkedPersonsArray\\\":[\\\"f3|l3\\\",\\\"f4|l4\\\"],\\\"personMap\\\":{\\\"six\\\":\\\"f6|l6\\\",\\\"cinq\\\":\\\"f5|l5\\\"}}\";\n        Assert.assertEquals(expected, s);\n        Assert.assertEquals(contact, c);\n    }",
        "error_msg": "org.apache.johnzon.mapper.ObjectConverterTest::testObjectConverter --> org.apache.johnzon.mapper.MapperException: No mapping for java.util.HashMap",
        "clean_error_msg": "org.apache.johnzon.mapper.MapperException: No mapping for java.util.HashMap"
      }
    }
  },
  "Jandex-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jboss/jandex/DotName.java",
        "start_loc": 118,
        "end_loc": 120,
        "buggy_function": "    public boolean isComponentized() {\n        return !componentized;\n    }",
        "fixed_function": "    public boolean isComponentized() {\n        return componentized;\n    }",
        "comment": "/**\n     * Returns whether this DotName is a componentized variant.\n     *\n     * @return true if it is componentized, false if it is a simple DotName\n     */"
      },
      {
        "path": "src/main/java/org/jboss/jandex/IndexWriter.java",
        "start_loc": 119,
        "end_loc": 136,
        "buggy_function": "    private void writeClassTable(PackedDataOutputStream stream) throws IOException {\n        stream.writePackedU32(classTable.size());\n\n        // Zero is reserved for null\n        int pos = 1;\n        for (Map.Entry<DotName, Integer> entry : classTable.entrySet()) {\n            entry.setValue(pos++);\n            DotName name = entry.getKey();\n            assert !name.isComponentized();\n\n            int nameDepth = 0;\n            for (DotName prefix = name.prefix(); prefix != null; prefix = prefix.prefix())\n                nameDepth++;\n\n            stream.writePackedU32(nameDepth);\n            stream.writeUTF(name.local());\n        }\n    }",
        "fixed_function": "    private void writeClassTable(PackedDataOutputStream stream) throws IOException {\n        stream.writePackedU32(classTable.size());\n\n        // Zero is reserved for null\n        int pos = 1;\n        for (Map.Entry<DotName, Integer> entry : classTable.entrySet()) {\n            entry.setValue(pos++);\n            DotName name = entry.getKey();\n            assert name.isComponentized();\n\n            int nameDepth = 0;\n            for (DotName prefix = name.prefix(); prefix != null; prefix = prefix.prefix())\n                nameDepth++;\n\n            stream.writePackedU32(nameDepth);\n            stream.writeUTF(name.local());\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jboss.jandex.test.DotNameTestCase::testIsComponentized": {
        "path": "org/jboss/jandex/test/DotNameTestCase.java",
        "function_name": "testIsComponentized",
        "src": "@Test\n    public void testIsComponentized() {\n        assertTrue(DotName.createComponentized(DotName.createComponentized(null, \"jboss\"), \"Foo\").isComponentized());\n        assertFalse(DotName.createSimple(\"org.jboss.Foo\").isComponentized());\n    }",
        "error_msg": "org.jboss.jandex.test.DotNameTestCase::testIsComponentized --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jandex-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jboss/jandex/DotName.java",
        "start_loc": 118,
        "end_loc": 120,
        "buggy_function": "    public boolean isComponentized() {\n        return !componentized;\n    }",
        "fixed_function": "    public boolean isComponentized() {\n        return componentized;\n    }",
        "comment": "/**\n     * Returns whether this DotName is a componentized variant.\n     *\n     * @return true if it is componentized, false if it is a simple DotName\n     */"
      },
      {
        "path": "src/main/java/org/jboss/jandex/IndexWriter.java",
        "start_loc": 119,
        "end_loc": 136,
        "buggy_function": "    private void writeClassTable(PackedDataOutputStream stream) throws IOException {\n        stream.writePackedU32(classTable.size());\n\n        // Zero is reserved for null\n        int pos = 1;\n        for (Map.Entry<DotName, Integer> entry : classTable.entrySet()) {\n            entry.setValue(pos++);\n            DotName name = entry.getKey();\n            assert !name.isComponentized();\n\n            int nameDepth = 0;\n            for (DotName prefix = name.prefix(); prefix != null; prefix = prefix.prefix())\n                nameDepth++;\n\n            stream.writePackedU32(nameDepth);\n            stream.writeUTF(name.local());\n        }\n    }",
        "fixed_function": "    private void writeClassTable(PackedDataOutputStream stream) throws IOException {\n        stream.writePackedU32(classTable.size());\n\n        // Zero is reserved for null\n        int pos = 1;\n        for (Map.Entry<DotName, Integer> entry : classTable.entrySet()) {\n            entry.setValue(pos++);\n            DotName name = entry.getKey();\n            assert name.isComponentized();\n\n            int nameDepth = 0;\n            for (DotName prefix = name.prefix(); prefix != null; prefix = prefix.prefix())\n                nameDepth++;\n\n            stream.writePackedU32(nameDepth);\n            stream.writeUTF(name.local());\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jboss.jandex.test.DotNameTestCase::testIsComponentized": {
        "path": "org/jboss/jandex/test/DotNameTestCase.java",
        "function_name": "testIsComponentized",
        "src": "@Test\n    public void testIsComponentized() {\n        assertTrue(DotName.createComponentized(DotName.createComponentized(null, \"jboss\"), \"Foo\").isComponentized());\n        assertFalse(DotName.createSimple(\"org.jboss.Foo\").isComponentized());\n    }",
        "error_msg": "org.jboss.jandex.test.DotNameTestCase::testIsComponentized --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jandex-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jboss/jandex/ClassInfo.java",
        "start_loc": 588,
        "end_loc": 598,
        "buggy_function": "    void setEnclosingMethod(EnclosingMethodInfo enclosingMethod) {\n        if (enclosingMethod == null) {\n            return;\n        }\n\n        if (nestingInfo == null) {\n            nestingInfo = new NestingInfo();\n        }\n\n        nestingInfo.enclosingMethod = enclosingMethod;\n    }",
        "fixed_function": "    void setFlags(short flags) {\n        this.flags = flags;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jboss/jandex/Indexer.java",
        "start_loc": 335,
        "end_loc": 353,
        "buggy_function": "    private void processInnerClasses(DataInputStream data, ClassInfo target) throws IOException {\n        int numClasses = data.readUnsignedShort();\n        innerClasses = numClasses > 0 ? new HashMap<DotName, InnerClassInfo>(numClasses)\n                                      : Collections.<DotName, InnerClassInfo>emptyMap();\n        for (int i = 0; i < numClasses; i++) {\n            DotName innerClass = decodeClassEntry(data.readUnsignedShort());\n            int outerIndex = data.readUnsignedShort();\n            DotName outerClass = outerIndex == 0 ? null : decodeClassEntry(outerIndex);\n            int simpleIndex = data.readUnsignedShort();\n            String simpleName = simpleIndex == 0 ? null : decodeUtf8Entry(simpleIndex);\n            int flags = data.readUnsignedShort();\n\n            if (innerClass.equals(target.name())) {\n                target.setInnerClassInfo(outerClass, simpleName);\n            }\n\n            innerClasses.put(innerClass, new InnerClassInfo(innerClass, outerClass, simpleName, flags));\n        }\n    }",
        "fixed_function": "    private void processInnerClasses(DataInputStream data, ClassInfo target) throws IOException {\n        int numClasses = data.readUnsignedShort();\n        innerClasses = numClasses > 0 ? new HashMap<DotName, InnerClassInfo>(numClasses)\n                                      : Collections.<DotName, InnerClassInfo>emptyMap();\n        for (int i = 0; i < numClasses; i++) {\n            DotName innerClass = decodeClassEntry(data.readUnsignedShort());\n            int outerIndex = data.readUnsignedShort();\n            DotName outerClass = outerIndex == 0 ? null : decodeClassEntry(outerIndex);\n            int simpleIndex = data.readUnsignedShort();\n            String simpleName = simpleIndex == 0 ? null : decodeUtf8Entry(simpleIndex);\n            int flags = data.readUnsignedShort();\n\n            if (innerClass.equals(target.name())) {\n                target.setInnerClassInfo(outerClass, simpleName);\n                target.setFlags((short)flags);\n            }\n\n            innerClasses.put(innerClass, new InnerClassInfo(innerClass, outerClass, simpleName, flags));\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jboss.jandex.test.BasicTestCase::testStaticInner": {
        "path": "org/jboss/jandex/test/BasicTestCase.java",
        "function_name": "testStaticInner",
        "src": "@Test\n    public void testStaticInner() throws IOException {\n        assertFlagSet(NestedC.class, Modifier.STATIC, true);\n        assertInner(NestedC.class, true);\n\n        assertFlagSet(NestedD.class, Modifier.STATIC, false);\n        assertInner(NestedC.class, true);\n\n        assertInner(BasicTestCase.class, false);\n        assertFlagSet(BasicTestCase.class, Modifier.STATIC, false);\n    }",
        "error_msg": "org.jboss.jandex.test.BasicTestCase::testStaticInner --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jandex-5": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jboss/jandex/ClassInfo.java",
        "start_loc": 588,
        "end_loc": 598,
        "buggy_function": "    void setEnclosingMethod(EnclosingMethodInfo enclosingMethod) {\n        if (enclosingMethod == null) {\n            return;\n        }\n\n        if (nestingInfo == null) {\n            nestingInfo = new NestingInfo();\n        }\n\n        nestingInfo.enclosingMethod = enclosingMethod;\n    }",
        "fixed_function": "    void setFlags(short flags) {\n        this.flags = flags;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jboss/jandex/Indexer.java",
        "start_loc": 335,
        "end_loc": 353,
        "buggy_function": "    private void processInnerClasses(DataInputStream data, ClassInfo target) throws IOException {\n        int numClasses = data.readUnsignedShort();\n        innerClasses = numClasses > 0 ? new HashMap<DotName, InnerClassInfo>(numClasses)\n                                      : Collections.<DotName, InnerClassInfo>emptyMap();\n        for (int i = 0; i < numClasses; i++) {\n            DotName innerClass = decodeClassEntry(data.readUnsignedShort());\n            int outerIndex = data.readUnsignedShort();\n            DotName outerClass = outerIndex == 0 ? null : decodeClassEntry(outerIndex);\n            int simpleIndex = data.readUnsignedShort();\n            String simpleName = simpleIndex == 0 ? null : decodeUtf8Entry(simpleIndex);\n            int flags = data.readUnsignedShort();\n\n            if (innerClass.equals(target.name())) {\n                target.setInnerClassInfo(outerClass, simpleName);\n            }\n\n            innerClasses.put(innerClass, new InnerClassInfo(innerClass, outerClass, simpleName, flags));\n        }\n    }",
        "fixed_function": "    private void processInnerClasses(DataInputStream data, ClassInfo target) throws IOException {\n        int numClasses = data.readUnsignedShort();\n        innerClasses = numClasses > 0 ? new HashMap<DotName, InnerClassInfo>(numClasses)\n                                      : Collections.<DotName, InnerClassInfo>emptyMap();\n        for (int i = 0; i < numClasses; i++) {\n            DotName innerClass = decodeClassEntry(data.readUnsignedShort());\n            int outerIndex = data.readUnsignedShort();\n            DotName outerClass = outerIndex == 0 ? null : decodeClassEntry(outerIndex);\n            int simpleIndex = data.readUnsignedShort();\n            String simpleName = simpleIndex == 0 ? null : decodeUtf8Entry(simpleIndex);\n            int flags = data.readUnsignedShort();\n\n            if (innerClass.equals(target.name())) {\n                target.setInnerClassInfo(outerClass, simpleName);\n                target.setFlags((short)flags);\n            }\n\n            innerClasses.put(innerClass, new InnerClassInfo(innerClass, outerClass, simpleName, flags));\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.jboss.jandex.test.BasicTestCase::testStaticInner": {
        "path": "org/jboss/jandex/test/BasicTestCase.java",
        "function_name": "testStaticInner",
        "src": "@Test\n    public void testStaticInner() throws IOException {\n        assertFlagSet(NestedC.class, Modifier.STATIC, true);\n        assertInner(NestedC.class, true);\n\n        assertFlagSet(NestedD.class, Modifier.STATIC, false);\n        assertInner(NestedC.class, true);\n\n        assertInner(BasicTestCase.class, false);\n        assertFlagSet(BasicTestCase.class, Modifier.STATIC, false);\n    }",
        "error_msg": "org.jboss.jandex.test.BasicTestCase::testStaticInner --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jboss_modules-5": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/jboss/modules/LocalModuleFinder.java",
        "start_loc": 267,
        "end_loc": 324,
        "buggy_function": "    public Iterator<String> iterateModules(final String baseName, final boolean recursive) {\n        return new Iterator<String>() {\n            private final Iterator<File> rootIter = Arrays.asList(repoRoots).iterator();\n            private final Set<String> found = new HashSet<>();\n            private Path rootPath;\n            private Iterator<Path> pathIter;\n            private String next;\n\n            public boolean hasNext() {\n                while (next == null) {\n                    while (pathIter == null) {\n                        if (! rootIter.hasNext()) {\n                            return false;\n                        }\n                        Path path = rootIter.next().toPath();\n                        rootPath = path;\n                        if (baseName != null && ! baseName.isEmpty()) {\n                            path = path.resolve(PathUtils.basicModuleNameToPath(baseName));\n                        }\n                        try {\n                            pathIter = Files.walk(path, recursive ? Integer.MAX_VALUE : 1).filter(ITER_FILTER).iterator();\n                        } catch (IOException ignored) {\n                            pathIter = null;\n                            continue;\n                        }\n                    }\n                    if (pathIter.hasNext()) {\n                        final Path nextPath = pathIter.next();\n                        if (nextPath.getParent() == null) {\n                            continue;\n                        }\n                        try (InputStream stream = Files.newInputStream(nextPath)) {\n                            final ModuleSpec moduleSpec = ModuleXmlParser.parseModuleXml(ModuleXmlParser.ResourceRootFactory.getDefault(), nextPath.getParent().toString(), stream, nextPath.toString(), null, (String)null);\n                            this.next = moduleSpec.getName();\n                            if (found.add(this.next)) {\n                                return true;\n                            }\n                            this.next = null;\n                        } catch (IOException | ModuleLoadException e) {\n                            // ignore\n                        }\n                    } else {\n                        pathIter = null;\n                    }\n                }\n                return true;\n            }\n\n            public String next() {\n                if (! hasNext()) throw new NoSuchElementException();\n                try {\n                    return next;\n                } finally {\n                    next = null;\n                }\n            }\n        };\n    }",
        "fixed_function": "    public Iterator<String> iterateModules(final String baseName, final boolean recursive, final ModuleLoader delegateLoader) {\n        return new Iterator<String>() {\n            private final Iterator<File> rootIter = Arrays.asList(repoRoots).iterator();\n            private final Set<String> found = new HashSet<>();\n            private Path rootPath;\n            private Iterator<Path> pathIter;\n            private String next;\n\n            public boolean hasNext() {\n                while (next == null) {\n                    while (pathIter == null) {\n                        if (! rootIter.hasNext()) {\n                            return false;\n                        }\n                        Path path = rootIter.next().toPath();\n                        rootPath = path;\n                        if (baseName != null && ! baseName.isEmpty()) {\n                            path = path.resolve(PathUtils.basicModuleNameToPath(baseName));\n                        }\n                        try {\n                            pathIter = Files.walk(path, recursive ? Integer.MAX_VALUE : 1).filter(ITER_FILTER).iterator();\n                        } catch (IOException ignored) {\n                            pathIter = null;\n                            continue;\n                        }\n                    }\n                    if (pathIter.hasNext()) {\n                        final Path nextPath = pathIter.next();\n                        if (nextPath.getParent() == null) {\n                            continue;\n                        }\n                        try (InputStream stream = Files.newInputStream(nextPath)) {\n                            final ModuleSpec moduleSpec = ModuleXmlParser.parseModuleXml(ModuleXmlParser.ResourceRootFactory.getDefault(), nextPath.getParent().toString(), stream, nextPath.toString(), delegateLoader, (String)null);\n                            this.next = moduleSpec.getName();\n                            if (found.add(this.next)) {\n                                return true;\n                            }\n                            this.next = null;\n                        } catch (IOException | ModuleLoadException e) {\n                            // ignore\n                        }\n                    } else {\n                        pathIter = null;\n                    }\n                }\n                return true;\n            }\n\n            public String next() {\n                if (! hasNext()) throw new NoSuchElementException();\n                try {\n                    return next;\n                } finally {\n                    next = null;\n                }\n            }\n        };\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/jboss/modules/ModuleLoader.java",
        "start_loc": 327,
        "end_loc": 367,
        "buggy_function": "    public final Iterator<String> iterateModules(final String baseName, final boolean recursive) {\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(MODULE_ITERATE_PERM);\n        }\n        return new Iterator<String>() {\n            int idx;\n            Iterator<String> nested;\n\n            public boolean hasNext() {\n                for (;;) {\n                    while (nested == null) {\n                        if (idx == finders.length) {\n                            return false;\n                        }\n                        final ModuleFinder finder = finders[idx++];\n                        if (finder instanceof IterableModuleFinder) {\n                            nested = ((IterableModuleFinder) finder).iterateModules(baseName, recursive);\n                        }\n                    }\n\n                    if (! nested.hasNext()) {\n                        nested = null;\n                    } else {\n                        return true;\n                    }\n                }\n            }\n\n            public String next() {\n                if (! hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return nested.next();\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
        "fixed_function": "    public final Iterator<String> iterateModules(final String baseName, final boolean recursive) {\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(MODULE_ITERATE_PERM);\n        }\n        return new Iterator<String>() {\n            int idx;\n            Iterator<String> nested;\n\n            public boolean hasNext() {\n                for (;;) {\n                    while (nested == null) {\n                        if (idx == finders.length) {\n                            return false;\n                        }\n                        final ModuleFinder finder = finders[idx++];\n                        if (finder instanceof IterableModuleFinder) {\n                            nested = ((IterableModuleFinder) finder).iterateModules(baseName, recursive, ModuleLoader.this);\n                        }\n                    }\n\n                    if (! nested.hasNext()) {\n                        nested = null;\n                    } else {\n                        return true;\n                    }\n                }\n            }\n\n            public String next() {\n                if (! hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return nested.next();\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
        "comment": "/**\n     * Iterate the modules which can be located via this module loader.\n     *\n     * @param baseName the identifier to start with, or {@code null} to iterate all modules; ignored if this module\n     * loader does not have a concept of nested modules\n     * @param recursive {@code true} to find recursively nested modules, {@code false} to only find immediately nested\n     * modules; ignored if this module finder does not have a concept of nested modules\n     * @return an iterator for the modules in this module finder\n     * @throws SecurityException if the caller does not have permission to iterate module loaders\n     */"
      }
    ],
    "trigger_test": {
      "org.jboss.modules.MODULES_377_Test::issueTest": {
        "path": "org/jboss/modules/MODULES_377_Test.java",
        "function_name": "issueTest",
        "src": "@Test\n    public void issueTest() {\n        Iterator<String> i = moduleLoader.iterateModules((String) null, true);\n        assertTrue(i.hasNext());\n        assertEquals(\"local.tests.module\", i.next());\n        assertFalse(i.hasNext());\n    }",
        "error_msg": "org.jboss.modules.MODULES_377_Test::issueTest --> java.lang.IllegalArgumentException: moduleLoader is null",
        "clean_error_msg": "java.lang.IllegalArgumentException: moduleLoader is null"
      }
    }
  },
  "Qpidjms_client-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/org/apache/qpid/client/message/AMQMessageDelegate_0_10.java",
        "start_loc": 253,
        "end_loc": 256,
        "buggy_function": "    public void setJMSCorrelationID(String correlationId) throws JMSException\n    {\n        setJMSCorrelationIDAsBytes(correlationId == null ? null : correlationId.getBytes());\n    }",
        "fixed_function": "    public void setJMSCorrelationID(String correlationId) throws JMSException\n    {\n        setJMSCorrelationIDAsBytes(correlationId == null ? null : correlationId.getBytes(StandardCharsets.UTF_8));\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/qpid/client/message/AMQMessageDelegate_0_10.java",
        "start_loc": 258,
        "end_loc": 262,
        "buggy_function": "    public String getJMSCorrelationID() throws JMSException\n    {\n        byte[] correlationIDAsBytes = getJMSCorrelationIDAsBytes();\n        return correlationIDAsBytes == null ? null : new String(correlationIDAsBytes);\n    }",
        "fixed_function": "    public String getJMSCorrelationID() throws JMSException\n    {\n        byte[] correlationIDAsBytes = getJMSCorrelationIDAsBytes();\n        return correlationIDAsBytes == null ? null : new String(correlationIDAsBytes, StandardCharsets.UTF_8);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.qpid.test.unit.message.MessageTest::testJMSCorrelationIdAdBytesWithNonUtf8Bytes": {
        "path": "org/apache/qpid/test/unit/message/MessageTest.java",
        "function_name": "testJMSCorrelationIdAdBytesWithNonUtf8Bytes",
        "src": "public void testJMSCorrelationIdAdBytesWithNonUtf8Bytes() throws Exception\n    {\n        // QPID-7897 and QPID-7899\n        byte[] correlationId = new byte[]{(byte) 0xc3, 0x28};\n        _testTextMessage.setJMSCorrelationIDAsBytes(correlationId);\n        assertArrayEquals(\"\", correlationId, _testTextMessage.getJMSCorrelationIDAsBytes());\n    }",
        "error_msg": "org.apache.qpid.test.unit.message.MessageTest::testJMSCorrelationIdAdBytesWithNonUtf8Bytes --> java.lang.AssertionError: : array lengths differed, expected.length=2 actual.length=4",
        "clean_error_msg": "java.lang.AssertionError: : array lengths differed, expected.length=2 actual.length=4"
      }
    }
  },
  "Maven2_artifact-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java",
        "start_loc": 56,
        "end_loc": 99,
        "buggy_function": "    public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArtifact, Map managedVersions,\n                                             ArtifactRepository localRepository, List remoteRepositories,\n                                             ArtifactMetadataSource source, ArtifactFilter filter, List listeners )\n        throws ArtifactResolutionException\n    {\n        Map resolvedArtifacts = new HashMap();\n\n        ResolutionNode root = new ResolutionNode( originatingArtifact, remoteRepositories );\n\n        root.addDependencies( artifacts, remoteRepositories, filter );\n\n        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                 listeners );\n\n        Set set = new HashSet();\n\n        for ( Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); )\n        {\n            List nodes = (List) i.next();\n            for ( Iterator j = nodes.iterator(); j.hasNext(); )\n            {\n                ResolutionNode node = (ResolutionNode) j.next();\n                if ( !node.equals( root ) && node.isActive() )\n                {\n                    Artifact artifact = node.getArtifact();\n\n                    if ( node.filterTrail( filter ) )\n                    {\n                        // If it was optional, we don't add it or its children, just allow the update of the version and scope\n                        if ( !artifact.isOptional() )\n                        {\n                            artifact.setDependencyTrail( node.getDependencyTrail() );\n\n                            set.add( node );\n                        }\n                    }\n                }\n            }\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n        result.setArtifactResolutionNodes( set );\n        return result;\n    }",
        "fixed_function": "    public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArtifact, Map managedVersions,\n                                             ArtifactRepository localRepository, List remoteRepositories,\n                                             ArtifactMetadataSource source, ArtifactFilter filter, List listeners )\n        throws ArtifactResolutionException\n    {\n        Map resolvedArtifacts = new HashMap();\n\n        ResolutionNode root = new ResolutionNode( originatingArtifact, remoteRepositories );\n\n        root.addDependencies( artifacts, remoteRepositories, filter );\n\n        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                 listeners );\n\n        Set set = new HashSet();\n\n        for ( Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); )\n        {\n            List nodes = (List) i.next();\n            for ( Iterator j = nodes.iterator(); j.hasNext(); )\n            {\n                ResolutionNode node = (ResolutionNode) j.next();\n                if ( !node.equals( root ) && node.isActive() )\n                {\n                    Artifact artifact = node.getArtifact();\n\n                    if ( node.filterTrail( filter ) )\n                    {\n                        // If it was optional, we don't add it or its children, just allow the update of the version and scope\n                        if ( node.isChildOfRootNode() || !artifact.isOptional() )\n                        {\n                            artifact.setDependencyTrail( node.getDependencyTrail() );\n\n                            set.add( node );\n                        }\n                    }\n                }\n            }\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n        result.setArtifactResolutionNodes( set );\n        return result;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java",
        "start_loc": 101,
        "end_loc": 310,
        "buggy_function": "    private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && !child.getArtifact().isOptional() )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }",
        "fixed_function": "    private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest::testOptionalIncludedAtRoot": {
        "path": "org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java",
        "function_name": "testOptionalIncludedAtRoot",
        "src": "public void testOptionalIncludedAtRoot()\n        throws ArtifactResolutionException, InvalidVersionSpecificationException\n    {\n        ArtifactSpec a = createArtifact( \"a\", \"1.0\" );\n\n        ArtifactSpec b = createArtifact( \"b\", \"1.0\", true );\n\n        ArtifactResolutionResult res = collect( createSet( new Object[]{a.artifact, b.artifact} ) );\n        assertEquals( \"Check artifact list\", createSet( new Object[]{a.artifact, b.artifact} ), res.getArtifacts() );\n    }",
        "error_msg": "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest::testOptionalIncludedAtRoot --> junit.framework.AssertionFailedError: Check artifact list expected:<[test:a:jar:1.0, test:b:jar:1.0]> but was:<[test:a:jar:1.0]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: Check artifact list expected:<[test:a:jar:1.0, test:b:jar:1.0]> but was:<[test:a:jar:1.0]>"
      }
    }
  },
  "Xbean_reflect-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "/src/main/java/org/apache/xbean/propertyeditor/AbstractConverter.java",
        "start_loc": 36,
        "end_loc": 41,
        "buggy_function": "    protected AbstractConverter(Class type) {\n    \n        super();\n        if (type == null) throw new NullPointerException(\"type is null\");\n        this.type = type;\n    }",
        "fixed_function": "    protected AbstractConverter(Class type) {\n        this(type, true);\n    }",
        "comment": "/**\n     * Creates an abstract converter for the specified type.\n     *\n     * @param type type of the property editor\n     */"
      },
      {
        "path": "/src/main/java/org/apache/xbean/propertyeditor/AbstractConverter.java",
        "start_loc": 53,
        "end_loc": 56,
        "buggy_function": "    public final void setAsText(String text) {\n        Object value = toObject(text.trim());\n        super.setValue(value);\n    }",
        "fixed_function": "    protected AbstractConverter(Class type, boolean trim) {\n        super();\n        if (type == null) throw new NullPointerException(\"type is null\");\n        this.type = type;\n        this.trim = trim;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/apache/xbean/propertyeditor/AbstractConverter.java",
        "start_loc": 76,
        "end_loc": 83,
        "buggy_function": "    public final Object toObject(String text) {\n        if (text == null) {\n            return null;\n        }\n\n        Object value = toObjectImpl(text.trim());\n        return value;\n    }",
        "fixed_function": "    public final void setAsText(String text) {\n        Object value = toObject((trim) ? text.trim() : text);\n        super.setValue(value);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.apache.xbean.recipe.ObjectRecipeTest::testWhitespaceInjection": {
        "path": "org/apache/xbean/recipe/ObjectRecipeTest.java",
        "function_name": "testWhitespaceInjection",
        "src": "public void testWhitespaceInjection() throws Exception {\n        String name = \" Foo Bar \";\n        char ch = ' ';\n        \n        ObjectRecipe objectRecipe = new ObjectRecipe(Value.class);\n        objectRecipe.setProperty(\"name\", name);\n        objectRecipe.setProperty(\"type\", \" \");\n        Value c = (Value) objectRecipe.create();\n        \n        assertEquals(name, c.name);\n        assertEquals(ch, c.type);\n    }",
        "error_msg": "org.apache.xbean.recipe.ObjectRecipeTest::testWhitespaceInjection --> org.apache.xbean.recipe.ConstructionException: Unable to convert property value from java.lang.String to char for injection public char org.apache.xbean.recipe.ObjectRecipeTest$Value.type",
        "clean_error_msg": "org.apache.xbean.recipe.ConstructionException: Unable to convert property value from java.lang.String to char for injection public char org.apache.xbean.recipe.ObjectRecipeTest$Value.type"
      }
    }
  },
  "Streamex-2": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/one/util/streamex/EntryStream.java",
        "start_loc": 332,
        "end_loc": 334,
        "buggy_function": "    public EntryStream<K, V> append(K key, V value) {\n        return appendSpliterator(null, Collections.singleton(new SimpleImmutableEntry<>(key, value)).spliterator());\n    }",
        "fixed_function": "    public EntryStream<K, V> append(K key, V value) {\n        return appendSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value)).spliterator());\n    }",
        "comment": "/**\n     * Returns a new {@code EntryStream} which is a concatenation of this stream\n     * and the supplied key-value pair.\n     * \n     * <p>\n     * This is a <a href=\"package-summary.html#StreamOps\">quasi-intermediate\n     * operation</a>.\n     * \n     * @param key the key of the new {@code Entry} to append to this stream\n     * @param value the value of the new {@code Entry} to append to this stream\n     * @return the new stream\n     */"
      },
      {
        "path": "src/main/java/one/util/streamex/EntryStream.java",
        "start_loc": 411,
        "end_loc": 413,
        "buggy_function": "    public EntryStream<K, V> prepend(K key, V value) {\n        return prependSpliterator(null, Collections.singleton(new SimpleImmutableEntry<>(key, value)).spliterator());\n    }",
        "fixed_function": "    public EntryStream<K, V> prepend(K key, V value) {\n        return prependSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value)).spliterator());\n    }",
        "comment": "/**\n     * Returns a new {@code EntryStream} which is a concatenation of the\n     * supplied key-value pair and this stream.\n     * \n     * <p>\n     * This is a <a href=\"package-summary.html#StreamOps\">quasi-intermediate\n     * operation</a> with <a href=\"package-summary.html#TSO\">tail-stream\n     * optimization</a>.\n     * \n     * @param key the key of the new {@code Entry} to prepend to this stream\n     * @param value the value of the new {@code Entry} to prepend to this stream\n     * @return the new stream\n     */"
      },
      {
        "path": "src/main/java/one/util/streamex/TailConcatSpliterator.java",
        "start_loc": 45,
        "end_loc": 56,
        "buggy_function": "    @Override\n    public boolean tryAdvance(Consumer<? super T> action) {\n        if (left != null) {\n            if (left.tryAdvance(action)) {\n                if (size > 0 && size != Long.MAX_VALUE)\n                    size--;\n                return true;\n            }\n            left = null;\n        }\n        return right.tryAdvance(action);\n    }",
        "fixed_function": "    @Override\n    public boolean tryAdvance(Consumer<? super T> action) {\n        if (left != null) {\n            if (left.tryAdvance(action)) {\n                if (size > 0 && size != Long.MAX_VALUE)\n                    size--;\n                return true;\n            }\n            left = null;\n        }\n        if(right != null)\n            right = TailSpliterator.tryAdvanceWithTail(right, action);\n        return right != null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/one/util/streamex/TailConcatSpliterator.java",
        "start_loc": 70,
        "end_loc": 75,
        "buggy_function": "    @Override\n    public void forEachRemaining(Consumer<? super T> action) {\n        if (left != null)\n            left.forEachRemaining(action);\n        right.forEachRemaining(action);\n    }",
        "fixed_function": "    @Override\n    public void forEachRemaining(Consumer<? super T> action) {\n        if (left != null)\n            left.forEachRemaining(action);\n        if(right != null)\n            TailSpliterator.forEachWithTail(right, action);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "one.util.streamex.StreamExTest::testPrependTSO": {
        "path": "one/util/streamex/StreamExTest.java",
        "function_name": "testPrependTSO",
        "src": "@Test\n    public void testPrependTSO() {\n        List<Integer> expected = IntStreamEx.rangeClosed(19999, 0, -1).boxed().toList();\n        assertEquals(expected, IntStreamEx.range(20000).mapToObj(StreamEx::of).reduce(StreamEx::prepend).get().toList());\n        assertEquals(expected, IntStreamEx.range(20000).parallel().mapToObj(StreamEx::of).reduce(StreamEx::prepend)\n                .get().toList());\n    }",
        "error_msg": "one.util.streamex.StreamExTest::testPrependTSO --> java.lang.StackOverflowError",
        "clean_error_msg": "java.lang.StackOverflowError"
      }
    }
  },
  "Streamex-7": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/one/util/streamex/StreamEx.java",
        "start_loc": 1252,
        "end_loc": 1260,
        "buggy_function": "    public EntryStream<T, Long> runLengths() {\n        return EntryStream.of(collapseInternal(Objects::equals, t -> new ObjLongBox<>(t, 1L), (acc, t) -> {\n            acc.b++;\n            return acc;\n        }, (e1, e2) -> {\n            e1.b += e2.b;\n            return e1;\n        }));\n    }",
        "fixed_function": "    public EntryStream<T, Long> runLengths() {\n        return strategy().newEntryStream(collapseInternal(Objects::equals, t -> new ObjLongBox<>(t, 1L), (acc, t) -> {\n            acc.b++;\n            return acc;\n        }, (e1, e2) -> {\n            e1.b += e2.b;\n            return e1;\n        }));\n    }",
        "comment": "/**\n     * Collapses adjacent equal elements and returns an {@link EntryStream}\n     * where keys are input elements and values specify how many elements were\n     * collapsed.\n     * \n     * <p>\n     * This is a <a href=\"package-summary.html#StreamOps\">quasi-intermediate</a>\n     * partial reduction operation.\n     * \n     * <p>\n     * For sorted input {@code runLengths().toMap()} is the same as\n     * {@code groupingBy(Function.identity(), Collectors.counting())}, but may\n     * perform faster. For unsorted input the resulting stream may contain\n     * repeating keys.\n     * \n     * @return the new stream\n     * @since 0.3.3\n     */"
      },
      {
        "path": "src/main/java/one/util/streamex/StreamFactory.java",
        "start_loc": 65,
        "end_loc": 68,
        "buggy_function": "        @Override\n        public <K, V> EntryStream<K, V> newEntryStream(Stream<Entry<K, V>> src) {\n            return new CustomEntryStream<>(src, this);\n        }",
        "fixed_function": "        @Override\n        public <K, V> EntryStream<K, V> newEntryStream(Stream<? extends Entry<K, V>> src) {\n            return new CustomEntryStream<>(src, this);\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/one/util/streamex/StreamFactory.java",
        "start_loc": 97,
        "end_loc": 100,
        "buggy_function": "        CustomEntryStream(Stream<Entry<K, V>> stream, CustomPoolStreamFactory strategy) {\n            super(stream);\n            this.strategy = strategy;\n        }",
        "fixed_function": "        CustomEntryStream(Stream<? extends Entry<K, V>> stream, CustomPoolStreamFactory strategy) {\n            super(stream);\n            this.strategy = strategy;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/one/util/streamex/StreamFactory.java",
        "start_loc": 524,
        "end_loc": 526,
        "buggy_function": "    public <K, V> EntryStream<K, V> newEntryStream(Stream<Entry<K, V>> src) {\n        return new EntryStream<>(src);\n    }",
        "fixed_function": "    public <K, V> EntryStream<K, V> newEntryStream(Stream<? extends Entry<K, V>> src) {\n        return new EntryStream<>(src);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "one.util.streamex.CustomPoolTest::testStreamEx": {
        "path": "one/util/streamex/CustomPoolTest.java",
        "function_name": "testStreamEx",
        "src": "@Test\n    public void testStreamEx() {\n        StreamEx.of(\"a\", \"b\", \"c\").parallel(pool).forEach(this::checkThread);\n        assertEquals(Arrays.asList(1, 2), StreamEx.of(\"a\", \"bb\").parallel(pool).peek(this::checkThread).map(\n            String::length).toList());\n        assertEquals(\"a\", StreamEx.of(\"a\").parallel(pool).peek(this::checkThread).findAny().get());\n        assertEquals(\"a\", StreamEx.of(\"a\", \"b\").parallel(pool).peek(this::checkThread).findFirst().get());\n        assertTrue(StreamEx.of(\"a\", \"b\").parallel(pool).peek(this::checkThread).anyMatch(\"a\"::equals));\n        assertFalse(StreamEx.of(\"a\", \"b\").parallel(pool).peek(this::checkThread).allMatch(\"a\"::equals));\n        assertFalse(StreamEx.of(\"a\", \"b\").parallel(pool).peek(this::checkThread).noneMatch(\"a\"::equals));\n        assertEquals(Arrays.asList(\"b\", \"c\"), StreamEx.of(\"a\", \"b\", \"c\").parallel(pool).peek(this::checkThread).skip(1)\n                .collect(Collectors.toList()));\n        assertEquals(6, StreamEx.of(\"a\", \"bb\", \"ccc\").parallel(pool).peek(this::checkThread).collect(\n            StringBuilder::new, StringBuilder::append, StringBuilder::append).length());\n        assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, StreamEx.of(\"a\", \"b\", \"c\").parallel(pool).peek(\n            this::checkThread).toArray(String[]::new));\n        assertArrayEquals(new Object[] { \"a\", \"b\", \"c\" }, StreamEx.of(\"a\", \"b\", \"c\").parallel(pool).peek(\n            this::checkThread).toArray());\n        assertEquals(\"{ccc={bb={a={}}}}\", StreamEx.of(\"a\", \"bb\", \"ccc\").parallel(pool).peek(this::checkThread)\n                .foldLeft(Collections.emptyMap(),\n                    (Map<String, Object> acc, String v) -> Collections.singletonMap(v, acc)).toString());\n        assertEquals(1000, IntStreamEx.constant(1, 1000).boxed().parallel(pool).peek(this::checkThread).foldLeft(0,\n            Integer::sum).intValue());\n\n        assertEquals(2, StreamEx.of(\"aa\", \"bbb\", \"cccc\").parallel(pool).peek(this::checkThread).filter(\n            x -> x.length() > 2).count());\n        assertEquals(\"bbbcccc\", StreamEx.of(\"aa\", \"bbb\", \"cccc\").parallel(pool).peek(this::checkThread).filter(\n            x -> x.length() > 2).reduce(String::concat).get());\n        assertEquals(\"bbbcccc\", StreamEx.of(\"aa\", \"bbb\", \"cccc\").parallel(pool).peek(this::checkThread).filter(\n            x -> x.length() > 2).reduce(\"\", String::concat));\n        assertEquals(7, (int) StreamEx.of(\"aa\", \"bbb\", \"cccc\").parallel(pool).peek(this::checkThread).filter(\n            x -> x.length() > 2).reduce(0, (x, s) -> x + s.length(), Integer::sum));\n        assertEquals(\"aabbbcccc\", StreamEx.of(\"aa\", \"bbb\", \"cccc\").parallel(pool).peek(this::checkThread).foldLeft(\"\",\n            String::concat));\n        assertEquals(Arrays.asList(1, 2, 3), StreamEx.of(1, 2, 3).parallel(pool).peek(this::checkThread).toListAndThen(\n            list -> {\n                this.checkThread(list);\n                return list;\n            }));\n        \n        assertEquals(Collections.singletonMap(1, 3L), StreamEx.of(1, 1, 1).parallel(pool).peek(this::checkThread)\n                .runLengths().toMap());\n    }",
        "error_msg": "one.util.streamex.CustomPoolTest::testStreamEx --> java.lang.IllegalStateException: java.lang.IllegalStateException: FJP is incorrect (element: 1)",
        "clean_error_msg": "java.lang.IllegalStateException: java.lang.IllegalStateException: FJP is incorrect (element: 1)"
      }
    }
  },
  "Spoon-13": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java",
        "start_loc": 1746,
        "end_loc": 1759,
        "buggy_function": "\t@Override\n\tpublic String printPackageInfo(CtPackage pack) {\n\t\treset();\n\t\telementPrinterHelper.writeComment(pack);\n\n\t\t// we need to compute imports only for annotations\n\t\t// we don't want to get all imports coming from content of package\n\t\telementPrinterHelper.writeAnnotations(pack);\n\n\t\tif (!pack.isUnnamedPackage()) {\n\t\t\telementPrinterHelper.writePackageLine(pack.getQualifiedName());\n\t\t}\n\t\treturn printer.getPrinterHelper().toString();\n\t}",
        "fixed_function": "\t@Override\n\tpublic String printPackageInfo(CtPackage pack) {\n\t\treset();\n\t\telementPrinterHelper.writeComment(pack);\n\n\t\t// we need to compute imports only for annotations\n\t\t// we don't want to get all imports coming from content of package\n\t\tfor (CtAnnotation annotation : pack.getAnnotations()) {\n\t\t\tthis.importsContext.computeImports(annotation);\n\t\t}\n\t\telementPrinterHelper.writeAnnotations(pack);\n\n\t\tif (!pack.isUnnamedPackage()) {\n\t\t\telementPrinterHelper.writePackageLine(pack.getQualifiedName());\n\t\t}\n\t\telementPrinterHelper.writeImports(this.importsContext.getAllImports());\n\t\treturn printer.getPrinterHelper().toString();\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/spoon/reflect/visitor/ElementPrinterHelper.java",
        "start_loc": 250,
        "end_loc": 293,
        "buggy_function": "\tpublic void writeImports(Collection<CtReference> imports) {\n\t\tSet<String> setImports = new HashSet<>();\n\t\tSet<String> setStaticImports = new HashSet<>();\n\t\tfor (CtReference ref : imports) {\n\t\t\tString importTypeStr;\n\n\t\t\tif (ref instanceof CtTypeReference) {\n\t\t\t\tCtTypeReference typeRef = (CtTypeReference) ref;\n\t\t\t\timportTypeStr = typeRef.getQualifiedName();\n\t\t\t\tif (isJavaLangClasses(importTypeStr) == false) {\n\t\t\t\t\tsetImports.add(importTypeStr);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof CtExecutableReference) {\n\t\t\t\tCtExecutableReference execRef = (CtExecutableReference) ref;\n\t\t\t\tif (execRef.getDeclaringType() != null) {\n\t\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(execRef.getDeclaringType().getQualifiedName()) + \".\" + execRef.getSimpleName());\n\t\t\t\t}\n\t\t\t} else if (ref instanceof CtFieldReference) {\n\t\t\t\tCtFieldReference fieldRef = (CtFieldReference) ref;\n\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(fieldRef.getDeclaringType().getQualifiedName()) + \".\" + fieldRef.getSimpleName());\n\t\t\t}\n\t\t}\n\n\t\tList<String> sortedImports = new ArrayList<>(setImports);\n\t\tCollections.sort(sortedImports);\n\t\tboolean isFirst = true;\n\t\tfor (String importLine : sortedImports) {\n\t\t\tif (isFirst) {\n\t\t\t}\n\t\t\tprinter.writeKeyword(\"import\").writeSpace();\n\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t}\n\t\tif (setStaticImports.size() > 0) {\n\t\t\tif (isFirst) {\n\t\t\t}\n\t\t\tprinter.writeln();\n\t\t\tList<String> sortedStaticImports = new ArrayList<>(setStaticImports);\n\t\t\tCollections.sort(sortedStaticImports);\n\t\t\tfor (String importLine : sortedStaticImports) {\n\t\t\t\tprinter.writeKeyword(\"import\").writeSpace().writeKeyword(\"static\").writeSpace();\n\t\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t\t}\n\t\t}\n\t}",
        "fixed_function": "\tpublic void writeImports(Collection<CtReference> imports) {\n\t\tSet<String> setImports = new HashSet<>();\n\t\tSet<String> setStaticImports = new HashSet<>();\n\t\tfor (CtReference ref : imports) {\n\t\t\tString importTypeStr;\n\n\t\t\tif (ref instanceof CtTypeReference) {\n\t\t\t\tCtTypeReference typeRef = (CtTypeReference) ref;\n\t\t\t\timportTypeStr = typeRef.getQualifiedName();\n\t\t\t\tif (isJavaLangClasses(importTypeStr) == false) {\n\t\t\t\t\tsetImports.add(importTypeStr);\n\t\t\t\t}\n\t\t\t} else if (ref instanceof CtExecutableReference) {\n\t\t\t\tCtExecutableReference execRef = (CtExecutableReference) ref;\n\t\t\t\tif (execRef.getDeclaringType() != null) {\n\t\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(execRef.getDeclaringType().getQualifiedName()) + \".\" + execRef.getSimpleName());\n\t\t\t\t}\n\t\t\t} else if (ref instanceof CtFieldReference) {\n\t\t\t\tCtFieldReference fieldRef = (CtFieldReference) ref;\n\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(fieldRef.getDeclaringType().getQualifiedName()) + \".\" + fieldRef.getSimpleName());\n\t\t\t}\n\t\t}\n\n\t\tList<String> sortedImports = new ArrayList<>(setImports);\n\t\tCollections.sort(sortedImports);\n\t\tboolean isFirst = true;\n\t\tfor (String importLine : sortedImports) {\n\t\t\tif (isFirst) {\n\t\t\t\tprinter.writeln();\n\t\t\t\tprinter.writeln();\n\t\t\t\tisFirst = false;\n\t\t\t}\n\t\t\tprinter.writeKeyword(\"import\").writeSpace();\n\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t}\n\t\tif (setStaticImports.size() > 0) {\n\t\t\tif (isFirst) {\n\t\t\t\tprinter.writeln();\n\t\t\t}\n\t\t\tprinter.writeln();\n\t\t\tList<String> sortedStaticImports = new ArrayList<>(setStaticImports);\n\t\t\tCollections.sort(sortedStaticImports);\n\t\t\tfor (String importLine : sortedStaticImports) {\n\t\t\t\tprinter.writeKeyword(\"import\").writeSpace().writeKeyword(\"static\").writeSpace();\n\t\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t\t}\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/spoon/reflect/visitor/ElementPrinterHelper.java",
        "start_loc": 298,
        "end_loc": 311,
        "buggy_function": "\tpublic void writeHeader(List<CtType<?>> types, Collection<CtReference> imports) {\n\t\tif (!types.isEmpty()) {\n\t\t\tfor (CtType<?> ctType : types) {\n\t\t\t\twriteComment(ctType, CommentOffset.TOP_FILE);\n\t\t\t}\n\t\t\t// writing the header package\n\t\t\tif (!types.get(0).getPackage().isUnnamedPackage()) {\n\t\t\t\twritePackageLine(types.get(0).getPackage().getQualifiedName());\n\t\t\t}\n\t\t\tprinter.writeln().writeln();\n\t\t\tthis.writeImports(imports);\n\t\t\tprinter.writeln();\n\t\t}\n\t}",
        "fixed_function": "\tpublic void writeHeader(List<CtType<?>> types, Collection<CtReference> imports) {\n\t\tif (!types.isEmpty()) {\n\t\t\tfor (CtType<?> ctType : types) {\n\t\t\t\twriteComment(ctType, CommentOffset.TOP_FILE);\n\t\t\t}\n\t\t\t// writing the header package\n\t\t\tif (!types.get(0).getPackage().isUnnamedPackage()) {\n\t\t\t\twritePackageLine(types.get(0).getPackage().getQualifiedName());\n\t\t\t}\n\t\t\tthis.writeImports(imports);\n\t\t\tprinter.writeln();\n\t\t\tprinter.writeln();\n\t\t}\n\t}",
        "comment": "/**\n\t * Write the compilation unit header.\n\t */"
      },
      {
        "path": "src/main/java/spoon/reflect/visitor/ElementPrinterHelper.java",
        "start_loc": 313,
        "end_loc": 316,
        "buggy_function": "\tpublic void writePackageLine(String packageQualifiedName) {\n\t\tprinter.writeKeyword(\"package\").writeSpace();\n\t\twriteQualifiedName(packageQualifiedName).writeSeparator(\";\");\n\t}",
        "fixed_function": "\tpublic void writePackageLine(String packageQualifiedName) {\n\t\tprinter.writeKeyword(\"package\").writeSpace();\n\t\twriteQualifiedName(packageQualifiedName).writeSeparator(\";\").writeln();\n\t}",
        "comment": ""
      }
    ],
    "trigger_test": {
      "spoon.test.comment.CommentTest::testCombinedPackageInfoComment": {
        "path": "spoon/test/comment/CommentTest.java",
        "function_name": "testCombinedPackageInfoComment",
        "src": "@Test\n\tpublic void testCombinedPackageInfoComment() {\n\t\tFactory f = getSpoonFactory();\n\t\tCtPackage p = f.Package().get(\"spoon.test.comment.testclasses\");\n\t\tString l_content = ((JavaOutputProcessor)f.getEnvironment().getDefaultFileGenerator()).getPrinter().printPackageInfo(p);\n\t\tString EOL = System.getProperty(\"line.separator\");\n\t\tassertEquals(\"/* comment1 */\"+EOL+\n\t\t\t\t\"// comment2\"+EOL+\n\t\t\t\t\"/**\"+EOL+\n\t\t\t\t\" * Comment3\"+EOL+\n\t\t\t\t\" */\"+EOL+\n\t\t\t\t\"@java.lang.Deprecated\"+EOL+\n\t\t\t\t\"package spoon.test.comment.testclasses;\"+EOL,l_content);\n\t}",
        "error_msg": "spoon.test.comment.CommentTest::testCombinedPackageInfoComment --> junit.framework.AssertionFailedError: expected:<...comment.testclasses;[",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...comment.testclasses;["
      }
    }
  },
  "Zip4j-15": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/headers/HeaderReader.java",
        "start_loc": 524,
        "end_loc": 598,
        "buggy_function": "  public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException {\n    LocalFileHeader localFileHeader = new LocalFileHeader();\n    byte[] intBuff = new byte[4];\n\n    //signature\n    int sig = rawIO.readIntLittleEndian(inputStream);\n    if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) {\n      return null;\n    }\n    localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER);\n    localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));\n\n    byte[] generalPurposeFlags = new byte[2];\n    if (readFully(inputStream, generalPurposeFlags) != 2) {\n      throw new ZipException(\"Could not read enough bytes for generalPurposeFlags\");\n    }\n    localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));\n    localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));\n    localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));\n    localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());\n\n    localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(\n        rawIO.readShortLittleEndian(inputStream)));\n    localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));\n\n    readFully(inputStream, intBuff);\n    localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));\n\n    localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4));\n    localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4));\n\n    int fileNameLength = rawIO.readShortLittleEndian(inputStream);\n    localFileHeader.setFileNameLength(fileNameLength);\n\n    localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));\n\n    if (fileNameLength > 0) {\n      byte[] fileNameBuf = new byte[fileNameLength];\n      readFully(inputStream, fileNameBuf);\n      String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);\n\n      if (fileName == null) {\n        throw new ZipException(\"file name is null, cannot assign file name to local file header\");\n      }\n\n      if (fileName.contains(\":\" + System.getProperty(\"file.separator\"))) {\n        fileName = fileName.substring(fileName.indexOf(\":\" + System.getProperty(\"file.separator\")) + 2);\n      }\n\n      localFileHeader.setFileName(fileName);\n      localFileHeader.setDirectory(fileName.endsWith(\"/\") || fileName.endsWith(\"\\\\\"));\n    } else {\n      localFileHeader.setFileName(null);\n    }\n\n    readExtraDataRecords(inputStream, localFileHeader);\n    readZip64ExtendedInfo(localFileHeader, rawIO);\n    readAesExtraDataRecord(localFileHeader, rawIO);\n\n    if (localFileHeader.isEncrypted()) {\n\n      if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) {\n        //Do nothing\n      } else {\n        if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) {\n          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);\n        } else {\n          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);\n        }\n      }\n\n    }\n\n    return localFileHeader;\n  }",
        "fixed_function": "  public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException {\n    LocalFileHeader localFileHeader = new LocalFileHeader();\n    byte[] intBuff = new byte[4];\n\n    //signature\n    int sig = rawIO.readIntLittleEndian(inputStream);\n    if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) {\n      return null;\n    }\n    localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER);\n    localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));\n\n    byte[] generalPurposeFlags = new byte[2];\n    if (readFully(inputStream, generalPurposeFlags) != 2) {\n      throw new ZipException(\"Could not read enough bytes for generalPurposeFlags\");\n    }\n    localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));\n    localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));\n    localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));\n    localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());\n\n    localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(\n        rawIO.readShortLittleEndian(inputStream)));\n    localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));\n\n    readFully(inputStream, intBuff);\n    localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));\n\n    localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4));\n    localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4));\n\n    int fileNameLength = rawIO.readShortLittleEndian(inputStream);\n    localFileHeader.setFileNameLength(fileNameLength);\n\n    localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));\n\n    if (fileNameLength > 0) {\n      byte[] fileNameBuf = new byte[fileNameLength];\n      readFully(inputStream, fileNameBuf);\n      String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);\n\n      if (fileName == null) {\n        throw new ZipException(\"file name is null, cannot assign file name to local file header\");\n      }\n\n      if (fileName.contains(\":\" + System.getProperty(\"file.separator\"))) {\n        fileName = fileName.substring(fileName.indexOf(\":\" + System.getProperty(\"file.separator\")) + 2);\n      }\n\n      localFileHeader.setFileName(fileName);\n      localFileHeader.setDirectory(fileName.endsWith(\"/\") || fileName.endsWith(\"\\\\\"));\n    } else {\n      localFileHeader.setFileName(null);\n    }\n\n    readExtraDataRecords(inputStream, localFileHeader);\n    readZip64ExtendedInfo(localFileHeader, rawIO);\n    readAesExtraDataRecord(localFileHeader, rawIO);\n\n    if (localFileHeader.isEncrypted()) {\n\n      if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) {\n        //Do nothing\n      } else {\n        if (isBitSet(localFileHeader.getGeneralPurposeFlag()[0], 6)) {\n          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);\n        } else {\n          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);\n        }\n      }\n\n    }\n\n    return localFileHeader;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java",
        "start_loc": 173,
        "end_loc": 190,
        "buggy_function": "  private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream,\n                                                          ZipParameters zipParameters) throws IOException {\n    if (!zipParameters.isEncryptFiles()) {\n      return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null);\n    }\n\n    if (password == null || password.length == 0) {\n      throw new ZipException(\"password not set\");\n    }\n\n    if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) {\n      return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password);\n    } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) {\n      return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password);\n    } else {\n      throw new ZipException(\"Invalid encryption method\");\n    }\n  }",
        "fixed_function": "  private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream,\n                                                          ZipParameters zipParameters) throws IOException {\n    if (!zipParameters.isEncryptFiles()) {\n      return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null);\n    }\n\n    if (password == null || password.length == 0) {\n      throw new ZipException(\"password not set\");\n    }\n\n    if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) {\n      return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password);\n    } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) {\n      return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password);\n    } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG) {\n      throw new ZipException(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG + \" encryption method is not supported\");\n    } else {\n      throw new ZipException(\"Invalid encryption method\");\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.CreateZipFileIT::testEncryptWithZipStrongEncryptionThrowsException": {
        "path": "net/lingala/zip4j/CreateZipFileIT.java",
        "function_name": "testEncryptWithZipStrongEncryptionThrowsException",
        "src": "@Test\n  public void testEncryptWithZipStrongEncryptionThrowsException() throws ZipException {\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    ZipParameters zipParameters = new ZipParameters();\n    zipParameters.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);\n    zipParameters.setEncryptFiles(true);\n\n    expectedException.expect(ZipException.class);\n    expectedException.expectMessage(\"ZIP_STANDARD_VARIANT_STRONG encryption method is not supported\");\n\n    zipFile.addFiles(FILES_TO_ADD, zipParameters);\n  }",
        "error_msg": "net.lingala.zip4j.CreateZipFileIT::testEncryptWithZipStrongEncryptionThrowsException --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Zip4j-27": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java",
        "start_loc": 60,
        "end_loc": 76,
        "buggy_function": "  public LocalFileHeader getNextEntry() throws IOException {\n\n    localFileHeader = headerReader.readLocalFileHeader(inputStream);\n\n    if (localFileHeader == null) {\n      return null;\n    }\n\n    verifyLocalFileHeader(localFileHeader);\n    crc32.reset();\n\n\n    if (!isZipEntryDirectory(localFileHeader.getFileName())) {\n      this.decompressedInputStream = initializeEntryInputStream(localFileHeader);\n    }\n    return localFileHeader;\n  }",
        "fixed_function": "  public LocalFileHeader getNextEntry() throws IOException {\n    return getNextEntry(null);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java",
        "start_loc": 80,
        "end_loc": 91,
        "buggy_function": "  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {\n    LocalFileHeader localFileHeader = zipInputStream.getNextEntry();\n\n    if (localFileHeader == null) {\n      throw new ZipException(\"Could not read corresponding local file header for file header: \"\n          + fileHeader.getFileName());\n    }\n\n    if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {\n      throw new ZipException(\"File header and local file header mismatch\");\n    }\n  }",
        "fixed_function": "  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {\n    LocalFileHeader localFileHeader = zipInputStream.getNextEntry(fileHeader);\n\n    if (localFileHeader == null) {\n      throw new ZipException(\"Could not read corresponding local file header for file header: \"\n          + fileHeader.getFileName());\n    }\n\n    if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {\n      throw new ZipException(\"File header and local file header mismatch\");\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java",
        "start_loc": 23,
        "end_loc": 39,
        "buggy_function": "  @Override\n  protected void executeTask(ExtractAllFilesTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    try (ZipInputStream zipInputStream = prepareZipInputStream()) {\n      for (FileHeader fileHeader : getZipModel().getCentralDirectory().getFileHeaders()) {\n        if (fileHeader.getFileName().startsWith(\"__MACOSX\")) {\n          progressMonitor.updateWorkCompleted(fileHeader.getUncompressedSize());\n          zipInputStream.getNextEntry();\n          continue;\n        }\n\n        //splitInputStream.prepareExtractionForFileHeader(fileHeader);\n        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor);\n        verifyIfTaskIsCancelled();\n      }\n    }\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(ExtractAllFilesTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    try (ZipInputStream zipInputStream = prepareZipInputStream()) {\n      for (FileHeader fileHeader : getZipModel().getCentralDirectory().getFileHeaders()) {\n        if (fileHeader.getFileName().startsWith(\"__MACOSX\")) {\n          progressMonitor.updateWorkCompleted(fileHeader.getUncompressedSize());\n          zipInputStream.getNextEntry(fileHeader);\n          continue;\n        }\n\n        //splitInputStream.prepareExtractionForFileHeader(fileHeader);\n        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor);\n        verifyIfTaskIsCancelled();\n      }\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/UnzipUtil.java",
        "start_loc": 19,
        "end_loc": 35,
        "buggy_function": "  public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws ZipException {\n    try {\n      SplitInputStream splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),\n          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry() == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n  }",
        "fixed_function": "  public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws ZipException {\n    try {\n      SplitInputStream splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),\n          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry(fileHeader) == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.ExtractZipFileIT::testExtractFilesForAZipMadeWithZip4jv1AndStoreCompressionWithAES": {
        "path": "net/lingala/zip4j/ExtractZipFileIT.java",
        "function_name": "testExtractFilesForAZipMadeWithZip4jv1AndStoreCompressionWithAES",
        "src": "@Test\n  public void testExtractFilesForAZipMadeWithZip4jv1AndStoreCompressionWithAES() throws IOException {\n    File zipArchiveToTest = getTestArchiveFromResources(\"store_compression_made_with_v1.3.3.zip\");\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(zipArchiveToTest, \"aaaaaaaa\".toCharArray(), outputFolder, 5,\n        false);\n  }",
        "error_msg": "net.lingala.zip4j.ExtractZipFileIT::testExtractFilesForAZipMadeWithZip4jv1AndStoreCompressionWithAES --> net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed"
      }
    }
  },
  "Zip4j-29": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/io/outputstream/CompressedOutputStream.java",
        "start_loc": 29,
        "end_loc": 31,
        "buggy_function": "  protected void decrementBytesWrittenForThisEntry(int value) {\n    cipherOutputStream.decrementBytesWrittenForThisEntry(value);\n  }",
        "fixed_function": "  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n    cipherOutputStream.write(b, off, len);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java",
        "start_loc": 32,
        "end_loc": 37,
        "buggy_function": "  public DeflaterOutputStream(CipherOutputStream cipherOutputStream, CompressionLevel compressionLevel) {\n    super(cipherOutputStream);\n    deflater = new Deflater();\n    deflater.setLevel(compressionLevel.getLevel());\n    firstBytesRead = false;\n  }",
        "fixed_function": "  public DeflaterOutputStream(CipherOutputStream cipherOutputStream, CompressionLevel compressionLevel) {\n    super(cipherOutputStream);\n    deflater = new Deflater(compressionLevel.getLevel(), true);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java",
        "start_loc": 56,
        "end_loc": 74,
        "buggy_function": "  private void deflate() throws IOException {\n    int len = deflater.deflate(buff, 0, buff.length);\n    if (len > 0) {\n      if (deflater.finished()) {\n        if (len == 4) return;\n        if (len < 4) {\n          decrementBytesWrittenForThisEntry(4 - len);\n          return;\n        }\n        len -= 4;\n      }\n      if (!firstBytesRead) {\n        super.write(buff, 2, len - 2);\n        firstBytesRead = true;\n      } else {\n        super.write(buff, 0, len);\n      }\n    }\n  }",
        "fixed_function": "  private void deflate() throws IOException {\n    int len = deflater.deflate(buff, 0, buff.length);\n    if (len > 0) {\n      super.write(buff, 0, len);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java",
        "start_loc": 76,
        "end_loc": 86,
        "buggy_function": "  public void closeEntry() throws IOException {\n    if (!deflater.finished()) {\n      deflater.finish();\n      while (!deflater.finished()) {\n        deflate();\n      }\n    }\n    firstBytesRead = false;\n    deflater.end();\n    super.closeEntry();\n  }",
        "fixed_function": "  public void closeEntry() throws IOException {\n    if (!deflater.finished()) {\n      deflater.finish();\n      while (!deflater.finished()) {\n        deflate();\n      }\n    }\n    deflater.end();\n    super.closeEntry();\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.AddFilesToZipIT::testAddFileWithAfterDeflateRemainingBytesTestFile": {
        "path": "net/lingala/zip4j/AddFilesToZipIT.java",
        "function_name": "testAddFileWithAfterDeflateRemainingBytesTestFile",
        "src": "@Test\n  public void testAddFileWithAfterDeflateRemainingBytesTestFile() throws IOException {\n    ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);\n    zipParameters.setAesVersion(AesVersion.TWO);\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n\n    zipFile.addFile(TestUtils.getTestFileFromResources(\"after_deflate_remaining_bytes.bin\"), zipParameters);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 1);\n    verifyZipFileContainsFiles(generatedZipFile, singletonList(\"after_deflate_remaining_bytes.bin\"),\n        CompressionMethod.DEFLATE, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);\n  }",
        "error_msg": "net.lingala.zip4j.AddFilesToZipIT::testAddFileWithAfterDeflateRemainingBytesTestFile --> net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed"
      }
    }
  },
  "Zip4j-31": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java",
        "start_loc": 30,
        "end_loc": 60,
        "buggy_function": "  protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outPath, String newFileName,\n                             ProgressMonitor progressMonitor) throws IOException {\n\n    progressMonitor.setFileName(fileHeader.getFileName());\n\n    if (!outPath.endsWith(FILE_SEPARATOR)) {\n      outPath += FILE_SEPARATOR;\n    }\n\n    // make sure no file is extracted outside of the target directory (a.k.a zip slip)\n    String fileName = fileHeader.getFileName();\n    String completePath = outPath + fileName;\n    if (!new File(completePath).getCanonicalPath().startsWith(new File(outPath).getPath())) {\n      throw new ZipException(\"illegal file name that breaks out of the target directory: \"\n          + fileHeader.getFileName());\n    }\n\n    verifyNextEntry(zipInputStream, fileHeader);\n\n    if (fileHeader.isDirectory()) {\n      File file = new File(completePath);\n      if (!file.exists()) {\n        if (!file.mkdirs()) {\n          throw new ZipException(\"Could not create directory: \" + file);\n        }\n      }\n    } else {\n      checkOutputDirectoryStructure(fileHeader, outPath, newFileName);\n      unzipFile(zipInputStream, fileHeader, outPath, newFileName, progressMonitor);\n    }\n  }",
        "fixed_function": "  protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outPath, String newFileName,\n                             ProgressMonitor progressMonitor) throws IOException {\n\n    progressMonitor.setFileName(fileHeader.getFileName());\n\n    if (!outPath.endsWith(FILE_SEPARATOR)) {\n      outPath += FILE_SEPARATOR;\n    }\n\n    // make sure no file is extracted outside of the target directory (a.k.a zip slip)\n    String fileName = fileHeader.getFileName();\n    String completePath = outPath + fileName;\n    if (!new File(completePath).getCanonicalPath().startsWith(new File(outPath).getCanonicalPath())) {\n      throw new ZipException(\"illegal file name that breaks out of the target directory: \"\n          + fileHeader.getFileName());\n    }\n\n    verifyNextEntry(zipInputStream, fileHeader);\n\n    if (fileHeader.isDirectory()) {\n      File file = new File(completePath);\n      if (!file.exists()) {\n        if (!file.mkdirs()) {\n          throw new ZipException(\"Could not create directory: \" + file);\n        }\n      }\n    } else {\n      checkOutputDirectoryStructure(fileHeader, outPath, newFileName);\n      unzipFile(zipInputStream, fileHeader, outPath, newFileName, progressMonitor);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java",
        "start_loc": 44,
        "end_loc": 54,
        "buggy_function": "  private void setDefaultFolderPath(AddFolderToZipTaskParameters taskParameters) {\n    String rootFolderPath;\n    File folderToAdd = taskParameters.folderToAdd;\n    if (taskParameters.zipParameters.isIncludeRootFolder()) {\n      rootFolderPath = folderToAdd.getParentFile().getPath();\n    } else {\n      rootFolderPath = folderToAdd.getAbsolutePath();\n    }\n\n    taskParameters.zipParameters.setDefaultFolderPath(rootFolderPath);\n  }",
        "fixed_function": "  private void setDefaultFolderPath(AddFolderToZipTaskParameters taskParameters) throws IOException {\n    String rootFolderPath;\n    File folderToAdd = taskParameters.folderToAdd;\n    if (taskParameters.zipParameters.isIncludeRootFolder()) {\n      rootFolderPath = folderToAdd.getParentFile().getCanonicalPath();\n    } else {\n      rootFolderPath = folderToAdd.getCanonicalPath();\n    }\n\n    taskParameters.zipParameters.setDefaultFolderPath(rootFolderPath);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/FileUtils.java",
        "start_loc": 184,
        "end_loc": 222,
        "buggy_function": "  public static String getRelativeFileName(String file, String rootFolderPath) {\n\n    String fileName;\n      if (isStringNotNullAndNotEmpty(rootFolderPath)) {\n        File rootFolderFile = new File(rootFolderPath);\n        String rootFolderFileRef = rootFolderFile.getPath();\n\n        if (!rootFolderFileRef.endsWith(FILE_SEPARATOR)) {\n          rootFolderFileRef += FILE_SEPARATOR;\n        }\n\n        String tmpFileName = file.substring(rootFolderFileRef.length());\n        if (tmpFileName.startsWith(System.getProperty(\"file.separator\"))) {\n          tmpFileName = tmpFileName.substring(1);\n        }\n\n        File tmpFile = new File(file);\n\n        if (tmpFile.isDirectory()) {\n          tmpFileName = tmpFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName += ZIP_FILE_SEPARATOR;\n        } else {\n          String bkFileName = tmpFileName.substring(0, tmpFileName.lastIndexOf(tmpFile.getName()));\n          bkFileName = bkFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName = bkFileName + tmpFile.getName();\n        }\n\n        fileName = tmpFileName;\n    } else {\n      File relFile = new File(file);\n      if (relFile.isDirectory()) {\n        fileName = relFile.getName() + ZIP_FILE_SEPARATOR;\n      } else {\n          fileName = relFile.getName();\n      }\n    }\n\n    return fileName;\n  }",
        "fixed_function": "  public static String getRelativeFileName(String file, String rootFolderPath) throws ZipException {\n\n    String fileName;\n    try {\n      String fileCanonicalPath = new File(file).getCanonicalPath();\n      if (isStringNotNullAndNotEmpty(rootFolderPath)) {\n        File rootFolderFile = new File(rootFolderPath);\n        String rootFolderFileRef = rootFolderFile.getCanonicalPath();\n\n        if (!rootFolderFileRef.endsWith(FILE_SEPARATOR)) {\n          rootFolderFileRef += FILE_SEPARATOR;\n        }\n\n        String tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());\n        if (tmpFileName.startsWith(System.getProperty(\"file.separator\"))) {\n          tmpFileName = tmpFileName.substring(1);\n        }\n\n        File tmpFile = new File(fileCanonicalPath);\n\n        if (tmpFile.isDirectory()) {\n          tmpFileName = tmpFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName += ZIP_FILE_SEPARATOR;\n        } else {\n          String bkFileName = tmpFileName.substring(0, tmpFileName.lastIndexOf(tmpFile.getName()));\n          bkFileName = bkFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName = bkFileName + tmpFile.getName();\n        }\n\n        fileName = tmpFileName;\n      } else {\n        File relFile = new File(fileCanonicalPath);\n        if (relFile.isDirectory()) {\n          fileName = relFile.getName() + ZIP_FILE_SEPARATOR;\n        } else {\n          fileName = relFile.getName();\n        }\n      }\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n\n    return fileName;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.ExtractZipFileIT::testAddFolderWithNotNormalizedPath": {
        "path": "net/lingala/zip4j/ExtractZipFileIT.java",
        "function_name": "testAddFolderWithNotNormalizedPath",
        "src": "@Test\n  public void testAddFolderWithNotNormalizedPath() throws IOException {\n    ZipFile zipFile = new ZipFile(generatedZipFile);\n    ZipParameters parameters = new ZipParameters();\n\n    String folderToAddPath = TestUtils.getTestFileFromResources(\"\").getPath() + InternalZipConstants.FILE_SEPARATOR + \"..\" + InternalZipConstants.FILE_SEPARATOR + TestUtils.getTestFileFromResources(\"\").getName();\n    File folderToAdd = new File(folderToAddPath);\n    zipFile.addFolder(folderToAdd, parameters);\n\n    File fileToAdd = TestUtils.getTestFileFromResources(\"file_PDF_1MB.pdf\");\n    zipFile.addFile(fileToAdd, parameters);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 13);\n  }",
        "error_msg": "net.lingala.zip4j.ExtractZipFileIT::testAddFolderWithNotNormalizedPath --> net.lingala.zip4j.exception.ZipException: java.lang.StringIndexOutOfBoundsException: String index out of range: -1",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.lang.StringIndexOutOfBoundsException: String index out of range: -1"
      },
      "net.lingala.zip4j.MiscZipFileIT::testUnzipFileZipSlipWithNotNormalizedTarget": {
        "path": "net/lingala/zip4j/MiscZipFileIT.java",
        "function_name": "testUnzipFileZipSlipWithNotNormalizedTarget",
        "src": "@Test\n  public void testUnzipFileZipSlipWithNotNormalizedTarget() throws IOException {\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    zipFile.addFiles(FILES_TO_ADD);\n    zipFile.extractAll(new File(outputFolder.getPath(),\n            \"..\" + InternalZipConstants.FILE_SEPARATOR + outputFolder.getName()).getAbsolutePath());\n  }",
        "error_msg": "net.lingala.zip4j.MiscZipFileIT::testUnzipFileZipSlipWithNotNormalizedTarget --> net.lingala.zip4j.exception.ZipException: illegal file name that breaks out of the target directory: sample_text1.txt",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: illegal file name that breaks out of the target directory: sample_text1.txt"
      }
    }
  },
  "Zip4j-38": {
    "function_num": 9,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/headers/HeaderUtil.java",
        "start_loc": 35,
        "end_loc": 66,
        "buggy_function": "  public static int getIndexOfFileHeader(ZipModel zipModel, FileHeader fileHeader) throws ZipException {\n\n    if (zipModel == null || fileHeader == null) {\n      throw new ZipException(\"input parameters is null, cannot determine index of file header\");\n    }\n\n    if (zipModel.getCentralDirectory() == null\n        || zipModel.getCentralDirectory().getFileHeaders() == null\n        || zipModel.getCentralDirectory().getFileHeaders().size() <= 0) {\n      return -1;\n    }\n\n    String fileName = fileHeader.getFileName();\n\n    if (!isStringNotNullAndNotEmpty(fileName)) {\n      throw new ZipException(\"file name in file header is empty or null, cannot determine index of file header\");\n    }\n\n    List<FileHeader> fileHeadersFromCentralDir = zipModel.getCentralDirectory().getFileHeaders();\n    for (int i = 0; i < fileHeadersFromCentralDir.size(); i++) {\n      FileHeader fileHeaderFromCentralDir = fileHeadersFromCentralDir.get(i);\n      String fileNameForHdr = fileHeaderFromCentralDir.getFileName();\n      if (!isStringNotNullAndNotEmpty(fileNameForHdr)) {\n        continue;\n      }\n\n      if (fileName.equalsIgnoreCase(fileNameForHdr)) {\n        return i;\n      }\n    }\n    return -1;\n  }",
        "fixed_function": "  public static FileHeader getFileHeader(ZipModel zipModel, String fileName) throws ZipException {\n    FileHeader fileHeader = getFileHeaderWithExactMatch(zipModel, fileName);\n\n    if (fileHeader == null) {\n      fileName = fileName.replaceAll(\"\\\\\\\\\", \"/\");\n      fileHeader = getFileHeaderWithExactMatch(zipModel, fileName);\n\n      if (fileHeader == null) {\n        fileName = fileName.replaceAll(\"/\", \"\\\\\\\\\");\n        fileHeader = getFileHeaderWithExactMatch(zipModel, fileName);\n      }\n    }\n\n    return fileHeader;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/headers/HeaderUtil.java",
        "start_loc": 68,
        "end_loc": 82,
        "buggy_function": "  public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded, Charset charset) {\n    if (InternalZipConstants.CHARSET_UTF_8.equals(charset) && !isUtf8Encoded) {\n      try {\n        return new String(data, ZIP_STANDARD_CHARSET);\n      } catch (UnsupportedEncodingException e) {\n        return new String(data);\n      }\n    }\n\n    if(charset != null) {\n      return new String(data, charset);\n    }\n\n    return new String(data, InternalZipConstants.CHARSET_UTF_8);\n  }",
        "fixed_function": "  public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded, Charset charset) {\n    if (InternalZipConstants.CHARSET_UTF_8.equals(charset) && !isUtf8Encoded) {\n      try {\n        return new String(data, ZIP_STANDARD_CHARSET);\n      } catch (UnsupportedEncodingException e) {\n        return new String(data);\n      }\n    }\n\n    if(charset != null) {\n      return new String(data, charset);\n    }\n\n    return new String(data, InternalZipConstants.CHARSET_UTF_8);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java",
        "start_loc": 34,
        "end_loc": 56,
        "buggy_function": "  void updateOffsetsForAllSubsequentFileHeaders(ZipModel zipModel, FileHeader fileHeaderModified, long offsetToAdd) throws ZipException {\n    int indexOfFileHeader = HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderModified);\n\n    if (indexOfFileHeader == -1) {\n      throw new ZipException(\"Could not locate modified file header in zipModel\");\n    }\n\n    List<FileHeader> allFileHeaders = zipModel.getCentralDirectory().getFileHeaders();\n\n    for (int i = indexOfFileHeader + 1; i < allFileHeaders.size(); i++) {\n      FileHeader fileHeaderToUpdate = allFileHeaders.get(i);\n      fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);\n\n      if (zipModel.isZip64Format()\n          && fileHeaderToUpdate.getZip64ExtendedInfo() != null\n          && fileHeaderToUpdate.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {\n\n        fileHeaderToUpdate.getZip64ExtendedInfo().setOffsetLocalHeader(\n            fileHeaderToUpdate.getZip64ExtendedInfo().getOffsetLocalHeader() + offsetToAdd\n        );\n      }\n    }\n  }",
        "fixed_function": "  void updateOffsetsForAllSubsequentFileHeaders(List<FileHeader> sortedFileHeaders, ZipModel zipModel,\n                                                FileHeader fileHeaderModified, long offsetToAdd) throws ZipException {\n    int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeaderModified);\n\n    if (indexOfFileHeader == -1) {\n      throw new ZipException(\"Could not locate modified file header in zipModel\");\n    }\n\n    for (int i = indexOfFileHeader + 1; i < sortedFileHeaders.size(); i++) {\n      FileHeader fileHeaderToUpdate = sortedFileHeaders.get(i);\n      fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);\n\n      if (zipModel.isZip64Format()\n          && fileHeaderToUpdate.getZip64ExtendedInfo() != null\n          && fileHeaderToUpdate.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {\n\n        fileHeaderToUpdate.getZip64ExtendedInfo().setOffsetLocalHeader(\n            fileHeaderToUpdate.getZip64ExtendedInfo().getOffsetLocalHeader() + offsetToAdd\n        );\n      }\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java",
        "start_loc": 68,
        "end_loc": 72,
        "buggy_function": "  long copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long length,\n                        ProgressMonitor progressMonitor) throws IOException {\n    FileUtils.copyFile(randomAccessFile, outputStream, start, start + length, progressMonitor);\n    return length;\n  }",
        "fixed_function": "  List<FileHeader> cloneAndSortFileHeadersByOffset(List<FileHeader> allFileHeaders) {\n    List<FileHeader> clonedFileHeaders = new ArrayList<>(allFileHeaders);\n    clonedFileHeaders.sort((o1, o2) -> {\n      if (o1.getFileName().equals(o2.getFileName())) {\n        return 0;\n      }\n\n      return o1.getOffsetLocalHeader() < o2.getOffsetLocalHeader() ? -1 : 1;\n    });\n\n    return clonedFileHeaders;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java",
        "start_loc": 74,
        "end_loc": 82,
        "buggy_function": "  private void restoreFileName(File zipFile, File temporaryZipFile) throws ZipException {\n    if (zipFile.delete()) {\n      if (!temporaryZipFile.renameTo(zipFile)) {\n        throw new ZipException(\"cannot rename modified zip file\");\n      }\n    } else {\n      throw new ZipException(\"cannot delete old zip file\");\n    }\n  }",
        "fixed_function": "  private int getIndexOfFileHeader(List<FileHeader> allFileHeaders, FileHeader fileHeaderForIndex) throws ZipException {\n    for (int i = 0; i < allFileHeaders.size(); i++) {\n      FileHeader fileHeader = allFileHeaders.get(i);\n      if (fileHeader.equals(fileHeaderForIndex)) {\n        return i;\n      }\n    }\n\n    throw new ZipException(\"Could not find file header in list of central directory file headers\");\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java",
        "start_loc": 32,
        "end_loc": 76,
        "buggy_function": "  @Override\n  protected void executeTask(RemoveFilesFromZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    if (zipModel.isSplitArchive()) {\n      throw new ZipException(\"This is a split archive. Zip file format does not allow updating split/spanned files\");\n    }\n\n    List<String> entriesToRemove = filterNonExistingEntries(taskParameters.filesToRemove);\n\n    if (entriesToRemove.isEmpty()) {\n      return;\n    }\n\n    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n\n    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);\n         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){\n\n      long currentFileCopyPointer = 0;\n      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : allUnchangedFileHeaders) {\n        long lengthOfCurrentEntry = HeaderUtil.getOffsetOfNextEntry(zipModel, fileHeader) - outputStream.getFilePointer();\n        if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {\n          updateHeaders(fileHeader, lengthOfCurrentEntry);\n\n          if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {\n            throw new ZipException(\"Could not remove entry from list of central directory headers\");\n          }\n\n          currentFileCopyPointer += lengthOfCurrentEntry;\n        } else {\n          // copy complete entry without any changes\n          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, lengthOfCurrentEntry, progressMonitor);\n        }\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);\n    }\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(RemoveFilesFromZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    if (zipModel.isSplitArchive()) {\n      throw new ZipException(\"This is a split archive. Zip file format does not allow updating split/spanned files\");\n    }\n\n    List<String> entriesToRemove = filterNonExistingEntries(taskParameters.filesToRemove);\n\n    if (entriesToRemove.isEmpty()) {\n      return;\n    }\n\n    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n\n    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);\n         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){\n\n      long currentFileCopyPointer = 0;\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,\n            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();\n        if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {\n          updateHeaders(sortedFileHeaders, fileHeader, lengthOfCurrentEntry);\n\n          if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {\n            throw new ZipException(\"Could not remove entry from list of central directory headers\");\n          }\n\n          currentFileCopyPointer += lengthOfCurrentEntry;\n        } else {\n          // copy complete entry without any changes\n          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, lengthOfCurrentEntry, progressMonitor);\n        }\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java",
        "start_loc": 105,
        "end_loc": 129,
        "buggy_function": "  private void updateHeaders(FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {\n    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderThatWasRemoved, negate(offsetToSubtract));\n\n    EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();\n    endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(\n        endOfCentralDirectoryRecord.getOffsetOfStartOfCentralDirectory() - offsetToSubtract);\n    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(\n        endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectory() - 1);\n\n    if (endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() > 0) {\n      endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(\n          endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() - 1);\n    }\n\n    if (zipModel.isZip64Format()) {\n      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() - offsetToSubtract);\n\n      zipModel.getZip64EndOfCentralDirectoryRecord().setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() - 1);\n\n      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(\n          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() - offsetToSubtract);\n    }\n  }",
        "fixed_function": "  private void updateHeaders(List<FileHeader> sortedFileHeaders, FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {\n    updateOffsetsForAllSubsequentFileHeaders(sortedFileHeaders, zipModel, fileHeaderThatWasRemoved, negate(offsetToSubtract));\n\n    EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();\n    endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(\n        endOfCentralDirectoryRecord.getOffsetOfStartOfCentralDirectory() - offsetToSubtract);\n    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(\n        endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectory() - 1);\n\n    if (endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() > 0) {\n      endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(\n          endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() - 1);\n    }\n\n    if (zipModel.isZip64Format()) {\n      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() - offsetToSubtract);\n\n      zipModel.getZip64EndOfCentralDirectoryRecord().setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() - 1);\n\n      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(\n          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() - offsetToSubtract);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java",
        "start_loc": 40,
        "end_loc": 89,
        "buggy_function": "  @Override\n  protected void executeTask(RenameFilesTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {\n    Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);\n    if (fileNamesMap.size() == 0) {\n      return;\n    }\n\n    File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());\n        SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {\n\n      long currentFileCopyPointer = 0;\n\n      // Maintain a different list to iterate, so that when the file name is changed in the central directory\n      // we still have access to the original file names. If iterating on the original list from central directory,\n      // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed\n      // and the file is part of that directory, by the time the file has to be changed, its name might have changed\n      // when changing the name of the directory. There is some overhead with this approach, but is safer.\n      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : allUnchangedFileHeaders) {\n        Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);\n        progressMonitor.setFileName(fileHeader.getFileName());\n\n        long lengthToCopy = HeaderUtil.getOffsetOfNextEntry(zipModel, fileHeader) - outputStream.getFilePointer();\n        if (fileNameMapForThisEntry == null) {\n          // copy complete entry without any changes\n          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);\n        } else {\n          String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());\n          byte[] newFileNameBytes = newFileName.getBytes(charset);\n          int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();\n\n          currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,\n              inputStream, outputStream, progressMonitor);\n\n          updateHeadersInZipModel(fileHeader, newFileName, newFileNameBytes, headersOffset);\n        }\n\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryFile);\n    }\n\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(RenameFilesTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {\n    Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);\n    if (fileNamesMap.size() == 0) {\n      return;\n    }\n\n    File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());\n        SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {\n\n      long currentFileCopyPointer = 0;\n      long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n\n      // Maintain a different list to iterate, so that when the file name is changed in the central directory\n      // we still have access to the original file names. If iterating on the original list from central directory,\n      // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed\n      // and the file is part of that directory, by the time the file has to be changed, its name might have changed\n      // when changing the name of the directory. There is some overhead with this approach, but is safer.\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);\n        progressMonitor.setFileName(fileHeader.getFileName());\n\n        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,\n            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();\n        if (fileNameMapForThisEntry == null) {\n          // copy complete entry without any changes\n          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);\n        } else {\n          String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());\n          byte[] newFileNameBytes = newFileName.getBytes(charset);\n          int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();\n\n          currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,\n              inputStream, outputStream, progressMonitor);\n\n          updateHeadersInZipModel(sortedFileHeaders, fileHeader, newFileName, newFileNameBytes, headersOffset);\n        }\n\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryFile);\n    }\n\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java",
        "start_loc": 136,
        "end_loc": 164,
        "buggy_function": "  private void updateHeadersInZipModel(FileHeader fileHeader, String newFileName, byte[] newFileNameBytes,\n                                       int headersOffset) throws ZipException {\n\n    FileHeader fileHeaderToBeChanged = HeaderUtil.getFileHeader(zipModel, fileHeader.getFileName());\n\n    if (fileHeaderToBeChanged == null) {\n      // If this is the case, then the file name in the header that was passed to this method was already changed.\n      // In theory, should never be here.\n      throw new ZipException(\"could not find any header with name: \" + fileHeader.getFileName());\n    }\n\n    fileHeaderToBeChanged.setFileName(newFileName);\n    fileHeaderToBeChanged.setFileNameLength(newFileNameBytes.length);\n\n    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderToBeChanged, headersOffset);\n\n    zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(\n        zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory() + headersOffset);\n\n    if (zipModel.isZip64Format()) {\n      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() + headersOffset\n      );\n\n      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(\n          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() + headersOffset\n      );\n    }\n  }",
        "fixed_function": "  private void updateHeadersInZipModel(List<FileHeader> sortedFileHeaders, FileHeader fileHeader, String newFileName,\n                                       byte[] newFileNameBytes, int headersOffset) throws ZipException {\n\n    FileHeader fileHeaderToBeChanged = HeaderUtil.getFileHeader(zipModel, fileHeader.getFileName());\n\n    if (fileHeaderToBeChanged == null) {\n      // If this is the case, then the file name in the header that was passed to this method was already changed.\n      // In theory, should never be here.\n      throw new ZipException(\"could not find any header with name: \" + fileHeader.getFileName());\n    }\n\n    fileHeaderToBeChanged.setFileName(newFileName);\n    fileHeaderToBeChanged.setFileNameLength(newFileNameBytes.length);\n\n    updateOffsetsForAllSubsequentFileHeaders(sortedFileHeaders, zipModel, fileHeaderToBeChanged, headersOffset);\n\n    zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(\n        zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory() + headersOffset);\n\n    if (zipModel.isZip64Format()) {\n      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(\n          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() + headersOffset\n      );\n\n      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(\n          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() + headersOffset\n      );\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RemoveFilesFromZipIT.java",
        "function_name": "testRemoveFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRemoveFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/zero_byte_file.txt\");\n  }",
        "error_msg": "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RemoveFilesFromZipIT.java",
        "function_name": "testRemoveMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRemoveMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/file_PDF_1MB.pdf\");\n  }",
        "error_msg": "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RemoveFilesFromZipIT.java",
        "function_name": "testRemoveLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRemoveLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/\u0431\u043e\u0440\u0435\u0438\u0441\u043a\u0430\u044f.txt\");\n  }",
        "error_msg": "net.lingala.zip4j.RemoveFilesFromZipIT::testRemoveLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRenameMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/file_PDF_1MB.pdf\");\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRenameLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/\u0431\u043e\u0440\u0435\u0438\u0441\u043a\u0430\u044f.txt\");\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries",
        "src": "@Test\n  public void testRenameFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {\n    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(\"test-files/zero_byte_file.txt\");\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      }
    }
  },
  "Zip4j-39": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java",
        "start_loc": 86,
        "end_loc": 95,
        "buggy_function": "  long getOffsetOfNextEntry(List<FileHeader> sortedFileHeaders, FileHeader fileHeader,\n                                   long offsetStartOfCentralDirectory) throws ZipException {\n    int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeader);\n\n    if (indexOfFileHeader == sortedFileHeaders.size() - 1) {\n      return offsetStartOfCentralDirectory;\n    } else {\n      return sortedFileHeaders.get(indexOfFileHeader + 1).getOffsetLocalHeader();\n    }\n  }",
        "fixed_function": "  long getOffsetOfNextEntry(List<FileHeader> sortedFileHeaders, FileHeader fileHeader,\n                                   ZipModel zipModel) throws ZipException {\n    int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeader);\n\n    if (indexOfFileHeader == sortedFileHeaders.size() - 1) {\n      return HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n    } else {\n      return sortedFileHeaders.get(indexOfFileHeader + 1).getOffsetLocalHeader();\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java",
        "start_loc": 32,
        "end_loc": 78,
        "buggy_function": "  @Override\n  protected void executeTask(RemoveFilesFromZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    if (zipModel.isSplitArchive()) {\n      throw new ZipException(\"This is a split archive. Zip file format does not allow updating split/spanned files\");\n    }\n\n    List<String> entriesToRemove = filterNonExistingEntries(taskParameters.filesToRemove);\n\n    if (entriesToRemove.isEmpty()) {\n      return;\n    }\n\n    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n\n    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);\n         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){\n\n      long currentFileCopyPointer = 0;\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,\n            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();\n        if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {\n          updateHeaders(sortedFileHeaders, fileHeader, lengthOfCurrentEntry);\n\n          if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {\n            throw new ZipException(\"Could not remove entry from list of central directory headers\");\n          }\n\n          currentFileCopyPointer += lengthOfCurrentEntry;\n        } else {\n          // copy complete entry without any changes\n          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, lengthOfCurrentEntry, progressMonitor);\n        }\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);\n    }\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(RemoveFilesFromZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n    if (zipModel.isSplitArchive()) {\n      throw new ZipException(\"This is a split archive. Zip file format does not allow updating split/spanned files\");\n    }\n\n    List<String> entriesToRemove = filterNonExistingEntries(taskParameters.filesToRemove);\n\n    if (entriesToRemove.isEmpty()) {\n      return;\n    }\n\n    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n\n    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);\n         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){\n\n      long currentFileCopyPointer = 0;\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader, zipModel) - outputStream.getFilePointer();\n        if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {\n          updateHeaders(sortedFileHeaders, fileHeader, lengthOfCurrentEntry);\n\n          if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {\n            throw new ZipException(\"Could not remove entry from list of central directory headers\");\n          }\n\n          currentFileCopyPointer += lengthOfCurrentEntry;\n        } else {\n          // copy complete entry without any changes\n          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, lengthOfCurrentEntry, progressMonitor);\n        }\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java",
        "start_loc": 39,
        "end_loc": 90,
        "buggy_function": "  @Override\n  protected void executeTask(RenameFilesTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {\n    Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);\n    if (fileNamesMap.size() == 0) {\n      return;\n    }\n\n    File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());\n        SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {\n\n      long currentFileCopyPointer = 0;\n      long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n\n      // Maintain a different list to iterate, so that when the file name is changed in the central directory\n      // we still have access to the original file names. If iterating on the original list from central directory,\n      // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed\n      // and the file is part of that directory, by the time the file has to be changed, its name might have changed\n      // when changing the name of the directory. There is some overhead with this approach, but is safer.\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);\n        progressMonitor.setFileName(fileHeader.getFileName());\n\n        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,\n            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();\n        if (fileNameMapForThisEntry == null) {\n          // copy complete entry without any changes\n          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);\n        } else {\n          String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());\n          byte[] newFileNameBytes = newFileName.getBytes(charset);\n          int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();\n\n          currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,\n              inputStream, outputStream, progressMonitor);\n\n          updateHeadersInZipModel(sortedFileHeaders, fileHeader, newFileName, newFileNameBytes, headersOffset);\n        }\n\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryFile);\n    }\n\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(RenameFilesTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {\n    Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);\n    if (fileNamesMap.size() == 0) {\n      return;\n    }\n\n    File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());\n    boolean successFlag = false;\n    try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());\n        SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {\n\n      long currentFileCopyPointer = 0;\n\n      // Maintain a different list to iterate, so that when the file name is changed in the central directory\n      // we still have access to the original file names. If iterating on the original list from central directory,\n      // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed\n      // and the file is part of that directory, by the time the file has to be changed, its name might have changed\n      // when changing the name of the directory. There is some overhead with this approach, but is safer.\n      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());\n\n      for (FileHeader fileHeader : sortedFileHeaders) {\n        Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);\n        progressMonitor.setFileName(fileHeader.getFileName());\n\n        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader, zipModel) - outputStream.getFilePointer();\n        if (fileNameMapForThisEntry == null) {\n          // copy complete entry without any changes\n          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);\n        } else {\n          String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());\n          byte[] newFileNameBytes = newFileName.getBytes(charset);\n          int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();\n\n          currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,\n              inputStream, outputStream, progressMonitor);\n\n          updateHeadersInZipModel(sortedFileHeaders, fileHeader, newFileName, newFileNameBytes, headersOffset);\n        }\n\n        verifyIfTaskIsCancelled();\n      }\n\n      headerWriter.finalizeZipFile(zipModel, outputStream, charset);\n      successFlag = true;\n    } finally {\n      cleanupFile(successFlag, zipModel.getZipFile(), temporaryFile);\n    }\n\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapRenamesSubFolder": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapRenamesSubFolder",
        "src": "@Test\n  public void testRenameWithMapRenamesSubFolder() throws IOException {\n    ZipFile zipFile = createZipFileWithFolder();\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"test-files/sample_directory/\", \"new-test-files/new_sample_directory/\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    zipFile.extractAll(outputFolder.getPath());\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapRenamesSubFolder --> net.lingala.zip4j.exception.ZipException: java.io.IOException: Cannot read fully into byte buffer",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.IOException: Cannot read fully into byte buffer"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapProgressMonitor": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapProgressMonitor",
        "src": "@Test\n  public void testRenameWithMapProgressMonitor() throws IOException, InterruptedException {\n    TestUtils.copyFileToFolder(getTestFileFromResources(\"file_PDF_1MB.pdf\"), temporaryFolder.getRoot(), 100);\n\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    ZipParameters zipParameters = buildZipParameters(CompressionMethod.DEFLATE, true, EncryptionMethod.AES);\n    zipParameters.setIncludeRootFolder(false);\n    zipFile.addFolder(temporaryFolder.getRoot(), zipParameters);\n\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"1.pdf\", \"1_new.pdf\");\n    fileNamesMap.put(\"25.pdf\", \"25_new.pdf\");\n\n    zipFile.setRunInThread(true);\n    ProgressMonitor progressMonitor = zipFile.getProgressMonitor();\n\n    zipFile.renameFiles(fileNamesMap);\n\n    boolean percentBetweenZeroAndHundred = false;\n    boolean fileNameSet = true;\n    while (!progressMonitor.getState().equals(ProgressMonitor.State.READY)) {\n      int percentDone = progressMonitor.getPercentDone();\n      String fileName = progressMonitor.getFileName();\n\n      if (percentDone > 0 && percentDone < 100) {\n        percentBetweenZeroAndHundred = true;\n      }\n\n      if (fileName != null) {\n        fileNameSet = true;\n      }\n\n      Thread.sleep(10);\n    }\n\n    assertThat(progressMonitor.getResult()).isEqualTo(ProgressMonitor.Result.SUCCESS);\n    assertThat(progressMonitor.getState().equals(ProgressMonitor.State.READY));\n    assertThat(progressMonitor.getException()).isNull();\n    assertThat(percentBetweenZeroAndHundred).isTrue();\n    assertThat(fileNameSet).isTrue();\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 100, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap, false);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapProgressMonitor --> net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapForStoreCompressionMethod": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapForStoreCompressionMethod",
        "src": "@Test\n  public void testRenameWithMapForStoreCompressionMethod() throws IOException {\n    ZipFile zipFile = createZipFile(CompressionMethod.STORE, false, null);\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"sample_text1.txt\", \"new-sample_text1.txt\");\n    fileNamesMap.put(\"sample_text_large.txt\", \"new-sample_text_large.txt\");\n    fileNamesMap.put(\"sample.pdf\", \"new-sample.pdf\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapForStoreCompressionMethod --> net.lingala.zip4j.exception.ZipException: Reached end of entry, but crc verification failed for new-sample.pdf",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: Reached end of entry, but crc verification failed for new-sample.pdf"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapRenamesRootFolder": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapRenamesRootFolder",
        "src": "@Test\n  public void testRenameWithMapRenamesRootFolder() throws IOException {\n    ZipFile zipFile = createZipFileWithFolder();\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"test-files/\", \"new-test-files/\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapRenamesRootFolder --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithFileHeaderRenamesAFolderSuccessfully": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithFileHeaderRenamesAFolderSuccessfully",
        "src": "@Test\n  public void testRenameWithFileHeaderRenamesAFolderSuccessfully() throws IOException {\n    ZipFile zipFile = createZipFileWithFolder();\n\n    zipFile.renameFile(zipFile.getFileHeader(\"test-files/sample_directory/\"), \"test-files/new_directory_name\");\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);\n    verifyFileNamesChanged(zipFile, Collections.singletonMap(\"test-files/sample_directory/\", \"test-files/new_directory_name/\"));\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithFileHeaderRenamesAFolderSuccessfully --> net.lingala.zip4j.exception.ZipException: File header and local file header mismatch",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: File header and local file header mismatch"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapForAllEntriesInZip": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapForAllEntriesInZip",
        "src": "@Test\n  public void testRenameWithMapForAllEntriesInZip() throws IOException {\n    ZipFile zipFile = createDefaultZipFile();\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"sample_text1.txt\", \"new-sample_text1.txt\");\n    fileNamesMap.put(\"sample_text_large.txt\", \"new-sample_text_large.txt\");\n    fileNamesMap.put(\"sample.pdf\", \"new-sample.pdf\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapForAllEntriesInZip --> net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapWithZipStandardEncryption": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapWithZipStandardEncryption",
        "src": "@Test\n  public void testRenameWithMapWithZipStandardEncryption() throws IOException {\n    ZipFile zipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD);\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"sample_text1.txt\", \"new-sample_text1.txt\");\n    fileNamesMap.put(\"sample_text_large.txt\", \"new-sample_text_large.txt\");\n    fileNamesMap.put(\"sample.pdf\", \"new-sample.pdf\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapWithZipStandardEncryption --> net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream"
      },
      "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapWithAesEncryption": {
        "path": "net/lingala/zip4j/RenameFilesInZipIT.java",
        "function_name": "testRenameWithMapWithAesEncryption",
        "src": "@Test\n  public void testRenameWithMapWithAesEncryption() throws IOException {\n    ZipFile zipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES);\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"sample_text1.txt\", \"new-sample_text1.txt\");\n    fileNamesMap.put(\"sample_text_large.txt\", \"new-sample_text_large.txt\");\n    fileNamesMap.put(\"sample.pdf\", \"new-sample.pdf\");\n\n    zipFile.renameFiles(fileNamesMap);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);\n    verifyFileNamesChanged(zipFile, fileNamesMap);\n  }",
        "error_msg": "net.lingala.zip4j.RenameFilesInZipIT::testRenameWithMapWithAesEncryption --> net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.IOException: Reached end of data for this entry, but aes verification failed"
      },
      "net.lingala.zip4j.ZipFileZip64IT::testZip64WithNumberOfEntriesGreaterThan70k": {
        "path": "net/lingala/zip4j/ZipFileZip64IT.java",
        "function_name": "testZip64WithNumberOfEntriesGreaterThan70k",
        "src": "@Test\n  public void testZip64WithNumberOfEntriesGreaterThan70k() throws IOException {\n    long eachEntrySize = 100;\n\n    ZipParameters zipParameters = new ZipParameters();\n    zipParameters.setEntrySize(eachEntrySize);\n\n    createZip64FileWithEntries(70000, eachEntrySize, zipParameters);\n\n    ZipFile zipFile = new ZipFile(generatedZipFile);\n    assertThat(zipFile.getFileHeaders()).hasSize(70000);\n    verifyZip64HeadersPresent();\n\n    zipFile = new ZipFile(generatedZipFile);\n    Map<String, String> fileNamesMap = new HashMap<>();\n    fileNamesMap.put(\"FILE_10\", \"NEW_FILE_10\");\n    fileNamesMap.put(\"FILE_20\", \"NEW_FILE_20\");\n    fileNamesMap.put(\"FILE_30\", \"NEW_FILE_30\");\n    zipFile.renameFiles(fileNamesMap);\n\n    verifyZip64HeadersPresent();\n    HeaderVerifier.verifyFileHeadersExist(zipFile, fileNamesMap.values());\n    HeaderVerifier.verifyFileHeadersDoesNotExist(zipFile, fileNamesMap.keySet());\n\n    zipFile = new ZipFile(generatedZipFile);\n    List<String> filesToRemove = new ArrayList<>();\n    filesToRemove.add(\"FILE_0\");\n    filesToRemove.add(\"NEW_FILE_10\");\n    filesToRemove.add(\"NEW_FILE_30\");\n    zipFile.removeFiles(filesToRemove);\n\n    HeaderVerifier.verifyFileHeadersDoesNotExist(zipFile, filesToRemove);\n  }",
        "error_msg": "net.lingala.zip4j.ZipFileZip64IT::testZip64WithNumberOfEntriesGreaterThan70k --> net.lingala.zip4j.exception.ZipException: invalid offsets",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: invalid offsets"
      }
    }
  },
  "Zip4j-42": {
    "function_num": 8,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java",
        "start_loc": 50,
        "end_loc": 65,
        "buggy_function": "  public AESEncrypter(char[] password, AesKeyStrength aesKeyStrength) throws ZipException {\n    if (password == null || password.length == 0) {\n      throw new ZipException(\"input password is empty or null\");\n    }\n    if (aesKeyStrength != AesKeyStrength.KEY_STRENGTH_128 &&\n        aesKeyStrength != AesKeyStrength.KEY_STRENGTH_256) {\n      throw new ZipException(\"Invalid AES key strength\");\n    }\n\n    this.password = password;\n    this.aesKeyStrength = aesKeyStrength;\n    this.finished = false;\n    counterBlock = new byte[AES_BLOCK_SIZE];\n    iv = new byte[AES_BLOCK_SIZE];\n    init();\n  }",
        "fixed_function": "  public AESEncrypter(char[] password, AesKeyStrength aesKeyStrength) throws ZipException {\n    if (password == null || password.length == 0) {\n      throw new ZipException(\"input password is empty or null\");\n    }\n    if (aesKeyStrength != AesKeyStrength.KEY_STRENGTH_128 &&\n        aesKeyStrength != AesKeyStrength.KEY_STRENGTH_256) {\n      throw new ZipException(\"Invalid AES key strength\");\n    }\n\n    this.finished = false;\n    counterBlock = new byte[AES_BLOCK_SIZE];\n    iv = new byte[AES_BLOCK_SIZE];\n    init(password, aesKeyStrength);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java",
        "start_loc": 67,
        "end_loc": 73,
        "buggy_function": "  private void init() throws ZipException {\n    saltBytes = generateSalt(aesKeyStrength.getSaltLength());\n    byte[] derivedKey = AesCipherUtil.derivePasswordBasedKey(saltBytes, password, aesKeyStrength);\n    derivedPasswordVerifier = AesCipherUtil.derivePasswordVerifier(derivedKey, aesKeyStrength);\n    aesEngine = AesCipherUtil.getAESEngine(derivedKey, aesKeyStrength);\n    mac = AesCipherUtil.getMacBasedPRF(derivedKey, aesKeyStrength);\n  }",
        "fixed_function": "  private void init(char[] password, AesKeyStrength aesKeyStrength) throws ZipException {\n    saltBytes = generateSalt(aesKeyStrength.getSaltLength());\n    byte[] derivedKey = derivePasswordBasedKey(saltBytes, password, aesKeyStrength);\n    derivedPasswordVerifier = derivePasswordVerifier(derivedKey, aesKeyStrength);\n    aesEngine = getAESEngine(derivedKey, aesKeyStrength);\n    mac = getMacBasedPRF(derivedKey, aesKeyStrength);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java",
        "start_loc": 113,
        "end_loc": 136,
        "buggy_function": "  private byte[] generateSalt(int size) throws ZipException {\n\n    if (size != 8 && size != 16) {\n      throw new ZipException(\"invalid salt size, cannot generate salt\");\n    }\n\n    int rounds = 0;\n\n    if (size == 8) {\n      rounds = 2;\n    } else if (size == 16) {\n      rounds = 4;\n    }\n\n    byte[] salt = new byte[size];\n    for (int j = 0; j < rounds; j++) {\n      int i = random.nextInt();\n      salt[0 + j * 4] = (byte) (i >> 24);\n      salt[1 + j * 4] = (byte) (i >> 16);\n      salt[2 + j * 4] = (byte) (i >> 8);\n      salt[3 + j * 4] = (byte) i;\n    }\n    return salt;\n  }",
        "fixed_function": "  private byte[] generateSalt(int size) throws ZipException {\n\n    if (size != 8 && size != 16) {\n      throw new ZipException(\"invalid salt size, cannot generate salt\");\n    }\n\n    int rounds;\n\n    if (size == 8) {\n      rounds = 2;\n    } else {\n      rounds = 4;\n    }\n\n    byte[] salt = new byte[size];\n    for (int j = 0; j < rounds; j++) {\n      int i = random.nextInt();\n      salt[j * 4] = (byte) (i >> 24);\n      salt[1 + j * 4] = (byte) (i >> 16);\n      salt[2 + j * 4] = (byte) (i >> 8);\n      salt[3 + j * 4] = (byte) i;\n    }\n    return salt;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java",
        "start_loc": 31,
        "end_loc": 36,
        "buggy_function": "  public StandardEncrypter(char[] password, long key) throws ZipException {\n   this.zipCryptoEngine = new ZipCryptoEngine();\n\n    this.headerBytes = new byte[STD_DEC_HDR_SIZE];\n    init(password, key);\n  }",
        "fixed_function": "  public StandardEncrypter(char[] password, long key) throws ZipException {\n    init(password, key);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java",
        "start_loc": 38,
        "end_loc": 55,
        "buggy_function": "  private void init(char[] password, long key) throws ZipException {\n    if (password == null || password.length <= 0) {\n      throw new ZipException(\"input password is null or empty, cannot initialize standard encrypter\");\n    }\n    zipCryptoEngine.initKeys(password);\n    headerBytes = generateRandomBytes(STD_DEC_HDR_SIZE);\n    // Initialize again since the generated bytes were encrypted.\n    zipCryptoEngine.initKeys(password);\n\n    headerBytes[STD_DEC_HDR_SIZE - 1] = (byte) ((key >>> 24));\n    headerBytes[STD_DEC_HDR_SIZE - 2] = (byte) ((key >>> 16));\n\n    if (headerBytes.length < STD_DEC_HDR_SIZE) {\n      throw new ZipException(\"invalid header bytes generated, cannot perform standard encryption\");\n    }\n\n    encryptData(headerBytes);\n  }",
        "fixed_function": "  private void init(char[] password, long key) throws ZipException {\n    if (password == null || password.length <= 0) {\n      throw new ZipException(\"input password is null or empty, cannot initialize standard encrypter\");\n    }\n    zipCryptoEngine.initKeys(password);\n    headerBytes = generateRandomBytes();\n    // Initialize again since the generated bytes were encrypted.\n    zipCryptoEngine.initKeys(password);\n\n    headerBytes[STD_DEC_HDR_SIZE - 1] = (byte) ((key >>> 24));\n    headerBytes[STD_DEC_HDR_SIZE - 2] = (byte) ((key >>> 16));\n\n    encryptData(headerBytes);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java",
        "start_loc": 81,
        "end_loc": 93,
        "buggy_function": "  protected byte[] generateRandomBytes(int size) throws ZipException {\n    if (size <= 0) {\n      throw new ZipException(\"size is either 0 or less than 0, cannot generate header for standard encryptor\");\n    }\n\n    byte[] buff = new byte[size];\n    SecureRandom random = new SecureRandom();\n    for (int i = 0; i < buff.length; i++) {\n      buff[i] = encryptByte((byte) random.nextInt(256));\n    }\n\n    return buff;\n  }",
        "fixed_function": "  protected byte[] generateRandomBytes() {\n    byte[] buff = new byte[STD_DEC_HDR_SIZE];\n    SecureRandom random = new SecureRandom();\n    for (int i = 0; i < buff.length; i++) {\n      buff[i] = encryptByte((byte) random.nextInt(256));\n    }\n    return buff;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/crypto/engine/ZipCryptoEngine.java",
        "start_loc": 38,
        "end_loc": 45,
        "buggy_function": "  public void initKeys(char[] password) {\n    keys[0] = 305419896;\n    keys[1] = 591751049;\n    keys[2] = 878082192;\n    for (int i = 0; i < password.length; i++) {\n      updateKeys((byte) (password[i] & 0xff));\n    }\n  }",
        "fixed_function": "  public void initKeys(char[] password) {\n    keys[0] = 305419896;\n    keys[1] = 591751049;\n    keys[2] = 878082192;\n    byte[] bytes = convertCharArrayToByteArray(password);\n    for (byte b : bytes) {\n      updateKeys((byte) (b & 0xff));\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/Zip4jUtil.java",
        "start_loc": 98,
        "end_loc": 104,
        "buggy_function": "  public static byte[] convertCharArrayToByteArray(char[] charArray) {\n    byte[] bytes = new byte[charArray.length];\n    for (int i = 0; i < charArray.length; i++) {\n      bytes[i] = (byte) charArray[i];\n    }\n    return bytes;\n  }",
        "fixed_function": "  public static byte[] convertCharArrayToByteArray(char[] charArray) {\n    try {\n      ByteBuffer buf = StandardCharsets.UTF_8.encode(CharBuffer.wrap(charArray));\n      byte[] bytes = new byte[buf.limit()];\n      buf.get(bytes);\n      return bytes;\n    } catch (Exception e) {\n      byte[] bytes = new byte[charArray.length];\n      for (int i = 0; i < charArray.length; i++) {\n        bytes[i] = (byte) charArray[i];\n      }\n      return bytes;\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.util.Zip4jUtilTest::testConvertCharArrayToByteArrayChineseChars": {
        "path": "net/lingala/zip4j/util/Zip4jUtilTest.java",
        "function_name": "testConvertCharArrayToByteArrayChineseChars",
        "src": "@Test\n  public void testConvertCharArrayToByteArrayChineseChars() {\n    char[] charArray = \"\u4f60\u597d\".toCharArray();\n\n    byte[] byteArray = Zip4jUtil.convertCharArrayToByteArray(charArray);\n\n    try {\n      // Make sure that StandardCharsets exists on the classpath\n      Class.forName(\"java.nio.charset.StandardCharsets\");\n      assertThat(byteArray.length).isEqualTo(6);\n      assertThat(byteArray).isEqualTo(new byte[]{-28, -67, -96, -27, -91, -67});\n    } catch (ClassNotFoundException e) {\n      // In some test environments (old Android SDK), StandardCharset class does not exist, in this case\n      // the method under test falls back to converting char to its byte representation\n      assertThat(byteArray.length).isEqualTo(2);\n      assertThat(byteArray).isEqualTo(new byte[]{96, 125});\n    }\n  }",
        "error_msg": "net.lingala.zip4j.util.Zip4jUtilTest::testConvertCharArrayToByteArrayChineseChars --> junit.framework.AssertionFailedError: expected:<[6]> but was:<[2]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[6]> but was:<[2]>"
      }
    }
  },
  "Zip4j-43": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/headers/HeaderReader.java",
        "start_loc": 137,
        "end_loc": 246,
        "buggy_function": "  private CentralDirectory readCentralDirectory(RandomAccessFile zip4jRaf, RawIO rawIO, Charset charset) throws IOException {\n    CentralDirectory centralDirectory = new CentralDirectory();\n    List<FileHeader> fileHeaders = new ArrayList<>();\n\n    long offSetStartCentralDir = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n    long centralDirEntryCount = getNumberOfEntriesInCentralDirectory(zipModel);\n    \n    zip4jRaf.seek(offSetStartCentralDir);\n\n    byte[] shortBuff = new byte[2];\n    byte[] intBuff = new byte[4];\n\n    for (int i = 0; i < centralDirEntryCount; i++) {\n      FileHeader fileHeader = new FileHeader();\n      if (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.CENTRAL_DIRECTORY.getValue()) {\n        throw new ZipException(\"Expected central directory entry not found (#\" + (i + 1) + \")\");\n      }\n      fileHeader.setSignature(HeaderSignature.CENTRAL_DIRECTORY);\n      fileHeader.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));\n      fileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));\n\n      byte[] generalPurposeFlags = new byte[2];\n      zip4jRaf.readFully(generalPurposeFlags);\n      fileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));\n      fileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));\n      fileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));\n      fileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());\n\n      fileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(rawIO.readShortLittleEndian(\n          zip4jRaf)));\n      fileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(zip4jRaf));\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));\n      fileHeader.setCrcRawData(intBuff);\n\n      fileHeader.setCompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));\n      fileHeader.setUncompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));\n\n      int fileNameLength = rawIO.readShortLittleEndian(zip4jRaf);\n      fileHeader.setFileNameLength(fileNameLength);\n\n      fileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(zip4jRaf));\n\n      int fileCommentLength = rawIO.readShortLittleEndian(zip4jRaf);\n      fileHeader.setFileCommentLength(fileCommentLength);\n\n      fileHeader.setDiskNumberStart(rawIO.readShortLittleEndian(zip4jRaf));\n\n      zip4jRaf.readFully(shortBuff);\n      fileHeader.setInternalFileAttributes(shortBuff.clone());\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setExternalFileAttributes(intBuff.clone());\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setOffsetLocalHeader(rawIO.readLongLittleEndian(intBuff, 0));\n\n      if (fileNameLength > 0) {\n        byte[] fileNameBuff = new byte[fileNameLength];\n        zip4jRaf.readFully(fileNameBuff);\n        String fileName = decodeStringWithCharset(fileNameBuff, fileHeader.isFileNameUTF8Encoded(), charset);\n\n        if (fileName.contains(\":\\\\\")) {\n          fileName = fileName.substring(fileName.indexOf(\":\\\\\") + 2);\n        }\n\n        fileHeader.setFileName(fileName);\n        fileHeader.setDirectory(fileName.endsWith(\"/\") || fileName.endsWith(\"\\\\\"));\n      } else {\n        fileHeader.setFileName(null);\n      }\n\n      readExtraDataRecords(zip4jRaf, fileHeader);\n      readZip64ExtendedInfo(fileHeader, rawIO);\n      readAesExtraDataRecord(fileHeader, rawIO);\n\n      if (fileCommentLength > 0) {\n        byte[] fileCommentBuff = new byte[fileCommentLength];\n        zip4jRaf.readFully(fileCommentBuff);\n        fileHeader.setFileComment(decodeStringWithCharset(fileCommentBuff, fileHeader.isFileNameUTF8Encoded(), charset));\n      }\n\n      if (fileHeader.isEncrypted()) {\n        if (fileHeader.getAesExtraDataRecord() != null) {\n          fileHeader.setEncryptionMethod(EncryptionMethod.AES);\n        } else {\n          fileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);\n        }\n      }\n\n      fileHeaders.add(fileHeader);\n    }\n\n    centralDirectory.setFileHeaders(fileHeaders);\n\n    DigitalSignature digitalSignature = new DigitalSignature();\n    if (rawIO.readIntLittleEndian(zip4jRaf) == HeaderSignature.DIGITAL_SIGNATURE.getValue()) {\n      digitalSignature.setSignature(HeaderSignature.DIGITAL_SIGNATURE);\n      digitalSignature.setSizeOfData(rawIO.readShortLittleEndian(zip4jRaf));\n\n      if (digitalSignature.getSizeOfData() > 0) {\n        byte[] signatureDataBuff = new byte[digitalSignature.getSizeOfData()];\n        zip4jRaf.readFully(signatureDataBuff);\n        digitalSignature.setSignatureData(new String(signatureDataBuff));\n      }\n    }\n\n    return centralDirectory;\n  }",
        "fixed_function": "  private CentralDirectory readCentralDirectory(RandomAccessFile zip4jRaf, RawIO rawIO, Charset charset) throws IOException {\n    CentralDirectory centralDirectory = new CentralDirectory();\n    List<FileHeader> fileHeaders = new ArrayList<>();\n\n    long offSetStartCentralDir = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);\n    long centralDirEntryCount = getNumberOfEntriesInCentralDirectory(zipModel);\n    \n    zip4jRaf.seek(offSetStartCentralDir);\n\n    byte[] shortBuff = new byte[2];\n    byte[] intBuff = new byte[4];\n\n    for (int i = 0; i < centralDirEntryCount; i++) {\n      FileHeader fileHeader = new FileHeader();\n      if (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.CENTRAL_DIRECTORY.getValue()) {\n        throw new ZipException(\"Expected central directory entry not found (#\" + (i + 1) + \")\");\n      }\n      fileHeader.setSignature(HeaderSignature.CENTRAL_DIRECTORY);\n      fileHeader.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));\n      fileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));\n\n      byte[] generalPurposeFlags = new byte[2];\n      zip4jRaf.readFully(generalPurposeFlags);\n      fileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));\n      fileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));\n      fileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));\n      fileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());\n\n      fileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(rawIO.readShortLittleEndian(\n          zip4jRaf)));\n      fileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(zip4jRaf));\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));\n      fileHeader.setCrcRawData(intBuff);\n\n      fileHeader.setCompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));\n      fileHeader.setUncompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));\n\n      int fileNameLength = rawIO.readShortLittleEndian(zip4jRaf);\n      fileHeader.setFileNameLength(fileNameLength);\n\n      fileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(zip4jRaf));\n\n      int fileCommentLength = rawIO.readShortLittleEndian(zip4jRaf);\n      fileHeader.setFileCommentLength(fileCommentLength);\n\n      fileHeader.setDiskNumberStart(rawIO.readShortLittleEndian(zip4jRaf));\n\n      zip4jRaf.readFully(shortBuff);\n      fileHeader.setInternalFileAttributes(shortBuff.clone());\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setExternalFileAttributes(intBuff.clone());\n\n      zip4jRaf.readFully(intBuff);\n      fileHeader.setOffsetLocalHeader(rawIO.readLongLittleEndian(intBuff, 0));\n\n      if (fileNameLength > 0) {\n        byte[] fileNameBuff = new byte[fileNameLength];\n        zip4jRaf.readFully(fileNameBuff);\n        String fileName = decodeStringWithCharset(fileNameBuff, fileHeader.isFileNameUTF8Encoded(), charset);\n\n        if (fileName.contains(\":\\\\\")) {\n          fileName = fileName.substring(fileName.indexOf(\":\\\\\") + 2);\n        }\n\n        fileHeader.setFileName(fileName);\n      } else {\n        fileHeader.setFileName(null);\n      }\n\n      fileHeader.setDirectory(isDirectory(fileHeader.getExternalFileAttributes(), fileHeader.getFileName()));\n      readExtraDataRecords(zip4jRaf, fileHeader);\n      readZip64ExtendedInfo(fileHeader, rawIO);\n      readAesExtraDataRecord(fileHeader, rawIO);\n\n      if (fileCommentLength > 0) {\n        byte[] fileCommentBuff = new byte[fileCommentLength];\n        zip4jRaf.readFully(fileCommentBuff);\n        fileHeader.setFileComment(decodeStringWithCharset(fileCommentBuff, fileHeader.isFileNameUTF8Encoded(), charset));\n      }\n\n      if (fileHeader.isEncrypted()) {\n        if (fileHeader.getAesExtraDataRecord() != null) {\n          fileHeader.setEncryptionMethod(EncryptionMethod.AES);\n        } else {\n          fileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);\n        }\n      }\n\n      fileHeaders.add(fileHeader);\n    }\n\n    centralDirectory.setFileHeaders(fileHeaders);\n\n    DigitalSignature digitalSignature = new DigitalSignature();\n    if (rawIO.readIntLittleEndian(zip4jRaf) == HeaderSignature.DIGITAL_SIGNATURE.getValue()) {\n      digitalSignature.setSignature(HeaderSignature.DIGITAL_SIGNATURE);\n      digitalSignature.setSizeOfData(rawIO.readShortLittleEndian(zip4jRaf));\n\n      if (digitalSignature.getSizeOfData() > 0) {\n        byte[] signatureDataBuff = new byte[digitalSignature.getSizeOfData()];\n        zip4jRaf.readFully(signatureDataBuff);\n        digitalSignature.setSignatureData(new String(signatureDataBuff));\n      }\n    }\n\n    return centralDirectory;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/headers/HeaderReader.java",
        "start_loc": 739,
        "end_loc": 752,
        "buggy_function": "  private String readZipComment(RandomAccessFile raf, int commentLength, Charset charset) {\n    if (commentLength <= 0) {\n      return null;\n    }\n\n    try {\n      byte[] commentBuf = new byte[commentLength];\n      raf.readFully(commentBuf);\n      return new String(commentBuf, charset);\n    } catch (IOException e) {\n      // Ignore any exception and set comment to null if comment cannot be read\n      return null;\n    }\n  }",
        "fixed_function": "  public boolean isDirectory(byte[] externalFileAttributes, String fileName) {\n    // first check if DOS attributes are set (lower order bytes from external attributes). If yes, check if the 4th bit\n    // which represents a directory is set. If UNIX attributes are set (higher order two bytes), check for the 6th bit\n    // in 4th byte which  represents a directory flag.\n    if (externalFileAttributes[0] != 0 && isBitSet(externalFileAttributes[0], 4)) {\n      return true;\n    } else if (externalFileAttributes[3] != 0 && isBitSet(externalFileAttributes[3], 6))  {\n      return true;\n    }\n\n    return fileName != null && (fileName.endsWith(\"/\") || fileName.endsWith(\"\\\\\"));\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java",
        "start_loc": 79,
        "end_loc": 104,
        "buggy_function": "  public LocalFileHeader getNextEntry(FileHeader fileHeader) throws IOException {\n    if (localFileHeader != null) {\n      readUntilEndOfEntry();\n    }\n\n    localFileHeader = headerReader.readLocalFileHeader(inputStream, charset);\n\n    if (localFileHeader == null) {\n      return null;\n    }\n\n    verifyLocalFileHeader(localFileHeader);\n    crc32.reset();\n\n    if (fileHeader != null) {\n      localFileHeader.setCrc(fileHeader.getCrc());\n      localFileHeader.setCompressedSize(fileHeader.getCompressedSize());\n      localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());\n      canSkipExtendedLocalFileHeader = true;\n    } else {\n      canSkipExtendedLocalFileHeader = false;\n    }\n\n    this.decompressedInputStream = initializeEntryInputStream(localFileHeader);\n    return localFileHeader;\n  }",
        "fixed_function": "  public LocalFileHeader getNextEntry(FileHeader fileHeader) throws IOException {\n    if (localFileHeader != null) {\n      readUntilEndOfEntry();\n    }\n\n    localFileHeader = headerReader.readLocalFileHeader(inputStream, charset);\n\n    if (localFileHeader == null) {\n      return null;\n    }\n\n    verifyLocalFileHeader(localFileHeader);\n    crc32.reset();\n\n    if (fileHeader != null) {\n      localFileHeader.setCrc(fileHeader.getCrc());\n      localFileHeader.setCompressedSize(fileHeader.getCompressedSize());\n      localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());\n      // file header's directory flag is more reliable than local file header's directory flag as file header has\n      // additional external file attributes which has a directory flag defined. In local file header, the only way\n      // to determine if an entry is directory is to check if the file name has a trailing forward slash \"/\"\n      localFileHeader.setDirectory(fileHeader.isDirectory());\n      canSkipExtendedLocalFileHeader = true;\n    } else {\n      canSkipExtendedLocalFileHeader = false;\n    }\n\n    this.decompressedInputStream = initializeEntryInputStream(localFileHeader);\n    return localFileHeader;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/FileUtils.java",
        "start_loc": 206,
        "end_loc": 272,
        "buggy_function": "  public static String getRelativeFileName(File fileToAdd, ZipParameters zipParameters) throws ZipException {\n\n    String fileName;\n    try {\n      String fileCanonicalPath = fileToAdd.getCanonicalPath();\n      if (isStringNotNullAndNotEmpty(zipParameters.getDefaultFolderPath())) {\n        File rootFolderFile = new File(zipParameters.getDefaultFolderPath());\n        String rootFolderFileRef = rootFolderFile.getCanonicalPath();\n\n        if (!rootFolderFileRef.endsWith(FILE_SEPARATOR)) {\n          rootFolderFileRef += FILE_SEPARATOR;\n        }\n\n        String tmpFileName;\n\n        if (isSymbolicLink(fileToAdd)) {\n          String rootPath = new File(fileToAdd.getParentFile().getCanonicalFile().getPath() + File.separator + fileToAdd.getCanonicalFile().getName()).getPath();\n          tmpFileName = rootPath.substring(rootFolderFileRef.length());\n        } else {\n           tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());\n        }\n\n        if (tmpFileName.startsWith(System.getProperty(\"file.separator\"))) {\n          tmpFileName = tmpFileName.substring(1);\n        }\n\n        File tmpFile = new File(fileCanonicalPath);\n\n        if (tmpFile.isDirectory()) {\n          tmpFileName = tmpFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName += ZIP_FILE_SEPARATOR;\n        } else {\n          String bkFileName = tmpFileName.substring(0, tmpFileName.lastIndexOf(tmpFile.getName()));\n          bkFileName = bkFileName.replaceAll(\"\\\\\\\\\", \"/\");\n          tmpFileName = bkFileName + getNameOfFileInZip(tmpFile, zipParameters.getFileNameInZip());\n        }\n\n        fileName = tmpFileName;\n      } else {\n        File relFile = new File(fileCanonicalPath);\n        fileName = getNameOfFileInZip(relFile, zipParameters.getFileNameInZip());\n        if (relFile.isDirectory()) {\n          fileName += ZIP_FILE_SEPARATOR;\n        }\n      }\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n\n    String rootFolderNameInZip = zipParameters.getRootFolderNameInZip();\n    if (Zip4jUtil.isStringNotNullAndNotEmpty(rootFolderNameInZip)) {\n      if (!rootFolderNameInZip.endsWith(\"\\\\\") && !rootFolderNameInZip.endsWith(\"/\")) {\n        rootFolderNameInZip = rootFolderNameInZip + InternalZipConstants.FILE_SEPARATOR;\n      }\n\n      rootFolderNameInZip = rootFolderNameInZip.replaceAll(\"\\\\\\\\\", ZIP_FILE_SEPARATOR);\n      fileName = rootFolderNameInZip + fileName;\n    }\n\n    if (!isStringNotNullAndNotEmpty(fileName)) {\n      throw new ZipException(\"fileName to add to zip is empty or null. fileName: '\" + fileName\n          + \"'. DefaultFolderPath: '\" + zipParameters.getDefaultFolderPath() + \"'. \"\n          + \"isSymlink: \" + isSymbolicLink(fileToAdd));\n    }\n\n    return fileName;\n  }",
        "fixed_function": "  public static String getRelativeFileName(File fileToAdd, ZipParameters zipParameters) throws ZipException {\n\n    String fileName;\n    try {\n      String fileCanonicalPath = fileToAdd.getCanonicalPath();\n      if (isStringNotNullAndNotEmpty(zipParameters.getDefaultFolderPath())) {\n        File rootFolderFile = new File(zipParameters.getDefaultFolderPath());\n        String rootFolderFileRef = rootFolderFile.getCanonicalPath();\n\n        if (!rootFolderFileRef.endsWith(FILE_SEPARATOR)) {\n          rootFolderFileRef += FILE_SEPARATOR;\n        }\n\n        String tmpFileName;\n\n        if (isSymbolicLink(fileToAdd)) {\n          String rootPath = new File(fileToAdd.getParentFile().getCanonicalFile().getPath() + File.separator + fileToAdd.getCanonicalFile().getName()).getPath();\n          tmpFileName = rootPath.substring(rootFolderFileRef.length());\n        } else {\n           tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());\n        }\n\n        if (tmpFileName.startsWith(System.getProperty(\"file.separator\"))) {\n          tmpFileName = tmpFileName.substring(1);\n        }\n\n        File tmpFile = new File(fileCanonicalPath);\n\n        if (tmpFile.isDirectory()) {\n          tmpFileName = tmpFileName.replaceAll(\"\\\\\\\\\", ZIP_FILE_SEPARATOR);\n          tmpFileName += ZIP_FILE_SEPARATOR;\n        } else {\n          String bkFileName = tmpFileName.substring(0, tmpFileName.lastIndexOf(tmpFile.getName()));\n          bkFileName = bkFileName.replaceAll(\"\\\\\\\\\", ZIP_FILE_SEPARATOR);\n          tmpFileName = bkFileName + getNameOfFileInZip(tmpFile, zipParameters.getFileNameInZip());\n        }\n\n        fileName = tmpFileName;\n      } else {\n        File relFile = new File(fileCanonicalPath);\n        fileName = getNameOfFileInZip(relFile, zipParameters.getFileNameInZip());\n        if (relFile.isDirectory()) {\n          fileName += ZIP_FILE_SEPARATOR;\n        }\n      }\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n\n    String rootFolderNameInZip = zipParameters.getRootFolderNameInZip();\n    if (Zip4jUtil.isStringNotNullAndNotEmpty(rootFolderNameInZip)) {\n      if (!rootFolderNameInZip.endsWith(\"\\\\\") && !rootFolderNameInZip.endsWith(\"/\")) {\n        rootFolderNameInZip = rootFolderNameInZip + InternalZipConstants.FILE_SEPARATOR;\n      }\n\n      rootFolderNameInZip = rootFolderNameInZip.replaceAll(\"\\\\\\\\\", ZIP_FILE_SEPARATOR);\n      fileName = rootFolderNameInZip + fileName;\n    }\n\n    if (!isStringNotNullAndNotEmpty(fileName)) {\n      throw new ZipException(\"fileName to add to zip is empty or null. fileName: '\" + fileName\n          + \"'. DefaultFolderPath: '\" + zipParameters.getDefaultFolderPath() + \"'. \"\n          + \"isSymlink: \" + isSymbolicLink(fileToAdd));\n    }\n\n    return fileName;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/FileUtils.java",
        "start_loc": 483,
        "end_loc": 503,
        "buggy_function": "  private static byte[] getWindowsFileAttributes(Path file) {\n    byte[] fileAttributes = new byte[4];\n\n    try {\n      DosFileAttributeView dosFileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class,\n          LinkOption.NOFOLLOW_LINKS);\n      DosFileAttributes dosFileAttributes = dosFileAttributeView.readAttributes();\n\n      byte windowsAttribute = 0;\n\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isReadOnly(), windowsAttribute, 0);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isHidden(), windowsAttribute, 1);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isSystem(), windowsAttribute, 2);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isArchive(), windowsAttribute, 5);\n      fileAttributes[0] = windowsAttribute;\n    } catch (IOException e) {\n      // ignore\n    }\n\n    return fileAttributes;\n  }",
        "fixed_function": "  private static byte[] getWindowsFileAttributes(Path file) {\n    byte[] fileAttributes = new byte[4];\n\n    try {\n      DosFileAttributeView dosFileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class,\n          LinkOption.NOFOLLOW_LINKS);\n      DosFileAttributes dosFileAttributes = dosFileAttributeView.readAttributes();\n\n      byte windowsAttribute = 0;\n\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isReadOnly(), windowsAttribute, 0);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isHidden(), windowsAttribute, 1);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isSystem(), windowsAttribute, 2);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isDirectory(), windowsAttribute, 4);\n      windowsAttribute = setBitIfApplicable(dosFileAttributes.isArchive(), windowsAttribute, 5);\n      fileAttributes[0] = windowsAttribute;\n    } catch (IOException e) {\n      // ignore\n    }\n\n    return fileAttributes;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.util.FileUtilsTestWindows::testGetFileAttributesForDirectory": {
        "path": "net/lingala/zip4j/util/FileUtilsTestWindows.java",
        "function_name": "testGetFileAttributesForDirectory",
        "src": "@Test\n  public void testGetFileAttributesForDirectory() throws IOException {\n    testGetFileAttributes(true);\n  }",
        "error_msg": "net.lingala.zip4j.util.FileUtilsTestWindows::testGetFileAttributesForDirectory --> junit.framework.AssertionFailedError: expected:<[tru]e> but was:<[fals]e>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[tru]e> but was:<[fals]e>"
      }
    }
  },
  "Zip4j-47": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java",
        "start_loc": 26,
        "end_loc": 72,
        "buggy_function": "  @Override\n  protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n\n    verifyZipParameters(taskParameters.zipParameters);\n\n    if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) {\n      throw new ZipException(\"fileNameInZip has to be set in zipParameters when adding stream\");\n    }\n\n    removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),\n        progressMonitor);\n\n    // For streams, it is necessary to write extended local file header because of Zip standard encryption.\n    // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,\n    // which cannot be calculated until we read the complete stream. If we use extended local file header,\n    // last modified file time is used, or current system time if not available.\n    taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);\n\n    if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) {\n      // Set some random value here. This will be updated again when closing entry\n      taskParameters.zipParameters.setEntrySize(0);\n    }\n\n    try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());\n        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {\n\n      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];\n      int readLen;\n\n      ZipParameters zipParameters = taskParameters.zipParameters;\n      zipOutputStream.putNextEntry(zipParameters);\n\n      if (!zipParameters.getFileNameInZip().endsWith(\"/\") &&\n          !zipParameters.getFileNameInZip().endsWith(\"\\\\\")) {\n        while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) {\n          zipOutputStream.write(readBuff, 0, readLen);\n        }\n      }\n\n      FileHeader fileHeader = zipOutputStream.closeEntry();\n\n      if (fileHeader.getCompressionMethod().equals(CompressionMethod.STORE)) {\n        updateLocalFileHeader(fileHeader, splitOutputStream);\n      }\n    }\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n\n    verifyZipParameters(taskParameters.zipParameters);\n\n    if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) {\n      throw new ZipException(\"fileNameInZip has to be set in zipParameters when adding stream\");\n    }\n\n    removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),\n        progressMonitor);\n\n    if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) {\n      // Set some random value here. This will be updated again when closing entry\n      taskParameters.zipParameters.setEntrySize(0);\n      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false);\n    } else {\n      // For streams, it is necessary to write extended local file header because of Zip standard encryption.\n      // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,\n      // which cannot be calculated until we read the complete stream. If we use extended local file header,\n      // last modified file time is used, or current system time if not available.\n      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);\n    }\n\n    try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());\n        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {\n\n      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];\n      int readLen;\n\n      ZipParameters zipParameters = taskParameters.zipParameters;\n      zipOutputStream.putNextEntry(zipParameters);\n\n      if (!zipParameters.getFileNameInZip().endsWith(\"/\") &&\n          !zipParameters.getFileNameInZip().endsWith(\"\\\\\")) {\n        while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) {\n          zipOutputStream.write(readBuff, 0, readLen);\n        }\n      }\n\n      FileHeader fileHeader = zipOutputStream.closeEntry();\n\n      if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) {\n        updateLocalFileHeader(fileHeader, splitOutputStream);\n      }\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/Zip4jUtil.java",
        "start_loc": 115,
        "end_loc": 125,
        "buggy_function": "  public static CompressionMethod getCompressionMethod(LocalFileHeader localFileHeader) {\n    if (localFileHeader.getCompressionMethod() != CompressionMethod.AES_INTERNAL_ONLY) {\n      return localFileHeader.getCompressionMethod();\n    }\n\n    if (localFileHeader.getAesExtraDataRecord() == null) {\n      throw new RuntimeException(\"AesExtraDataRecord not present in local header for aes encrypted data\");\n    }\n\n    return localFileHeader.getAesExtraDataRecord().getCompressionMethod();\n  }",
        "fixed_function": "  public static CompressionMethod getCompressionMethod(AbstractFileHeader localFileHeader) {\n    if (localFileHeader.getCompressionMethod() != CompressionMethod.AES_INTERNAL_ONLY) {\n      return localFileHeader.getCompressionMethod();\n    }\n\n    if (localFileHeader.getAesExtraDataRecord() == null) {\n      throw new RuntimeException(\"AesExtraDataRecord not present in local header for aes encrypted data\");\n    }\n\n    return localFileHeader.getAesExtraDataRecord().getCompressionMethod();\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.AddFilesToZipIT::testAddStreamWithStoreCompressionAndAesEncryptionWorksFine": {
        "path": "net/lingala/zip4j/AddFilesToZipIT.java",
        "function_name": "testAddStreamWithStoreCompressionAndAesEncryptionWorksFine",
        "src": "@Test\n  public void testAddStreamWithStoreCompressionAndAesEncryptionWorksFine() throws IOException {\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    File fileToAdd = TestUtils.getTestFileFromResources(\"sample.pdf\");\n\n    try(InputStream inputStream = new FileInputStream(fileToAdd)) {\n      ZipParameters zipParameters = new ZipParameters();\n      zipParameters.setCompressionMethod(CompressionMethod.STORE);\n      zipParameters.setEncryptionMethod(EncryptionMethod.AES);\n      zipParameters.setEncryptFiles(true);\n      zipParameters.setFileNameInZip(fileToAdd.getName());\n      zipFile.addStream(inputStream, zipParameters);\n    }\n\n    extractZipFileWithStream(generatedZipFile, PASSWORD);\n  }",
        "error_msg": "net.lingala.zip4j.AddFilesToZipIT::testAddStreamWithStoreCompressionAndAesEncryptionWorksFine --> java.io.IOException: Reached end of data for this entry, but aes verification failed",
        "clean_error_msg": "java.io.IOException: Reached end of data for this entry, but aes verification failed"
      }
    }
  },
  "Zip4j-49": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java",
        "start_loc": 82,
        "end_loc": 84,
        "buggy_function": "  public LocalFileHeader getNextEntry() throws IOException {\n    return getNextEntry(null);\n  }",
        "fixed_function": "  public LocalFileHeader getNextEntry() throws IOException {\n    return getNextEntry(null, true);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java",
        "start_loc": 86,
        "end_loc": 116,
        "buggy_function": "  public LocalFileHeader getNextEntry(FileHeader fileHeader) throws IOException {\n    if (localFileHeader != null) {\n      readUntilEndOfEntry();\n    }\n\n    localFileHeader = headerReader.readLocalFileHeader(inputStream, zip4jConfig.getCharset());\n\n    if (localFileHeader == null) {\n      return null;\n    }\n\n    verifyLocalFileHeader(localFileHeader);\n    crc32.reset();\n\n    if (fileHeader != null) {\n      localFileHeader.setCrc(fileHeader.getCrc());\n      localFileHeader.setCompressedSize(fileHeader.getCompressedSize());\n      localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());\n      // file header's directory flag is more reliable than local file header's directory flag as file header has\n      // additional external file attributes which has a directory flag defined. In local file header, the only way\n      // to determine if an entry is directory is to check if the file name has a trailing forward slash \"/\"\n      localFileHeader.setDirectory(fileHeader.isDirectory());\n      canSkipExtendedLocalFileHeader = true;\n    } else {\n      canSkipExtendedLocalFileHeader = false;\n    }\n\n    this.decompressedInputStream = initializeEntryInputStream(localFileHeader);\n    this.entryEOFReached = false;\n    return localFileHeader;\n  }",
        "fixed_function": "  public LocalFileHeader getNextEntry(FileHeader fileHeader, boolean readUntilEndOfCurrentEntryIfOpen)\n      throws IOException {\n\n    if (localFileHeader != null && readUntilEndOfCurrentEntryIfOpen) {\n      readUntilEndOfEntry();\n    }\n\n    localFileHeader = headerReader.readLocalFileHeader(inputStream, zip4jConfig.getCharset());\n\n    if (localFileHeader == null) {\n      return null;\n    }\n\n    verifyLocalFileHeader(localFileHeader);\n    crc32.reset();\n\n    if (fileHeader != null) {\n      localFileHeader.setCrc(fileHeader.getCrc());\n      localFileHeader.setCompressedSize(fileHeader.getCompressedSize());\n      localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());\n      // file header's directory flag is more reliable than local file header's directory flag as file header has\n      // additional external file attributes which has a directory flag defined. In local file header, the only way\n      // to determine if an entry is directory is to check if the file name has a trailing forward slash \"/\"\n      localFileHeader.setDirectory(fileHeader.isDirectory());\n      canSkipExtendedLocalFileHeader = true;\n    } else {\n      canSkipExtendedLocalFileHeader = false;\n    }\n\n    this.decompressedInputStream = initializeEntryInputStream(localFileHeader);\n    this.entryEOFReached = false;\n    return localFileHeader;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java",
        "start_loc": 137,
        "end_loc": 153,
        "buggy_function": "  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {\n    if (BitUtils.isBitSet(fileHeader.getGeneralPurposeFlag()[0], 6)) {\n      throw new ZipException(\"Entry with name \" + fileHeader.getFileName() + \" is encrypted with Strong Encryption. \" +\n          \"Zip4j does not support Strong Encryption, as this is patented.\");\n    }\n\n    LocalFileHeader localFileHeader = zipInputStream.getNextEntry(fileHeader);\n\n    if (localFileHeader == null) {\n      throw new ZipException(\"Could not read corresponding local file header for file header: \"\n          + fileHeader.getFileName());\n    }\n\n    if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {\n      throw new ZipException(\"File header and local file header mismatch\");\n    }\n  }",
        "fixed_function": "  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {\n    if (BitUtils.isBitSet(fileHeader.getGeneralPurposeFlag()[0], 6)) {\n      throw new ZipException(\"Entry with name \" + fileHeader.getFileName() + \" is encrypted with Strong Encryption. \" +\n          \"Zip4j does not support Strong Encryption, as this is patented.\");\n    }\n\n    LocalFileHeader localFileHeader = zipInputStream.getNextEntry(fileHeader, false);\n\n    if (localFileHeader == null) {\n      throw new ZipException(\"Could not read corresponding local file header for file header: \"\n          + fileHeader.getFileName());\n    }\n\n    if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {\n      throw new ZipException(\"File header and local file header mismatch\");\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/UnzipUtil.java",
        "start_loc": 21,
        "end_loc": 41,
        "buggy_function": "  public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws IOException {\n\n    SplitInputStream splitInputStream = null;\n    try {\n      splitInputStream = createSplitInputStream(zipModel);\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry(fileHeader) == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      if (splitInputStream != null) {\n        splitInputStream.close();\n      }\n      throw e;\n    }\n  }",
        "fixed_function": "  public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws IOException {\n\n    SplitInputStream splitInputStream = null;\n    try {\n      splitInputStream = createSplitInputStream(zipModel);\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry(fileHeader, false) == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      if (splitInputStream != null) {\n        splitInputStream.close();\n      }\n      throw e;\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.ExtractZipFileIT::testExtractJarFileWithFileHeaderCompressedSize2": {
        "path": "net/lingala/zip4j/ExtractZipFileIT.java",
        "function_name": "testExtractJarFileWithFileHeaderCompressedSize2",
        "src": "@Test\n  public void testExtractJarFileWithFileHeaderCompressedSize2() throws IOException {\n    extractFile(TestUtils.getTestArchiveFromResources(\"jar-dir-fh-entry-size-2.jar\"));\n  }",
        "error_msg": "net.lingala.zip4j.ExtractZipFileIT::testExtractJarFileWithFileHeaderCompressedSize2 --> net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: java.io.EOFException: Unexpected end of input stream"
      }
    }
  },
  "Zip4j-52": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java",
        "start_loc": 28,
        "end_loc": 75,
        "buggy_function": "  @Override\n  protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n\n    verifyZipParameters(taskParameters.zipParameters);\n\n    if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) {\n      throw new ZipException(\"fileNameInZip has to be set in zipParameters when adding stream\");\n    }\n\n    removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),\n        progressMonitor);\n\n    if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) {\n      // Set some random value here. This will be updated again when closing entry\n      taskParameters.zipParameters.setEntrySize(0);\n      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false);\n    } else {\n      // For streams, it is necessary to write extended local file header because of Zip standard encryption.\n      // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,\n      // which cannot be calculated until we read the complete stream. If we use extended local file header,\n      // last modified file time is used, or current system time if not available.\n      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);\n    }\n\n    try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());\n        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {\n\n      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];\n      int readLen;\n\n      ZipParameters zipParameters = taskParameters.zipParameters;\n      zipOutputStream.putNextEntry(zipParameters);\n\n      if (!zipParameters.getFileNameInZip().endsWith(\"/\") &&\n          !zipParameters.getFileNameInZip().endsWith(\"\\\\\")) {\n        while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) {\n          zipOutputStream.write(readBuff, 0, readLen);\n        }\n      }\n\n      FileHeader fileHeader = zipOutputStream.closeEntry();\n\n      if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) {\n        updateLocalFileHeader(fileHeader, splitOutputStream);\n      }\n    }\n  }",
        "fixed_function": "  @Override\n  protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)\n      throws IOException {\n\n    verifyZipParameters(taskParameters.zipParameters);\n\n    if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) {\n      throw new ZipException(\"fileNameInZip has to be set in zipParameters when adding stream\");\n    }\n\n    removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),\n        progressMonitor);\n\n    // For streams, it is necessary to write extended local file header because of Zip standard encryption.\n    // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,\n    // which cannot be calculated until we read the complete stream. If we use extended local file header,\n    // last modified file time is used, or current system time if not available.\n    taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);\n\n    if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) {\n      // Set some random value here. This will be updated again when closing entry\n      taskParameters.zipParameters.setEntrySize(0);\n    }\n\n    try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());\n        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {\n\n      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];\n      int readLen;\n\n      ZipParameters zipParameters = taskParameters.zipParameters;\n      zipOutputStream.putNextEntry(zipParameters);\n\n      if (!zipParameters.getFileNameInZip().endsWith(\"/\") &&\n          !zipParameters.getFileNameInZip().endsWith(\"\\\\\")) {\n        while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) {\n          zipOutputStream.write(readBuff, 0, readLen);\n        }\n      }\n\n      FileHeader fileHeader = zipOutputStream.closeEntry();\n\n      if (fileHeader.getCompressionMethod().equals(CompressionMethod.STORE)) {\n        updateLocalFileHeader(fileHeader, splitOutputStream);\n      }\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/lingala/zip4j/util/Zip4jUtil.java",
        "start_loc": 115,
        "end_loc": 125,
        "buggy_function": "  public static CompressionMethod getCompressionMethod(AbstractFileHeader localFileHeader) {\n    if (localFileHeader.getCompressionMethod() != CompressionMethod.AES_INTERNAL_ONLY) {\n      return localFileHeader.getCompressionMethod();\n    }\n\n    if (localFileHeader.getAesExtraDataRecord() == null) {\n      throw new RuntimeException(\"AesExtraDataRecord not present in local header for aes encrypted data\");\n    }\n\n    return localFileHeader.getAesExtraDataRecord().getCompressionMethod();\n  }",
        "fixed_function": "  public static CompressionMethod getCompressionMethod(LocalFileHeader localFileHeader) {\n    if (localFileHeader.getCompressionMethod() != CompressionMethod.AES_INTERNAL_ONLY) {\n      return localFileHeader.getCompressionMethod();\n    }\n\n    if (localFileHeader.getAesExtraDataRecord() == null) {\n      throw new RuntimeException(\"AesExtraDataRecord not present in local header for aes encrypted data\");\n    }\n\n    return localFileHeader.getAesExtraDataRecord().getCompressionMethod();\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.lingala.zip4j.AddFilesToZipIT::testAddStreamToWithStoreCompressionAndZipStandardEncryption": {
        "path": "net/lingala/zip4j/AddFilesToZipIT.java",
        "function_name": "testAddStreamToWithStoreCompressionAndZipStandardEncryption",
        "src": "@Test\n  public void testAddStreamToWithStoreCompressionAndZipStandardEncryption() throws IOException {\n    File fileToAdd = TestUtils.getTestFileFromResources(\"sample_text_large.txt\");\n    ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);\n    zipParameters.setCompressionMethod(CompressionMethod.STORE);\n    zipParameters.setFileNameInZip(fileToAdd.getName());\n    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    InputStream inputStream = new FileInputStream(fileToAdd);\n\n    zipFile.addStream(inputStream, zipParameters);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 1);\n    verifyZipFileContainsFiles(generatedZipFile, singletonList(\"sample_text_large.txt\"), CompressionMethod.STORE,\n        EncryptionMethod.ZIP_STANDARD, null);\n\n    zipFile = new ZipFile(generatedZipFile, PASSWORD);\n    byte[] generalPurposeBytes = zipFile.getFileHeaders().get(0).getGeneralPurposeFlag();\n    // assert that extra data record is not present\n    assertThat(BitUtils.isBitSet(generalPurposeBytes[0], 3)).isTrue();\n  }",
        "error_msg": "net.lingala.zip4j.AddFilesToZipIT::testAddStreamToWithStoreCompressionAndZipStandardEncryption --> net.lingala.zip4j.exception.ZipException: Wrong password!",
        "clean_error_msg": "net.lingala.zip4j.exception.ZipException: Wrong password!"
      },
      "net.lingala.zip4j.AddFilesToZipIT::testAddStreamToWithStoreCompressionAndWithoutEncryption": {
        "path": "net/lingala/zip4j/AddFilesToZipIT.java",
        "function_name": "testAddStreamToWithStoreCompressionAndWithoutEncryption",
        "src": "@Test\n  public void testAddStreamToWithStoreCompressionAndWithoutEncryption() throws IOException {\n    File fileToAdd = TestUtils.getTestFileFromResources(\"\u0431\u043e\u0440\u0435\u0438\u0441\u043a\u0430\u044f.txt\");\n    ZipParameters zipParameters = new ZipParameters();\n    zipParameters.setCompressionMethod(CompressionMethod.STORE);\n    zipParameters.setFileNameInZip(fileToAdd.getName());\n    ZipFile zipFile = new ZipFile(generatedZipFile);\n    InputStream inputStream = new FileInputStream(fileToAdd);\n\n    zipFile.addStream(inputStream, zipParameters);\n\n    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);\n    verifyZipFileContainsFiles(generatedZipFile, singletonList(\"\u0431\u043e\u0440\u0435\u0438\u0441\u043a\u0430\u044f.txt\"), CompressionMethod.STORE, null, null);\n\n    zipFile = new ZipFile(generatedZipFile);\n    byte[] generalPurposeBytes = zipFile.getFileHeaders().get(0).getGeneralPurposeFlag();\n    // assert that extra data record is not present\n    assertThat(BitUtils.isBitSet(generalPurposeBytes[0], 3)).isTrue();\n  }",
        "error_msg": "net.lingala.zip4j.AddFilesToZipIT::testAddStreamToWithStoreCompressionAndWithoutEncryption --> junit.framework.AssertionFailedError: expected:<[tru]e> but was:<[fals]e>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[tru]e> but was:<[fals]e>"
      }
    }
  },
  "Assertj_assertions_generator-6": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/fest/assertions/generator/description/converter/ClassToClassDescriptionConverter.java",
        "start_loc": 59,
        "end_loc": 86,
        "buggy_function": "  private Set<TypeName> getNeededImportsFor(Class<?> clazz) {\n    // collect property types\n    Set<Class<?>> classesToImport = new HashSet<Class<?>>();\n    for (Method getter : getterMethodsOf(clazz)) {\n      Class<?> propertyType = getter.getReturnType();\n      if (propertyType.isArray()) {\n        // we only need the component type, that is T in T[] array\n        classesToImport.add(propertyType.getComponentType());\n      } else if (isIterable(propertyType)) {\n        // we need the Iterable parameter type, that is T in Iterable<T> \n        // we don't need to import the Iterable since it does not appear directly in generated code, ex :\n        // assertThat(actual.getTeamMates()).contains(teamMates); // teamMates -> List\n        ParameterizedType parameterizedType = (ParameterizedType) getter.getGenericReturnType();\n        Class<?> actualParameterClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n        classesToImport.add(actualParameterClass);\n        // return type is generic type, add it and all its parameters type.\n      } else {\n        // return type is not generic type, simply add it.\n        classesToImport.add(propertyType);\n      }\n    }\n    // convert to TypeName, excluding primitive or types in java.lang that don't need to be imported.\n    Set<TypeName> typeToImports = new TreeSet<TypeName>();\n    for (Class<?> propertyType : classesToImport) {\n        typeToImports.add(new TypeName(propertyType));\n    }\n    return typeToImports;\n  }",
        "fixed_function": "  private Set<TypeName> getNeededImportsFor(Class<?> clazz) {\n    // collect property types\n    Set<Class<?>> classesToImport = new HashSet<Class<?>>();\n    for (Method getter : getterMethodsOf(clazz)) {\n      Class<?> propertyType = getter.getReturnType();\n      if (propertyType.isArray()) {\n        // we only need the component type, that is T in T[] array\n        classesToImport.add(propertyType.getComponentType());\n      } else if (isIterable(propertyType)) {\n        // we need the Iterable parameter type, that is T in Iterable<T> \n        // we don't need to import the Iterable since it does not appear directly in generated code, ex :\n        // assertThat(actual.getTeamMates()).contains(teamMates); // teamMates -> List\n        ParameterizedType parameterizedType = (ParameterizedType) getter.getGenericReturnType();\n        Class<?> actualParameterClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n        classesToImport.add(actualParameterClass);\n      } else if (getter.getGenericReturnType() instanceof ParameterizedType) {\n        // return type is generic type, add it and all its parameters type.\n        ParameterizedType parameterizedType = (ParameterizedType) getter.getGenericReturnType();\n        classesToImport.addAll(getClassesRelatedTo(parameterizedType));\n      } else {\n        // return type is not generic type, simply add it.\n        classesToImport.add(propertyType);\n      }\n    }\n    // convert to TypeName, excluding primitive or types in java.lang that don't need to be imported.\n    Set<TypeName> typeToImports = new TreeSet<TypeName>();\n    for (Class<?> propertyType : classesToImport) {\n      if (!propertyType.isPrimitive() && !JAVA_LANG_PACKAGE.equals(propertyType.getPackage().getName())) {\n        typeToImports.add(new TypeName(propertyType));\n      }\n    }\n    return typeToImports;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/fest/assertions/generator/util/ClassUtil.java",
        "start_loc": 206,
        "end_loc": 223,
        "buggy_function": "  public static List<Method> getterMethodsOf(Class<?> clazz) {\n    Method[] declaredMethods = clazz.getDeclaredMethods();\n    List<Method> getters = new ArrayList<Method>();\n    for (int i = 0; i < declaredMethods.length; i++) {\n      Method method = declaredMethods[i];\n      if (isStandardGetter(method) || isBooleanGetter(method)) {\n        // probably a getter\n        getters.add(method);\n      }\n    }\n    return getters;\n\n\n    // non generic type : just add current type.\n\n    // generic type : add current type and its parameter types\n        // I'm almost sure we should not arrive here !\n  }",
        "fixed_function": "  public static List<Method> getterMethodsOf(Class<?> clazz) {\n    Method[] declaredMethods = clazz.getDeclaredMethods();\n    List<Method> getters = new ArrayList<Method>();\n    for (int i = 0; i < declaredMethods.length; i++) {\n      Method method = declaredMethods[i];\n      if (isStandardGetter(method) || isBooleanGetter(method)) {\n        // probably a getter\n        getters.add(method);\n      }\n    }\n    return getters;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.fest.assertions.generator.description.converter.ClassToClassDescriptionConverterTest::should_build_player_class_description": {
        "path": "org/fest/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java",
        "function_name": "should_build_player_class_description",
        "src": "@Test\n  public void should_build_player_class_description() throws Exception {\n    ClassDescription classDescription = converter.convertToClassDescription(Player.class);\n    assertThat(classDescription.getClassName()).isEqualTo(\"Player\");\n    assertThat(classDescription.getPackageName()).isEqualTo(\"org.fest.assertions.generator.data\");\n    assertThat(classDescription.getGetters()).hasSize(8);\n    assertThat(classDescription.getImports()).containsOnly(new TypeName(Player.class), new TypeName(Name.class));\n  }",
        "error_msg": "org.fest.assertions.generator.description.converter.ClassToClassDescriptionConverterTest::should_build_player_class_description --> junit.framework.AssertionFailedError: expecting:",
        "clean_error_msg": "junit.framework.AssertionFailedError: expecting:"
      },
      "org.fest.assertions.generator.description.converter.ClassToClassDescriptionConverterTest::should_build_fellowshipOfTheRing_class_description": {
        "path": "org/fest/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java",
        "function_name": "should_build_fellowshipOfTheRing_class_description",
        "src": "@Test\n  public void should_build_fellowshipOfTheRing_class_description() throws Exception {\n    ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);\n    assertThat(classDescription.getClassName()).isEqualTo(\"FellowshipOfTheRing\");\n    assertThat(classDescription.getPackageName()).isEqualTo(\"org.fest.assertions.generator.data.lotr\");\n    assertThat(classDescription.getGetters()).hasSize(1);\n    assertThat(classDescription.getImports()).containsOnly(new TypeName(Map.class), new TypeName(List.class),\n        new TypeName(Race.class), new TypeName(TolkienCharacter.class));\n  }",
        "error_msg": "org.fest.assertions.generator.description.converter.ClassToClassDescriptionConverterTest::should_build_fellowshipOfTheRing_class_description --> junit.framework.AssertionFailedError: expecting:",
        "clean_error_msg": "junit.framework.AssertionFailedError: expecting:"
      }
    }
  },
  "Config_magic-2": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/skife/config/Bully.java",
        "start_loc": 74,
        "end_loc": 92,
        "buggy_function": "    public synchronized Object coerce(Class<?> clazz, String value) {\n\n\n\n\n\n\n\n\n        Coercer<?> coercer = getCoercerFor(coercibles, clazz);\n        if (coercer == null) {\n            coercer = getCoercerFor(DEFAULT_COERCIBLES, clazz);\n\n            if (coercer == null) {\n                throw new IllegalStateException(String.format(\"Don't know how to handle a '%s' type for value '%s'\", clazz.getName(), value));\n            }\n        }\n        return coercer.coerce(value);\n    }",
        "fixed_function": "    public synchronized Object coerce(Type type, String value) {\n        if (type instanceof Class) {\n            Class<?> clazz = (Class<?>)type;\n\n            if (clazz.isArray()) {\n                return coerceArray(clazz.getComponentType(), value);\n            }\n            else {\n                return coerce(clazz, value);\n            }\n        }\n        else if (type instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType)type;\n            Type rawType = parameterizedType.getRawType();\n\n            if (rawType instanceof Class<?>) {\n                Type[] args = parameterizedType.getActualTypeArguments();\n\n                if (args != null && args.length == 1 && args[0] instanceof Class<?>) {\n                    return coerceCollection((Class<?>)rawType, (Class<?>)args[0], value);\n                }\n            }\n        }\n        throw new IllegalStateException(String.format(\"Don't know how to handle a '%s' type for value '%s'\", type, value));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/skife/config/ConfigurationObjectFactory.java",
        "start_loc": 99,
        "end_loc": 161,
        "buggy_function": "    private void buildSimple(ArrayList<Callback> callbacks, Method method, Config annotation,\n                             Map<String, String> mappedReplacements)\n    {\n        String[] propertyNames = annotation.value();\n\n        if (propertyNames == null || propertyNames.length == 0) {\n            throw new IllegalArgumentException(\"Method \" +\n                                               method.toGenericString() +\n                                               \" declares config annotation but no field name!\");\n        }\n\n        String value = null;\n\n        for (String propertyName : propertyNames) {\n            if (mappedReplacements != null) {\n                propertyName = applyReplacements(propertyName, mappedReplacements);\n            }\n            value = config.getString(propertyName);\n\n            // First value found wins\n            if (value != null) {\n                break;\n            }\n        }\n\n        final boolean hasDefault = method.isAnnotationPresent(Default.class);\n        final boolean hasDefaultNull = method.isAnnotationPresent(DefaultNull.class);\n\n        if (hasDefault && hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"@Default and @DefaultNull present in [%s]\", method.toGenericString()));\n        }\n\n        boolean useMethod = false;\n\n        //\n        // This is how the value logic works if no value has been set by the config:\n        //\n        // - if the @Default annotation is present, use its value.\n        // - if the @DefaultNull annotation is present, accept null as the value\n        // - otherwise, check whether the method is not abstract. If it is not, mark the callback that it should call the method and\n        //   ignore the passed in value (which will be null)\n        // - if all else fails, throw an exception.\n        //\n        if (value == null) {\n        \tif (hasDefault) {\n        \t\tvalue = method.getAnnotation(Default.class).value();\n        \t}\n        \telse if (!hasDefaultNull) {\n        \t\t// Final try: Is the method is actually callable?\n        \t\tif (!Modifier.isAbstract(method.getModifiers())) {\n        \t\t\tuseMethod = true;\n        \t\t}\n        \t\telse {\n        \t\t\tthrow new IllegalArgumentException(String.format(\"No value present for '%s' in [%s]\",\n        \t\t\t\t\tprettyPrint(propertyNames, mappedReplacements),\n        \t\t\t\t\tmethod.toGenericString()));\n        \t\t}\n        \t}\n        }\n\n        final Object finalValue = bully.coerce(method.getReturnType(), value);\n        callbacks.add(new ConfigMagicFixedValue(finalValue, useMethod));\n    }",
        "fixed_function": "    private void buildSimple(ArrayList<Callback> callbacks, Method method, Config annotation,\n                             Map<String, String> mappedReplacements)\n    {\n        String[] propertyNames = annotation.value();\n\n        if (propertyNames == null || propertyNames.length == 0) {\n            throw new IllegalArgumentException(\"Method \" +\n                                               method.toGenericString() +\n                                               \" declares config annotation but no field name!\");\n        }\n\n        String value = null;\n\n        for (String propertyName : propertyNames) {\n            if (mappedReplacements != null) {\n                propertyName = applyReplacements(propertyName, mappedReplacements);\n            }\n            value = config.getString(propertyName);\n\n            // First value found wins\n            if (value != null) {\n                break;\n            }\n        }\n\n        final boolean hasDefault = method.isAnnotationPresent(Default.class);\n        final boolean hasDefaultNull = method.isAnnotationPresent(DefaultNull.class);\n\n        if (hasDefault && hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"@Default and @DefaultNull present in [%s]\", method.toGenericString()));\n        }\n\n        boolean useMethod = false;\n\n        //\n        // This is how the value logic works if no value has been set by the config:\n        //\n        // - if the @Default annotation is present, use its value.\n        // - if the @DefaultNull annotation is present, accept null as the value\n        // - otherwise, check whether the method is not abstract. If it is not, mark the callback that it should call the method and\n        //   ignore the passed in value (which will be null)\n        // - if all else fails, throw an exception.\n        //\n        if (value == null) {\n        \tif (hasDefault) {\n        \t\tvalue = method.getAnnotation(Default.class).value();\n        \t}\n        \telse if (!hasDefaultNull) {\n        \t\t// Final try: Is the method is actually callable?\n        \t\tif (!Modifier.isAbstract(method.getModifiers())) {\n        \t\t\tuseMethod = true;\n        \t\t}\n        \t\telse {\n        \t\t\tthrow new IllegalArgumentException(String.format(\"No value present for '%s' in [%s]\",\n        \t\t\t\t\tprettyPrint(propertyNames, mappedReplacements),\n        \t\t\t\t\tmethod.toGenericString()));\n        \t\t}\n        \t}\n        }\n\n        final Object finalValue = bully.coerce(method.getGenericReturnType(), value);\n        callbacks.add(new ConfigMagicFixedValue(finalValue, useMethod));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/skife/config/ConfigurationObjectFactory.java",
        "start_loc": 173,
        "end_loc": 224,
        "buggy_function": "    private void buildParameterized(ArrayList<Callback> callbacks, Method method, Config annotation)\n    {\n        String defaultValue = null;\n\n        final boolean hasDefault = method.isAnnotationPresent(Default.class);\n        final boolean hasDefaultNull = method.isAnnotationPresent(DefaultNull.class);\n\n        if (hasDefault && hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"@Default and @DefaultNull present in [%s]\", method.toGenericString()));\n        }\n\n        if (hasDefault) {\n            defaultValue = method.getAnnotation(Default.class).value();\n        }\n        else if (!hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"No value present for '%s' in [%s]\",\n        \t\t\tprettyPrint(annotation.value(), null),\n        \t\t\tmethod.toGenericString()));\n        }\n\n        final Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        final List<String> paramTokenList = new ArrayList<String>();\n        for (Annotation[] parameterTab : parameterAnnotations) {\n            for (Annotation parameter : parameterTab) {\n                if (parameter.annotationType().equals(Param.class)) {\n                    Param paramAnnotation = (Param) parameter;\n                    paramTokenList.add(makeToken(paramAnnotation.value()));\n                    break;\n                }\n            }\n        }\n\n        if (paramTokenList.size() != method.getParameterTypes().length) {\n            throw new RuntimeException(String.format(\"Method [%s] is missing one or more @Param annotations\",\n                                                     method.toGenericString()));\n        }\n\n        final Object bulliedDefaultValue = bully.coerce(method.getReturnType(), defaultValue);\n        final String[] annotationValues = annotation.value();\n\n        if (annotationValues == null || annotationValues.length == 0) {\n            throw new IllegalArgumentException(\"Method \" +\n                                               method.toGenericString() +\n                                               \" declares config annotation but no field name!\");\n        }\n\n        callbacks.add(new ConfigMagicMethodInterceptor(config,\n                                                       annotationValues,\n                                                       paramTokenList,\n                                                       bully,\n                                                       bulliedDefaultValue));\n    }",
        "fixed_function": "    private void buildParameterized(ArrayList<Callback> callbacks, Method method, Config annotation)\n    {\n        String defaultValue = null;\n\n        final boolean hasDefault = method.isAnnotationPresent(Default.class);\n        final boolean hasDefaultNull = method.isAnnotationPresent(DefaultNull.class);\n\n        if (hasDefault && hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"@Default and @DefaultNull present in [%s]\", method.toGenericString()));\n        }\n\n        if (hasDefault) {\n            defaultValue = method.getAnnotation(Default.class).value();\n        }\n        else if (!hasDefaultNull) {\n        \tthrow new IllegalArgumentException(String.format(\"No value present for '%s' in [%s]\",\n        \t\t\tprettyPrint(annotation.value(), null),\n        \t\t\tmethod.toGenericString()));\n        }\n\n        final Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        final List<String> paramTokenList = new ArrayList<String>();\n        for (Annotation[] parameterTab : parameterAnnotations) {\n            for (Annotation parameter : parameterTab) {\n                if (parameter.annotationType().equals(Param.class)) {\n                    Param paramAnnotation = (Param) parameter;\n                    paramTokenList.add(makeToken(paramAnnotation.value()));\n                    break;\n                }\n            }\n        }\n\n        if (paramTokenList.size() != method.getParameterTypes().length) {\n            throw new RuntimeException(String.format(\"Method [%s] is missing one or more @Param annotations\",\n                                                     method.toGenericString()));\n        }\n\n        final Object bulliedDefaultValue = bully.coerce(method.getGenericReturnType(), defaultValue);\n        final String[] annotationValues = annotation.value();\n\n        if (annotationValues == null || annotationValues.length == 0) {\n            throw new IllegalArgumentException(\"Method \" +\n                                               method.toGenericString() +\n                                               \" declares config annotation but no field name!\");\n        }\n\n        callbacks.add(new ConfigMagicMethodInterceptor(config,\n                                                       annotationValues,\n                                                       paramTokenList,\n                                                       bully,\n                                                       bulliedDefaultValue));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/skife/config/ConfigurationObjectFactory.java",
        "start_loc": 346,
        "end_loc": 366,
        "buggy_function": "        public Object intercept(final Object o,\n                                final Method method,\n                                final Object[] args,\n                                final MethodProxy methodProxy) throws Throwable\n        {\n            for (String property : properties) {\n                if (args.length == paramTokenList.size()) {\n                    for (int i = 0; i < paramTokenList.size(); ++i) {\n                        property = property.replace(paramTokenList.get(i), String.valueOf(args[i]));\n                    }\n                    String value = config.getString(property);\n                    if (value != null) {\n                        return bully.coerce(method.getReturnType(), value);\n                    }\n                }\n                else {\n                    throw new IllegalStateException(\"Argument list doesn't match @Param list\");\n                }\n            }\n            return defaultValue;\n        }",
        "fixed_function": "        public Object intercept(final Object o,\n                                final Method method,\n                                final Object[] args,\n                                final MethodProxy methodProxy) throws Throwable\n        {\n            for (String property : properties) {\n                if (args.length == paramTokenList.size()) {\n                    for (int i = 0; i < paramTokenList.size(); ++i) {\n                        property = property.replace(paramTokenList.get(i), String.valueOf(args[i]));\n                    }\n                    String value = config.getString(property);\n                    if (value != null) {\n                        return bully.coerce(method.getGenericReturnType(), value);\n                    }\n                }\n                else {\n                    throw new IllegalStateException(\"Argument list doesn't match @Param list\");\n                }\n            }\n            return defaultValue;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/skife/config/DefaultCoercibles.java",
        "start_loc": 289,
        "end_loc": 300,
        "buggy_function": "    private static final RuntimeException convertException(final Throwable t)\n    {\n        if (t instanceof RuntimeException) {\n            return (RuntimeException) t;\n        }\n        else if (t instanceof InvocationTargetException) {\n            return convertException(((InvocationTargetException)t).getTargetException());\n        }\n        else {\n            return new RuntimeException(t);\n        }\n    }",
        "fixed_function": "    public static final RuntimeException convertException(final Throwable t)\n    {\n        if (t instanceof RuntimeException) {\n            return (RuntimeException) t;\n        }\n        else if (t instanceof InvocationTargetException) {\n            return convertException(((InvocationTargetException)t).getTargetException());\n        }\n        else {\n            return new RuntimeException(t);\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.skife.config.TestArrays::testClassDefault": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testClassDefault",
        "src": "@Test\n    public void testClassDefault()\n    {\n        EmptyClass ec = cof.build(EmptyClass.class);\n\n        Assert.assertArrayEquals(new String[] { \"one\", \"three\", \"two\" }, ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestArrays::testClassDefault --> java.lang.IllegalStateException: Don't know how to handle a '[Ljava.lang.String;' type for value 'one, three, two'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[Ljava.lang.String;' type for value 'one, three, two'"
      },
      "org.skife.config.TestArrays::testAbstractClassDefaultNull": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testAbstractClassDefaultNull",
        "src": "@Test\n    public void testAbstractClassDefaultNull()\n    {\n    \tEmptyAbstractClassDefaultNull ec = cof.build(EmptyAbstractClassDefaultNull.class);\n\n    \tAssert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestArrays::testAbstractClassDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a '[Ljava.lang.String;' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[Ljava.lang.String;' type for value 'null'"
      },
      "org.skife.config.TestArrays::testInterface": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testInterface",
        "src": "@Test\n    public void testInterface()\n    {\n        EmptyInterface ec = cof.build(EmptyInterface.class);\n\n        Assert.assertArrayEquals(new float[] { 1.0f, 2.0f }, ec.getValue(), 0.0f);\n    }",
        "error_msg": "org.skife.config.TestArrays::testInterface --> java.lang.IllegalStateException: Don't know how to handle a '[F' type for value '1.0, 2.0'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[F' type for value '1.0, 2.0'"
      },
      "org.skife.config.TestArrays::testInterfaceDefaultNull": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testInterfaceDefaultNull",
        "src": "@Test\n    public void testInterfaceDefaultNull()\n    {\n        EmptyInterfaceDefaultNull ec = cof.build(EmptyInterfaceDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestArrays::testInterfaceDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a '[Lorg.skife.config.TestArrays$TestEnum;' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[Lorg.skife.config.TestArrays$TestEnum;' type for value 'null'"
      },
      "org.skife.config.TestArrays::testAbstractClassDefault": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testAbstractClassDefault",
        "src": "@Test\n    public void testAbstractClassDefault()\n    {\n    \tEmptyAbstractClass ec = cof.build(EmptyAbstractClass.class);\n\n        Assert.assertArrayEquals(new TestEnum[] { TestEnum.TWO, TestEnum.ONE }, ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestArrays::testAbstractClassDefault --> java.lang.IllegalStateException: Don't know how to handle a '[Lorg.skife.config.TestArrays$TestEnum;' type for value 'TWO, ONE'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[Lorg.skife.config.TestArrays$TestEnum;' type for value 'TWO, ONE'"
      },
      "org.skife.config.TestArrays::testClassDefaultNull": {
        "path": "org/skife/config/TestArrays.java",
        "function_name": "testClassDefaultNull",
        "src": "@Test\n    public void testClassDefaultNull()\n    {\n    \tEmptyClassDefaultNull ec = cof.build(EmptyClassDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestArrays::testClassDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a '[I' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a '[I' type for value 'null'"
      },
      "org.skife.config.TestCollections::testAbstractClassDefaultNull": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testAbstractClassDefaultNull",
        "src": "@Test\n    public void testAbstractClassDefaultNull()\n    {\n    \tEmptyAbstractClassDefaultNull ec = cof.build(EmptyAbstractClassDefaultNull.class);\n\n    \tAssert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testAbstractClassDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.Set' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.Set' type for value 'null'"
      },
      "org.skife.config.TestCollections::testClassWithCollectionDefault": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testClassWithCollectionDefault",
        "src": "@Test\n    public void testClassWithCollectionDefault()\n    {\n        EmptyClassCollection ec = cof.build(EmptyClassCollection.class);\n\n        Assert.assertEquals(Arrays.asList(\"one\", \"three\", \"two\"), ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testClassWithCollectionDefault --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.Collection' type for value 'one, three, two'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.Collection' type for value 'one, three, two'"
      },
      "org.skife.config.TestCollections::testClassWithListDefault": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testClassWithListDefault",
        "src": "@Test\n    public void testClassWithListDefault()\n    {\n        EmptyClassList ec = cof.build(EmptyClassList.class);\n\n        Assert.assertEquals(Arrays.asList(\"one\", \"three\", \"two\"), ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testClassWithListDefault --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'one, three, two'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'one, three, two'"
      },
      "org.skife.config.TestCollections::testInterface": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testInterface",
        "src": "@Test\n    public void testInterface()\n    {\n        EmptyInterface ec = cof.build(EmptyInterface.class);\n\n        Assert.assertEquals(new LinkedHashSet<String>(Arrays.asList(\"one\", \"two\")), ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testInterface --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.LinkedHashSet' type for value 'one, two'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.LinkedHashSet' type for value 'one, two'"
      },
      "org.skife.config.TestCollections::testInterfaceDefaultNull": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testInterfaceDefaultNull",
        "src": "@Test\n    public void testInterfaceDefaultNull()\n    {\n        EmptyInterfaceDefaultNull ec = cof.build(EmptyInterfaceDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testInterfaceDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'null'"
      },
      "org.skife.config.TestCollections::testAbstractClassDefault": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testAbstractClassDefault",
        "src": "@Test\n    public void testAbstractClassDefault()\n    {\n    \tEmptyAbstractClass ec = cof.build(EmptyAbstractClass.class);\n\n        Assert.assertEquals(new HashSet<TestEnum>(Arrays.asList(TestEnum.TWO, TestEnum.ONE)), ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testAbstractClassDefault --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.Set' type for value 'TWO, ONE'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.Set' type for value 'TWO, ONE'"
      },
      "org.skife.config.TestCollections::testClassDefaultNull": {
        "path": "org/skife/config/TestCollections.java",
        "function_name": "testClassDefaultNull",
        "src": "@Test\n    public void testClassDefaultNull()\n    {\n    \tEmptyClassDefaultNull ec = cof.build(EmptyClassDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestCollections::testClassDefaultNull --> java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'null'",
        "clean_error_msg": "java.lang.IllegalStateException: Don't know how to handle a 'java.util.List' type for value 'null'"
      },
      "org.skife.config.TestEnums::testAbstractClassDefaultNull": {
        "path": "org/skife/config/TestEnums.java",
        "function_name": "testAbstractClassDefaultNull",
        "src": "@Test\n    public void testAbstractClassDefaultNull()\n    {\n    \tEmptyAbstractClassDefaultNull ec = cof.build(EmptyAbstractClassDefaultNull.class);\n\n    \tAssert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestEnums::testAbstractClassDefaultNull --> java.lang.NullPointerException: Name is null",
        "clean_error_msg": "java.lang.NullPointerException: Name is null"
      },
      "org.skife.config.TestEnums::testInterfaceDefaultNull": {
        "path": "org/skife/config/TestEnums.java",
        "function_name": "testInterfaceDefaultNull",
        "src": "@Test\n    public void testInterfaceDefaultNull()\n    {\n        EmptyInterfaceDefaultNull ec = cof.build(EmptyInterfaceDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestEnums::testInterfaceDefaultNull --> java.lang.NullPointerException: Name is null",
        "clean_error_msg": "java.lang.NullPointerException: Name is null"
      },
      "org.skife.config.TestEnums::testClassDefaultNull": {
        "path": "org/skife/config/TestEnums.java",
        "function_name": "testClassDefaultNull",
        "src": "@Test\n    public void testClassDefaultNull()\n    {\n    \tEmptyClassDefaultNull ec = cof.build(EmptyClassDefaultNull.class);\n\n        Assert.assertNull(ec.getValue());\n    }",
        "error_msg": "org.skife.config.TestEnums::testClassDefaultNull --> java.lang.NullPointerException: Name is null",
        "clean_error_msg": "java.lang.NullPointerException: Name is null"
      },
      "org.skife.config.TestFile::testAbstractClassDefaultNull": {
        "path": "org/skife/config/TestFile.java",
        "function_name": "testAbstractClassDefaultNull",
        "src": "@Test\n    public void testAbstractClassDefaultNull()\n    {\n    \tEmptyAbstractClassDefaultNull ec = cof.build(EmptyAbstractClassDefaultNull.class);\n\n        Assert.assertNull(ec.getFile());\n    }",
        "error_msg": "org.skife.config.TestFile::testAbstractClassDefaultNull --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Jcodemodel-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/helger/jcodemodel/fmt/JSerializedObject.java",
        "start_loc": 75,
        "end_loc": 88,
        "buggy_function": "  @Override\n  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n    }\n  }",
        "fixed_function": "  @Override\n  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n      oos.flush();\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/fmt/JTextFile.java",
        "start_loc": 89,
        "end_loc": 102,
        "buggy_function": "  @Override\n  public void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    if (m_sContents != null)\n      try (final Writer w = new OutputStreamWriter (aOS, m_aEncoding)\n      {\n        @Override\n        public void close ()\n        {}\n      })\n      {\n        w.write (m_sContents);\n      }\n  }",
        "fixed_function": "  @Override\n  public void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    if (m_sContents != null)\n      try (final Writer w = new OutputStreamWriter (aOS, m_aEncoding)\n      {\n        @Override\n        public void close ()\n        {}\n      })\n      {\n        w.write (m_sContents);\n        w.flush();\n      }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.helger.jcodemodel.supplementary.issues.Issue61FuncTest::testIssue": {
        "path": "com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java",
        "function_name": "testIssue",
        "src": "@Test\n  public void testIssue () throws Exception\n  {\n    final JCodeModel generator = new JCodeModel ();\n    final Charset ascii = Charset.forName(\"US-ASCII\");\n    final ByteArrayOutputStream resOut = new ByteArrayOutputStream();\n    final JTextFile res = (JTextFile) generator.rootPackage().addResourceFile(new JTextFile(\"example.txt\", ascii));\n    \n    res.setContents(\"Testing\");\n    generator.build(new SingleStreamCodeWriter(new ByteArrayOutputStream()), new SingleStreamCodeWriter(resOut));\n    String txtRes = ascii.decode(ByteBuffer.wrap(resOut.toByteArray())).toString();\n    assertTrue(txtRes.contains(\"Testing\"));\n  }",
        "error_msg": "com.helger.jcodemodel.supplementary.issues.Issue61FuncTest::testIssue --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jcodemodel-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/helger/jcodemodel/fmt/JSerializedObject.java",
        "start_loc": 75,
        "end_loc": 88,
        "buggy_function": "  @Override\n  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n    }\n  }",
        "fixed_function": "  @Override\n  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n      oos.flush();\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/fmt/JTextFile.java",
        "start_loc": 89,
        "end_loc": 102,
        "buggy_function": "  @Override\n  public void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    if (m_sContents != null)\n      try (final Writer w = new OutputStreamWriter (aOS, m_aEncoding)\n      {\n        @Override\n        public void close ()\n        {}\n      })\n      {\n        w.write (m_sContents);\n      }\n  }",
        "fixed_function": "  @Override\n  public void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    if (m_sContents != null)\n      try (final Writer w = new OutputStreamWriter (aOS, m_aEncoding)\n      {\n        @Override\n        public void close ()\n        {}\n      })\n      {\n        w.write (m_sContents);\n        w.flush();\n      }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.helger.jcodemodel.supplementary.issues.Issue61FuncTest::testIssue": {
        "path": "com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java",
        "function_name": "testIssue",
        "src": "@Test\n  public void testIssue () throws Exception\n  {\n    final JCodeModel generator = new JCodeModel ();\n    final Charset ascii = Charset.forName(\"US-ASCII\");\n    final ByteArrayOutputStream resOut = new ByteArrayOutputStream();\n    final JTextFile res = (JTextFile) generator.rootPackage().addResourceFile(new JTextFile(\"example.txt\", ascii));\n    \n    res.setContents(\"Testing\");\n    generator.build(new SingleStreamCodeWriter(new ByteArrayOutputStream()), new SingleStreamCodeWriter(resOut));\n    String txtRes = ascii.decode(ByteBuffer.wrap(resOut.toByteArray())).toString();\n    assertTrue(txtRes.contains(\"Testing\"));\n  }",
        "error_msg": "com.helger.jcodemodel.supplementary.issues.Issue61FuncTest::testIssue --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Jcodemodel-6": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/helger/jcodemodel/JFieldVar.java",
        "start_loc": 74,
        "end_loc": 82,
        "buggy_function": "  protected JFieldVar (@Nonnull final JDefinedClass aOwnerClass,\n                       @Nonnull final JMods mods,\n                       @Nonnull final AbstractJType type,\n                       @Nonnull final String name,\n                       @Nullable final IJExpression init)\n  {\n    super (mods, type, name, init);\n    this.m_aOwnerClass = aOwnerClass;\n  }",
        "fixed_function": "  protected JFieldVar (@Nonnull final JDefinedClass aOwnerClass,\n                       @Nonnull final JMods mods,\n                       @Nonnull final AbstractJType type,\n                       @Nonnull final String name,\n                       @Nullable final IJExpression init)\n  {\n    super (mods, type, name, init);\n    m_aOwnerClass = JCValueEnforcer.notNull (aOwnerClass, \"OwnerClass\");\n  }",
        "comment": "/**\n   * JFieldVar constructor\n   *\n   * @param aOwnerClass\n   *        The owning class.\n   * @param mods\n   *        modifiers to use\n   * @param type\n   *        Datatype of this variable\n   * @param name\n   *        Name of this variable\n   * @param init\n   *        Value to initialize this variable to\n   */"
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JFieldVar.java",
        "start_loc": 126,
        "end_loc": 132,
        "buggy_function": "  @Override\n  public void generate (@Nonnull final JFormatter f)\n  {\n      // Ensure the type is collected - see issue #30\n      f.type (m_aOwnerClass).print ('.');\n    super.generate (f);\n  }",
        "fixed_function": "  @Override\n  public void generate (@Nonnull final JFormatter f)\n  {\n    if (false)\n    {\n      // Ensure the type is collected - see issue #30\n      f.type (m_aOwnerClass).print ('.');\n    }\n    super.generate (f);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JFormatter.java",
        "start_loc": 364,
        "end_loc": 406,
        "buggy_function": "  @Nonnull\n  public JFormatter type (@Nonnull final AbstractJClass aType)\n  {\n    switch (m_eMode)\n    {\n      case FIND_ERROR_TYPES:\n        if (aType.isError ())\n          m_bContainsErrorTypes = true;\n        break;\n      case PRINTING:\n        // many of the JTypes in this list are either primitive or belong to\n        // package java so we don't need a FQCN\n        if (m_aImportedClasses.contains (aType) || aType._package () == m_aPckJavaLang)\n        {\n          // FQCN imported or not necessary, so generate short name\n          print (aType.name ());\n        }\n        else\n        {\n          final AbstractJClass aOuterClass = aType.outer ();\n          if (aOuterClass != null)\n            type (aOuterClass).print ('.').print (aType.name ());\n          else\n          {\n            // collision was detected, so generate FQCN\n            print (aType.fullName ());\n          }\n        }\n        break;\n      case COLLECTING:\n        // Never import direct classes\n        final String shortName = aType.name ();\n        Usages usage = m_aCollectedReferences.get (shortName);\n        if (usage == null)\n        {\n          usage = new Usages ();\n          m_aCollectedReferences.put (shortName, usage);\n        }\n        usage.addReferencedType (aType);\n        break;\n    }\n    return this;\n  }",
        "fixed_function": "  @Nonnull\n  public JFormatter type (@Nonnull final AbstractJClass aType)\n  {\n    switch (m_eMode)\n    {\n      case FIND_ERROR_TYPES:\n        if (aType.isError ())\n          m_bContainsErrorTypes = true;\n        break;\n      case PRINTING:\n        // many of the JTypes in this list are either primitive or belong to\n        // package java so we don't need a FQCN\n        if (m_aImportedClasses.contains (aType) || aType._package () == m_aPckJavaLang)\n        {\n          // FQCN imported or not necessary, so generate short name\n          print (aType.name ());\n        }\n        else\n        {\n          final AbstractJClass aOuterClass = aType.outer ();\n          if (aOuterClass != null)\n            type (aOuterClass).print ('.').print (aType.name ());\n          else\n          {\n            // collision was detected, so generate FQCN\n            print (aType.fullName ());\n          }\n        }\n        break;\n      case COLLECTING:\n        // Never import direct classes\n        if (!(aType instanceof JDirectClass))\n        {\n          final String sShortName = aType.name ();\n          Usages aUsage = m_aCollectedReferences.get (sShortName);\n          if (aUsage == null)\n          {\n            aUsage = new Usages ();\n            m_aCollectedReferences.put (sShortName, aUsage);\n          }\n          aUsage.addReferencedType (aType);\n        }\n        break;\n    }\n    return this;\n  }",
        "comment": "/**\n   * Print a type name.\n   * <p>\n   * In the collecting mode we use this information to decide what types to\n   * import and what not to.\n   */"
      }
    ],
    "trigger_test": {
      "com.helger.jcodemodel.JDirectClassTest::testGenerics": {
        "path": "com/helger/jcodemodel/JDirectClassTest.java",
        "function_name": "testGenerics",
        "src": "@Test\n  public void testGenerics () throws Exception\n  {\n    final JCodeModel cm = new JCodeModel ();\n\n    final JDirectClass aDirectClass = cm.directClass (\"com.test.GenericFragmentArguments<S,P>\");\n    assertEquals (\"com.test\", aDirectClass._package ().name ());\n    assertEquals (\"com.test.GenericFragmentArguments<S,P>\", aDirectClass.name ());\n    assertEquals (\"com.test.GenericFragmentArguments<S,P>\", aDirectClass.fullName ());\n\n    cm._class (\"UsingClass\").method (JMod.PUBLIC, cm.VOID, \"test\").body ().add (JExpr._new (aDirectClass));\n\n    CodeModelTestsHelper.parseCodeModel (cm);\n  }",
        "error_msg": "com.helger.jcodemodel.JDirectClassTest::testGenerics --> japa.parser.ParseException: Encountered  < <  at line 1, column 41.",
        "clean_error_msg": "japa.parser.ParseException: Encountered  < <  at line 1, column 41."
      }
    }
  },
  "Jcodemodel-7": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/com/helger/jcodemodel/JDirectClass.java",
        "start_loc": 61,
        "end_loc": 65,
        "buggy_function": "  @Deprecated\n  protected JDirectClass (@Nonnull final JCodeModel aOwner, @Nonnull final String sFullName)\n  {\n    this (aOwner, null, EClassType.CLASS, sFullName);\n  }",
        "fixed_function": "  @Nonnull\n  private static String _getName (@Nonnull final String sFullName)\n  {\n    final int nLast = sFullName.lastIndexOf ('.');\n    if (nLast < 0)\n      return sFullName;\n    return sFullName.substring (nLast + 1);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JDirectClass.java",
        "start_loc": 68,
        "end_loc": 74,
        "buggy_function": "  protected JDirectClass (@Nonnull final JCodeModel aOwner,\n                          @Nullable final IJClassContainer <?> aOuter,\n                          @Nonnull final EClassType eClassType,\n                          @Nonnull final String sFullName)\n  {\n    super (aOwner, aOuter, eClassType, sFullName);\n  }",
        "fixed_function": "  protected JDirectClass (@Nonnull final JCodeModel aOwner,\n                          @Nullable final IJClassContainer <?> aOuter,\n                          @Nonnull final EClassType eClassType,\n                          @Nonnull final String sFullName)\n  {\n    super (aOwner, aOuter, eClassType, _getName (sFullName));\n    m_sFullName = sFullName;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JDirectClass.java",
        "start_loc": 79,
        "end_loc": 88,
        "buggy_function": "  @Override\n  @Nullable\n  public String fullName ()\n  {\n    if (getOuter () instanceof AbstractJClassContainer <?>)\n      return ((AbstractJClassContainer <?>) getOuter ()).fullName () + '.' + name ();\n\n    // The fully qualified name was already provided in the ctor\n    return name ();\n  }",
        "fixed_function": "  @Override\n  @Nullable\n  public String fullName ()\n  {\n    if (getOuter () instanceof AbstractJClassContainer <?>)\n      return ((AbstractJClassContainer <?>) getOuter ()).fullName () + '.' + m_sFullName;\n\n    // The fully qualified name was already provided in the ctor\n    return m_sFullName;\n  }",
        "comment": "/**\n   * Gets the fully qualified name of this class.\n   */"
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JDirectClass.java",
        "start_loc": 90,
        "end_loc": 106,
        "buggy_function": "  @Override\n  @Nonnull\n  public JPackage _package ()\n  {\n    final IJClassContainer <?> aOuter = getOuter ();\n    if (aOuter instanceof AbstractJClassContainer <?>)\n      return ((AbstractJClassContainer <?>) aOuter)._package ();\n    if (aOuter instanceof JPackage)\n      return (JPackage) aOuter;\n\n    // No package present - use name based analysis\n    final String sFullName = name ();\n    final int i = sFullName.lastIndexOf ('.');\n    if (i >= 0)\n      return owner ()._package (sFullName.substring (0, i));\n    return owner ().rootPackage ();\n  }",
        "fixed_function": "  @Override\n  @Nonnull\n  public JPackage _package ()\n  {\n    final IJClassContainer <?> aOuter = getOuter ();\n    if (aOuter instanceof AbstractJClassContainer <?>)\n      return ((AbstractJClassContainer <?>) aOuter)._package ();\n    if (aOuter instanceof JPackage)\n      return (JPackage) aOuter;\n\n    // No package present - use name based analysis\n    final String sFullName = fullName ();\n    final int i = sFullName.lastIndexOf ('.');\n    if (i >= 0)\n      return owner ()._package (sFullName.substring (0, i));\n    return owner ().rootPackage ();\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/helger/jcodemodel/JFormatter.java",
        "start_loc": 363,
        "end_loc": 407,
        "buggy_function": "  @Nonnull\n  public JFormatter type (@Nonnull final AbstractJClass aType)\n  {\n    switch (m_eMode)\n    {\n      case FIND_ERROR_TYPES:\n        if (aType.isError ())\n          m_bContainsErrorTypes = true;\n        break;\n      case PRINTING:\n        // many of the JTypes in this list are either primitive or belong to\n        // package java so we don't need a FQCN\n        if (m_aImportedClasses.contains (aType) || aType._package () == m_aPckJavaLang)\n        {\n          // FQCN imported or not necessary, so generate short name\n          print (aType.name ());\n        }\n        else\n        {\n          final AbstractJClass aOuterClass = aType.outer ();\n          if (aOuterClass != null)\n            type (aOuterClass).print ('.').print (aType.name ());\n          else\n          {\n            // collision was detected, so generate FQCN\n            print (aType.fullName ());\n          }\n        }\n        break;\n      case COLLECTING:\n        if (!(aType instanceof JDirectClass))\n        {\n          final String sShortName = aType.name ();\n          Usages aUsage = m_aCollectedReferences.get (sShortName);\n          if (aUsage == null)\n          {\n            aUsage = new Usages ();\n            m_aCollectedReferences.put (sShortName, aUsage);\n          }\n          aUsage.addReferencedType (aType);\n        }\n        break;\n    }\n    return this;\n  }",
        "fixed_function": "  @Nonnull\n  public JFormatter type (@Nonnull final AbstractJClass aType)\n  {\n    switch (m_eMode)\n    {\n      case FIND_ERROR_TYPES:\n        if (aType.isError ())\n          m_bContainsErrorTypes = true;\n        break;\n      case PRINTING:\n        // many of the JTypes in this list are either primitive or belong to\n        // package java so we don't need a FQCN\n        if (m_aImportedClasses.contains (aType) || aType._package () == m_aPckJavaLang)\n        {\n          // FQCN imported or not necessary, so generate short name\n          print (aType.name ());\n        }\n        else\n        {\n          final AbstractJClass aOuterClass = aType.outer ();\n          if (aOuterClass != null)\n            type (aOuterClass).print ('.').print (aType.name ());\n          else\n          {\n            // collision was detected, so generate FQCN\n            print (aType.fullName ());\n          }\n        }\n        break;\n      case COLLECTING:\n        final String sShortName = aType.name ();\n        Usages aUsage = m_aCollectedReferences.get (sShortName);\n        if (aUsage == null)\n        {\n          aUsage = new Usages ();\n          m_aCollectedReferences.put (sShortName, aUsage);\n        }\n        aUsage.addReferencedType (aType);\n        break;\n    }\n    return this;\n  }",
        "comment": "/**\n   * Print a type name.\n   * <p>\n   * In the collecting mode we use this information to decide what types to\n   * import and what not to.\n   */"
      }
    ],
    "trigger_test": {
      "com.helger.jcodemodel.JDirectClassTest::testGenerics": {
        "path": "com/helger/jcodemodel/JDirectClassTest.java",
        "function_name": "testGenerics",
        "src": "@Test\n  public void testGenerics () throws Exception\n  {\n    final JCodeModel cm = new JCodeModel ();\n\n    final AbstractJClass aNarrowedClass = (AbstractJClass) cm.parseType (\"com.test.GenericFragmentArguments<S,P>\");\n    assertTrue (aNarrowedClass instanceof JNarrowedClass);\n    assertTrue (aNarrowedClass.erasure () instanceof JDirectClass);\n    assertEquals (\"com.test\", aNarrowedClass._package ().name ());\n    assertEquals (\"GenericFragmentArguments<S,P>\", aNarrowedClass.name ());\n    assertEquals (\"GenericFragmentArguments\", aNarrowedClass.erasure ().name ());\n    assertEquals (\"com.test.GenericFragmentArguments<S,P>\", aNarrowedClass.fullName ());\n    assertEquals (\"com.test.GenericFragmentArguments\", aNarrowedClass.erasure ().fullName ());\n\n    cm._class (\"UsingClass\").method (JMod.PUBLIC, cm.VOID, \"test\").body ().add (JExpr._new (aNarrowedClass));\n\n    CodeModelTestsHelper.parseCodeModel (cm);\n  }",
        "error_msg": "com.helger.jcodemodel.JDirectClassTest::testGenerics --> junit.framework.AssertionFailedError: expected:<[]GenericFragmentArgum...> but was:<[com.test.]GenericFragmentArgum...>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[]GenericFragmentArgum...> but was:<[com.test.]GenericFragmentArgum...>"
      }
    }
  },
  "Jdbm3-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/net/kotek/jdbm/Serialization.java",
        "start_loc": 92,
        "end_loc": 394,
        "buggy_function": "    public void serialize(final DataOutput out, final Object obj, FastArrayList objectStack) throws IOException {\n\n        /**try to find object on stack if it exists*/\n        if (objectStack != null) {\n            int indexInObjectStack = objectStack.identityIndexOf(obj);\n            if (indexInObjectStack != -1) {\n                //object was already serialized, just write reference to it and return\n                out.write(OBJECT_STACK);\n                LongPacker.packInt(out, indexInObjectStack);\n                return;\n            }\n            //add this object to objectStack\n            objectStack.add(obj);\n        }\n\n        final Class clazz = obj != null ? obj.getClass() : null;\n\n        /** first try to serialize object without initializing object stack*/\n        if (obj == null) {\n            out.write(NULL);\n            return;\n        } else if (clazz == Boolean.class) {\n            if (((Boolean) obj).booleanValue())\n                out.write(BOOLEAN_TRUE);\n            else\n                out.write(BOOLEAN_FALSE);\n            return;\n        } else if (clazz == Integer.class) {\n            final int val = (Integer) obj;\n            writeInteger(out, val);\n            return;\n        } else if (clazz == Double.class) {\n            double v = (Double) obj;\n            if (v == -1d)\n                out.write(DOUBLE_MINUS_1);\n            else if (v == 0d)\n                out.write(DOUBLE_0);\n            else if (v == 1d)\n                out.write(DOUBLE_1);\n            else if (v >= 0 && v <= 255 && (int) v == v) {\n                out.write(DOUBLE_255);\n                out.write((int) v);\n            } else if (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE && (short) v == v) {\n                out.write(DOUBLE_SHORT);\n                out.writeShort((int) v);\n            } else {\n                out.write(DOUBLE_FULL);\n                out.writeDouble(v);\n            }\n            return;\n        } else if (clazz == Float.class) {\n            float v = (Float) obj;\n            if (v == -1f)\n                out.write(FLOAT_MINUS_1);\n            else if (v == 0f)\n                out.write(FLOAT_0);\n            else if (v == 1f)\n                out.write(FLOAT_1);\n            else if (v >= 0 && v <= 255 && (int) v == v) {\n                out.write(FLOAT_255);\n                out.write((int) v);\n            } else if (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE && (short) v == v) {\n                out.write(FLOAT_SHORT);\n                out.writeShort((int) v);\n\n            } else {\n                out.write(FLOAT_FULL);\n                out.writeFloat(v);\n            }\n            return;\n        } else if (clazz == BigInteger.class) {\n            out.write(BIGINTEGER);\n            byte[] buf = ((BigInteger) obj).toByteArray();\n            serializeByteArrayInt(out, buf);\n            return;\n        } else if (clazz == BigDecimal.class) {\n            out.write(BIGDECIMAL);\n            BigDecimal d = (BigDecimal) obj;\n            serializeByteArrayInt(out, d.unscaledValue().toByteArray());\n            LongPacker.packInt(out, d.scale());\n            return;\n        } else if (clazz == Long.class) {\n            final long val = (Long) obj;\n            writeLong(out, val);\n            return;\n        } else if (clazz == Short.class) {\n            short val = (Short) obj;\n            if (val == -1)\n                out.write(SHORT_MINUS_1);\n            else if (val == 0)\n                out.write(SHORT_0);\n            else if (val == 1)\n                out.write(SHORT_1);\n            else if (val > 0 && val < 255) {\n                out.write(SHORT_255);\n                out.write(val);\n            } else {\n                out.write(SHORT_FULL);\n                out.writeShort(val);\n            }\n            return;\n        } else if (clazz == Byte.class) {\n            byte val = (Byte) obj;\n            if (val == -1)\n                out.write(BYTE_MINUS_1);\n            else if (val == 0)\n                out.write(BYTE_0);\n            else if (val == 1)\n                out.write(BYTE_1);\n            else {\n                out.write(SHORT_FULL);\n                out.writeByte(val);\n            }\n            return;\n        } else if (clazz == Character.class) {\n            out.write(CHAR);\n            out.writeChar((Character) obj);\n            return;\n        } else if (clazz == String.class) {\n            String s = (String) obj;\n            if (s.length() == 0) {\n                out.write(STRING_EMPTY);\n            } else {\n                out.write(STRING);\n                serializeString(out, s);\n            }\n            return;\n        } else if (obj instanceof Class) {\n            out.write(CLASS);\n            serialize(out, ((Class) obj).getName());\n            return;\n        } else if (obj instanceof int[]) {\n            writeIntArray(out, (int[]) obj);\n            return;\n        } else if (obj instanceof long[]) {\n            writeLongArray(out, (long[]) obj);\n            return;\n        } else if (obj instanceof short[]) {\n            out.write(SHORT_ARRAY);\n            short[] a = (short[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(short s:a) out.writeShort(s);\n            return;\n        } else if (obj instanceof boolean[]) {\n            out.write(BOOLEAN_ARRAY);\n            boolean[] a = (boolean[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(boolean s:a) out.writeBoolean(s); //TODO pack 8 booleans to single byte\n            return;\n        } else if (obj instanceof double[]) {\n            out.write(DOUBLE_ARRAY);\n            double[] a = (double[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(double s:a) out.writeDouble(s);\n            return;\n        } else if (obj instanceof float[]) {\n            out.write(FLOAT_ARRAY);\n            float[] a = (float[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(float s:a) out.writeFloat(s);\n            return;\n        } else if (obj instanceof char[]) {\n            out.write(CHAR_ARRAY);\n            char[] a = (char[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(char s:a) out.writeChar(s);\n            return;\n        } else if (obj instanceof byte[]) {\n            byte[] b = (byte[]) obj;\n            out.write(ARRAY_BYTE_INT);\n            serializeByteArrayInt(out, b);\n            return;\n        } else if (clazz == Date.class) {\n            out.write(DATE);\n            out.writeLong(((Date) obj).getTime());\n            return;\n        } else if (clazz == BTree.class) {\n            out.write(BTREE);\n            ((BTree) obj).writeExternal(out);\n            return;\n        } else if (clazz == HTree.class) {\n            out.write(HTREE);\n            ((HTree) obj).serialize(out);\n            return;\n        } else if (clazz == LinkedList2.class) {\n            out.write(JDBMLINKEDLIST);\n            ((LinkedList2) obj).serialize(out);\n            return;\n        }\n\n\n        /** classes bellow need object stack, so initialize it if not alredy initialized*/\n        if (objectStack == null) {\n            objectStack = new FastArrayList();\n            objectStack.add(obj);\n        }\n\n\n        if (obj instanceof Object[]) {\n            Object[] b = (Object[]) obj;\n            boolean packableLongs = b.length <= 255;\n            if (packableLongs) {\n                //check if it contains packable longs\n                for (Object o : b) {\n                    if (o != null && (o.getClass() != Long.class || (((Long) o).longValue() < 0 && ((Long) o).longValue() != Long.MAX_VALUE))) {\n                        packableLongs = false;\n                        break;\n                    }\n                }\n            }\n\n            if (packableLongs) {\n                //packable Longs is special case,  it is often used in JDBM to reference fields\n                out.write(ARRAY_OBJECT_PACKED_LONG);\n                out.write(b.length);\n                for (Object o : b) {\n                    if (o == null)\n                        LongPacker.packLong(out, 0);\n                    else\n                        LongPacker.packLong(out, ((Long) o).longValue() + 1);\n                }\n\n            } else {\n                out.write(ARRAY_OBJECT);\n                LongPacker.packInt(out, b.length);\n                \n                // Write class id for components\n                Class<?> componentType = obj.getClass().getComponentType();\n                registerClass(componentType);\n                //write class header\n                int classId = getClassId(componentType);\n                LongPacker.packInt(out, classId);\n                \n                for (Object o : b)\n                    serialize(out, o, objectStack);\n\n            }\n\n        } else if (clazz == ArrayList.class) {\n            ArrayList l = (ArrayList) obj;\n            boolean packableLongs = l.size() < 255;\n            if (packableLongs) {\n                //packable Longs is special case,  it is often used in JDBM to reference fields\n                for (Object o : l) {\n                    if (o != null && (o.getClass() != Long.class || (((Long) o).longValue() < 0 && ((Long) o).longValue() != Long.MAX_VALUE))) {\n                        packableLongs = false;\n                        break;\n                    }\n                }\n            }\n            if (packableLongs) {\n                out.write(ARRAYLIST_PACKED_LONG);\n                out.write(l.size());\n                for (Object o : l) {\n                    if (o == null)\n                        LongPacker.packLong(out, 0);\n                    else\n                        LongPacker.packLong(out, ((Long) o).longValue() + 1);\n                }\n            } else {\n                serializeCollection(ARRAYLIST, out, obj, objectStack);\n            }\n\n        } else if (clazz == java.util.LinkedList.class) {\n            serializeCollection(LINKEDLIST, out, obj, objectStack);\n        } else if (clazz == Vector.class) {\n            serializeCollection(VECTOR, out, obj, objectStack);\n        } else if (clazz == TreeSet.class) {\n            TreeSet l = (TreeSet) obj;\n            out.write(TREESET);\n            LongPacker.packInt(out, l.size());\n            serialize(out, l.comparator(), objectStack);\n            for (Object o : l)\n                serialize(out, o, objectStack);\n        } else if (clazz == HashSet.class) {\n            serializeCollection(HASHSET, out, obj, objectStack);\n        } else if (clazz == LinkedHashSet.class) {\n            serializeCollection(LINKEDHASHSET, out, obj, objectStack);\n        } else if (clazz == TreeMap.class) {\n            TreeMap l = (TreeMap) obj;\n            out.write(TREEMAP);\n            LongPacker.packInt(out, l.size());\n            serialize(out, l.comparator(), objectStack);\n            for (Object o : l.keySet()) {\n                serialize(out, o, objectStack);\n                serialize(out, l.get(o), objectStack);\n            }\n        } else if (clazz == HashMap.class) {\n            serializeMap(HASHMAP, out, obj, objectStack);\n        } else if (clazz == IdentityHashMap.class) {\n            serializeMap(IDENTITYHASHMAP, out, obj, objectStack);\n        } else if (clazz == LinkedHashMap.class) {\n            serializeMap(LINKEDHASHMAP, out, obj, objectStack);\n        } else if (clazz == Hashtable.class) {\n            serializeMap(HASHTABLE, out, obj, objectStack);\n        } else if (clazz == Properties.class) {\n            serializeMap(PROPERTIES, out, obj, objectStack);\n        } else {\n            out.write(NORMAL);\n            writeObject(out, obj, objectStack);\n        }\n\n    }",
        "fixed_function": "    public void serialize(final DataOutput out, final Object obj, FastArrayList objectStack) throws IOException {\n\n        /**try to find object on stack if it exists*/\n        if (objectStack != null) {\n            int indexInObjectStack = objectStack.identityIndexOf(obj);\n            if (indexInObjectStack != -1) {\n                //object was already serialized, just write reference to it and return\n                out.write(OBJECT_STACK);\n                LongPacker.packInt(out, indexInObjectStack);\n                return;\n            }\n            //add this object to objectStack\n            objectStack.add(obj);\n        }\n\n        final Class clazz = obj != null ? obj.getClass() : null;\n\n        /** first try to serialize object without initializing object stack*/\n        if (obj == null) {\n            out.write(NULL);\n            return;\n        } else if (clazz == Boolean.class) {\n            if (((Boolean) obj).booleanValue())\n                out.write(BOOLEAN_TRUE);\n            else\n                out.write(BOOLEAN_FALSE);\n            return;\n        } else if (clazz == Integer.class) {\n            final int val = (Integer) obj;\n            writeInteger(out, val);\n            return;\n        } else if (clazz == Double.class) {\n            double v = (Double) obj;\n            if (v == -1d)\n                out.write(DOUBLE_MINUS_1);\n            else if (v == 0d)\n                out.write(DOUBLE_0);\n            else if (v == 1d)\n                out.write(DOUBLE_1);\n            else if (v >= 0 && v <= 255 && (int) v == v) {\n                out.write(DOUBLE_255);\n                out.write((int) v);\n            } else if (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE && (short) v == v) {\n                out.write(DOUBLE_SHORT);\n                out.writeShort((int) v);\n            } else {\n                out.write(DOUBLE_FULL);\n                out.writeDouble(v);\n            }\n            return;\n        } else if (clazz == Float.class) {\n            float v = (Float) obj;\n            if (v == -1f)\n                out.write(FLOAT_MINUS_1);\n            else if (v == 0f)\n                out.write(FLOAT_0);\n            else if (v == 1f)\n                out.write(FLOAT_1);\n            else if (v >= 0 && v <= 255 && (int) v == v) {\n                out.write(FLOAT_255);\n                out.write((int) v);\n            } else if (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE && (short) v == v) {\n                out.write(FLOAT_SHORT);\n                out.writeShort((int) v);\n\n            } else {\n                out.write(FLOAT_FULL);\n                out.writeFloat(v);\n            }\n            return;\n        } else if (clazz == BigInteger.class) {\n            out.write(BIGINTEGER);\n            byte[] buf = ((BigInteger) obj).toByteArray();\n            serializeByteArrayInt(out, buf);\n            return;\n        } else if (clazz == BigDecimal.class) {\n            out.write(BIGDECIMAL);\n            BigDecimal d = (BigDecimal) obj;\n            serializeByteArrayInt(out, d.unscaledValue().toByteArray());\n            LongPacker.packInt(out, d.scale());\n            return;\n        } else if (clazz == Long.class) {\n            final long val = (Long) obj;\n            writeLong(out, val);\n            return;\n        } else if (clazz == Short.class) {\n            short val = (Short) obj;\n            if (val == -1)\n                out.write(SHORT_MINUS_1);\n            else if (val == 0)\n                out.write(SHORT_0);\n            else if (val == 1)\n                out.write(SHORT_1);\n            else if (val > 0 && val < 255) {\n                out.write(SHORT_255);\n                out.write(val);\n            } else {\n                out.write(SHORT_FULL);\n                out.writeShort(val);\n            }\n            return;\n        } else if (clazz == Byte.class) {\n            byte val = (Byte) obj;\n            if (val == -1)\n                out.write(BYTE_MINUS_1);\n            else if (val == 0)\n                out.write(BYTE_0);\n            else if (val == 1)\n                out.write(BYTE_1);\n            else {\n                out.write(SHORT_FULL);\n                out.writeByte(val);\n            }\n            return;\n        } else if (clazz == Character.class) {\n            out.write(CHAR);\n            out.writeChar((Character) obj);\n            return;\n        } else if (clazz == String.class) {\n            String s = (String) obj;\n            if (s.length() == 0) {\n                out.write(STRING_EMPTY);\n            } else {\n                out.write(STRING);\n                serializeString(out, s);\n            }\n            return;\n        } else if (obj instanceof Class) {\n            out.write(CLASS);\n            serialize(out, ((Class) obj).getName());\n            return;\n        } else if (obj instanceof int[]) {\n            writeIntArray(out, (int[]) obj);\n            return;\n        } else if (obj instanceof long[]) {\n            writeLongArray(out, (long[]) obj);\n            return;\n        } else if (obj instanceof short[]) {\n            out.write(SHORT_ARRAY);\n            short[] a = (short[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(short s:a) out.writeShort(s);\n            return;\n        } else if (obj instanceof boolean[]) {\n            out.write(BOOLEAN_ARRAY);\n            boolean[] a = (boolean[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(boolean s:a) out.writeBoolean(s); //TODO pack 8 booleans to single byte\n            return;\n        } else if (obj instanceof double[]) {\n            out.write(DOUBLE_ARRAY);\n            double[] a = (double[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(double s:a) out.writeDouble(s);\n            return;\n        } else if (obj instanceof float[]) {\n            out.write(FLOAT_ARRAY);\n            float[] a = (float[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(float s:a) out.writeFloat(s);\n            return;\n        } else if (obj instanceof char[]) {\n            out.write(CHAR_ARRAY);\n            char[] a = (char[]) obj;\n            LongPacker.packInt(out,a.length);\n            for(char s:a) out.writeChar(s);\n            return;\n        } else if (obj instanceof byte[]) {\n            byte[] b = (byte[]) obj;\n            out.write(ARRAY_BYTE_INT);\n            serializeByteArrayInt(out, b);\n            return;\n        } else if (clazz == Date.class) {\n            out.write(DATE);\n            out.writeLong(((Date) obj).getTime());\n            return;\n        } else if (clazz == BTree.class) {\n            out.write(BTREE);\n            ((BTree) obj).writeExternal(out);\n            return;\n        } else if (clazz == HTree.class) {\n            out.write(HTREE);\n            ((HTree) obj).serialize(out);\n            return;\n        } else if (clazz == LinkedList2.class) {\n            out.write(JDBMLINKEDLIST);\n            ((LinkedList2) obj).serialize(out);\n            return;\n        }\n\n\n        /** classes bellow need object stack, so initialize it if not alredy initialized*/\n        if (objectStack == null) {\n            objectStack = new FastArrayList();\n            objectStack.add(obj);\n        }\n\n\n        if (obj instanceof Object[]) {\n            Object[] b = (Object[]) obj;\n            boolean packableLongs = b.length <= 255;\n            if (packableLongs) {\n                //check if it contains packable longs\n                for (Object o : b) {\n                    if (o != null && (o.getClass() != Long.class || (((Long) o).longValue() < 0 && ((Long) o).longValue() != Long.MAX_VALUE))) {\n                        packableLongs = false;\n                        break;\n                    }\n                }\n            }\n\n            if (packableLongs) {\n                //packable Longs is special case,  it is often used in JDBM to reference fields\n                out.write(ARRAY_OBJECT_PACKED_LONG);\n                out.write(b.length);\n                for (Object o : b) {\n                    if (o == null)\n                        LongPacker.packLong(out, 0);\n                    else\n                        LongPacker.packLong(out, ((Long) o).longValue() + 1);\n                }\n\n            } else {\n                out.write(ARRAY_OBJECT);\n                LongPacker.packInt(out, b.length);\n                \n                // Write class id for components\n                Class<?> componentType = obj.getClass().getComponentType();\n                registerClass(componentType);\n                //write class header\n                int classId = getClassId(componentType);\n                LongPacker.packInt(out, classId);\n                \n                for (Object o : b)\n                    serialize(out, o, objectStack);\n\n            }\n\n        } else if (clazz == ArrayList.class) {\n            ArrayList l = (ArrayList) obj;\n            boolean packableLongs = l.size() < 255;\n            if (packableLongs) {\n                //packable Longs is special case,  it is often used in JDBM to reference fields\n                for (Object o : l) {\n                    if (o != null && (o.getClass() != Long.class || (((Long) o).longValue() < 0 && ((Long) o).longValue() != Long.MAX_VALUE))) {\n                        packableLongs = false;\n                        break;\n                    }\n                }\n            }\n            if (packableLongs) {\n                out.write(ARRAYLIST_PACKED_LONG);\n                out.write(l.size());\n                for (Object o : l) {\n                    if (o == null)\n                        LongPacker.packLong(out, 0);\n                    else\n                        LongPacker.packLong(out, ((Long) o).longValue() + 1);\n                }\n            } else {\n                serializeCollection(ARRAYLIST, out, obj, objectStack);\n            }\n\n        } else if (clazz == java.util.LinkedList.class) {\n            serializeCollection(LINKEDLIST, out, obj, objectStack);\n        } else if (clazz == Vector.class) {\n            serializeCollection(VECTOR, out, obj, objectStack);\n        } else if (clazz == TreeSet.class) {\n            TreeSet l = (TreeSet) obj;\n            out.write(TREESET);\n            LongPacker.packInt(out, l.size());\n            serialize(out, l.comparator(), objectStack);\n            for (Object o : l)\n                serialize(out, o, objectStack);\n        } else if (clazz == HashSet.class) {\n            serializeCollection(HASHSET, out, obj, objectStack);\n        } else if (clazz == LinkedHashSet.class) {\n            serializeCollection(LINKEDHASHSET, out, obj, objectStack);\n        } else if (clazz == TreeMap.class) {\n            TreeMap l = (TreeMap) obj;\n            out.write(TREEMAP);\n            LongPacker.packInt(out, l.size());\n            serialize(out, l.comparator(), objectStack);\n            for (Object o : l.keySet()) {\n                serialize(out, o, objectStack);\n                serialize(out, l.get(o), objectStack);\n            }\n        } else if (clazz == HashMap.class) {\n            serializeMap(HASHMAP, out, obj, objectStack);\n        } else if (clazz == IdentityHashMap.class) {\n            serializeMap(IDENTITYHASHMAP, out, obj, objectStack);\n        } else if (clazz == LinkedHashMap.class) {\n            serializeMap(LINKEDHASHMAP, out, obj, objectStack);\n        } else if (clazz == Hashtable.class) {\n            serializeMap(HASHTABLE, out, obj, objectStack);\n        } else if (clazz == Properties.class) {\n            serializeMap(PROPERTIES, out, obj, objectStack);\n        } else if (clazz == Locale.class){\n            out.write(LOCALE);\n            Locale l = (Locale) obj;\n            out.writeUTF(l.getLanguage());\n            out.writeUTF(l.getCountry());\n            out.writeUTF(l.getVariant());\n        } else {\n            out.write(NORMAL);\n            writeObject(out, obj, objectStack);\n        }\n\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/Serialization.java",
        "start_loc": 614,
        "end_loc": 954,
        "buggy_function": "    public Object deserialize(DataInput is, FastArrayList objectStack) throws IOException, ClassNotFoundException {\n\n        Object ret = null;\n\n        final int head = is.readUnsignedByte();\n\n        /** first try to deserialize object without allocating object stack*/\n        switch (head) {\n            case NULL:\n                break;\n            case BOOLEAN_TRUE:\n                ret = Boolean.TRUE;\n                break;\n            case BOOLEAN_FALSE:\n                ret = Boolean.FALSE;\n                break;\n            case INTEGER_MINUS_1:\n                ret = Integer.valueOf(-1);\n                break;\n            case INTEGER_0:\n                ret = Integer.valueOf(0);\n                break;\n            case INTEGER_1:\n                ret = Integer.valueOf(1);\n                break;\n            case INTEGER_2:\n                ret = Integer.valueOf(2);\n                break;\n            case INTEGER_3:\n                ret = Integer.valueOf(3);\n                break;\n            case INTEGER_4:\n                ret = Integer.valueOf(4);\n                break;\n            case INTEGER_5:\n                ret = Integer.valueOf(5);\n                break;\n            case INTEGER_6:\n                ret = Integer.valueOf(6);\n                break;\n            case INTEGER_7:\n                ret = Integer.valueOf(7);\n                break;\n            case INTEGER_8:\n                ret = Integer.valueOf(8);\n                break;\n            case INTEGER_MINUS_MAX:\n                ret = Integer.valueOf(Integer.MIN_VALUE);\n                break;\n            case INTEGER_255:\n                ret = Integer.valueOf(is.readUnsignedByte());\n                break;\n            case INTEGER_PACK_NEG:\n                ret = Integer.valueOf(-LongPacker.unpackInt(is));\n                break;\n            case INTEGER_PACK:\n                ret = Integer.valueOf(LongPacker.unpackInt(is));\n                break;\n            case LONG_MINUS_1:\n                ret = Long.valueOf(-1);\n                break;\n            case LONG_0:\n                ret = Long.valueOf(0);\n                break;\n            case LONG_1:\n                ret = Long.valueOf(1);\n                break;\n            case LONG_2:\n                ret = Long.valueOf(2);\n                break;\n            case LONG_3:\n                ret = Long.valueOf(3);\n                break;\n            case LONG_4:\n                ret = Long.valueOf(4);\n                break;\n            case LONG_5:\n                ret = Long.valueOf(5);\n                break;\n            case LONG_6:\n                ret = Long.valueOf(6);\n                break;\n            case LONG_7:\n                ret = Long.valueOf(7);\n                break;\n            case LONG_8:\n                ret = Long.valueOf(8);\n                break;\n            case LONG_255:\n                ret = Long.valueOf(is.readUnsignedByte());\n                break;\n            case LONG_PACK_NEG:\n                ret = Long.valueOf(-LongPacker.unpackLong(is));\n                break;\n            case LONG_PACK:\n                ret = Long.valueOf(LongPacker.unpackLong(is));\n                break;\n            case LONG_MINUS_MAX:\n                ret = Long.valueOf(Long.MIN_VALUE);\n                break;\n            case SHORT_MINUS_1:\n                ret = Short.valueOf((short) -1);\n                break;\n            case SHORT_0:\n                ret = Short.valueOf((short) 0);\n                break;\n            case SHORT_1:\n                ret = Short.valueOf((short) 1);\n                break;\n            case SHORT_255:\n                ret = Short.valueOf((short) is.readUnsignedByte());\n                break;\n            case SHORT_FULL:\n                ret = Short.valueOf(is.readShort());\n                break;\n            case BYTE_MINUS_1:\n                ret = Byte.valueOf((byte) -1);\n                break;\n            case BYTE_0:\n                ret = Byte.valueOf((byte) 0);\n                break;\n            case BYTE_1:\n                ret = Byte.valueOf((byte) 1);\n                break;\n            case BYTE_FULL:\n                ret = Byte.valueOf(is.readByte());\n                break;\n            case SHORT_ARRAY:\n                int size = LongPacker.unpackInt(is);\n                ret = new short[size];\n                for(int i=0;i<size;i++) ((short[])ret)[i] = is.readShort();\n                break;\n            case BOOLEAN_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new boolean[size];\n                for(int i=0;i<size;i++) ((boolean[])ret)[i] = is.readBoolean();\n                break;\n            case DOUBLE_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new double[size];\n                for(int i=0;i<size;i++) ((double[])ret)[i] = is.readDouble();\n                break;\n            case FLOAT_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new float[size];\n                for(int i=0;i<size;i++) ((float[])ret)[i] = is.readFloat();\n                break;\n            case CHAR_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new char[size];\n                for(int i=0;i<size;i++) ((char[])ret)[i] = is.readChar();\n                break;\n            case CHAR:\n                ret = Character.valueOf(is.readChar());\n                break;\n            case FLOAT_MINUS_1:\n                ret = Float.valueOf(-1);\n                break;\n            case FLOAT_0:\n                ret = Float.valueOf(0);\n                break;\n            case FLOAT_1:\n                ret = Float.valueOf(1);\n                break;\n            case FLOAT_255:\n                ret = Float.valueOf(is.readUnsignedByte());\n                break;\n            case FLOAT_SHORT:\n                ret = Float.valueOf(is.readShort());\n                break;\n            case FLOAT_FULL:\n                ret = Float.valueOf(is.readFloat());\n                break;\n            case DOUBLE_MINUS_1:\n                ret = Double.valueOf(-1);\n                break;\n            case DOUBLE_0:\n                ret = Double.valueOf(0);\n                break;\n            case DOUBLE_1:\n                ret = Double.valueOf(1);\n                break;\n            case DOUBLE_255:\n                ret = Double.valueOf(is.readUnsignedByte());\n                break;\n            case DOUBLE_SHORT:\n                ret = Double.valueOf(is.readShort());\n                break;\n            case DOUBLE_FULL:\n                ret = Double.valueOf(is.readDouble());\n                break;\n            case BIGINTEGER:\n                ret = new BigInteger(deserializeArrayByteInt(is));\n                break;\n            case BIGDECIMAL:\n                ret = new BigDecimal(new BigInteger(deserializeArrayByteInt(is)), LongPacker.unpackInt(is));\n                break;\n            case STRING:\n                ret = deserializeString(is);\n                break;\n            case STRING_EMPTY:\n                ret = Utils.EMPTY_STRING;\n                break;\n\n            case CLASS:\n                ret = deserializeClass(is);\n                break;\n            case DATE:\n                ret = new Date(is.readLong());\n                break;\n            case ARRAY_INT_B_255:\n                ret = deserializeArrayIntB255(is);\n                break;\n            case ARRAY_INT_B_INT:\n                ret = deserializeArrayIntBInt(is);\n                break;\n            case ARRAY_INT_S:\n                ret = deserializeArrayIntSInt(is);\n                break;\n            case ARRAY_INT_I:\n                ret = deserializeArrayIntIInt(is);\n                break;\n            case ARRAY_INT_PACKED:\n                ret = deserializeArrayIntPack(is);\n                break;\n            case ARRAY_LONG_B:\n                ret = deserializeArrayLongB(is);\n                break;\n            case ARRAY_LONG_S:\n                ret = deserializeArrayLongS(is);\n                break;\n            case ARRAY_LONG_I:\n                ret = deserializeArrayLongI(is);\n                break;\n            case ARRAY_LONG_L:\n                ret = deserializeArrayLongL(is);\n                break;\n            case ARRAY_LONG_PACKED:\n                ret = deserializeArrayLongPack(is);\n                break;\n            case ARRAYLIST_PACKED_LONG:\n                ret = deserializeArrayListPackedLong(is);\n                break;\n            case ARRAY_BYTE_INT:\n                ret = deserializeArrayByteInt(is);\n                break;\n            case JDBMLINKEDLIST:\n                ret = LinkedList2.deserialize(is, this);\n                break;\n            case HTREE:\n                ret = HTree.deserialize(is,this);\n                break;\n            case BTREE:\n                ret = BTree.readExternal(is,this);\n                break;\n            case BTREE_NODE_LEAF:\n                throw new InternalError(\"BPage header, wrong serializer used\");\n            case BTREE_NODE_NONLEAF:\n                throw new InternalError(\"BPage header, wrong serializer used\");\n            case JAVA_SERIALIZATION:\n                throw new InternalError(\"Wrong header, data were probably serialized with OutputStream, not with JDBM serialization\");\n\n            case -1:\n                throw new EOFException();\n\n        }\n\n        if (ret != null || head == NULL) {\n            if (objectStack != null)\n                objectStack.add(ret);\n            return ret;\n        }\n\n        /**  something else which needs object stack initialized*/\n\n        if (objectStack == null)\n            objectStack = new FastArrayList();\n        int oldObjectStackSize = objectStack.size();\n\n        switch (head) {\n            case NORMAL:\n                ret = readObject(is, objectStack);\n                break;\n            case OBJECT_STACK:\n                ret = objectStack.get(LongPacker.unpackInt(is));\n                break;\n            case ARRAYLIST:\n                ret = deserializeArrayList(is, objectStack);\n                break;\n            case ARRAY_OBJECT:\n                ret = deserializeArrayObject(is, objectStack);\n                break;\n            case ARRAY_OBJECT_PACKED_LONG:\n                ret = deserializeArrayObjectPackedLong(is);\n                break;\n            case LINKEDLIST:\n                ret = deserializeLinkedList(is, objectStack);\n                break;\n            case TREESET:\n                ret = deserializeTreeSet(is, objectStack);\n                break;\n            case HASHSET:\n                ret = deserializeHashSet(is, objectStack);\n                break;\n            case LINKEDHASHSET:\n                ret = deserializeLinkedHashSet(is, objectStack);\n                break;\n            case VECTOR:\n                ret = deserializeVector(is, objectStack);\n                break;\n            case TREEMAP:\n                ret = deserializeTreeMap(is, objectStack);\n                break;\n            case HASHMAP:\n                ret = deserializeHashMap(is, objectStack);\n                break;\n            case IDENTITYHASHMAP:\n                ret = deserializeIdentityHashMap(is, objectStack);\n                break;\n            case LINKEDHASHMAP:\n                ret = deserializeLinkedHashMap(is, objectStack);\n                break;\n            case HASHTABLE:\n                ret = deserializeHashtable(is, objectStack);\n                break;\n            case PROPERTIES:\n                ret = deserializeProperties(is, objectStack);\n                break;\n\n            default:\n                throw new InternalError(\"Unknown serialization header: \" + head);\n        }\n\n        if (head != OBJECT_STACK && objectStack.size() == oldObjectStackSize) {\n            //check if object was not already added to stack as part of collection\n            objectStack.add(ret);\n        }\n\n\n        return ret;\n    }",
        "fixed_function": "    public Object deserialize(DataInput is, FastArrayList objectStack) throws IOException, ClassNotFoundException {\n\n        Object ret = null;\n\n        final int head = is.readUnsignedByte();\n\n        /** first try to deserialize object without allocating object stack*/\n        switch (head) {\n            case NULL:\n                break;\n            case BOOLEAN_TRUE:\n                ret = Boolean.TRUE;\n                break;\n            case BOOLEAN_FALSE:\n                ret = Boolean.FALSE;\n                break;\n            case INTEGER_MINUS_1:\n                ret = Integer.valueOf(-1);\n                break;\n            case INTEGER_0:\n                ret = Integer.valueOf(0);\n                break;\n            case INTEGER_1:\n                ret = Integer.valueOf(1);\n                break;\n            case INTEGER_2:\n                ret = Integer.valueOf(2);\n                break;\n            case INTEGER_3:\n                ret = Integer.valueOf(3);\n                break;\n            case INTEGER_4:\n                ret = Integer.valueOf(4);\n                break;\n            case INTEGER_5:\n                ret = Integer.valueOf(5);\n                break;\n            case INTEGER_6:\n                ret = Integer.valueOf(6);\n                break;\n            case INTEGER_7:\n                ret = Integer.valueOf(7);\n                break;\n            case INTEGER_8:\n                ret = Integer.valueOf(8);\n                break;\n            case INTEGER_MINUS_MAX:\n                ret = Integer.valueOf(Integer.MIN_VALUE);\n                break;\n            case INTEGER_255:\n                ret = Integer.valueOf(is.readUnsignedByte());\n                break;\n            case INTEGER_PACK_NEG:\n                ret = Integer.valueOf(-LongPacker.unpackInt(is));\n                break;\n            case INTEGER_PACK:\n                ret = Integer.valueOf(LongPacker.unpackInt(is));\n                break;\n            case LONG_MINUS_1:\n                ret = Long.valueOf(-1);\n                break;\n            case LONG_0:\n                ret = Long.valueOf(0);\n                break;\n            case LONG_1:\n                ret = Long.valueOf(1);\n                break;\n            case LONG_2:\n                ret = Long.valueOf(2);\n                break;\n            case LONG_3:\n                ret = Long.valueOf(3);\n                break;\n            case LONG_4:\n                ret = Long.valueOf(4);\n                break;\n            case LONG_5:\n                ret = Long.valueOf(5);\n                break;\n            case LONG_6:\n                ret = Long.valueOf(6);\n                break;\n            case LONG_7:\n                ret = Long.valueOf(7);\n                break;\n            case LONG_8:\n                ret = Long.valueOf(8);\n                break;\n            case LONG_255:\n                ret = Long.valueOf(is.readUnsignedByte());\n                break;\n            case LONG_PACK_NEG:\n                ret = Long.valueOf(-LongPacker.unpackLong(is));\n                break;\n            case LONG_PACK:\n                ret = Long.valueOf(LongPacker.unpackLong(is));\n                break;\n            case LONG_MINUS_MAX:\n                ret = Long.valueOf(Long.MIN_VALUE);\n                break;\n            case SHORT_MINUS_1:\n                ret = Short.valueOf((short) -1);\n                break;\n            case SHORT_0:\n                ret = Short.valueOf((short) 0);\n                break;\n            case SHORT_1:\n                ret = Short.valueOf((short) 1);\n                break;\n            case SHORT_255:\n                ret = Short.valueOf((short) is.readUnsignedByte());\n                break;\n            case SHORT_FULL:\n                ret = Short.valueOf(is.readShort());\n                break;\n            case BYTE_MINUS_1:\n                ret = Byte.valueOf((byte) -1);\n                break;\n            case BYTE_0:\n                ret = Byte.valueOf((byte) 0);\n                break;\n            case BYTE_1:\n                ret = Byte.valueOf((byte) 1);\n                break;\n            case BYTE_FULL:\n                ret = Byte.valueOf(is.readByte());\n                break;\n            case SHORT_ARRAY:\n                int size = LongPacker.unpackInt(is);\n                ret = new short[size];\n                for(int i=0;i<size;i++) ((short[])ret)[i] = is.readShort();\n                break;\n            case BOOLEAN_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new boolean[size];\n                for(int i=0;i<size;i++) ((boolean[])ret)[i] = is.readBoolean();\n                break;\n            case DOUBLE_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new double[size];\n                for(int i=0;i<size;i++) ((double[])ret)[i] = is.readDouble();\n                break;\n            case FLOAT_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new float[size];\n                for(int i=0;i<size;i++) ((float[])ret)[i] = is.readFloat();\n                break;\n            case CHAR_ARRAY:\n                size = LongPacker.unpackInt(is);\n                ret = new char[size];\n                for(int i=0;i<size;i++) ((char[])ret)[i] = is.readChar();\n                break;\n            case CHAR:\n                ret = Character.valueOf(is.readChar());\n                break;\n            case FLOAT_MINUS_1:\n                ret = Float.valueOf(-1);\n                break;\n            case FLOAT_0:\n                ret = Float.valueOf(0);\n                break;\n            case FLOAT_1:\n                ret = Float.valueOf(1);\n                break;\n            case FLOAT_255:\n                ret = Float.valueOf(is.readUnsignedByte());\n                break;\n            case FLOAT_SHORT:\n                ret = Float.valueOf(is.readShort());\n                break;\n            case FLOAT_FULL:\n                ret = Float.valueOf(is.readFloat());\n                break;\n            case DOUBLE_MINUS_1:\n                ret = Double.valueOf(-1);\n                break;\n            case DOUBLE_0:\n                ret = Double.valueOf(0);\n                break;\n            case DOUBLE_1:\n                ret = Double.valueOf(1);\n                break;\n            case DOUBLE_255:\n                ret = Double.valueOf(is.readUnsignedByte());\n                break;\n            case DOUBLE_SHORT:\n                ret = Double.valueOf(is.readShort());\n                break;\n            case DOUBLE_FULL:\n                ret = Double.valueOf(is.readDouble());\n                break;\n            case BIGINTEGER:\n                ret = new BigInteger(deserializeArrayByteInt(is));\n                break;\n            case BIGDECIMAL:\n                ret = new BigDecimal(new BigInteger(deserializeArrayByteInt(is)), LongPacker.unpackInt(is));\n                break;\n            case STRING:\n                ret = deserializeString(is);\n                break;\n            case STRING_EMPTY:\n                ret = Utils.EMPTY_STRING;\n                break;\n\n            case CLASS:\n                ret = deserializeClass(is);\n                break;\n            case DATE:\n                ret = new Date(is.readLong());\n                break;\n            case ARRAY_INT_B_255:\n                ret = deserializeArrayIntB255(is);\n                break;\n            case ARRAY_INT_B_INT:\n                ret = deserializeArrayIntBInt(is);\n                break;\n            case ARRAY_INT_S:\n                ret = deserializeArrayIntSInt(is);\n                break;\n            case ARRAY_INT_I:\n                ret = deserializeArrayIntIInt(is);\n                break;\n            case ARRAY_INT_PACKED:\n                ret = deserializeArrayIntPack(is);\n                break;\n            case ARRAY_LONG_B:\n                ret = deserializeArrayLongB(is);\n                break;\n            case ARRAY_LONG_S:\n                ret = deserializeArrayLongS(is);\n                break;\n            case ARRAY_LONG_I:\n                ret = deserializeArrayLongI(is);\n                break;\n            case ARRAY_LONG_L:\n                ret = deserializeArrayLongL(is);\n                break;\n            case ARRAY_LONG_PACKED:\n                ret = deserializeArrayLongPack(is);\n                break;\n            case ARRAYLIST_PACKED_LONG:\n                ret = deserializeArrayListPackedLong(is);\n                break;\n            case ARRAY_BYTE_INT:\n                ret = deserializeArrayByteInt(is);\n                break;\n            case LOCALE :\n                ret = new Locale(is.readUTF(),is.readUTF(),is.readUTF());\n                break;\n            case JDBMLINKEDLIST:\n                ret = LinkedList2.deserialize(is, this);\n                break;\n            case HTREE:\n                ret = HTree.deserialize(is,this);\n                break;\n            case BTREE:\n                ret = BTree.readExternal(is,this);\n                break;\n            case BTREE_NODE_LEAF:\n                throw new InternalError(\"BPage header, wrong serializer used\");\n            case BTREE_NODE_NONLEAF:\n                throw new InternalError(\"BPage header, wrong serializer used\");\n            case JAVA_SERIALIZATION:\n                throw new InternalError(\"Wrong header, data were probably serialized with OutputStream, not with JDBM serialization\");\n\n            case -1:\n                throw new EOFException();\n\n        }\n\n        if (ret != null || head == NULL) {\n            if (objectStack != null)\n                objectStack.add(ret);\n            return ret;\n        }\n\n        /**  something else which needs object stack initialized*/\n\n        if (objectStack == null)\n            objectStack = new FastArrayList();\n        int oldObjectStackSize = objectStack.size();\n\n        switch (head) {\n            case NORMAL:\n                ret = readObject(is, objectStack);\n                break;\n            case OBJECT_STACK:\n                ret = objectStack.get(LongPacker.unpackInt(is));\n                break;\n            case ARRAYLIST:\n                ret = deserializeArrayList(is, objectStack);\n                break;\n            case ARRAY_OBJECT:\n                ret = deserializeArrayObject(is, objectStack);\n                break;\n            case ARRAY_OBJECT_PACKED_LONG:\n                ret = deserializeArrayObjectPackedLong(is);\n                break;\n            case LINKEDLIST:\n                ret = deserializeLinkedList(is, objectStack);\n                break;\n            case TREESET:\n                ret = deserializeTreeSet(is, objectStack);\n                break;\n            case HASHSET:\n                ret = deserializeHashSet(is, objectStack);\n                break;\n            case LINKEDHASHSET:\n                ret = deserializeLinkedHashSet(is, objectStack);\n                break;\n            case VECTOR:\n                ret = deserializeVector(is, objectStack);\n                break;\n            case TREEMAP:\n                ret = deserializeTreeMap(is, objectStack);\n                break;\n            case HASHMAP:\n                ret = deserializeHashMap(is, objectStack);\n                break;\n            case IDENTITYHASHMAP:\n                ret = deserializeIdentityHashMap(is, objectStack);\n                break;\n            case LINKEDHASHMAP:\n                ret = deserializeLinkedHashMap(is, objectStack);\n                break;\n            case HASHTABLE:\n                ret = deserializeHashtable(is, objectStack);\n                break;\n            case PROPERTIES:\n                ret = deserializeProperties(is, objectStack);\n                break;\n\n            default:\n                throw new InternalError(\"Unknown serialization header: \" + head);\n        }\n\n        if (head != OBJECT_STACK && objectStack.size() == oldObjectStackSize) {\n            //check if object was not already added to stack as part of collection\n            objectStack.add(ret);\n        }\n\n\n        return ret;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.kotek.jdbm.SerializationTest::testLocale": {
        "path": "net/kotek/jdbm/SerializationTest.java",
        "function_name": "testLocale",
        "src": "public void testLocale() throws Exception{\n        assertEquals(Locale.FRANCE, ser.deserialize(ser.serialize(Locale.FRANCE)));\n        assertEquals(Locale.CANADA_FRENCH, ser.deserialize(ser.serialize(Locale.CANADA_FRENCH)));\n        assertEquals(Locale.SIMPLIFIED_CHINESE, ser.deserialize(ser.serialize(Locale.SIMPLIFIED_CHINESE)));\n        assertEquals(Locale.UNICODE_LOCALE_EXTENSION, ser.deserialize(ser.serialize(Locale.UNICODE_LOCALE_EXTENSION)));\n\n    }",
        "error_msg": "net.kotek.jdbm.SerializationTest::testLocale --> java.lang.NoSuchFieldError: class java.util.Locale.hashcode",
        "clean_error_msg": "java.lang.NoSuchFieldError: class java.util.Locale.hashcode"
      }
    }
  },
  "Jdbm3-5": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/net/kotek/jdbm/SerialClassInfo.java",
        "start_loc": 78,
        "end_loc": 86,
        "buggy_function": "\t\tClassInfo(String name, FieldInfo[] fields) {\n            this.name = name;\n\n            for (FieldInfo f : fields) {\n                this.name2fieldId.put(f.getName(), this.fields.size());\n                this.fields.add(f);\n                this.name2fieldInfo.put(f.getName(), f);\n            }\n        }",
        "fixed_function": "\t\tClassInfo(final String name, final FieldInfo[] fields, final boolean isEnum, final boolean isExternalizable) {\n            this.name = name;\n            this.isEnum = isEnum;\n            this.isExternalizable = isExternalizable;\n\n            for (FieldInfo f : fields) {\n                this.name2fieldId.put(f.getName(), this.fields.size());\n                this.fields.add(f);\n                this.name2fieldInfo.put(f.getName(), f);\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/SerialClassInfo.java",
        "start_loc": 126,
        "end_loc": 128,
        "buggy_function": "\t\tpublic int getEnum() {\n\t\t\treturn isEnum;\n\t\t}",
        "fixed_function": "    public void registerClass(Class clazz) throws IOException {\n        if(clazz != Object.class)\n        \tassertClassSerializable(clazz);\n\n        if (containsClass(clazz))\n            return;\n\n        ObjectStreamField[] streamFields = getFields(clazz);\n        FieldInfo[] fields = new FieldInfo[streamFields.length];\n        for (int i = 0; i < fields.length; i++) {\n            ObjectStreamField sf = streamFields[i];\n            fields[i] = new FieldInfo(sf, clazz);\n        }\n\n        ClassInfo i = new ClassInfo(clazz.getName(), fields,clazz.isEnum(), Externalizable.class.isAssignableFrom(clazz));\n        class2classId.put(clazz, registered.size());\n        classId2class.put(registered.size(), clazz);\n        registered.add(i);\n\n\n        if (db != null)\n            db.update(serialClassInfoRecid, (Serialization) this, db.defaultSerializationSerializer);\n\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/SerialClassInfo.java",
        "start_loc": 130,
        "end_loc": 132,
        "buggy_function": "\t\tpublic void setEnum(boolean isEnum) {\n\t\t\tthis.isEnum = isEnum?1:0;\n\t\t}",
        "fixed_function": "    public void writeObject(DataOutput out, Object obj, FastArrayList objectStack) throws IOException {\n        registerClass(obj.getClass());\n\n        //write class header\n        int classId = getClassId(obj.getClass());\n        LongPacker.packInt(out, classId);\n        ClassInfo classInfo = registered.get(classId);\n\n        if(classInfo.isExternalizable){\n            Externalizable o = (Externalizable) obj;\n            DataInputOutput out2 = (DataInputOutput) out;\n            try{\n                out2.serializer = this;\n                out2.objectStack = objectStack;\n                o.writeExternal(out2);\n            }finally {\n                out2.serializer = null;\n                out2.objectStack = null;\n            }\n            return;\n        }\n\n        \n        if(classInfo.isEnum) {\n        \tint ordinal = ((Enum)obj).ordinal();\n            LongPacker.packInt(out, ordinal);\n        }\n\n        ObjectStreamField[] fields = getFields(obj.getClass());\n        LongPacker.packInt(out, fields.length);\n\n        for (ObjectStreamField f : fields) {\n            //write field ID\n            int fieldId = classInfo.getFieldId(f.getName());\n            if (fieldId == -1) {\n                //field does not exists in class definition stored in db,\n                //propably new field was added so add field descriptor\n                fieldId = classInfo.addFieldInfo(new FieldInfo(f, obj.getClass()));\n                db.update(serialClassInfoRecid, (Serialization) this, db.defaultSerializationSerializer);\n            }\n            LongPacker.packInt(out, fieldId);\n            //and write value\n            Object fieldValue = getFieldValue(classInfo.getField(fieldId), obj);\n            serialize(out, fieldValue, objectStack);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/SerialClassInfo.java",
        "start_loc": 266,
        "end_loc": 289,
        "buggy_function": "    public void registerClass(Class clazz) throws IOException {\n        if(clazz != Object.class)\n        \tassertClassSerializable(clazz);\n\n        if (containsClass(clazz))\n            return;\n\n        ObjectStreamField[] streamFields = getFields(clazz);\n        FieldInfo[] fields = new FieldInfo[streamFields.length];\n        for (int i = 0; i < fields.length; i++) {\n            ObjectStreamField sf = streamFields[i];\n            fields[i] = new FieldInfo(sf, clazz);\n        }\n\n        ClassInfo i = new ClassInfo(clazz.getName(), fields);\n        class2classId.put(clazz, registered.size());\n        classId2class.put(registered.size(), clazz);\n        registered.add(i);\n        i.setEnum(clazz.isEnum());\n\n        if (db != null)\n            db.update(serialClassInfoRecid, (Serialization) this, db.defaultSerializationSerializer);\n\n    }",
        "fixed_function": "    public Object readObject(DataInput in, FastArrayList objectStack) throws IOException {\n        //read class header\n        try {\n            int classId = LongPacker.unpackInt(in);\n            ClassInfo classInfo = registered.get(classId);\n//            Class clazz = Class.forName(classInfo.getName());\n            Class clazz = classId2class.get(classId);\n            if(clazz == null)\n            \tclazz = Class.forName(classInfo.getName());\n            assertClassSerializable(clazz);\n\n            Object o;\n            \n            if(classInfo.isEnum) {\n                int ordinal = LongPacker.unpackInt(in);\n                o = clazz.getEnumConstants()[ordinal];\n            }\n            else {\n            \to = createInstance(clazz, Object.class);\n            }\n            \n            objectStack.add(o);\n\n            if(classInfo.isExternalizable){\n                Externalizable oo = (Externalizable) o;\n                DataInputOutput in2 = (DataInputOutput) in;\n                try{\n                    in2.serializer = this;\n                    in2.objectStack = objectStack;\n                    oo.readExternal(in2);\n                }finally {\n                    in2.serializer = null;\n                    in2.objectStack = null;\n                }\n\n            }else{\n                int fieldCount = LongPacker.unpackInt(in);\n                for (int i = 0; i < fieldCount; i++) {\n                    int fieldId = LongPacker.unpackInt(in);\n                    FieldInfo f = classInfo.getField(fieldId);\n                    Object fieldValue = deserialize(in, objectStack);\n                    setFieldValue(f, o, fieldValue);\n                }\n            }\n            return o;\n        } catch (Exception e) {\n            throw new Error(\"Could not instanciate class\", e);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/Serialization.java",
        "start_loc": 56,
        "end_loc": 60,
        "buggy_function": "    public Serialization() {\n        super(null,0L,new ArrayList<ClassInfo>());\n        // Add java.lang.Object as registered class\n        registered.add(new ClassInfo(Object.class.getName(), new FieldInfo[]{}));\n    }",
        "fixed_function": "    public Serialization() {\n        super(null,0L,new ArrayList<ClassInfo>());\n        // Add java.lang.Object as registered class\n        registered.add(new ClassInfo(Object.class.getName(), new FieldInfo[]{},false,false));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/kotek/jdbm/Serialization.java",
        "start_loc": 65,
        "end_loc": 74,
        "buggy_function": "    public byte[] serialize(Object obj)\n            throws IOException {\n        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n        DataOutputStream da = new DataOutputStream(ba);\n        serialize(da, obj);\n\n        da.close();\n\n        return ba.toByteArray();\n    }",
        "fixed_function": "    public byte[] serialize(Object obj)\n            throws IOException {\n        DataInputOutput ba = new DataInputOutput();\n\n        serialize(ba, obj);\n\n        return ba.toByteArray();\n    }",
        "comment": "/**\n     * Serialize the object into a byte array.\n     */"
      },
      {
        "path": "src/main/java/net/kotek/jdbm/Serialization.java",
        "start_loc": 595,
        "end_loc": 603,
        "buggy_function": "    public Object deserialize(byte[] buf) throws ClassNotFoundException, IOException {\n        ByteArrayInputStream bs = new ByteArrayInputStream(buf);\n        DataInputStream das = new DataInputStream(bs);\n        Object ret = deserialize(das);\n        if (bs.available() != 0)\n            throw new InternalError(\"bytes left: \" + bs.available());\n\n        return ret;\n    }",
        "fixed_function": "    public Object deserialize(byte[] buf) throws ClassNotFoundException, IOException {\n        DataInputOutput bs = new DataInputOutput(buf);\n        Object ret = deserialize(bs);\n        if (bs.available() != 0)\n            throw new InternalError(\"bytes left: \" + bs.available());\n\n        return ret;\n    }",
        "comment": "/**\n     * Deserialize an object from a byte array\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */"
      }
    ],
    "trigger_test": {
      "net.kotek.jdbm.SerializationTest::testExternalizable": {
        "path": "net/kotek/jdbm/SerializationTest.java",
        "function_name": "testExternalizable",
        "src": "public void testExternalizable() throws Exception{\n        Extr e = new Extr();\n        e.aaa = 15;\n        e.l = \"pakla\";\n\n        e = (Extr) ser.deserialize(ser.serialize(e));\n        assertEquals(e.aaa,16); //was incremented during serialization\n        assertEquals(e.l,\"pakla\");\n\n    }",
        "error_msg": "net.kotek.jdbm.SerializationTest::testExternalizable --> junit.framework.AssertionFailedError: expected:<0> but was:<16>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0> but was:<16>"
      }
    }
  },
  "Mybatis_pagehelper-3": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/github/pagehelper/PageInterceptor.java",
        "start_loc": 68,
        "end_loc": 116,
        "buggy_function": "    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        try {\n            Object[] args = invocation.getArgs();\n            MappedStatement ms = (MappedStatement) args[0];\n            Object parameter = args[1];\n            RowBounds rowBounds = (RowBounds) args[2];\n            ResultHandler resultHandler = (ResultHandler) args[3];\n            Executor executor = (Executor) invocation.getTarget();\n            CacheKey cacheKey;\n            BoundSql boundSql;\n            //\u7531\u4e8e\u903b\u8f91\u5173\u7cfb\uff0c\u53ea\u4f1a\u8fdb\u5165\u4e00\u6b21\n            if (args.length == 4) {\n                //4 \u4e2a\u53c2\u6570\u65f6\n                boundSql = ms.getBoundSql(parameter);\n                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);\n            } else {\n                //6 \u4e2a\u53c2\u6570\u65f6\n                cacheKey = (CacheKey) args[4];\n                boundSql = (BoundSql) args[5];\n            }\n            checkDialectExists();\n\n            List resultList;\n            //\u8c03\u7528\u65b9\u6cd5\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c\u5206\u9875\uff0c\u5982\u679c\u4e0d\u9700\u8981\uff0c\u76f4\u63a5\u8fd4\u56de\u7ed3\u679c\n            if (!dialect.skip(ms, parameter, rowBounds)) {\n                //\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c count \u67e5\u8be2\n                if (dialect.beforeCount(ms, parameter, rowBounds)) {\n                    //\u67e5\u8be2\u603b\u6570\n                    Long count = count(executor, ms, parameter, rowBounds, resultHandler, boundSql);\n                    //\u5904\u7406\u67e5\u8be2\u603b\u6570\uff0c\u8fd4\u56de true \u65f6\u7ee7\u7eed\u5206\u9875\u67e5\u8be2\uff0cfalse \u65f6\u76f4\u63a5\u8fd4\u56de\n                    if (!dialect.afterCount(count, parameter, rowBounds)) {\n                        //\u5f53\u67e5\u8be2\u603b\u6570\u4e3a 0 \u65f6\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u7684\u7ed3\u679c\n                        return dialect.afterPage(new ArrayList(), parameter, rowBounds);\n                    }\n                }\n                resultList = ExecutorUtil.pageQuery(dialect, executor,\n                        ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);\n            } else {\n                //rowBounds\u7528\u53c2\u6570\u503c\uff0c\u4e0d\u4f7f\u7528\u5206\u9875\u63d2\u4ef6\u5904\u7406\u65f6\uff0c\u4ecd\u7136\u652f\u6301\u9ed8\u8ba4\u7684\u5185\u5b58\u5206\u9875\n                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);\n            }\n            return dialect.afterPage(resultList, parameter, rowBounds);\n        } finally {\n            if(dialect != null){\n                dialect.afterAll();\n            }\n        }\n    }",
        "fixed_function": "    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        try {\n            Object[] args = invocation.getArgs();\n            MappedStatement ms = (MappedStatement) args[0];\n            Object parameter = args[1];\n            RowBounds rowBounds = (RowBounds) args[2];\n            ResultHandler resultHandler = (ResultHandler) args[3];\n            Executor executor = (Executor) invocation.getTarget();\n            CacheKey cacheKey;\n            BoundSql boundSql;\n            //\u7531\u4e8e\u903b\u8f91\u5173\u7cfb\uff0c\u53ea\u4f1a\u8fdb\u5165\u4e00\u6b21\n            if (args.length == 4) {\n                //4 \u4e2a\u53c2\u6570\u65f6\n                boundSql = ms.getBoundSql(parameter);\n                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);\n            } else {\n                //6 \u4e2a\u53c2\u6570\u65f6\n                cacheKey = (CacheKey) args[4];\n                boundSql = (BoundSql) args[5];\n            }\n            checkDialectExists();\n\n            List resultList;\n            //\u8c03\u7528\u65b9\u6cd5\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c\u5206\u9875\uff0c\u5982\u679c\u4e0d\u9700\u8981\uff0c\u76f4\u63a5\u8fd4\u56de\u7ed3\u679c\n            if (!dialect.skip(ms, parameter, rowBounds)) {\n                //\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c count \u67e5\u8be2\n                if (dialect.beforeCount(ms, parameter, rowBounds)) {\n                    //\u67e5\u8be2\u603b\u6570\n                    Long count = count(executor, ms, parameter, rowBounds, null, boundSql);\n                    //\u5904\u7406\u67e5\u8be2\u603b\u6570\uff0c\u8fd4\u56de true \u65f6\u7ee7\u7eed\u5206\u9875\u67e5\u8be2\uff0cfalse \u65f6\u76f4\u63a5\u8fd4\u56de\n                    if (!dialect.afterCount(count, parameter, rowBounds)) {\n                        //\u5f53\u67e5\u8be2\u603b\u6570\u4e3a 0 \u65f6\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u7684\u7ed3\u679c\n                        return dialect.afterPage(new ArrayList(), parameter, rowBounds);\n                    }\n                }\n                resultList = ExecutorUtil.pageQuery(dialect, executor,\n                        ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);\n            } else {\n                //rowBounds\u7528\u53c2\u6570\u503c\uff0c\u4e0d\u4f7f\u7528\u5206\u9875\u63d2\u4ef6\u5904\u7406\u65f6\uff0c\u4ecd\u7136\u652f\u6301\u9ed8\u8ba4\u7684\u5185\u5b58\u5206\u9875\n                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);\n            }\n            return dialect.afterPage(resultList, parameter, rowBounds);\n        } finally {\n            if(dialect != null){\n                dialect.afterAll();\n            }\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/pagehelper/PageInterceptor.java",
        "start_loc": 133,
        "end_loc": 153,
        "buggy_function": "    private Long count(Executor executor, MappedStatement ms, Object parameter,\n                       RowBounds rowBounds, ResultHandler resultHandler,\n                       BoundSql boundSql) throws SQLException {\n        String countMsId = ms.getId() + countSuffix;\n        Long count;\n        //\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u624b\u5199\u7684 count \u67e5\u8be2\n        MappedStatement countMs = ExecutorUtil.getExistedMappedStatement(ms.getConfiguration(), countMsId);\n        if (countMs != null) {\n            count = ExecutorUtil.executeManualCount(executor, countMs, parameter, boundSql, null);\n        } else {\n            countMs = msCountMap.get(countMsId);\n            //\u81ea\u52a8\u521b\u5efa\n            if (countMs == null) {\n                //\u6839\u636e\u5f53\u524d\u7684 ms \u521b\u5efa\u4e00\u4e2a\u8fd4\u56de\u503c\u4e3a Long \u7c7b\u578b\u7684 ms\n                countMs = MSUtils.newCountMappedStatement(ms, countMsId);\n                msCountMap.put(countMsId, countMs);\n            }\n            count = ExecutorUtil.executeAutoCount(dialect, executor, countMs, parameter, boundSql, rowBounds, resultHandler);\n        }\n        return count;\n    }",
        "fixed_function": "    private Long count(Executor executor, MappedStatement ms, Object parameter,\n                       RowBounds rowBounds, ResultHandler resultHandler,\n                       BoundSql boundSql) throws SQLException {\n        String countMsId = ms.getId() + countSuffix;\n        Long count;\n        //\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u624b\u5199\u7684 count \u67e5\u8be2\n        MappedStatement countMs = ExecutorUtil.getExistedMappedStatement(ms.getConfiguration(), countMsId);\n        if (countMs != null) {\n            count = ExecutorUtil.executeManualCount(executor, countMs, parameter, boundSql, resultHandler);\n        } else {\n            countMs = msCountMap.get(countMsId);\n            //\u81ea\u52a8\u521b\u5efa\n            if (countMs == null) {\n                //\u6839\u636e\u5f53\u524d\u7684 ms \u521b\u5efa\u4e00\u4e2a\u8fd4\u56de\u503c\u4e3a Long \u7c7b\u578b\u7684 ms\n                countMs = MSUtils.newCountMappedStatement(ms, countMsId);\n                msCountMap.put(countMsId, countMs);\n            }\n            count = ExecutorUtil.executeAutoCount(dialect, executor, countMs, parameter, boundSql, rowBounds, resultHandler);\n        }\n        return count;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/pagehelper/dialect/AbstractHelperDialect.java",
        "start_loc": 83,
        "end_loc": 96,
        "buggy_function": "    @Override\n    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {\n        Page page = getLocalPage();\n        page.setTotal(count);\n        if (rowBounds instanceof PageRowBounds) {\n            ((PageRowBounds) rowBounds).setTotal(count);\n        }\n        //pageSize < 0 \u7684\u65f6\u5019\uff0c\u4e0d\u6267\u884c\u5206\u9875\u67e5\u8be2\n        //pageSize = 0 \u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u6267\u884c\u540e\u7eed\u67e5\u8be2\uff0c\u4f46\u662f\u4e0d\u4f1a\u5206\u9875\n        if (page.getPageSize() < 0) {\n            return false;\n        }\n        return count > ((page.getPageNum() - 1) * page.getPageSize());\n    }",
        "fixed_function": "    @Override\n    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {\n        Page page = getLocalPage();\n        page.setTotal(count);\n        if (rowBounds instanceof PageRowBounds) {\n            ((PageRowBounds) rowBounds).setTotal(count);\n        }\n        //pageSize < 0 \u7684\u65f6\u5019\uff0c\u4e0d\u6267\u884c\u5206\u9875\u67e5\u8be2\n        //pageSize = 0 \u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u6267\u884c\u540e\u7eed\u67e5\u8be2\uff0c\u4f46\u662f\u4e0d\u4f1a\u5206\u9875\n        if (page.getPageSize() < 0) {\n            return false;\n        }\n        return page.getPageNum() > 0 && (count > ((page.getPageNum() - 1) * page.getPageSize()));\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.github.pagehelper.test.reasonable.PageTest::testMapperWithStartPageAndReasonableFalse": {
        "path": "com/github/pagehelper/test/reasonable/PageTest.java",
        "function_name": "testMapperWithStartPageAndReasonableFalse",
        "src": "@Test\n    public void testMapperWithStartPageAndReasonableFalse() {\n        SqlSession sqlSession = MybatisReasonableHelper.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        try {\n            //\u83b7\u53d6\u7b2c20\u9875\uff0c2\u6761\u5185\u5bb9\n            //\u5206\u9875\u63d2\u4ef6\u4f1a\u81ea\u52a8\u6539\u4e3a\u67e5\u8be2\u6700\u540e\u4e00\u9875\n            PageHelper.startPage(20, 50, true, false, false);\n            List<User> list = userMapper.selectAll();\n            PageInfo<User> page = new PageInfo<User>(list);\n            assertEquals(0, list.size());\n            assertEquals(0, page.getStartRow());\n            assertEquals(20, page.getPageNum());\n            assertEquals(183, page.getTotal());\n\n            PageHelper.startPage(4, 50, true, false, false);\n            list = userMapper.selectAll();\n            page = new PageInfo<User>(list);\n            assertEquals(33, list.size());\n            assertEquals(151, page.getStartRow());\n            assertEquals(4, page.getPageNum());\n            assertEquals(183, page.getTotal());\n\n            PageHelper.startPage(-1, 50, true, false, false);\n            list = userMapper.selectAll();\n            page = new PageInfo<User>(list);\n            assertEquals(0, list.size());\n            assertEquals(0, page.getStartRow());\n            assertEquals(-1, page.getPageNum());\n            assertEquals(183, page.getTotal());\n        } finally {\n            sqlSession.close();\n        }\n    }",
        "error_msg": "com.github.pagehelper.test.reasonable.PageTest::testMapperWithStartPageAndReasonableFalse --> junit.framework.AssertionFailedError: expected:<0> but was:<50>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0> but was:<50>"
      }
    }
  },
  "Mybatis_pagehelper-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/github/pagehelper/Page.java",
        "start_loc": 229,
        "end_loc": 234,
        "buggy_function": "    public Page<E> setPageSizeZero(Boolean pageSizeZero) {\n        if (pageSizeZero != null) {\n            this.pageSizeZero = pageSizeZero;\n        }\n        return this;\n    }",
        "fixed_function": "    public Page<E> setPageSizeZero(Boolean pageSizeZero) {\n        if (this.pageSizeZero == null && pageSizeZero != null) {\n            this.pageSizeZero = pageSizeZero;\n        }\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/pagehelper/dialect/AbstractHelperDialect.java",
        "start_loc": 83,
        "end_loc": 98,
        "buggy_function": "    @Override\n    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {\n        Page page = getLocalPage();\n        page.setTotal(count);\n        if (rowBounds instanceof PageRowBounds) {\n            ((PageRowBounds) rowBounds).setTotal(count);\n        }\n        //pageSize < 0 \u7684\u65f6\u5019\uff0c\u4e0d\u6267\u884c\u5206\u9875\u67e5\u8be2\n        //pageSize = 0 \u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u6267\u884c\u540e\u7eed\u67e5\u8be2\uff0c\u4f46\u662f\u4e0d\u4f1a\u5206\u9875\n        if (page.getPageSize() < 0) {\n            //PageSizeZero=false&&pageSize<=0\n                return false;\n            //PageSizeZero=true&&pageSize<0 \u8fd4\u56de false\uff0c\u53ea\u6709>=0\u624d\u9700\u8981\u6267\u884c\u540e\u7eed\u7684\n        }\n        return page.getPageNum() > 0 && (count > ((page.getPageNum() - 1) * page.getPageSize()));\n    }",
        "fixed_function": "    @Override\n    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {\n        Page page = getLocalPage();\n        page.setTotal(count);\n        if (rowBounds instanceof PageRowBounds) {\n            ((PageRowBounds) rowBounds).setTotal(count);\n        }\n        //pageSize < 0 \u7684\u65f6\u5019\uff0c\u4e0d\u6267\u884c\u5206\u9875\u67e5\u8be2\n        //pageSize = 0 \u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u6267\u884c\u540e\u7eed\u67e5\u8be2\uff0c\u4f46\u662f\u4e0d\u4f1a\u5206\u9875\n        if (page.getPageSizeZero() != null) {\n            //PageSizeZero=false&&pageSize<=0\n            if (!page.getPageSizeZero() && page.getPageSize() <= 0) {\n                return false;\n            }\n            //PageSizeZero=true&&pageSize<0 \u8fd4\u56de false\uff0c\u53ea\u6709>=0\u624d\u9700\u8981\u6267\u884c\u540e\u7eed\u7684\n            else if (page.getPageSizeZero() && page.getPageSize() < 0) {\n                return false;\n            }\n        }\n        return page.getPageNum() > 0 && (count > ((page.getPageNum() - 1) * page.getPageSize()));\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.github.pagehelper.test.pagesize.PageSizeLessThenOrEqualZeroTest::testWithStartPage": {
        "path": "com/github/pagehelper/test/pagesize/PageSizeLessThenOrEqualZeroTest.java",
        "function_name": "testWithStartPage",
        "src": "@Test\n    public void testWithStartPage() {\n        SqlSession sqlSession = MybatisHelper.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        try {\n            //pageSize=0,\u8fd9\u65f6\u5019\u76f8\u5f53\u4e8e\u7528\u5206\u9875\u63d2\u4ef6\u6c42count\n            PageHelper.startPage(1, 0);\n            List<User> list = userMapper.selectAll();\n            PageInfo<User> page = new PageInfo<User>(list);\n            assertEquals(0, list.size());\n            assertEquals(183, page.getTotal());\n\n            //limit<0\u7684\u65f6\u5019\u540c\u4e0a\n            PageHelper.startPage(1, -100);\n            list = userMapper.selectAll();\n            page = new PageInfo<User>(list);\n            assertEquals(0, list.size());\n            assertEquals(183, page.getTotal());\n        } finally {\n            sqlSession.close();\n        }\n    }",
        "error_msg": "com.github.pagehelper.test.pagesize.PageSizeLessThenOrEqualZeroTest::testWithStartPage --> junit.framework.AssertionFailedError: expected:<0> but was:<183>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0> but was:<183>"
      },
      "com.github.pagehelper.test.reasonable.PageTest::testMapperWithStartPageAndPageSizeZeroFalse": {
        "path": "com/github/pagehelper/test/reasonable/PageTest.java",
        "function_name": "testMapperWithStartPageAndPageSizeZeroFalse",
        "src": "@Test\n    public void testMapperWithStartPageAndPageSizeZeroFalse() {\n        SqlSession sqlSession = MybatisReasonableHelper.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        try {\n            //\u83b7\u53d6\u7b2c20\u9875\uff0c2\u6761\u5185\u5bb9\n            //\u5206\u9875\u63d2\u4ef6\u4f1a\u81ea\u52a8\u6539\u4e3a\u67e5\u8be2\u6700\u540e\u4e00\u9875\n            PageHelper.startPage(1, 0, true, true, false);\n            List<User> list = userMapper.selectAll();\n            PageInfo<User> page = new PageInfo<User>(list);\n            assertEquals(0, list.size());\n            assertEquals(0, page.getStartRow());\n            assertEquals(1, page.getPageNum());\n            assertEquals(183, page.getTotal());\n\n            PageHelper.startPage(1, Integer.MAX_VALUE, true, true, false);\n            list = userMapper.selectAll();\n            page = new PageInfo<User>(list);\n            assertEquals(183, list.size());\n            assertEquals(1, page.getStartRow());\n            assertEquals(1, page.getPageNum());\n            assertEquals(183, page.getTotal());\n        } finally {\n            sqlSession.close();\n        }\n    }",
        "error_msg": "com.github.pagehelper.test.reasonable.PageTest::testMapperWithStartPageAndPageSizeZeroFalse --> junit.framework.AssertionFailedError: expected:<0> but was:<183>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0> but was:<183>"
      }
    }
  },
  "Vectorz-5": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/mikera/matrixx/impl/SparseColumnMatrix.java",
        "start_loc": 191,
        "end_loc": 201,
        "buggy_function": "\tprivate AVector ensureMutableColumn(int i) {\n\t\tAVector v = unsafeGetVec(i);\n\t\tif (v == null) {\n\t\t\tAVector nv=SparseIndexedVector.createLength(rows);\n\t\t\treturn nv;\n\t\t}\n\t\tif (v.isFullyMutable()) return v;\n\t\tAVector mv=v.mutable();\n\t\tunsafeSetVec(i, mv);\n\t\treturn mv;\n\t}",
        "fixed_function": "\tprivate AVector ensureMutableColumn(int i) {\n\t\tAVector v = unsafeGetVec(i);\n\t\tif (v == null) {\n\t\t\tAVector nv=SparseIndexedVector.createLength(rows);\n            unsafeSetVec(i, nv);\n\t\t\treturn nv;\n\t\t}\n\t\tif (v.isFullyMutable()) return v;\n\t\tAVector mv=v.mutable();\n\t\tunsafeSetVec(i, mv);\n\t\treturn mv;\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/mikera/matrixx/impl/SparseRowMatrix.java",
        "start_loc": 199,
        "end_loc": 209,
        "buggy_function": "\tprivate AVector ensureMutableRow(int i) {\n\t\tAVector v = unsafeGetVec(i);\n\t\tif (v == null) {\n\t\t\tAVector nv=SparseIndexedVector.createLength(cols);\n\t\t\treturn nv;\n\t\t}\n\t\tif (v.isFullyMutable()) return v;\n\t\tAVector mv=v.mutable();\n\t\tunsafeSetVec(i, mv);\n\t\treturn mv;\n\t}",
        "fixed_function": "\tprivate AVector ensureMutableRow(int i) {\n\t\tAVector v = unsafeGetVec(i);\n\t\tif (v == null) {\n\t\t\tAVector nv=SparseIndexedVector.createLength(cols);\n            unsafeSetVec(i, nv);\n\t\t\treturn nv;\n\t\t}\n\t\tif (v.isFullyMutable()) return v;\n\t\tAVector mv=v.mutable();\n\t\tunsafeSetVec(i, mv);\n\t\treturn mv;\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/mikera/vectorz/impl/SparseIndexedVector.java",
        "start_loc": 374,
        "end_loc": 399,
        "buggy_function": "\t@Override\n\tpublic void set(AVector v) {\n\t\tcheckSameLength(v);\n\t\t\n\t\tif (v instanceof ADenseArrayVector) {\n\t\t\tset((ADenseArrayVector)v);\n\t\t\treturn;\n\t\t}\n            double[] data=this.data;\n            int nz=(int) v.nonZeroCount();\n            if (nz!=data.length) {\n                data=new double[nz];\n                this.data=data;\n                index=Index.createLength(nz);\n            }\n            \n            int di=0;\n            for (int i=0; i<length; i++) {\n                double val=v.unsafeGet(i);\n                if (val!=0) {\n                    data[di]=val;\n                    index.set(di, i);\n                    di++;\n                }\n            }\n        }",
        "fixed_function": "\t@Override\n\tpublic void set(AVector v) {\n\t\tcheckSameLength(v);\n\t\t\n\t\tif (v instanceof ADenseArrayVector) {\n\t\t\tset((ADenseArrayVector)v);\n\t\t\treturn;\n\t\t} else if (v instanceof ASparseVector) {\n            int[] nzi = v.nonZeroIndices();\n            index=Index.wrap(nzi);\n            if (nzi.length!=data.length) {\n                data=new double[nzi.length];\n            }\n            for (int i=0; i<index.length(); i++) {\n                double val=v.unsafeGet(index.get(i));\n                data[i]=val;\n            }\n            return;\n        } else {\n            double[] data=this.data;\n            int nz=(int) v.nonZeroCount();\n            if (nz!=data.length) {\n                data=new double[nz];\n                this.data=data;\n                index=Index.createLength(nz);\n            }\n            \n            int di=0;\n            for (int i=0; i<nz; i++) {\n                double val=v.unsafeGet(i);\n                if (val!=0) {\n                    data[di]=val;\n                    index.set(di, i);\n                    di++;\n                }\n            }\n        }\n\t}",
        "comment": ""
      }
    ],
    "trigger_test": {
      "mikera.matrixx.impl.TestSparseColumnMatrix::testSetColumn": {
        "path": "mikera/matrixx/impl/TestSparseColumnMatrix.java",
        "function_name": "testSetColumn",
        "src": "@Test public void testSetColumn() {\n        SparseColumnMatrix m=SparseColumnMatrix.create(3, 3);\n        \n        Vector v=Vector.of(1,2,3);\n        \n        m.setColumn(0, v);\n        assertEquals(v,m.getColumn(0));\n        assertEquals(1,m.getColumn(0).get(0),0.0);\n    }",
        "error_msg": "mikera.matrixx.impl.TestSparseColumnMatrix::testSetColumn --> junit.framework.AssertionFailedError: expected:<[1.0,2.0,3.0]> but was:<[0.0,0.0,0.0]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[1.0,2.0,3.0]> but was:<[0.0,0.0,0.0]>"
      }
    }
  },
  "Vectorz-6": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/mikera/arrayz/AbstractArray.java",
        "start_loc": 61,
        "end_loc": 72,
        "buggy_function": "\t@Override\n\tpublic void fill(double value) {\n\t\tif (dimensionality()==0) {\n\t\t\tset(value);\n\t\t} else {\n\t\t\tint sc=sliceCount();\n\t\t\tfor (int i=0; i<sc; i++) {\n\t\t\t\tINDArray s=slice(i);\n\t\t\t\ts.fill(value);\n\t\t\t}\t\t\t\n\t\t}\n\t}\t",
        "fixed_function": "\t@Override\n\tpublic boolean epsilonEquals(INDArray a, double epsilon) {\n\t\tif (dimensionality()==0) {\n\t\t\tdouble d=get()-a.get();\n\t\t\treturn (Math.abs(d)<=epsilon);\n\t\t} else {\n\t\t\tint sc=sliceCount();\n\t\t\tif (a.sliceCount()!=sc) return false;\n\t\t\tfor (int i=0; i<sc; i++) {\n\t\t\t\tINDArray s=slice(i);\n\t\t\t\tif (!s.epsilonEquals(a.slice(i),epsilon)) return false;\n\t\t\t}\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/mikera/arrayz/SliceArray.java",
        "start_loc": 89,
        "end_loc": 94,
        "buggy_function": "\t@Override\n\tpublic void set(double value) {\n\t\tfor (T s:slices) {\n\t\t\ts.set(value);\n\t\t}\n\t}\t",
        "fixed_function": "\t@Override\n\tpublic void set(int[] indexes, double value) {\n\t\tint d=indexes.length;\n\t\tif (d==0) {\n\t\t\tfor (int i=0; i<slices.length; i++) {\n\t\t\t\tslices[i].set(indexes,value);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tT slice=slices[indexes[0]];\n\t\tswitch (d) {\n\t\t\tcase 0: throw new VectorzException(\"Can't do 0D set on SliceArray!\");\n\t\t\tcase 1: slice.set(value); return;\n\t\t\tcase 2: slice.set(indexes[1],value); return;\n\t\t\tcase 3: slice.set(indexes[1],indexes[2],value); return;\n\t\t\tdefault: slice.set(Arrays.copyOfRange(indexes,1,d),value); return;\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/mikera/matrixx/AMatrix.java",
        "start_loc": 80,
        "end_loc": 83,
        "buggy_function": "\t@Override \n\tpublic void set(double value) {\n\t\tthrow new VectorzException(\"0D set not supported on matrix!\");\n\t}",
        "fixed_function": "\t@Override \n\tpublic void set(double value) {\n\t\tasVector().fill(value);\n\t}",
        "comment": ""
      }
    ],
    "trigger_test": {
      "mikera.matrixx.TestMatrixx::genericTests": {
        "path": "mikera/matrixx/TestMatrixx.java",
        "function_name": "genericTests",
        "src": "@Test public void genericTests() {\n\t\t// zero matrices\n\t\tdoGenericTests(Matrixx.createImmutableZeroMatrix(3, 2));\n\t\tdoGenericTests(Matrixx.createImmutableZeroMatrix(5, 5));\n\t\tdoGenericTests(Matrixx.createImmutableZeroMatrix(3, 3));\n\t\tdoGenericTests(Matrixx.createImmutableZeroMatrix(1, 7));\n\t\t\n\t\t// specialised 3x3 matrix\n\t\tMatrix33 m33=new Matrix33();\n\t\tdoGenericTests(m33);\n\t\t\n\t\t// specialised 2*2 matrix\n\t\tMatrix22 m22=new Matrix22();\n\t\tdoGenericTests(m22);\n\t\t\n\t\t// specialised Mx3 matrix\n\t\tVectorMatrixM3 mm3=new VectorMatrixM3(10);\n\t\tdoGenericTests(mm3);\n\t\n\t\t// general M*N matrix\n\t\tVectorMatrixMN mmn=new VectorMatrixMN(6 ,7);\n\t\tdoGenericTests(mmn);\n\t\t\n\t\t// permuted matrix\n\t\tPermutedMatrix pmm=new PermutedMatrix(mmn,\n\t\t\t\tIndexz.createRandomPermutation(mmn.rowCount()),\n\t\t\t\tIndexz.createRandomPermutation(mmn.columnCount()));\n\t\tdoGenericTests(pmm);\n\n\t\t// small 2*2 matrix\n\t\tmmn=new VectorMatrixMN(2,2);\n\t\tdoGenericTests(mmn);\n\t\t\n\t\t// 1x0 matrix should work\n\t\tmmn=new VectorMatrixMN(1 ,0);\n\t\tdoGenericTests(mmn);\n\n\t\t// square M*M matrix\n\t\tmmn=new VectorMatrixMN(6 ,6);\n\t\tdoGenericTests(mmn);\n\n\t\tMatrix am1=new Matrix(m33);\n\t\tdoGenericTests(am1);\n\t\t\n\t\tMatrix am2=new Matrix(mmn);\n\t\tdoGenericTests(am2);\n\t\t\n\t\tdoGenericTests(SubsetMatrix.create(Index.of(0,1,2),3));\n\t\tdoGenericTests(SubsetMatrix.create(Index.of(0,1,3,10),12));\n\t\tdoGenericTests(SubsetMatrix.create(Index.of(0,3,2,1),4));\n\t\t\n\t\tdoGenericTests(ScalarMatrix.create(1,3.0));\n\t\tdoGenericTests(ScalarMatrix.create(3,3.0));\n\t\tdoGenericTests(ScalarMatrix.create(5,0));\n\t\t\n\t\tdoGenericTests(new RowMatrix(Vector.of(1,2,3,4)));\n\t\tdoGenericTests(new ColumnMatrix(Vector.of(1,2,3,4)));\n\t\tdoGenericTests(new RowMatrix(Vector3.of(1,2,3)));\n\t\tdoGenericTests(new ColumnMatrix(Vector3.of(1,2,3)));\n\t}",
        "error_msg": "mikera.matrixx.TestMatrixx::genericTests --> mikera.vectorz.util.VectorzException: 0D set not supported on matrix!",
        "clean_error_msg": "mikera.vectorz.util.VectorzException: 0D set not supported on matrix!"
      }
    }
  },
  "Sparkey_java-2": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/spotify/sparkey/SnappyOutputStream.java",
        "start_loc": 75,
        "end_loc": 88,
        "buggy_function": "  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n\n    int remaining = remaining();\n    if (len < remaining) {\n      System.arraycopy(b, off, uncompressedBuffer, pending, len);\n      pending += len;\n    } else {\n      System.arraycopy(b, off, uncompressedBuffer, pending, remaining);\n      pending = maxBlockSize;\n      flush();\n      write(b, off + remaining, len - remaining);\n    }\n  }",
        "fixed_function": "  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n    while (len > 0) {\n      int written = writeImpl(b, off, len);\n      off += written;\n      len -= written;\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/SnappyReader.java",
        "start_loc": 68,
        "end_loc": 83,
        "buggy_function": "  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n\n    int available = available();\n    if (len <= available) {\n      System.arraycopy(uncompressedBuf, bufPos, b, off, len);\n      bufPos += len;\n      return len;\n    } else {\n      System.arraycopy(uncompressedBuf, bufPos, b, off, available);\n      bufPos = blockSize;\n      fetchBlock();\n      read(b, off + available, len - available);\n      return len;\n    }\n  }",
        "fixed_function": "  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int remain = len;\n    while (remain > 0) {\n      int didRead = readImpl(b, off, remain);\n      off += didRead;\n      remain -= didRead;\n    }\n    return len;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/SnappyReader.java",
        "start_loc": 85,
        "end_loc": 98,
        "buggy_function": "  @Override\n  public long skip(long n) throws IOException {\n\n    int available = available();\n    if (n <= available) {\n      bufPos += n;\n      return n;\n    } else {\n      bufPos = blockSize;\n      fetchBlock();\n      skip(n - available);\n      return n;\n    }\n  }",
        "fixed_function": "  private int readImpl(byte[] b, int off, int len) throws IOException {\n    int available = available();\n    if (len <= available) {\n      System.arraycopy(uncompressedBuf, bufPos, b, off, len);\n      bufPos += len;\n      return len;\n    } else {\n      System.arraycopy(uncompressedBuf, bufPos, b, off, available);\n      bufPos = blockSize;\n      fetchBlock();\n      return available;\n    }\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.spotify.sparkey.SnappyOutputStreamTest::testLargeWrite": {
        "path": "com/spotify/sparkey/SnappyOutputStreamTest.java",
        "function_name": "testLargeWrite",
        "src": "@Test\n    public void testLargeWrite() throws IOException {\n        File testFile = File.createTempFile(\"sparkey-test\", \"\");\n        testFile.deleteOnExit();\n        FileOutputStream fos = new FileOutputStream(testFile);\n\n        byte[] buf = new byte[1000 * 1000];\n        SnappyOutputStream os = new SnappyOutputStream(10, fos, fos.getFD());\n        os.write(buf);\n\n        testFile.delete();\n    }",
        "error_msg": "com.spotify.sparkey.SnappyOutputStreamTest::testLargeWrite --> java.lang.StackOverflowError",
        "clean_error_msg": "java.lang.StackOverflowError"
      },
      "com.spotify.sparkey.SnappyReaderTest::testLargeRead": {
        "path": "com/spotify/sparkey/SnappyReaderTest.java",
        "function_name": "testLargeRead",
        "src": "@Test\n    public void testLargeRead() throws IOException {\n        byte[] buf = new byte[1000 * 1000];\n        int ret = reader().read(buf);\n        assertEquals(1000 * 1000, ret);\n    }",
        "error_msg": "com.spotify.sparkey.SnappyReaderTest::testLargeRead --> java.lang.StackOverflowError",
        "clean_error_msg": "java.lang.StackOverflowError"
      },
      "com.spotify.sparkey.SnappyReaderTest::testLargeSkip": {
        "path": "com/spotify/sparkey/SnappyReaderTest.java",
        "function_name": "testLargeSkip",
        "src": "@Test\n    public void testLargeSkip() throws IOException {\n        long ret = reader().skip(1000 * 1000);\n        assertEquals(1000 * 1000, ret);\n    }",
        "error_msg": "com.spotify.sparkey.SnappyReaderTest::testLargeSkip --> java.lang.StackOverflowError",
        "clean_error_msg": "java.lang.StackOverflowError"
      }
    }
  },
  "Sparkey_java-3": {
    "function_num": 10,
    "functions": [
      {
        "path": "src/main/java/com/spotify/sparkey/IndexHash.java",
        "start_loc": 43,
        "end_loc": 68,
        "buggy_function": "  private IndexHash(File indexFile, File logFile, IndexHeader header, LogHeader logHeader, ReadOnlyMemMap indexData, int maxBlockSize, BlockRandomInput logData) {\n    this.indexFile = indexFile;\n    this.logFile = logFile;\n    this.header = header;\n    this.logHeader = logHeader;\n    this.indexData = indexData;\n    this.maxBlockSize = maxBlockSize;\n    this.logData = logData;\n\n    indexStart = header.size();\n    hashSeed = header.getHashSeed();\n    hashCapacity = header.getHashCapacity();\n\n    int maxKeyLen = (int) header.getMaxKeyLen();\n    keyBuf = new byte[Math.max(maxKeyLen, 1024)];\n    slotSize = header.getSlotSize();\n    entry = new IndexHashEntry();\n    entryBlockBits = header.getEntryBlockBits();\n    entryBlockBitmask = ((1 << entryBlockBits) - 1);\n\n    stream = new SafeStream(logData);\n    long expectedFileSize = IndexHeader.HEADER_SIZE + slotSize * hashCapacity;\n    if (expectedFileSize != indexFile.length()) {\n      throw new RuntimeException(\"Corrupt index file - incorrect size. Expected \" + expectedFileSize + \" but was \" + indexFile.length());\n    }\n  }",
        "fixed_function": "  private IndexHash(File indexFile, File logFile, IndexHeader header, LogHeader logHeader, ReadOnlyMemMap indexData, int maxBlockSize, BlockRandomInput logData) {\n    this.indexFile = indexFile;\n    this.logFile = logFile;\n    this.header = header;\n    this.logHeader = logHeader;\n    this.indexData = indexData;\n    this.maxBlockSize = maxBlockSize;\n    this.logData = logData;\n\n    indexStart = header.size();\n    hashSeed = header.getHashSeed();\n    hashCapacity = header.getHashCapacity();\n\n    int maxKeyLen = (int) header.getMaxKeyLen();\n    keyBuf = new byte[Math.max(maxKeyLen, 1024)];\n    slotSize = header.getSlotSize();\n    entry = new IndexHashEntry();\n    entryBlockBits = header.getEntryBlockBits();\n    entryBlockBitmask = ((1 << entryBlockBits) - 1);\n\n    stream = new SafeStream(logData);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 55,
        "end_loc": 83,
        "buggy_function": "  ReadOnlyMemMap(File file) throws IOException {\n\n    this.randomAccessFile = new RandomAccessFile(file, \"r\");\n    this.size = file.length();\n    if (size <= 0) {\n      throw new IllegalArgumentException(\"Non-positive size: \" + size);\n    }\n    long numFullMaps = (size - 1) >> 30;\n    if (numFullMaps >= Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"Too large size: \" + size);\n    }\n    long sizeFullMaps = numFullMaps * MAP_SIZE;\n\n    numChunks = (int) (numFullMaps + 1);\n    chunks = new MappedByteBuffer[numChunks];\n    long offset = 0;\n    for (int i = 0; i < numFullMaps; i++) {\n      chunks[i] = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, offset, MAP_SIZE);\n      offset += MAP_SIZE;\n    }\n    long lastSize = size - sizeFullMaps;\n    if (lastSize > 0) {\n      chunks[numChunks - 1] = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, offset, lastSize);\n    }\n\n    curChunkIndex = 0;\n    curChunk = chunks[0];\n    curChunk.position(0);\n  }",
        "fixed_function": "  ReadOnlyMemMap(File file) throws IOException {\n    this.file = file;\n    this.allInstances = Lists.newArrayList();\n    this.allInstances.add(this);\n\n    this.randomAccessFile = new RandomAccessFile(file, \"r\");\n    this.size = file.length();\n    if (size <= 0) {\n      throw new IllegalArgumentException(\"Non-positive size: \" + size);\n    }\n    long numFullMaps = (size - 1) >> 30;\n    if (numFullMaps >= Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"Too large size: \" + size);\n    }\n    long sizeFullMaps = numFullMaps * MAP_SIZE;\n\n    numChunks = (int) (numFullMaps + 1);\n    chunks = new MappedByteBuffer[numChunks];\n    long offset = 0;\n    for (int i = 0; i < numFullMaps; i++) {\n      chunks[i] = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, offset, MAP_SIZE);\n      offset += MAP_SIZE;\n    }\n    long lastSize = size - sizeFullMaps;\n    if (lastSize > 0) {\n      chunks[numChunks - 1] = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, offset, lastSize);\n    }\n\n    curChunkIndex = 0;\n    curChunk = chunks[0];\n    curChunk.position(0);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 85,
        "end_loc": 96,
        "buggy_function": "  private ReadOnlyMemMap(ReadOnlyMemMap largeMemMap) {\n    this.randomAccessFile = largeMemMap.randomAccessFile;\n    this.size = largeMemMap.size;\n    this.numChunks = largeMemMap.numChunks;\n    this.chunks = new MappedByteBuffer[numChunks];\n    for (int i = 0; i < numChunks; i++) {\n      chunks[i] = (MappedByteBuffer) largeMemMap.chunks[i].duplicate();\n    }\n    curChunkIndex = 0;\n    curChunk = chunks[0];\n    curChunk.position(0);\n  }",
        "fixed_function": "  private ReadOnlyMemMap(ReadOnlyMemMap source, MappedByteBuffer[] chunks) {\n    this.file = source.file;\n    this.allInstances = source.allInstances;\n    this.randomAccessFile = source.randomAccessFile;\n    this.size = source.size;\n    this.numChunks = source.numChunks;\n    this.chunks = chunks;\n    curChunkIndex = 0;\n    curChunk = chunks[0];\n    curChunk.position(0);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 98,
        "end_loc": 110,
        "buggy_function": "  public void close() {\n    for (int i = 0; i < numChunks; i++) {\n      chunks[i] = null;\n    }\n    // Wait a bit with closing so that all threads have a chance to see the that\n    // chunks and curChunks are null\n    curChunk = null;\n    try {\n      randomAccessFile.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }",
        "fixed_function": "  public void close() {\n    final MappedByteBuffer[] chunks;\n    synchronized (allInstances) {\n      if (this.chunks == null) {\n        return;\n      }\n      chunks = this.chunks;\n      for (ReadOnlyMemMap map : allInstances) {\n        map.chunks = null;\n        map.curChunk = null;\n        try {\n          map.randomAccessFile.close();\n        } catch (IOException e) {\n          e.printStackTrace(System.err);\n        }\n      }\n    }\n    // Wait a bit with closing so that all threads have a chance to see the that\n    // chunks and curChunks are null\n    CLEANER.schedule(new Runnable() {\n      @Override\n      public void run() {\n        for (MappedByteBuffer chunk : chunks) {\n          ByteBufferCleaner.cleanMapping(chunk);\n        }\n      }\n    }, 1000, TimeUnit.MILLISECONDS);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 112,
        "end_loc": 121,
        "buggy_function": "  public void seek(long pos) throws IOException {\n    if (pos > size) {\n      throw new IOException(\"Corrupt index: referencing data outside of range\");\n    }\n    int partIndex = (int) (pos >>> 30);\n    curChunkIndex = partIndex;\n    curChunk = chunks[partIndex];\n    curChunk.position((int) (pos & BITMASK_30));\n    this.curChunk = curChunk;\n  }",
        "fixed_function": "  public void seek(long pos) throws IOException {\n    if (pos > size) {\n      throw corruptionException();\n    }\n    int partIndex = (int) (pos >>> 30);\n    curChunkIndex = partIndex;\n    MappedByteBuffer[] chunks = getChunks();\n    MappedByteBuffer curChunk = chunks[partIndex];\n    curChunk.position((int) (pos & BITMASK_30));\n    this.curChunk = curChunk;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 123,
        "end_loc": 130,
        "buggy_function": "  private void next() throws IOException {\n    curChunkIndex++;\n    if (curChunkIndex >= chunks.length) {\n      throw new IOException(\"Corrupt index: referencing data outside of range\");\n    }\n    curChunk = chunks[curChunkIndex];\n    curChunk.position(0);\n  }",
        "fixed_function": "  private void next() throws IOException {\n    MappedByteBuffer[] chunks = getChunks();\n    curChunkIndex++;\n    if (curChunkIndex >= chunks.length) {\n      throw corruptionException();\n    }\n    MappedByteBuffer curChunk = chunks[curChunkIndex];\n    if (curChunk != null) {\n      curChunk.position(0);\n      this.curChunk = curChunk;\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 132,
        "end_loc": 138,
        "buggy_function": "  @Override\n  public int readUnsignedByte() throws IOException {\n    if (curChunk.remaining() == 0) {\n      next();\n    }\n    return ((int) curChunk.get()) & 0xFF;\n  }",
        "fixed_function": "  @Override\n  public int readUnsignedByte() throws IOException {\n    MappedByteBuffer curChunk = getCurChunk();\n    if (curChunk.remaining() == 0) {\n      next();\n    }\n    return ((int) curChunk.get()) & 0xFF;\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 140,
        "end_loc": 152,
        "buggy_function": "  public void readFully(byte[] buffer, int offset, int length) throws IOException {\n    long remaining = curChunk.remaining();\n    if (remaining >= length) {\n      curChunk.get(buffer, offset, length);\n    } else {\n      int remaining1 = (int) remaining;\n      curChunk.get(buffer, offset, remaining1);\n      length -= remaining1;\n      offset += remaining1;\n      next();\n      readFully(buffer, offset, length);\n    }\n  }",
        "fixed_function": "  public void readFully(byte[] buffer, int offset, int length) throws IOException {\n    MappedByteBuffer curChunk = getCurChunk();\n    long remaining = curChunk.remaining();\n    if (remaining >= length) {\n      curChunk.get(buffer, offset, length);\n    } else {\n      int remaining1 = (int) remaining;\n      curChunk.get(buffer, offset, remaining1);\n      length -= remaining1;\n      offset += remaining1;\n      next();\n      readFully(buffer, offset, length);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 154,
        "end_loc": 162,
        "buggy_function": "  public void skipBytes(long amount) throws IOException {\n    int remaining = curChunk.remaining();\n    if (remaining >= amount) {\n      curChunk.position((int) (curChunk.position() + amount));\n    } else {\n      next();\n      skipBytes(amount - remaining);\n    }\n  }",
        "fixed_function": "  public void skipBytes(long amount) throws IOException {\n    MappedByteBuffer curChunk = getCurChunk();\n    int remaining = curChunk.remaining();\n    if (remaining >= amount) {\n      curChunk.position((int) (curChunk.position() + amount));\n    } else {\n      next();\n      skipBytes(amount - remaining);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java",
        "start_loc": 168,
        "end_loc": 171,
        "buggy_function": "  public ReadOnlyMemMap duplicate() {\n        // Duplicating a closed instance is silly, and there's no point in actually duplicating it\n    return new ReadOnlyMemMap(this);\n  }",
        "fixed_function": "  private MappedByteBuffer[] getChunks() throws SparkeyReaderClosedException {\n    MappedByteBuffer[] localChunks = chunks;\n    if (localChunks == null) {\n      throw closedException();\n    }\n    return localChunks;\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.spotify.sparkey.ReadOnlyMemMapTest::testDontRunOutOfFileDescriptors": {
        "path": "com/spotify/sparkey/ReadOnlyMemMapTest.java",
        "function_name": "testDontRunOutOfFileDescriptors",
        "src": "@Test\n  public void testDontRunOutOfFileDescriptors() throws Exception {\n    for (int iter = 0; iter < 10*1000; iter++) {\n      ReadOnlyMemMap memMap = new ReadOnlyMemMap(new File(\"README.md\"));\n      ArrayList<ReadOnlyMemMap> maps = Lists.newArrayList();\n      for (int i = 0; i < 100; i++) {\n        maps.add(memMap.duplicate());\n      }\n      memMap.close();\n      for (ReadOnlyMemMap map : maps) {\n        try {\n          map.readUnsignedByte();\n          fail();\n        } catch (IOException e) {\n        }\n        try {\n          map.seek(1);\n          fail();\n        } catch (IOException e) {\n        }\n        try {\n          map.skipBytes(1);\n          fail();\n        } catch (IOException e) {\n        }\n      }\n    }\n\n  }",
        "error_msg": "com.spotify.sparkey.ReadOnlyMemMapTest::testDontRunOutOfFileDescriptors --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Shazamcrest-1": {
    "function_num": 9,
    "functions": [
      {
        "path": "src/main/java/com/shazam/shazamcrest/FieldsIgnorer.java",
        "start_loc": 46,
        "end_loc": 59,
        "buggy_function": "\tprivate static JsonElement findPaths(JsonElement jsonElement, Set<String> pathsToFind) {\n\t\tif (pathsToFind.isEmpty()) {\n\t\t\treturn jsonElement;\n\t\t}\n\t\t\n\t\tString pathToFind = headOf(pathsToFind);\n\t\tList<String> pathSegments = asList(pathToFind.split(Pattern.quote(\".\")));\n\t\ttry {\n\t\t\tfindPath(jsonElement, pathToFind, pathSegments);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new IllegalArgumentException(pathToFind + \" does not exist\");\n\t\t}\n\t\treturn findPaths(jsonElement, removePathFromSet(pathsToFind, pathToFind));\n\t}",
        "fixed_function": "\tpublic static JsonElement findPaths(JsonElement jsonElement, Set<String> pathsToFind) {\n\t\tif (pathsToFind.isEmpty()) {\n\t\t\treturn jsonElement;\n\t\t}\n\t\t\n\t\tString pathToFind = headOf(pathsToFind);\n\t\tList<String> pathSegments = asList(pathToFind.split(Pattern.quote(\".\")));\n\t\ttry {\n\t\t\tfindPath(jsonElement, pathToFind, pathSegments);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new IllegalArgumentException(pathToFind + \" does not exist\");\n\t\t}\n\t\treturn findPaths(jsonElement, removePathFromSet(pathsToFind, pathToFind));\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/FieldsIgnorer.java",
        "start_loc": 67,
        "end_loc": 95,
        "buggy_function": "\tprivate static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) {\n\t\tString field = headOf(pathSegments);\n\t\tif (jsonElement.isJsonArray()) {\n\t\t\tIterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tJsonElement arrayElement = (JsonElement) iterator.next();\n\t\t\t\tif (arrayElement.isJsonNull()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfindPath(arrayElement, pathToFind, pathSegments);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pathSegments.size() == 1) {\n\t\t\t\tignorePath(jsonElement, pathToFind);\n\t\t\t} else {\n\t\t\t\tJsonElement child = jsonElement.getAsJsonObject().get(field);\n\t\t\t\tif (child == null) {\n\t\t\t\t\tchild = jsonElement.getAsJsonObject().get(SET_MARKER + field);\n\t\t\t\t\tif (child == null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tchild = sortSet(child);\n\t\t\t\t\tjsonElement.getAsJsonObject().add(SET_MARKER + field, child);\n\t\t\t\t}\t\t\n\t\t\t\tList<String> tail = pathSegments.subList(1, pathSegments.size());\n\t\t\t\tfindPath(child, pathToFind, tail);\n\t\t\t}\n\t\t}\n\t}",
        "fixed_function": "\tprivate static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) {\n\t\tString field = headOf(pathSegments);\n\t\tif (pathSegments.size() == 1) {\n\t\t\tignorePath(jsonElement, pathToFind);\n\t\t} else {\n\t\t\tif (!jsonElement.isJsonObject()) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tJsonElement child = jsonElement.getAsJsonObject().get(field);\n\t\t\tList<String> tail = pathSegments.subList(1, pathSegments.size());\n\t\t\t\n\t\t\tif (child == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (child.isJsonArray()) {\n\t\t\t\tIterator<JsonElement> iterator = child.getAsJsonArray().iterator();\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tfindPath((JsonElement) iterator.next(), pathToFind, tail);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfindPath(child, pathToFind, tail);\n\t\t\t}\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/FieldsIgnorer.java",
        "start_loc": 97,
        "end_loc": 110,
        "buggy_function": "\tprivate static JsonElement sortSet(JsonElement jsonElement) {\n\t\tTreeSet<JsonElement> orderedSet = newTreeSet(new Comparator<JsonElement>() {\n\t\t\t@Override\n\t\t\tpublic int compare(JsonElement o1, JsonElement o2) {\n\t\t\t\treturn o1.toString().compareTo(o2.toString());\n\t\t\t}\n\t\t});\n\t\torderedSet.addAll(newArrayList(jsonElement.getAsJsonArray().iterator()));\n\t\tJsonArray jsonArray = new JsonArray();\n\t\tfor (JsonElement element : orderedSet) {\n\t\t\tjsonArray.add(element);\n\t\t}\n\t\treturn jsonArray;\n\t}",
        "fixed_function": "\tprivate static void ignorePath(JsonElement jsonElement, String pathToIgnore) {\n\t\tif (!jsonElement.isJsonNull()) {\n\t\t\tif (!jsonElement.isJsonObject()) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tjsonElement.getAsJsonObject().remove(getLastSegmentOf(pathToIgnore));\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/DiagnosingCustomisableMatcher.java",
        "start_loc": 53,
        "end_loc": 62,
        "buggy_function": "\t@Override\n\tpublic void describeTo(Description description) {\n\t\tGson gson = gson(typesToIgnore, circularReferenceTypes);\n\t\tdescription.appendText(filterJson(gson, expected));\n\t\tfor (String fieldPath : customMatchers.keySet()) {\n\t\t\tdescription.appendText(\"\\nand \")\n\t\t\t\t.appendText(fieldPath).appendText(\" \")\n\t\t\t\t.appendDescriptionOf(customMatchers.get(fieldPath));\n\t\t}\n\t}",
        "fixed_function": "\t@Override\n\tpublic void describeTo(Description description) {\n\t\tGson gson = gson(typesToIgnore, circularReferenceTypes);\n\t\tdescription.appendText(filterJson(gson, gson.toJson(expected)));\n\t\tfor (String fieldPath : customMatchers.keySet()) {\n\t\t\tdescription.appendText(\"\\nand \")\n\t\t\t\t.appendText(fieldPath).appendText(\" \")\n\t\t\t\t.appendDescriptionOf(customMatchers.get(fieldPath));\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/DiagnosingCustomisableMatcher.java",
        "start_loc": 64,
        "end_loc": 76,
        "buggy_function": "\t@Override\n\tprotected boolean matches(Object actual, Description mismatchDescription) {\n\t\tGson gson = gson(typesToIgnore, circularReferenceTypes);\n\t\t\n\t\tif (!areCustomMatchersMatching(actual, mismatchDescription, gson)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tString expectedJson = removeSetMarker(filterJson(gson, expected));\n\t\tString actualJson = removeSetMarker(filterJson(gson, actual));\n\n\t\treturn assertEquals(expectedJson, actualJson, mismatchDescription, gson);\n\t}",
        "fixed_function": "\t@Override\n\tprotected boolean matches(Object actual, Description mismatchDescription) {\n\t\tGson gson = gson(typesToIgnore, circularReferenceTypes);\n\t\t\n\t\tif (!areCustomMatchersMatching(actual, mismatchDescription, gson)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tString expectedJson = filterJson(gson, gson.toJson(expected));\n\t\tString actualJson = filterJson(gson, gson.toJson(actual));\n\n\t\treturn assertEquals(expectedJson, actualJson, mismatchDescription, gson);\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/DiagnosingCustomisableMatcher.java",
        "start_loc": 78,
        "end_loc": 80,
        "buggy_function": "\tprivate String removeSetMarker(String json) {\n\t\treturn json.replaceAll(SET_MARKER, \"\");\n\t}",
        "fixed_function": "\tprivate String filterJson(Gson gson, String unfilteredJson) {\n\t\tSet<String> set = new HashSet<String>();\n\t\tset.addAll(pathsToIgnore);\n\t\tset.addAll(customMatchers.keySet());\n\t\tJsonElement filteredJson = findPaths(jsonParser.parse(unfilteredJson), set);\n\n\t\treturn gson.toJson(filteredJson);\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/GsonProvider.java",
        "start_loc": 53,
        "end_loc": 70,
        "buggy_function": "    public static Gson gson(final List<Class<?>> typesToIgnore, List<Class<?>> circularReferenceTypes) {\n    \tfinal GsonBuilder gsonBuilder = initGson();\n    \t\n        if (!circularReferenceTypes.isEmpty()) {\n            registerCircularReferenceTypes(circularReferenceTypes, gsonBuilder);\n        }\n\n        registerSetSerialisation(gsonBuilder);\n        \n        registerMapSerialisation(gsonBuilder);\n        markSetFields(gsonBuilder);\n        \n        if (!typesToIgnore.isEmpty()) {\n        \treturn registerTypesToIgnore(typesToIgnore, gsonBuilder).create();\n        }\n        \n        return gsonBuilder.create();\n    }",
        "fixed_function": "    public static Gson gson(final List<Class<?>> typesToIgnore, List<Class<?>> circularReferenceTypes) {\n    \tfinal GsonBuilder gsonBuilder = initGson();\n    \t\n        if (!circularReferenceTypes.isEmpty()) {\n            registerCircularReferenceTypes(circularReferenceTypes, gsonBuilder);\n        }\n\n        registerSetSerialisation(gsonBuilder);\n        \n        registerMapSerialisation(gsonBuilder);\n        \n        if (!typesToIgnore.isEmpty()) {\n        \treturn registerTypesToIgnore(typesToIgnore, gsonBuilder).create();\n        }\n        \n        return gsonBuilder.create();\n    }",
        "comment": "/**\n     * Returns a {@link Gson} instance containing {@link ExclusionStrategy} based on the object types to ignore during\n     * serialisation.\n     *\n     * @param typesToIgnore the object types to exclude from serialisation\n     * @param circularReferenceTypes cater for circular referenced objects\n     * @return an instance of {@link Gson}\n     */"
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/GsonProvider.java",
        "start_loc": 72,
        "end_loc": 82,
        "buggy_function": "\tprivate static void markSetFields(final GsonBuilder gsonBuilder) {\n\t\tgsonBuilder.setFieldNamingStrategy(new FieldNamingStrategy() {\n\t\t\t@Override\n\t\t\tpublic String translateName(Field f) {\n\t\t\t\tif (Set.class.isAssignableFrom(f.getType())) {\n\t\t\t\t\treturn SET_MARKER + f.getName();\n\t\t\t\t}\n\t\t\t\treturn f.getName();\n\t\t\t}\n\t\t});\n\t}",
        "fixed_function": "\tprivate static JsonArray arrayOfObjectsOrderedByTheirJsonRepresentation(Gson gson, ArrayListMultimap<String, Object> objects, Map map) {\n\t\tImmutableList<String> sortedMapKeySet = Ordering.natural().immutableSortedCopy(objects.keySet());\n\t\tJsonArray array = new JsonArray();\n\t\tif (allKeysArePrimitive(sortedMapKeySet, objects)) {\n\t\t\tfor (String jsonRepresentation : sortedMapKeySet) {\n\t\t\t\tList<Object> objectsInTheSet = objects.get(jsonRepresentation);\n\t\t\t\tfor (Object objectInTheSet : objectsInTheSet) {\n\t\t\t\t\tJsonObject jsonObject = new JsonObject();\n\t\t\t\t\tjsonObject.add(String.valueOf(objectInTheSet), gson.toJsonTree(map.get(objectInTheSet)));\n\t\t\t\t\tarray.add(jsonObject);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String jsonRepresentation : sortedMapKeySet) {\n\t\t\t\tJsonArray keyValueArray = new JsonArray();\n\t\t\t\tList<Object> objectsInTheSet = objects.get(jsonRepresentation);\n\t\t\t\tfor (Object objectInTheSet : objectsInTheSet) {\n\t\t\t\t\tkeyValueArray.add(gson.toJsonTree(objectInTheSet));\n\t\t\t\t\tkeyValueArray.add(gson.toJsonTree(map.get(objectInTheSet)));\n\t\t\t\t\tarray.add(keyValueArray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/shazam/shazamcrest/matcher/GsonProvider.java",
        "start_loc": 157,
        "end_loc": 182,
        "buggy_function": "\tprivate static JsonArray arrayOfObjectsOrderedByTheirJsonRepresentation(Gson gson, ArrayListMultimap<String, Object> objects, Map map) {\n\t\tImmutableList<String> sortedMapKeySet = Ordering.natural().immutableSortedCopy(objects.keySet());\n\t\tJsonArray array = new JsonArray();\n\t\tif (allKeysArePrimitiveOrStringOrEnum(sortedMapKeySet, objects)) {\n\t\t\tfor (String jsonRepresentation : sortedMapKeySet) {\n\t\t\t\tList<Object> objectsInTheSet = objects.get(jsonRepresentation);\n\t\t\t\tfor (Object objectInTheSet : objectsInTheSet) {\n\t\t\t\t\tJsonObject jsonObject = new JsonObject();\n\t\t\t\t\tjsonObject.add(String.valueOf(objectInTheSet), gson.toJsonTree(map.get(objectInTheSet)));\n\t\t\t\t\tarray.add(jsonObject);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String jsonRepresentation : sortedMapKeySet) {\n\t\t\t\tJsonArray keyValueArray = new JsonArray();\n\t\t\t\tList<Object> objectsInTheSet = objects.get(jsonRepresentation);\n\t\t\t\tfor (Object objectInTheSet : objectsInTheSet) {\n\t\t\t\t\tkeyValueArray.add(gson.toJsonTree(objectInTheSet));\n\t\t\t\t\tkeyValueArray.add(gson.toJsonTree(map.get(objectInTheSet)));\n\t\t\t\t\tarray.add(keyValueArray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t}",
        "fixed_function": "    private static boolean allKeysArePrimitive(ImmutableList<String> sortedMapKeySet, ArrayListMultimap<String, Object> objects) {\n    \tfor (String jsonRepresentation : sortedMapKeySet) {\n\t\t\tList<Object> mapKeys = objects.get(jsonRepresentation);\n\t\t\tfor (Object object : mapKeys) {\n\t\t\t\tif (!(isPrimitiveOrWrapper(object.getClass()) || object.getClass() == String.class || object.getClass().isEnum())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.shazam.shazamcrest.MatcherAssertIgnoringFieldTest::throwsIllegalArgumentExceptionWhenLastPathSegmentDoesNotExistInMap": {
        "path": "com/shazam/shazamcrest/MatcherAssertIgnoringFieldTest.java",
        "function_name": "throwsIllegalArgumentExceptionWhenLastPathSegmentDoesNotExistInMap",
        "src": "@Test(expected = IllegalArgumentException.class)\n\tpublic void throwsIllegalArgumentExceptionWhenLastPathSegmentDoesNotExistInMap() {\n\t\tMap<Object, Object> expectedMap = newHashMap();\n\t\texpectedMap.put(bean().string(\"key\").build(), bean().string(\"value\").build());\n\t\tMapContainer expected = new MapContainer(expectedMap);\n\n\t\tMap<Object, Object> actualMap = newHashMap();\n\t\tactualMap.put(bean().string(\"key\").build(), bean().string(\"unexpected value\").build());\n\t\tMapContainer actual = new MapContainer(actualMap);\n\t\t\n\t\tassertThat(actual, sameBeanAs(expected).ignoring(\"map.key\"));\n\t}",
        "error_msg": "com.shazam.shazamcrest.MatcherAssertIgnoringFieldTest::throwsIllegalArgumentExceptionWhenLastPathSegmentDoesNotExistInMap --> java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<org.junit.ComparisonFailure>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<org.junit.ComparisonFailure>"
      },
      "com.shazam.shazamcrest.MatcherAssertIgnoringFieldTest::throwsIllegalArgumentExceptionWhenPathDoesNotExistInMap": {
        "path": "com/shazam/shazamcrest/MatcherAssertIgnoringFieldTest.java",
        "function_name": "throwsIllegalArgumentExceptionWhenPathDoesNotExistInMap",
        "src": "@Test(expected = IllegalArgumentException.class)\n\tpublic void throwsIllegalArgumentExceptionWhenPathDoesNotExistInMap() {\n\t\tMap<Object, Object> expectedMap = newHashMap();\n\t\texpectedMap.put(bean().string(\"key\").build(), bean().string(\"value\").build());\n\t\tMapContainer expected = new MapContainer(expectedMap);\n\t\t\n\t\tMap<Object, Object> actualMap = newHashMap();\n\t\tactualMap.put(bean().string(\"key\").build(), bean().string(\"unexpected value\").build());\n\t\tMapContainer actual = new MapContainer(actualMap);\n\t\t\n\t\tassertThat(actual, sameBeanAs(expected).ignoring(\"map.key.subpath\"));\n\t}",
        "error_msg": "com.shazam.shazamcrest.MatcherAssertIgnoringFieldTest::throwsIllegalArgumentExceptionWhenPathDoesNotExistInMap --> java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<org.junit.ComparisonFailure>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<org.junit.ComparisonFailure>"
      }
    }
  },
  "Chronicle_network-1": {
    "function_num": 6,
    "functions": [
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java",
        "start_loc": 56,
        "end_loc": 65,
        "buggy_function": "    @UsedViaReflection\n    public HeartbeatHandler(@NotNull WireIn w) {\n        heartbeatTimeoutMs = w.read(\"heartbeatTimeoutMs\").int64();\n        heartbeatIntervalMs = w.read(\"heartbeatIntervalMs\").int64();\n        assert heartbeatTimeoutMs >= 1000 :\n                \"heartbeatTimeoutMs=\" + heartbeatTimeoutMs + \", this is too small\";\n        assert heartbeatIntervalMs >= 500 :\n                \"heartbeatIntervalMs=\" + heartbeatIntervalMs + \", this is too small\";\n        onMessageReceived();\n    }",
        "fixed_function": "    @UsedViaReflection\n    public HeartbeatHandler(@NotNull WireIn w) {\n        this(w.read(\"heartbeatTimeoutMs\").int64(),\n                w.read(\"heartbeatIntervalMs\").int64());\n        onMessageReceived();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java",
        "start_loc": 67,
        "end_loc": 80,
        "buggy_function": "    private HeartbeatHandler(long heartbeatTimeoutMs, long heartbeatIntervalMs) {\n        this.heartbeatTimeoutMs = heartbeatTimeoutMs;\n        this.heartbeatIntervalMs = heartbeatIntervalMs;\n        assert heartbeatTimeoutMs > heartbeatIntervalMs :\n                \"heartbeatIntervalMs=\" + heartbeatIntervalMs + \", \" +\n                        \"heartbeatTimeoutMs=\" + heartbeatTimeoutMs;\n\n        assert heartbeatTimeoutMs >= 1000 :\n                \"heartbeatTimeoutMs=\" + heartbeatTimeoutMs + \", this is too small\";\n\n        assert heartbeatIntervalMs >= 500 :\n                \"heartbeatIntervalMs=\" + heartbeatIntervalMs + \", this is too small\";\n\n    }",
        "fixed_function": "    private HeartbeatHandler(long heartbeatTimeoutMs, long heartbeatIntervalMs) {\n        this.heartbeatTimeoutMs = heartbeatTimeoutMs;\n        this.heartbeatIntervalMs = heartbeatIntervalMs;\n        validateHeartbeatParameters(this.heartbeatTimeoutMs, this.heartbeatIntervalMs);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java",
        "start_loc": 82,
        "end_loc": 86,
        "buggy_function": "    public static WriteMarshallable heartbeatHandler(final long heartbeatTimeoutMs,\n                                                     final long heartbeatIntervalMs,\n                                                     final long cid) {\n        return new WriteHeartbeatHandler(cid, heartbeatTimeoutMs, heartbeatIntervalMs);\n    }",
        "fixed_function": "    private static void validateHeartbeatParameters(long heartbeatTimeoutMs, long heartbeatIntervalMs) {\n        if (heartbeatTimeoutMs <= heartbeatIntervalMs) {\n            throw new IllegalArgumentException(\"Heartbeat timeout must be greater than heartbeat interval, \" +\n                    \"please fix this in your configuration, (heartbeatIntervalMs=\" + heartbeatIntervalMs + \", \" +\n                    \"heartbeatTimeoutMs=\" + heartbeatTimeoutMs + \")\");\n        }\n\n        if (heartbeatTimeoutMs < MINIMUM_HEARTBEAT_TIMEOUT_MS) {\n            throw new IllegalArgumentException(\"heartbeatTimeoutMs=\" + heartbeatTimeoutMs + \", this is too small (minimum=\" + MINIMUM_HEARTBEAT_TIMEOUT_MS + \")\");\n        }\n\n        if (heartbeatIntervalMs < MINIMUM_HEARTBEAT_INTERVAL_MS) {\n            throw new IllegalArgumentException(\"heartbeatIntervalMs=\" + heartbeatIntervalMs + \", this is too small (minimum=\" + MINIMUM_HEARTBEAT_INTERVAL_MS + \")\");\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java",
        "start_loc": 62,
        "end_loc": 73,
        "buggy_function": "    private UberHandler(final int localIdentifier,\n                        final int remoteIdentifier,\n                        @NotNull final WireType wireType) {\n\n        this.localIdentifier = localIdentifier;\n        this.remoteIdentifier = remoteIdentifier;\n\n        assert remoteIdentifier != localIdentifier :\n                \"remoteIdentifier=\" + remoteIdentifier + \", \" +\n                        \"localIdentifier=\" + localIdentifier;\n        wireType(wireType);\n    }",
        "fixed_function": "    private UberHandler(final int localIdentifier,\n                        final int remoteIdentifier,\n                        @NotNull final WireType wireType) {\n\n        this.localIdentifier = localIdentifier;\n        this.remoteIdentifier = remoteIdentifier;\n\n        checkRemoteAndLocalIdentifiersAreNotEqual();\n        wireType(wireType);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java",
        "start_loc": 110,
        "end_loc": 135,
        "buggy_function": "    @Override\n    protected void onInitialize() {\n        @NotNull final ClusteredNetworkContext<T> nc = nc();\n        nc.wireType(wireType());\n        isAcceptor(nc.isAcceptor());\n\n        assert checkIdentifierEqualsHostId();\n        assert remoteIdentifier != localIdentifier :\n                \"remoteIdentifier=\" + remoteIdentifier + \", \" +\n                        \"localIdentifier=\" + localIdentifier;\n\n        @NotNull final WireOutPublisher publisher = nc.wireOutPublisher();\n        publisher(publisher);\n\n        @NotNull final EventLoop eventLoop = nc.eventLoop();\n        if (!eventLoop.isClosing()) {\n            eventLoop.start();\n\n            // reflect the uber handler\n            if (nc().isAcceptor())\n                publish(uberHandler(localIdentifier, remoteIdentifier, wireType));\n\n            if (!isClosed())\n                notifyConnectionListeners();\n        }\n    }",
        "fixed_function": "    @Override\n    protected void onInitialize() {\n        @NotNull final ClusteredNetworkContext<T> nc = nc();\n        nc.wireType(wireType());\n        isAcceptor(nc.isAcceptor());\n\n        validateIdentifiers();\n\n        @NotNull final WireOutPublisher publisher = nc.wireOutPublisher();\n        publisher(publisher);\n\n        @NotNull final EventLoop eventLoop = nc.eventLoop();\n        if (!eventLoop.isClosing()) {\n            eventLoop.start();\n\n            // reflect the uber handler\n            if (nc().isAcceptor())\n                publish(uberHandler(localIdentifier, remoteIdentifier, wireType));\n\n            if (!isClosed())\n                notifyConnectionListeners();\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java",
        "start_loc": 137,
        "end_loc": 144,
        "buggy_function": "    private boolean checkIdentifierEqualsHostId() {\n\n\n        byte localHostIdentifier = nc().getLocalHostIdentifier();\n        if (localIdentifier != localHostIdentifier && localHostIdentifier != 0)\n            throw new AssertionError(\"localId: \" + localIdentifier + \" != nc().localId: \" + localHostIdentifier);\n        return true;\n    }",
        "fixed_function": "    private void validateIdentifiers() {\n        checkIdentifierEqualsHostId();\n        checkRemoteAndLocalIdentifiersAreNotEqual();\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.openhft.chronicle.network.UberHandlerTest::constructorWillThrowIfLocalAndRemoteIdentifiersAreTheSame": {
        "path": "net/openhft/chronicle/network/UberHandlerTest.java",
        "function_name": "constructorWillThrowIfLocalAndRemoteIdentifiersAreTheSame",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void constructorWillThrowIfLocalAndRemoteIdentifiersAreTheSame() {\n        Wire wire = new BinaryWire(Bytes.allocateElasticOnHeap());\n        UberHandler.uberHandler(123, 123, WireType.BINARY).writeMarshallable(wire);\n    }",
        "error_msg": "net.openhft.chronicle.network.UberHandlerTest::constructorWillThrowIfLocalAndRemoteIdentifiersAreTheSame --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.UberHandlerTest::testHandlerWillCloseWhenHostIdsAreWrong": {
        "path": "net/openhft/chronicle/network/UberHandlerTest.java",
        "function_name": "testHandlerWillCloseWhenHostIdsAreWrong",
        "src": "@Test\n    public void testHandlerWillCloseWhenHostIdsAreWrong() throws IOException {\n        expectException(\"Received a handler for host ID: 98, my host ID is: 1 this is probably a configuration error\");\n        expectException(\"Closed\");\n        expectException(\"SubHandler HeartbeatHandler\");\n\n        TCPRegistry.createServerSocketChannelFor(\"initiator\", \"acceptor\");\n        HostDetails initiatorHost = new HostDetails().hostId(99).connectUri(\"initiator\");\n        HostDetails acceptorHost = new HostDetails().hostId(1).connectUri(\"acceptor\");\n        HostDetails acceptorHostWithInvalidId = new HostDetails().hostId(98).connectUri(\"acceptor\");\n\n        try (MyClusterContext acceptorCtx = clusterContext(acceptorHost, initiatorHost);\n             MyClusterContext initiatorCtx = clusterContext(initiatorHost, acceptorHostWithInvalidId)) {\n\n            acceptorCtx.cluster().start(acceptorHost.hostId());\n            initiatorCtx.cluster().start(initiatorHost.hostId());\n\n            AtomicBoolean establishedConnection = new AtomicBoolean(false);\n            initiatorCtx.connectionManager(acceptorHostWithInvalidId.hostId()).addListener((nc, isConnected) -> {\n                if (isConnected) {\n                    establishedConnection.set(true);\n                }\n            });\n            Jvm.pause(2000);\n            assertFalse(establishedConnection.get());\n            assertTrue(exceptions.keySet().stream().anyMatch(k -> k.throwable != null && k.throwable.getMessage().contains(\"Received a handler for host ID: 98, my host ID is: 1 this is probably a configuration error\")));\n        }\n    }",
        "error_msg": "net.openhft.chronicle.network.UberHandlerTest::testHandlerWillCloseWhenHostIdsAreWrong --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentException": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentException",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentException() {\n        HeartbeatHandler.heartbeatHandler(TOO_SMALL_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_INTERVAL_MS, CID);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentException --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalGreaterThanTimeoutThrowsIllegalStateException": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "intervalGreaterThanTimeoutThrowsIllegalStateException",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void intervalGreaterThanTimeoutThrowsIllegalStateException() {\n        HeartbeatHandler.heartbeatHandler(VALID_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_TIMEOUT_MS + 100, CID);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalGreaterThanTimeoutThrowsIllegalStateException --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentExceptionConstructor": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentExceptionConstructor",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentExceptionConstructor() {\n        createByDeserialization(TOO_SMALL_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_INTERVAL_MS);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatTimeoutMsThrowsIllegalArgumentExceptionConstructor --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalEqualToTimeoutThrowsIllegalStateExceptionConstructor": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "intervalEqualToTimeoutThrowsIllegalStateExceptionConstructor",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void intervalEqualToTimeoutThrowsIllegalStateExceptionConstructor() {\n        createByDeserialization(VALID_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_TIMEOUT_MS);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalEqualToTimeoutThrowsIllegalStateExceptionConstructor --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatIntervalMsThrowsIllegalArgumentExceptionConstructor": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "tooSmallHeartbeatIntervalMsThrowsIllegalArgumentExceptionConstructor",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void tooSmallHeartbeatIntervalMsThrowsIllegalArgumentExceptionConstructor() {\n        createByDeserialization(VALID_HEARTBEAT_TIMEOUT_MS, TOO_SMALL_HEARTBEAT_INTERVAL_MS);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatIntervalMsThrowsIllegalArgumentExceptionConstructor --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatIntervalMsThrowsIllegalArgumentException": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "tooSmallHeartbeatIntervalMsThrowsIllegalArgumentException",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void tooSmallHeartbeatIntervalMsThrowsIllegalArgumentException() {\n        HeartbeatHandler.heartbeatHandler(VALID_HEARTBEAT_TIMEOUT_MS, TOO_SMALL_HEARTBEAT_INTERVAL_MS, CID);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::tooSmallHeartbeatIntervalMsThrowsIllegalArgumentException --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalEqualToTimeoutThrowsIllegalStateException": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "intervalEqualToTimeoutThrowsIllegalStateException",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void intervalEqualToTimeoutThrowsIllegalStateException() {\n        HeartbeatHandler.heartbeatHandler(VALID_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_TIMEOUT_MS, CID);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalEqualToTimeoutThrowsIllegalStateException --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      },
      "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalGreaterThanTimeoutThrowsIllegalStateExceptionConstructor": {
        "path": "net/openhft/chronicle/network/cluster/handlers/HeartbeatHandlerTest.java",
        "function_name": "intervalGreaterThanTimeoutThrowsIllegalStateExceptionConstructor",
        "src": "@Test(expected = IllegalArgumentException.class)\n    public void intervalGreaterThanTimeoutThrowsIllegalStateExceptionConstructor() {\n        createByDeserialization(VALID_HEARTBEAT_TIMEOUT_MS, VALID_HEARTBEAT_TIMEOUT_MS + 100);\n    }",
        "error_msg": "net.openhft.chronicle.network.cluster.handlers.HeartbeatHandlerTest::intervalGreaterThanTimeoutThrowsIllegalStateExceptionConstructor --> junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException"
      }
    }
  },
  "Chronicle_network-2": {
    "function_num": 15,
    "functions": [
      {
        "path": "src/main/java/net/openhft/chronicle/network/TcpEventHandler.java",
        "start_loc": 352,
        "end_loc": 377,
        "buggy_function": "        @Override\n        public boolean action() throws InvalidEventHandlerException {\n            if (!sc.isOpen()) throw new InvalidEventHandlerException();\n\n            boolean busy = false;\n            try {\n                // get more data to write if the buffer was empty\n                // or we can write some of what is there\n                int remaining = outBB.remaining();\n                busy = remaining > 0;\n                if (busy)\n                    tryWrite();\n                if (outBB.remaining() == remaining) {\n                    busy |= invokeHandler();\n                    if (!busy)\n                        busy = tryWrite();\n                }\n            } catch (ClosedChannelException cce) {\n                closeSC();\n\n            } catch (IOException e) {\n                if (!closed)\n                    handleIOE(e, tcpHandler.hasClientClosed(), nc.heartbeatListener());\n            }\n            return busy;\n        }",
        "fixed_function": "        @Override\n        public boolean action() throws InvalidEventHandlerException {\n            if (!sc.isOpen()) throw new InvalidEventHandlerException();\n\n            boolean busy = false;\n            try {\n                // get more data to write if the buffer was empty\n                // or we can write some of what is there\n                int remaining = outBB.remaining();\n                busy = remaining > 0;\n                if (busy)\n                    tryWrite();\n                if (outBB.remaining() == remaining) {\n                    busy |= invokeHandler();\n                    if (!busy)\n                        busy = tryWrite();\n                }\n            } catch (ClosedChannelException cce) {\n                closeSC();\n\n            } catch (IOException e) {\n                handleIOE(e, tcpHandler.hasClientClosed(), nc.heartbeatListener());\n            }\n            return busy;\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/WireTcpHandler.java",
        "start_loc": 117,
        "end_loc": 140,
        "buggy_function": "    private void onRead0() {\n        assert inWire.startUse();\n\n        try {\n        while (!inWire.bytes().isEmpty()) {\n            long start = inWire.bytes().readPosition();\n            try (DocumentContext dc = inWire.readingDocument()) {\n                if (!dc.isPresent()) {\n                    return;\n                }\n\n                try {\n                    logYaml(start);\n                    onRead(dc, outWire);\n\n                } catch (Exception e) {\n                    LOG.error(\"inWire=\" + inWire.getClass(), e);\n                }\n                }\n            }\n        } finally {\n            assert inWire.endUse();\n        }\n    }",
        "fixed_function": "    private void onRead0() {\n\n        while (!inWire.bytes().isEmpty()) {\n            long start = inWire.bytes().readPosition();\n            try (DocumentContext dc = inWire.readingDocument()) {\n                if (!dc.isPresent()) {\n                    return;\n                }\n\n                try {\n                    logYaml(start);\n                    onRead(dc, outWire);\n\n                } catch (Exception e) {\n                    LOG.error(\"inWire=\" + inWire.getClass(), e);\n                }\n            }\n        }\n    }",
        "comment": "/**\n     * process all messages in this batch, provided there is plenty of output space.\n     */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/WireTcpHandler.java",
        "start_loc": 150,
        "end_loc": 180,
        "buggy_function": "    protected void checkWires(Bytes in, Bytes out, @NotNull WireType wireType) {\n        if (recreateWire) {\n            recreateWire = false;\n            inWire = wireType.apply(in);\n            outWire = wireType.apply(out);\n            return;\n        }\n\n        if (inWire == null) {\n            inWire = wireType.apply(in);\n            recreateWire = false;\n        }\n\n        assert inWire.startUse();\n        if (inWire.bytes() != in) {\n            inWire = wireType.apply(in);\n            recreateWire = false;\n        }\n        assert inWire.endUse();\n\n        boolean replace = outWire == null;\n        if (!replace) {\n            assert outWire.startUse();\n            replace = outWire.bytes() != out;\n            assert outWire.endUse();\n        }\n        if (replace) {\n            outWire = wireType.apply(out);\n            recreateWire = false;\n        }\n    }",
        "fixed_function": "    protected void checkWires(Bytes in, Bytes out, @NotNull WireType wireType) {\n        if (recreateWire) {\n            recreateWire = false;\n            inWire = wireType.apply(in);\n            outWire = wireType.apply(out);\n            return;\n        }\n\n        if (inWire == null) {\n            inWire = wireType.apply(in);\n            recreateWire = false;\n        }\n\n        if (inWire.bytes() != in) {\n            inWire = wireType.apply(in);\n            recreateWire = false;\n        }\n\n        if ((outWire == null || outWire.bytes() != out)) {\n            outWire = wireType.apply(out);\n            recreateWire = false;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/WireTypeSniffingTcpHandler.java",
        "start_loc": 51,
        "end_loc": 89,
        "buggy_function": "    @Override\n    public void process(@NotNull Bytes in, @NotNull Bytes out) {\n\n        final WireOutPublisher publisher = nc.wireOutPublisher();\n\n        if (publisher != null && out.writePosition() < TcpEventHandler.TCP_BUFFER)\n            publisher.applyAction(out);\n\n        // read the wire type of the messages from the header - the header its self must be\n        // of type TEXT or BINARY\n        if (in.readRemaining() < 5)\n            return;\n\n        final int required = Wires.lengthOf(in.readInt(in.readPosition()));\n\n        assert required < 10 << 20;\n\n        if (in.readRemaining() < required + 4)\n            return;\n\n        final byte b = in.readByte(4);\n        final WireType wireType;\n        if (b < 0)\n            wireType = BINARY;\n        else if (b > ' ')\n            wireType = TEXT;\n        else\n            throw new IllegalStateException(\"Unable to identify the wire type from \" + Integer.toHexString(b & 0xFF));\n\n        // the type of the header\n        nc.wireType(wireType);\n\n        final TcpHandler handler = delegateHandlerFactory.apply(nc);\n\n        if (handler instanceof NetworkContextManager)\n            ((NetworkContextManager) handler).nc(nc);\n\n        handlerManager.tcpHandler(handler);\n    }",
        "fixed_function": "    @Override\n    public void process(@NotNull Bytes in, @NotNull Bytes out) {\n\n        final WireOutPublisher publisher = nc.wireOutPublisher();\n\n        if (publisher != null && out.writePosition() < TcpEventHandler.TCP_BUFFER)\n            publisher.applyAction(out);\n\n        // read the wire type of the messages from the header - the header its self must be\n        // of type TEXT or BINARY\n        if (in.readRemaining() < 5)\n            return;\n\n        final int required = Wires.lengthOf(in.readInt(in.readPosition()));\n\n        assert required < 10 << 20;\n\n        if (in.readRemaining() < required + 4)\n            return;\n\n        final byte b = in.readByte(4);\n        final WireType wireType = (b & 0x80) == 0 ? TEXT : BINARY;\n\n        // the type of the header\n        nc.wireType(wireType);\n\n        final TcpHandler handler = delegateHandlerFactory.apply(nc);\n\n        if (handler instanceof NetworkContextManager)\n            ((NetworkContextManager) handler).nc(nc);\n\n        handlerManager.tcpHandler(handler);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 122,
        "end_loc": 151,
        "buggy_function": "    public TcpChannelHub(@Nullable final SessionProvider sessionProvider,\n                         @NotNull final EventLoop eventLoop,\n                         @NotNull final WireType wireType,\n                         @NotNull final String name,\n                         @NotNull final SocketAddressSupplier socketAddressSupplier,\n                         boolean shouldSendCloseMessage,\n                         @Nullable ClientConnectionMonitor clientConnectionMonitor,\n                         @NotNull final HandlerPriority monitor) {\n        assert !name.trim().isEmpty();\n        this.priority = monitor;\n        this.socketAddressSupplier = socketAddressSupplier;\n        this.eventLoop = eventLoop;\n        this.tcpBufferSize = Integer.getInteger(\"tcp.client.buffer.size\", BUFFER_SIZE);\n        this.outWire = wireType.apply(elasticByteBuffer());\n        this.inWire = wireType.apply(elasticByteBuffer());\n        this.name = name.trim();\n        this.timeoutMs = Integer.getInteger(\"tcp.client.timeout\", 10_000);\n        this.wireType = wireType;\n\n        // we are always going to send the header as text wire, the server will\n        // respond in the wire define by the wireType field, all subsequent types must be in wireType\n        this.handShakingWire = WireType.TEXT.apply(Bytes.elasticByteBuffer());\n\n        this.sessionProvider = sessionProvider;\n        this.shouldSendCloseMessage = shouldSendCloseMessage;\n        this.clientConnectionMonitor = clientConnectionMonitor;\n        hubs.add(this);\n        eventLoop.addHandler(new PauserMonitor(pauser, \"async-read\", 30));\n        this.tcpSocketConsumer = new TcpSocketConsumer();\n    }",
        "fixed_function": "    public TcpChannelHub(@Nullable final SessionProvider sessionProvider,\n                         @NotNull final EventLoop eventLoop,\n                         @NotNull final WireType wireType,\n                         @NotNull final String name,\n                         @NotNull final SocketAddressSupplier socketAddressSupplier,\n                         boolean shouldSendCloseMessage,\n                         @Nullable ClientConnectionMonitor clientConnectionMonitor,\n                         @NotNull final HandlerPriority monitor) {\n        assert !name.trim().isEmpty();\n        this.priority = monitor;\n        this.socketAddressSupplier = socketAddressSupplier;\n        this.eventLoop = eventLoop;\n        this.tcpBufferSize = Integer.getInteger(\"tcp.client.buffer.size\", BUFFER_SIZE);\n        this.outWire = wireType.apply(elasticByteBuffer());\n        this.inWire = wireType.apply(elasticByteBuffer());\n        this.name = name.trim();\n        this.timeoutMs = Integer.getInteger(\"tcp.client.timeout\", 10_000);\n        this.wire = wireType;\n\n        // we are always going to send the header as text wire, the server will\n        // respond in the wire define by the wireType field, all subsequent types must be in wireType\n        this.handShakingWire = WireType.TEXT.apply(Bytes.elasticByteBuffer());\n\n        this.sessionProvider = sessionProvider;\n        this.tcpSocketConsumer = new TcpSocketConsumer(wireType);\n        this.shouldSendCloseMessage = shouldSendCloseMessage;\n        this.clientConnectionMonitor = clientConnectionMonitor;\n        this.wireType = wireType;\n        hubs.add(this);\n        eventLoop.addHandler(new PauserMonitor(pauser, \"async-read\", 30));\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 230,
        "end_loc": 235,
        "buggy_function": "    private void clear(@NotNull final Wire wire) {\n        assert wire.startUse();\n        wire.clear();\n        ((ByteBuffer) wire.bytes().underlyingObject()).clear();\n        assert wire.endUse();\n    }",
        "fixed_function": "    private void clear(@NotNull final Wire wire) {\n        wire.clear();\n        ((ByteBuffer) wire.bytes().underlyingObject()).clear();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 325,
        "end_loc": 350,
        "buggy_function": "    private void doHandShaking(@NotNull SocketChannel socketChannel) throws IOException {\n\n        assert outBytesLock.isHeldByCurrentThread();\n        final SessionDetails sessionDetails = sessionDetails();\n        if (sessionDetails != null) {\n            handShakingWire.clear();\n            final Bytes<?> bytes = handShakingWire.bytes();\n            bytes.clear();\n\n            // we are always going to send the header as text wire, the server will\n            // respond in the wire define by the wireType field, all subsequent types must be in wireType\n\n            handShakingWire.writeDocument(false, wireOut -> {\n                wireOut.writeEventName(EventId.userId).text(sessionDetails.userId());\n                wireOut.writeEventName(EventId.domain).text(sessionDetails.domain());\n                wireOut.writeEventName(EventId.sessionMode).text(sessionDetails.sessionMode().toString());\n                wireOut.writeEventName(EventId.securityToken).text(sessionDetails.securityToken());\n                wireOut.writeEventName(EventId.clientId).text(sessionDetails.clientId().toString());\n                wireOut.writeEventName(EventId.wireType).text(wireType.toString());\n\n\n            });\n\n            writeSocket1(handShakingWire, socketChannel);\n        }\n    }",
        "fixed_function": "    private void doHandShaking(@NotNull SocketChannel socketChannel) throws IOException {\n\n        assert outBytesLock.isHeldByCurrentThread();\n        final SessionDetails sessionDetails = sessionDetails();\n        if (sessionDetails != null) {\n            handShakingWire.clear();\n            final Bytes<?> bytes = handShakingWire.bytes();\n            bytes.clear();\n\n            // we are always going to send the header as text wire, the server will\n            // respond in the wire define by the wireType field, all subsequent types must be in wireType\n\n            handShakingWire.writeDocument(false, wireOut -> {\n                wireOut.writeEventName(EventId.userId).text(sessionDetails.userId());\n                wireOut.writeEventName(EventId.domain).text(sessionDetails.domain());\n                wireOut.writeEventName(EventId.sessionMode).text(sessionDetails.sessionMode().toString());\n                wireOut.writeEventName(EventId.securityToken).text(sessionDetails.securityToken());\n                wireOut.writeEventName(EventId.clientId).text(sessionDetails.clientId().toString());\n                WireType wt = wireType;\n\n                if (wt != null)\n\n                    try {\n                        wireOut.writeEventName(EventId.wireType).text(wt.toString());\n                    } catch (NullPointerException e) {\n                        final String charSequence = wt.toString();\n                        final ValueOut valueOut = wireOut.writeEventName(EventId.wireType);\n                        valueOut.text(charSequence);\n                    }\n            });\n\n            writeSocket1(handShakingWire, socketChannel);\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 513,
        "end_loc": 559,
        "buggy_function": "    public void writeSocket(@NotNull final WireOut wire, boolean reconnectOnFailure) {\n\n        assert outBytesLock().isHeldByCurrentThread();\n\n        try {\n\n            assert wire.startUse();\n            SocketChannel clientChannel = this.clientChannel;\n\n            // wait for the channel to be non null\n            if (clientChannel == null) {\n                if (!reconnectOnFailure) {\n                    return;\n                }\n                final byte[] bytes = wire.bytes().toByteArray();\n                assert wire.endUse();\n                condition.await(10, TimeUnit.SECONDS);\n                assert wire.startUse();\n                wire.bytes().clear().write(bytes);\n            }\n\n            writeSocket1(wire, this.clientChannel);\n        } catch (ClosedChannelException e) {\n            closeSocket();\n            Jvm.pause(500);\n            if (reconnectOnFailure)\n                throw new ConnectionDroppedException(e);\n        } catch (IOException e) {\n            if (!\"Broken pipe\".equals(e.getMessage()))\n                LOG.error(\"\", e);\n            closeSocket();\n            Jvm.pause(500);\n            throw new ConnectionDroppedException(e);\n\n        } catch (ConnectionDroppedException e) {\n            closeSocket();\n            Jvm.pause(500);\n            throw e;\n        } catch (Exception e) {\n            LOG.error(\"\", e);\n            closeSocket();\n            Jvm.pause(500);\n            throw new ConnectionDroppedException(e);\n        } finally {\n            assert wire.endUse();\n        }\n    }",
        "fixed_function": "    public void writeSocket(@NotNull final WireOut wire, boolean reconnectOnFailure) {\n\n        assert outBytesLock().isHeldByCurrentThread();\n\n        try {\n\n            SocketChannel clientChannel = this.clientChannel;\n\n            // wait for the channel to be non null\n            if (clientChannel == null) {\n                if (!reconnectOnFailure) {\n                    return;\n                }\n                final byte[] bytes = wire.bytes().toByteArray();\n                condition.await(10, TimeUnit.SECONDS);\n                wire.bytes().clear().write(bytes);\n            }\n\n            writeSocket1(wire, this.clientChannel);\n        } catch (ClosedChannelException e) {\n            closeSocket();\n            Jvm.pause(500);\n            if (reconnectOnFailure)\n                throw new ConnectionDroppedException(e);\n        } catch (IOException e) {\n            if (!\"Broken pipe\".equals(e.getMessage()))\n                LOG.error(\"\", e);\n            closeSocket();\n            Jvm.pause(500);\n            throw new ConnectionDroppedException(e);\n\n        } catch (ConnectionDroppedException e) {\n            closeSocket();\n            Jvm.pause(500);\n            throw e;\n        } catch (Exception e) {\n            LOG.error(\"\", e);\n            closeSocket();\n            Jvm.pause(500);\n            throw new ConnectionDroppedException(e);\n        }\n    }",
        "comment": "/**\n     * sends data to the server via TCP/IP\n     *\n     * @param wire the {@code wire} containing the outbound data\n     */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 594,
        "end_loc": 700,
        "buggy_function": "    private void writeSocket1(@NotNull WireOut outWire, @Nullable SocketChannel clientChannel) throws\n            IOException {\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"sending :\" + Wires.fromSizePrefixedBlobs(outWire.bytes()));\n\n        if (clientChannel == null) {\n            LOG.info(\"Connection Dropped\");\n            throw new ConnectionDroppedException(\"Connection Dropped\");\n        }\n\n        assert outBytesLock.isHeldByCurrentThread();\n\n        long start = Time.currentTimeMillis();\n        assert outWire.startUse();\n        try {\n            final Bytes<?> bytes = outWire.bytes();\n            final ByteBuffer outBuffer = (ByteBuffer) bytes.underlyingObject();\n            outBuffer.limit((int) bytes.writePosition());\n            outBuffer.position(0);\n\n            assert outBytesLock().isHeldByCurrentThread();\n\n        // this check ensure that a put does not occur while currently re-subscribing\n            boolean isOutBufferFull = false;\n            logToStandardOutMessageSent(outWire, outBuffer);\n            updateLargestChunkSoFarSize(outBuffer);\n\n            try {\n\n                int prevRemaining = outBuffer.remaining();\n                while (outBuffer.remaining() > 0) {\n\n                    // if the socket was changed, we need to resend using this one instead\n                    // unless the client channel still has not be set, then we will use this one\n                    // this can happen during the handshaking phase of a new connection\n\n                    if (clientChannel != this.clientChannel)\n                        throw new ConnectionDroppedException(\"Connection has Changed\");\n\n                    int len = clientChannel.write(outBuffer);\n                    if (len == -1)\n                        throw new IORuntimeException(\"Disconnection to server=\" +\n                                socketAddressSupplier + \", name=\" + name);\n\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"W:\" + len + \",socket=\" + socketAddressSupplier.get());\n\n                    // reset the timer if we wrote something.\n                    if (prevRemaining != outBuffer.remaining()) {\n                        start = Time.currentTimeMillis();\n                        isOutBufferFull = false;\n                        //  if (Jvm.isDebug() && outBuffer.remaining() == 0)\n                        //    System.out.println(\"W: \" + (prevRemaining - outBuffer\n                        //          .remaining()));\n                        prevRemaining = outBuffer.remaining();\n                        final TcpSocketConsumer tcpSocketConsumer = this.tcpSocketConsumer;\n\n                        if (tcpSocketConsumer != null)\n                            this.tcpSocketConsumer.lastTimeMessageReceivedOrSent = start;\n                    } else {\n                        if (!isOutBufferFull && Jvm.isDebug() && LOG.isDebugEnabled())\n                            LOG.debug(\"----> TCP write buffer is FULL! \" + outBuffer.remaining() + \" bytes\" +\n                                    \" remaining.\");\n                        isOutBufferFull = true;\n\n                        long writeTime = Time.currentTimeMillis() - start;\n\n                        // the reason that this is so large is that results from a bootstrap can\n                        // take a very long time to send all the data from the server to the client\n                        // we don't want this to fail as it will cause a disconnection !\n                        if (writeTime > TimeUnit.MINUTES.toMillis(15)) {\n\n                            for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {\n                                Thread thread = entry.getKey();\n                                if (thread.getThreadGroup().getName().equals(\"system\"))\n                                    continue;\n                                StringBuilder sb = new StringBuilder();\n                                sb.append(thread).append(\" \").append(thread.getState());\n                                Jvm.trimStackTrace(sb, entry.getValue());\n                                sb.append(\"\\n\");\n                                LOG.error(\"\\n========= THREAD DUMP =========\\n\", sb);\n                            }\n\n                            closeSocket();\n\n                            throw new IORuntimeException(\"Took \" + writeTime + \" ms \" +\n                                    \"to perform a write, remaining= \" + outBuffer.remaining());\n                        }\n\n                        // its important to yield, if the read buffer gets full\n                        // we wont be able to write, lets give some time to the read thread !\n                        Thread.yield();\n                    }\n                }\n            } catch (IOException e) {\n                closeSocket();\n                throw e;\n            }\n\n            outBuffer.clear();\n            bytes.clear();\n        } finally {\n            assert outWire.endUse();\n        }\n\n    }",
        "fixed_function": "    private void writeSocket1(@NotNull WireOut outWire, @Nullable SocketChannel clientChannel) throws\n            IOException {\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"sending :\" + Wires.fromSizePrefixedBlobs(outWire.bytes()));\n\n        if (clientChannel == null) {\n            LOG.info(\"Connection Dropped\");\n            throw new ConnectionDroppedException(\"Connection Dropped\");\n        }\n\n        assert outBytesLock.isHeldByCurrentThread();\n\n        long start = Time.currentTimeMillis();\n\n        final Bytes<?> bytes = outWire.bytes();\n        final ByteBuffer outBuffer = (ByteBuffer) bytes.underlyingObject();\n        outBuffer.limit((int) bytes.writePosition());\n        outBuffer.position(0);\n\n        // this check ensure that a put does not occur while currently re-subscribing\n        assert outBytesLock().isHeldByCurrentThread();\n\n        boolean isOutBufferFull = false;\n        logToStandardOutMessageSent(outWire, outBuffer);\n        updateLargestChunkSoFarSize(outBuffer);\n\n        try {\n\n            int prevRemaining = outBuffer.remaining();\n            while (outBuffer.remaining() > 0) {\n\n                // if the socket was changed, we need to resend using this one instead\n                // unless the client channel still has not be set, then we will use this one\n                // this can happen during the handshaking phase of a new connection\n\n                if (clientChannel != this.clientChannel)\n                    throw new ConnectionDroppedException(\"Connection has Changed\");\n\n                int len = clientChannel.write(outBuffer);\n                if (len == -1)\n                    throw new IORuntimeException(\"Disconnection to server=\" +\n                            socketAddressSupplier + \", name=\" + name);\n\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"W:\" + len + \",socket=\" + socketAddressSupplier.get());\n\n                // reset the timer if we wrote something.\n                if (prevRemaining != outBuffer.remaining()) {\n                    start = Time.currentTimeMillis();\n                    isOutBufferFull = false;\n                    //  if (Jvm.isDebug() && outBuffer.remaining() == 0)\n                    //    System.out.println(\"W: \" + (prevRemaining - outBuffer\n                    //          .remaining()));\n                    prevRemaining = outBuffer.remaining();\n                    final TcpSocketConsumer tcpSocketConsumer = this.tcpSocketConsumer;\n\n                    if (tcpSocketConsumer != null)\n                        this.tcpSocketConsumer.lastTimeMessageReceivedOrSent = start;\n                } else {\n                    if (!isOutBufferFull && Jvm.isDebug() && LOG.isDebugEnabled())\n                        LOG.debug(\"----> TCP write buffer is FULL! \" + outBuffer.remaining() + \" bytes\" +\n                                \" remaining.\");\n                    isOutBufferFull = true;\n\n                    long writeTime = Time.currentTimeMillis() - start;\n\n                    // the reason that this is so large is that results from a bootstrap can\n                    // take a very long time to send all the data from the server to the client\n                    // we don't want this to fail as it will cause a disconnection !\n                    if (writeTime > TimeUnit.MINUTES.toMillis(15)) {\n\n                        for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {\n                            Thread thread = entry.getKey();\n                            if (thread.getThreadGroup().getName().equals(\"system\"))\n                                continue;\n                            StringBuilder sb = new StringBuilder();\n                            sb.append(thread).append(\" \").append(thread.getState());\n                            Jvm.trimStackTrace(sb, entry.getValue());\n                            sb.append(\"\\n\");\n                            LOG.error(\"\\n========= THREAD DUMP =========\\n\", sb);\n                        }\n\n                        closeSocket();\n\n                        throw new IORuntimeException(\"Took \" + writeTime + \" ms \" +\n                                \"to perform a write, remaining= \" + outBuffer.remaining());\n                    }\n\n                    // its important to yield, if the read buffer gets full\n                    // we wont be able to write, lets give some time to the read thread !\n                    Thread.yield();\n                }\n            }\n        } catch (IOException e) {\n            closeSocket();\n            throw e;\n        }\n\n        outBuffer.clear();\n        bytes.clear();\n\n    }",
        "comment": "/**\n     * writes the bytes to the socket, onto the clientChannel provided\n     *\n     * @param outWire       the data that you wish to write\n     * @param clientChannel\n     * @throws IOException\n     */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 950,
        "end_loc": 955,
        "buggy_function": "        TcpSocketConsumer() {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"constructor remoteAddress=\" + socketAddressSupplier);\n\n            executorService = start();\n        }",
        "fixed_function": "        private TcpSocketConsumer(\n                @NotNull final Function<Bytes, Wire> wireFunction) {\n            this.wireFunction = wireFunction;\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"constructor remoteAddress=\" + socketAddressSupplier);\n\n            executorService = start();\n        }",
        "comment": "/**\n         * @param wireFunction converts bytes into wire, ie TextWire or BinaryWire\n         */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 1176,
        "end_loc": 1254,
        "buggy_function": "        private void running() {\n            try {\n                final Wire inWire = wireType.apply(elasticByteBuffer());\n                assert inWire != null;\n                assert inWire.startUse();\n\n                while (!isShuttingdown()) {\n\n                    checkConnectionState();\n\n                    try {\n                        // if we have processed all the bytes that we have read in\n                        final Bytes<?> bytes = inWire.bytes();\n\n                        // the number bytes ( still required  ) to read the size\n                        blockingRead(inWire, SIZE_OF_SIZE);\n\n                        final int header = bytes.readVolatileInt(0);\n                        final long messageSize = size(header);\n\n                        // read the data\n                        start = System.currentTimeMillis();\n                        if (Wires.isData(header)) {\n                            assert messageSize < Integer.MAX_VALUE;\n\n                            final boolean clearTid = processData(tid, Wires.isReady(header), header,\n                                    (int) messageSize, inWire);\n\n                            long timeTaken = System.currentTimeMillis() - start;\n                            start = Long.MAX_VALUE;\n                            if (timeTaken > 20)\n                                LOG.info(\"Processing data=\" + timeTaken + \"ms\");\n\n                            if (clearTid)\n                                tid = -1;\n\n                        } else {\n                            // read  meta data - get the tid\n                            blockingRead(inWire, messageSize);\n                            logToStandardOutMessageReceived(inWire);\n                            // ensure the tid is reset\n                            this.tid = -1;\n                            inWire.readDocument((WireIn w) -> this.tid = CoreFields.tid(w), null);\n                        }\n\n                    } catch (@NotNull Exception e) {\n                        start = Long.MAX_VALUE;\n\n                        if (Jvm.isDebug() && LOG.isDebugEnabled())\n                            LOG.debug(\"\", e);\n\n                        tid = -1;\n                        if (isShuttingdown()) {\n                            break;\n\n                        } else {\n                            String message = e.getMessage();\n                            if (e instanceof ConnectionDroppedException)\n                                LOG.debug(\"reconnecting due to dropped connection \" + ((message == null) ? \"\" : message));\n                            else if (e instanceof IOException && \"Connection reset by peer\".equals(message))\n                                LOG.warn(\"reconnecting due to \\\"Connection reset by peer\\\" \" + message);\n                            else\n                                LOG.warn(\"reconnecting due to unexpected exception\", e);\n                            closeSocket();\n                            Jvm.pause(1000);\n                        }\n                    } finally {\n                        start = Long.MAX_VALUE;\n                        clear(inWire);\n                    }\n                }\n\n            } catch (Throwable e) {\n                if (!isShuttingdown())\n                    LOG.error(\"\", e);\n            } finally {\n                closeSocket();\n            }\n        }",
        "fixed_function": "        private void running() {\n            try {\n                final Wire inWire = wireFunction.apply(elasticByteBuffer());\n                assert inWire != null;\n\n                while (!isShuttingdown()) {\n\n                    checkConnectionState();\n\n                    try {\n                        // if we have processed all the bytes that we have read in\n                        final Bytes<?> bytes = inWire.bytes();\n\n                        // the number bytes ( still required  ) to read the size\n                        blockingRead(inWire, SIZE_OF_SIZE);\n\n                        final int header = bytes.readVolatileInt(0);\n                        final long messageSize = size(header);\n\n                        // read the data\n                        start = System.currentTimeMillis();\n                        if (Wires.isData(header)) {\n                            assert messageSize < Integer.MAX_VALUE;\n\n                            final boolean clearTid = processData(tid, Wires.isReady(header), header,\n                                    (int) messageSize, inWire);\n\n                            long timeTaken = System.currentTimeMillis() - start;\n                            start = Long.MAX_VALUE;\n                            if (timeTaken > 20)\n                                LOG.info(\"Processing data=\" + timeTaken + \"ms\");\n\n                            if (clearTid)\n                                tid = -1;\n\n                        } else {\n                            // read  meta data - get the tid\n                            blockingRead(inWire, messageSize);\n                            logToStandardOutMessageReceived(inWire);\n                            // ensure the tid is reset\n                            this.tid = -1;\n                            inWire.readDocument((WireIn w) -> this.tid = CoreFields.tid(w), null);\n                        }\n\n                    } catch (@NotNull Exception e) {\n                        start = Long.MAX_VALUE;\n\n                        if (Jvm.isDebug() && LOG.isDebugEnabled())\n                            LOG.debug(\"\", e);\n\n                        tid = -1;\n                        if (isShuttingdown()) {\n                            break;\n\n                        } else {\n                            String message = e.getMessage();\n                            if (e instanceof ConnectionDroppedException)\n                                LOG.debug(\"reconnecting due to dropped connection \" + ((message == null) ? \"\" : message));\n                            else if (e instanceof IOException && \"Connection reset by peer\".equals(message))\n                                LOG.warn(\"reconnecting due to \\\"Connection reset by peer\\\" \" + message);\n                            else\n                                LOG.warn(\"reconnecting due to unexpected exception\", e);\n                            closeSocket();\n                            Jvm.pause(1000);\n                        }\n                    } finally {\n                        start = Long.MAX_VALUE;\n                        clear(inWire);\n                    }\n                }\n\n            } catch (Throwable e) {\n                if (!isShuttingdown())\n                    LOG.error(\"\", e);\n            } finally {\n                closeSocket();\n            }\n        }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 1403,
        "end_loc": 1434,
        "buggy_function": "        private void processServerSystemMessage(final int header, final int messageSize)\n                throws IOException {\n\n            serverHeartBeatHandler.clear();\n            final Bytes bytes = serverHeartBeatHandler;\n\n            bytes.clear();\n            final ByteBuffer byteBuffer = (ByteBuffer) bytes.underlyingObject();\n            byteBuffer.clear();\n            // we have to first write the header back to the bytes so that is can be\n            // viewed as a document\n            bytes.writeInt(0, header);\n            byteBuffer.position(SIZE_OF_SIZE);\n            byteBuffer.limit(SIZE_OF_SIZE + messageSize);\n            readBuffer(byteBuffer);\n\n            bytes.readLimit(byteBuffer.position());\n\n            final StringBuilder eventName = Wires.acquireStringBuilder();\n            final Wire inWire = TcpChannelHub.this.wireType.apply(bytes);\n            if (YamlLogging.showHeartBeats())\n                logToStandardOutMessageReceived(inWire);\n            inWire.readDocument(null, d -> {\n                        final ValueIn valueIn = d.readEventName(eventName);\n                        if (EventId.heartbeat.contentEquals(eventName))\n                            reflectServerHeartbeatMessage(valueIn);\n                        else if (EventId.onClosingReply.contentEquals(eventName))\n                            receivedClosedAcknowledgement.countDown();\n\n                    }\n            );\n        }",
        "fixed_function": "        private void processServerSystemMessage(final int header, final int messageSize)\n                throws IOException {\n\n            serverHeartBeatHandler.clear();\n            final Bytes bytes = serverHeartBeatHandler;\n\n            bytes.clear();\n            final ByteBuffer byteBuffer = (ByteBuffer) bytes.underlyingObject();\n            byteBuffer.clear();\n            // we have to first write the header back to the bytes so that is can be\n            // viewed as a document\n            bytes.writeInt(0, header);\n            byteBuffer.position(SIZE_OF_SIZE);\n            byteBuffer.limit(SIZE_OF_SIZE + messageSize);\n            readBuffer(byteBuffer);\n\n            bytes.readLimit(byteBuffer.position());\n\n            final StringBuilder eventName = Wires.acquireStringBuilder();\n            final Wire inWire = wire.apply(bytes);\n            if (YamlLogging.showHeartBeats())\n                logToStandardOutMessageReceived(inWire);\n            inWire.readDocument(null, d -> {\n                        final ValueIn valueIn = d.readEventName(eventName);\n                        if (EventId.heartbeat.contentEquals(eventName))\n                            reflectServerHeartbeatMessage(valueIn);\n                        else if (EventId.onClosingReply.contentEquals(eventName))\n                            receivedClosedAcknowledgement.countDown();\n\n                    }\n            );\n        }",
        "comment": "/**\n         * process system messages which originate from the server\n         *\n         * @param header      a value representing the type of message\n         * @param messageSize the size of the message\n         * @throws IOException\n         */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java",
        "start_loc": 1540,
        "end_loc": 1572,
        "buggy_function": "        private void sendHeartbeat() {\n            assert outWire.startUse();\n            try {\n                if (outWire.bytes().writePosition() > 100)\n                    return;\n\n                long l = System.nanoTime();\n\n                // this denotes that the next message is a system message as it has a null csp\n\n                subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this, null, name) {\n                    @Override\n                    public void onSubscribe(@NotNull WireOut wireOut) {\n                        if (Jvm.isDebug())\n                            LOG.info(\"sending heartbeat\");\n                        wireOut.writeEventName(EventId.heartbeat).int64(Time\n                                .currentTimeMillis());\n                    }\n\n                    @Override\n                    public void onConsumer(@NotNull WireIn inWire) {\n                        long roundTipTimeMicros = NANOSECONDS.toMicros(System.nanoTime() - l);\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"heartbeat round trip time=\" + roundTipTimeMicros + \"\" +\n                                    \" server=\" + socketAddressSupplier);\n\n                        inWire.clear();\n                    }\n                }, true);\n            } finally {\n                assert outWire.endUse();\n            }\n        }",
        "fixed_function": "        private void sendHeartbeat() {\n\n            if (outWire.bytes().writePosition() > 100)\n                return;\n\n            long l = System.nanoTime();\n\n            // this denotes that the next message is a system message as it has a null csp\n\n            subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this, null, name) {\n                @Override\n                public void onSubscribe(@NotNull WireOut wireOut) {\n                    if (Jvm.isDebug())\n                        LOG.info(\"sending heartbeat\");\n                    wireOut.writeEventName(EventId.heartbeat).int64(Time\n                            .currentTimeMillis());\n                }\n\n                @Override\n                public void onConsumer(@NotNull WireIn inWire) {\n                    long roundTipTimeMicros = NANOSECONDS.toMicros(System.nanoTime() - l);\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"heartbeat round trip time=\" + roundTipTimeMicros + \"\" +\n                                \" server=\" + socketAddressSupplier);\n\n                    inWire.clear();\n                }\n            }, true);\n        }",
        "comment": "/**\n         * sends a heartbeat from the client to the server and logs the round trip time\n         */"
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java",
        "start_loc": 80,
        "end_loc": 106,
        "buggy_function": "    @Override\n    public void put(final Object key, WriteMarshallable event) {\n\n        if (closed) {\n            LOG.debug(\"message ignored as closed\");\n            return;\n        }\n\n        // writes the data and its size\n        synchronized (lock()) {\n            wrapperWire.writeDocument(false, d -> {\n\n                assert wire.startUse();\n                try {\n                final long start = wire.bytes().writePosition();\n                event.writeMarshallable(wire);\n                if (YamlLogging.showServerWrites())\n                    LOG.info(\"Server is about to send:\" + Wires.fromSizePrefixedBlobs(wire.bytes(),\n                            start, wire\n                                    .bytes().writePosition() - start));\n                } finally {\n                    assert wire.endUse();\n                }\n\n            });\n        }\n    }",
        "fixed_function": "    @Override\n    public void put(final Object key, WriteMarshallable event) {\n\n        if (closed) {\n            LOG.debug(\"message ignored as closed\");\n            return;\n        }\n\n        // writes the data and its size\n        synchronized (lock()) {\n            wrapperWire.writeDocument(false, d -> {\n\n                final long start = wire.bytes().writePosition();\n                event.writeMarshallable(wire);\n                if (YamlLogging.showServerWrites())\n                    LOG.info(\"Server is about to send:\" + Wires.fromSizePrefixedBlobs(wire.bytes(),\n                            start, wire\n                                    .bytes().writePosition() - start));\n\n            });\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java",
        "start_loc": 125,
        "end_loc": 134,
        "buggy_function": "    public boolean canTakeMoreData() {\n        synchronized (lock()) {\n            assert wrapperWire.startUse();\n            try {\n                return wrapperWire.bytes().writePosition() < TcpChannelHub.BUFFER_SIZE / 2; // don't attempt to fill the buffer completely.\n            } finally {\n                assert wrapperWire.endUse();\n            }\n        }\n    }",
        "fixed_function": "    public boolean canTakeMoreData() {\n        return wrapperWire.bytes().writePosition() < TcpChannelHub.BUFFER_SIZE;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "net.openhft.performance.tests.network.ConnectionEventHandlerTest::testConnection": {
        "path": "net/openhft/performance/tests/network/ConnectionEventHandlerTest.java",
        "function_name": "testConnection",
        "src": "",
        "error_msg": "net.openhft.performance.tests.network.ConnectionEventHandlerTest::testConnection --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Gocd_slack_build_notifier-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/in/ashwanthkumar/gocd/slack/ruleset/PipelineRule.java",
        "start_loc": 147,
        "end_loc": 167,
        "buggy_function": "    public static PipelineRule merge(PipelineRule pipelineRule, PipelineRule defaultRule) {\n        PipelineRule ruleToReturn = new PipelineRule(pipelineRule);\n        if (isEmpty(pipelineRule.getNameRegex())) {\n            ruleToReturn.setNameRegex(defaultRule.getNameRegex());\n        }\n        if (isEmpty(pipelineRule.getStageRegex())) {\n            ruleToReturn.setStageRegex(defaultRule.getStageRegex());\n        }\n\n        if (isEmpty(pipelineRule.getChannel())) {\n            ruleToReturn.setChannel(defaultRule.getChannel());\n        }\n\n        if (pipelineRule.getStatus().isEmpty()) {\n            ruleToReturn.setStatus(defaultRule.getStatus());\n        } else {\n            ruleToReturn.getStatus().addAll(defaultRule.getStatus());\n        }\n\n        return ruleToReturn;\n    }",
        "fixed_function": "    public static PipelineRule merge(PipelineRule pipelineRule, PipelineRule defaultRule) {\n        PipelineRule ruleToReturn = new PipelineRule(pipelineRule);\n        if (isEmpty(pipelineRule.getNameRegex())) {\n            ruleToReturn.setNameRegex(defaultRule.getNameRegex());\n        }\n        if (isEmpty(pipelineRule.getStageRegex())) {\n            ruleToReturn.setStageRegex(defaultRule.getStageRegex());\n        }\n\n        if (isEmpty(pipelineRule.getChannel())) {\n            ruleToReturn.setChannel(defaultRule.getChannel());\n        }\n\n        if (pipelineRule.getStatus().isEmpty()) {\n            ruleToReturn.setStatus(defaultRule.getStatus());\n        } else {\n            ruleToReturn.getStatus().addAll(pipelineRule.getStatus());\n        }\n\n        return ruleToReturn;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/in/ashwanthkumar/gocd/slack/ruleset/Rules.java",
        "start_loc": 123,
        "end_loc": 177,
        "buggy_function": "    public static Rules fromConfig(Config config) {\n        boolean isEnabled = config.getBoolean(\"enabled\");\n\n        String webhookUrl = config.getString(\"webhookUrl\");\n        String channel = null;\n        if (config.hasPath(\"channel\")) {\n            channel = config.getString(\"channel\");\n        }\n\n        String displayName = \"gocd-slack-bot\";\n        if(config.hasPath(\"slackDisplayName\")) {\n            displayName = config.getString(\"slackDisplayName\");\n        }\n\n        String iconURL = \"https://raw.githubusercontent.com/ashwanthkumar/assets/c597777ee749c89fec7ce21304d727724a65be7d/images/gocd-logo.png\";\n        if(config.hasPath(\"slackUserIconURL\")) {\n            iconURL = config.getString(\"slackUserIconURL\");\n        }\n\n        String serverHost = config.getString(\"server-host\");\n        String login = null;\n        if (config.hasPath(\"login\")) {\n            login = config.getString(\"login\");\n        }\n        String password = null;\n        if (config.hasPath(\"password\")) {\n            password = config.getString(\"password\");\n        }\n\n        final PipelineRule defaultRule = PipelineRule.fromConfig(config.getConfig(\"default\"), channel);\n\n        List<PipelineRule> pipelineRules = Lists.map((List<Config>) config.getConfigList(\"pipelines\"), new Function<Config, PipelineRule>() {\n            public PipelineRule apply(Config input) {\n                return merge(PipelineRule.fromConfig(input), defaultRule);\n            }\n        });\n\n        Rules rules = new Rules()\n                .setEnabled(isEnabled)\n                .setWebHookUrl(webhookUrl)\n                .setSlackChannel(channel)\n                .setSlackDisplayName(displayName)\n                .setSlackUserIcon(iconURL)\n                .setPipelineRules(pipelineRules)\n                .setGoServerHost(serverHost)\n                .setGoLogin(login)\n                .setGoPassword(password);\n        try {\n            rules.pipelineListener = Class.forName(config.getString(\"listener\")).asSubclass(PipelineListener.class).getConstructor(Rules.class).newInstance(rules);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return rules;\n    }",
        "fixed_function": "    public static Rules fromConfig(Config config) {\n        boolean isEnabled = config.getBoolean(\"enabled\");\n\n        String webhookUrl = config.getString(\"webhookUrl\");\n        String channel = null;\n        if (config.hasPath(\"channel\")) {\n            channel = config.getString(\"channel\");\n        }\n\n        String displayName = \"gocd-slack-bot\";\n        if(config.hasPath(\"slackDisplayName\")) {\n            displayName = config.getString(\"slackDisplayName\");\n        }\n\n        String iconURL = \"https://raw.githubusercontent.com/ashwanthkumar/assets/c597777ee749c89fec7ce21304d727724a65be7d/images/gocd-logo.png\";\n        if(config.hasPath(\"slackUserIconURL\")) {\n            iconURL = config.getString(\"slackUserIconURL\");\n        }\n\n        String serverHost = config.getString(\"server-host\");\n        String login = null;\n        if (config.hasPath(\"login\")) {\n            login = config.getString(\"login\");\n        }\n        String password = null;\n        if (config.hasPath(\"password\")) {\n            password = config.getString(\"password\");\n        }\n\n        final PipelineRule defaultRule = PipelineRule.fromConfig(config.getConfig(\"default\"), channel);\n\n        List<PipelineRule> pipelineRules = Lists.map((List<Config>) config.getConfigList(\"pipelines\"), new Function<Config, PipelineRule>() {\n            public PipelineRule apply(Config input) {\n                return merge(PipelineRule.fromConfig(input), defaultRule);\n            }\n        });\n\n        Rules rules = new Rules()\n                .setEnabled(isEnabled)\n                .setWebHookUrl(webhookUrl)\n                .setSlackChannel(channel)\n                .setSlackDisplayName(displayName)\n                .setSlackUserIcon(iconURL)\n                .setPipelineRules(pipelineRules)\n                .setGoServerHost(serverHost)\n                .setGoLogin(login)\n                .setGoPassword(password);\n        try {\n            rules.pipelineListener = Class.forName(config.getString(\"listener\")).asSubclass(PipelineListener.class).getConstructor(Rules.class).newInstance(rules);\n        } catch (Exception e) {\n            LOGGER.error(\"Exception while initializing pipeline listener\", e);\n            throw new RuntimeException(e);\n        }\n\n        return rules;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "in.ashwanthkumar.gocd.slack.ruleset.RulesReaderTest::shouldReadMinimalConfigWithPipeline": {
        "path": "in/ashwanthkumar/gocd/slack/ruleset/RulesReaderTest.java",
        "function_name": "shouldReadMinimalConfigWithPipeline",
        "src": "@Test\n    public void shouldReadMinimalConfigWithPipeline() {\n        Rules rules = RulesReader.read(\"configs/test-config-minimal-with-pipeline.conf\");\n        assertThat(rules.isEnabled(), is(true));\n        assertThat(rules.getSlackChannel(), nullValue());\n        assertThat(rules.getGoServerHost(), is(\"https://go-instance:8153/\"));\n        assertThat(rules.getWebHookUrl(), is(\"https://hooks.slack.com/services/\"));\n        assertThat(rules.getPipelineRules().size(), is(1));\n\n        PipelineRule pipelineRule = new PipelineRule()\n                .setNameRegex(\".*\")\n                .setStageRegex(\".*\")\n                .setChannel(\"#foo\")\n                .setStatus(Sets.of(PipelineStatus.FAILED));\n        assertThat(rules.getPipelineRules(), hasItem(pipelineRule));\n\n        assertThat(rules.getPipelineListener(), notNullValue());\n    }",
        "error_msg": "in.ashwanthkumar.gocd.slack.ruleset.RulesReaderTest::shouldReadMinimalConfigWithPipeline --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      }
    }
  },
  "Trident_ml-1": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/github/pmerienne/trident/ml/classification/ClassifyQuery.java",
        "start_loc": 42,
        "end_loc": 66,
        "buggy_function": "\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic List<L> batchRetrieve(MapState<Classifier<L>> state, List<TridentTuple> tuples) {\n\t\tList<L> labels = new ArrayList<L>();\n\n\t\tList<Classifier<L>> classifiers = state.multiGet(KeysUtil.toKeys(this.classifierName));\n\t\tif (classifiers != null && !classifiers.isEmpty()) {\n\t\t\tClassifier<L> classifier = classifiers.get(0);\n\t\t\tif(classifier == null) {\n\t\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\t\tlabels.add(null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tL label;\n\t\t\tInstance<L> instance;\n\t\t\tfor (TridentTuple tuple : tuples) {\n\t\t\t\tinstance = (Instance<L>) tuple.get(0);\n\t\t\t\tlabel = classifier.classify(instance.features);\n\t\t\t\tlabels.add(label);\n\t\t\t}\n\t\t}\n\n\t\treturn labels;\n\t}",
        "fixed_function": "\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic List<L> batchRetrieve(MapState<Classifier<L>> state, List<TridentTuple> tuples) {\n\t\tList<L> labels = new ArrayList<L>();\n\n\t\tList<Classifier<L>> classifiers = state.multiGet(KeysUtil.toKeys(this.classifierName));\n\t\tif (classifiers != null && !classifiers.isEmpty()) {\n\t\t\tClassifier<L> classifier = classifiers.get(0);\n\t\t\tif(classifier == null) {\n\t\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\t\tlabels.add(null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tL label;\n\t\t\tInstance<L> instance;\n\t\t\tfor (TridentTuple tuple : tuples) {\n\t\t\t\tinstance = (Instance<L>) tuple.get(0);\n\t\t\t\tlabel = classifier.classify(instance.features);\n\t\t\t\tlabels.add(label);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\tlabels.add(null);\n\t\t\t}\n\t\t}\n\n\t\treturn labels;\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/pmerienne/trident/ml/regression/RegressionQuery.java",
        "start_loc": 43,
        "end_loc": 67,
        "buggy_function": "\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic List<Double> batchRetrieve(MapState<Regressor> state, List<TridentTuple> tuples) {\n\t\tList<Double> labels = new ArrayList<Double>();\n\n\t\tList<Regressor> regressors = state.multiGet(KeysUtil.toKeys(this.regressorName));\n\t\tif (regressors != null && !regressors.isEmpty()) {\n\t\t\tRegressor regressor = regressors.get(0);\n\t\t\tif (regressor == null) {\n\t\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\t\tlabels.add(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDouble label;\n\t\t\t\tInstance<Double> instance;\n\t\t\t\tfor (TridentTuple tuple : tuples) {\n\t\t\t\t\tinstance = (Instance<Double>) tuple.get(0);\n\t\t\t\t\tlabel = regressor.predict(instance.features);\n\t\t\t\t\tlabels.add(label);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn labels;\n\t}",
        "fixed_function": "\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic List<Double> batchRetrieve(MapState<Regressor> state, List<TridentTuple> tuples) {\n\t\tList<Double> labels = new ArrayList<Double>();\n\n\t\tList<Regressor> regressors = state.multiGet(KeysUtil.toKeys(this.regressorName));\n\t\tif (regressors != null && !regressors.isEmpty()) {\n\t\t\tRegressor regressor = regressors.get(0);\n\t\t\tif (regressor == null) {\n\t\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\t\tlabels.add(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDouble label;\n\t\t\t\tInstance<Double> instance;\n\t\t\t\tfor (TridentTuple tuple : tuples) {\n\t\t\t\t\tinstance = (Instance<Double>) tuple.get(0);\n\t\t\t\t\tlabel = regressor.predict(instance.features);\n\t\t\t\t\tlabels.add(label);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\tlabels.add(null);\n\t\t\t}\n\t\t}\n\n\t\treturn labels;\n\t}",
        "comment": "/**\n\t * What about cyclomatic complexity !! TODO : refactor this mess\n\t */"
      }
    ],
    "trigger_test": {
      "com.github.pmerienne.trident.ml.classification.ClassifyQueryTest::should_classify_instance_without_classifier": {
        "path": "com/github/pmerienne/trident/ml/classification/ClassifyQueryTest.java",
        "function_name": "should_classify_instance_without_classifier",
        "src": "@Test\n\tpublic void should_classify_instance_without_classifier() {\n\t\t// Given\n\t\tString classifierName = \"TestLearner\";\n\t\tClassifyQuery<Boolean> query = new ClassifyQuery<Boolean>(classifierName);\n\n\t\tdouble[] features1 = new double[10];\n\t\tdouble[] features2 = new double[10];\n\t\tTridentTuple tuple1 = createMockedInstanceTuple(features1);\n\t\tTridentTuple tuple2 = createMockedInstanceTuple(features2);\n\t\tList<TridentTuple> tuples = Arrays.asList(tuple1, tuple2);\n\n\t\tMapState<Classifier<Boolean>> state = mock(MapState.class);\n\t\tgiven(state.multiGet(asList(asList((Object) classifierName)))).willReturn(EMPTY_LIST);\n\n\t\t// When\n\t\tList<Boolean> labels = query.batchRetrieve(state, tuples);\n\n\t\tassertEquals(2, labels.size());\n\t\tassertNull(labels.get(0));\n\t\tassertNull(labels.get(1));\n\t}",
        "error_msg": "com.github.pmerienne.trident.ml.classification.ClassifyQueryTest::should_classify_instance_without_classifier --> junit.framework.AssertionFailedError: expected:<2> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<0>"
      },
      "com.github.pmerienne.trident.ml.regression.RegressionQueryTest::should_classify_instance_without_classifier": {
        "path": "com/github/pmerienne/trident/ml/regression/RegressionQueryTest.java",
        "function_name": "should_classify_instance_without_classifier",
        "src": "@Test\n\tpublic void should_classify_instance_without_classifier() {\n\t\t// Given\n\t\tString regressorName = \"TestLearner\";\n\t\tRegressionQuery query = new RegressionQuery(regressorName);\n\n\t\tTridentTuple tuple1 = mock(TridentTuple.class);\n\t\tTridentTuple tuple2 = mock(TridentTuple.class);\n\t\tList<TridentTuple> tuples = Arrays.asList(tuple1, tuple2);\n\n\t\tList<List<Object>> expectedKeys = asList(asList((Object) regressorName));\n\t\tMapState<Regressor> state = mock(MapState.class);\n\t\tgiven(state.multiGet(expectedKeys)).willReturn(EMPTY_LIST);\n\n\t\t// When\n\t\tList<Double> actualPredictions = query.batchRetrieve(state, tuples);\n\n\t\tassertEquals(2, actualPredictions.size());\n\t\tassertNull(actualPredictions.get(0));\n\t\tassertNull(actualPredictions.get(1));\n\t}",
        "error_msg": "com.github.pmerienne.trident.ml.regression.RegressionQueryTest::should_classify_instance_without_classifier --> junit.framework.AssertionFailedError: expected:<2> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<0>"
      }
    }
  },
  "Sansorm-6": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/Introspected.java",
        "start_loc": 149,
        "end_loc": 170,
        "buggy_function": "   public Object get(Object target, String columnName)\n   {\n      FieldColumnInfo fcInfo = columnToField.get(columnName);\n      if (fcInfo == null) {\n         throw new RuntimeException(\"Cannot find field mapped to column \" + columnName + \" on type \" + target.getClass().getCanonicalName());\n      }\n\n      try {\n         Object value = fcInfo.field.get(target);\n         // Fix-up column value for enums, integer as boolean, etc.\n         if (fcInfo.getConverter() != null) {\n            value = fcInfo.getConverter().convertToDatabaseColumn(value);\n         } else if (fcInfo.enumConstants != null && value != null) {\n            value = (fcInfo.enumType == EnumType.ORDINAL ? ((Enum<?>) value).ordinal() : ((Enum<?>) value).name());\n         }\n\n         return value;\n      }\n      catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }",
        "fixed_function": "   public Object get(Object target, String columnName)\n   {\n      FieldColumnInfo fcInfo = delimitedColumnToField.get(columnName);\n      if (fcInfo == null) {\n         throw new RuntimeException(\"Cannot find field mapped to column \" + columnName + \" on type \" + target.getClass().getCanonicalName());\n      }\n\n      try {\n         Object value = fcInfo.field.get(target);\n         // Fix-up column value for enums, integer as boolean, etc.\n         if (fcInfo.getConverter() != null) {\n            value = fcInfo.getConverter().convertToDatabaseColumn(value);\n         } else if (fcInfo.enumConstants != null && value != null) {\n            value = (fcInfo.enumType == EnumType.ORDINAL ? ((Enum<?>) value).ordinal() : ((Enum<?>) value).name());\n         }\n\n         return value;\n      }\n      catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }",
        "comment": "/**\n    * @param target\n    * @param columnName In case of delimited fields surrounded by delimiters.\n    * @return\n    */"
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/Introspected.java",
        "start_loc": 312,
        "end_loc": 329,
        "buggy_function": "   public String[] getInsertableColumns()\n   {\n      if (insertableColumns != null) {\n         return insertableColumns;\n      }\n\n      List<String> columns = new LinkedList<>();\n      if (hasGeneratedId()) {\n         columns.addAll(Arrays.asList(columnsSansIds));\n      }\n      else {\n         columns.addAll(Arrays.asList(columnNames));\n      }\n\n      columns.removeIf(s -> !isInsertableColumn(s));\n      insertableColumns = columns.toArray(new String[0]);\n      return insertableColumns;\n   }",
        "fixed_function": "   public String[] getInsertableColumns()\n   {\n      if (insertableColumns != null) {\n         return insertableColumns;\n      }\n\n      List<String> columns = new LinkedList<>();\n      if (hasGeneratedId()) {\n         columns.addAll(Arrays.asList(columnsSansIds));\n      }\n      else {\n         getDelimitedInsertableColumns(columns);\n      }\n\n      insertableColumns = columns.toArray(new String[0]);\n      return insertableColumns;\n   }",
        "comment": "/**\n    * Get the insertable columns for this object.\n    *\n    * @return the insertable columns. In case of delimited column names the names are surrounded by delimiters.\n    */"
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/Introspected.java",
        "start_loc": 344,
        "end_loc": 361,
        "buggy_function": "   public String[] getUpdatableColumns()\n   {\n      if (updatableColumns != null) {\n         return updatableColumns;\n      }\n\n      List<String> columns = new LinkedList<>();\n      if (hasGeneratedId()) {\n         columns.addAll(Arrays.asList(columnsSansIds));\n      }\n      else {\n         columns.addAll(Arrays.asList(columnNames));\n      }\n\n      columns.removeIf(s -> !isUpdatableColumn(s));\n      updatableColumns = columns.toArray(new String[0]);\n      return updatableColumns;\n   }",
        "fixed_function": "   public String[] getUpdatableColumns()\n   {\n      if (updatableColumns != null) {\n         return updatableColumns;\n      }\n\n      List<String> columns = new LinkedList<>();\n      if (hasGeneratedId()) {\n         columns.addAll(Arrays.asList(columnsSansIds));\n      }\n      else {\n         getDelimitedUpdatableColumns(columns);\n      }\n\n      updatableColumns = columns.toArray(new String[0]);\n      return updatableColumns;\n   }",
        "comment": "/**\n    * Get the updatable columns for this object.\n    *\n    * @return the updatable columns\n    */"
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/Introspected.java",
        "start_loc": 443,
        "end_loc": 469,
        "buggy_function": "   private void readColumnInfo(List<FieldColumnInfo> idFcInfos)\n   {\n      idFieldColumnInfos = new FieldColumnInfo[idFcInfos.size()];\n      idColumnNames = new String[idFcInfos.size()];\n      int i = 0;\n      int j = 0;\n      for (FieldColumnInfo fcInfo : idFcInfos) {\n         idColumnNames[i] = fcInfo.columnName;\n         idFieldColumnInfos[i] = fcInfo;\n         ++i;\n      }\n\n      columnNames = new String[columnToField.size()];\n      columnTableNames = new String[columnNames.length];\n      columnsSansIds = new String[columnNames.length - idColumnNames.length];\n      i = 0;\n      j = 0;\n      for (Entry<String, FieldColumnInfo> entry : columnToField.entrySet()) {\n         columnNames[i] = entry.getKey();\n         columnTableNames[i] = entry.getValue().columnTableName;\n         if (!idFcInfos.contains(entry.getValue())) {\n            columnsSansIds[j] = entry.getKey();\n            ++j;\n         }\n         ++i;\n      }\n   }",
        "fixed_function": "   private void readColumnInfo(List<FieldColumnInfo> idFcInfos)\n   {\n      idFieldColumnInfos = new FieldColumnInfo[idFcInfos.size()];\n      idColumnNames = new String[idFcInfos.size()];\n      int i = 0;\n      int j = 0;\n      for (FieldColumnInfo fcInfo : idFcInfos) {\n         idColumnNames[i] = fcInfo.columnName;\n         idFieldColumnInfos[i] = fcInfo;\n         ++i;\n      }\n\n      columnNames = new String[columnToField.size()];\n      columnTableNames = new String[columnNames.length];\n      columnsSansIds = new String[columnNames.length - idColumnNames.length];\n      i = 0;\n      j = 0;\n      for (Entry<String, FieldColumnInfo> entry : columnToField.entrySet()) {\n         columnNames[i] = entry.getValue().columnName;\n         columnTableNames[i] = entry.getValue().columnTableName;\n         if (!idFcInfos.contains(entry.getValue())) {\n            columnsSansIds[j] = entry.getValue().columnName;\n            ++j;\n         }\n         ++i;\n      }\n   }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/Introspected.java",
        "start_loc": 487,
        "end_loc": 529,
        "buggy_function": "   private void processColumnAnnotation(FieldColumnInfo fcInfo)\n   {\n      Field field = fcInfo.field;\n\n      Column columnAnnotation = field.getAnnotation(Column.class);\n      if (columnAnnotation != null) {\n         String columnName = columnAnnotation.name();\n         fcInfo.columnName = columnName.isEmpty()\n            ? field.getName() // as per documentation, empty name in Column \"defaults to the property or field name\"\n            : columnName.toLowerCase();\n\n         String columnTableName = columnAnnotation.table();\n         if (!columnTableName.isEmpty()) {\n            fcInfo.columnTableName = columnTableName.toLowerCase();\n         }\n\n         fcInfo.insertable = columnAnnotation.insertable();\n         fcInfo.updatable = columnAnnotation.updatable();\n      }\n      else {\n         // If there is no Column annotation, is there a JoinColumn annotation?\n         JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class);\n         if (joinColumnAnnotation != null) {\n            // Is the JoinColumn a self-join?\n            if (field.getType() == clazz) {\n               fcInfo.columnName = joinColumnAnnotation.name().toLowerCase();\n               selfJoinFCInfo = fcInfo;\n            }\n            else {\n               throw new RuntimeException(\"JoinColumn annotations can only be self-referencing: \" + field.getType().getCanonicalName() + \" != \"\n                     + clazz.getCanonicalName());\n            }\n         }\n         else {\n            fcInfo.columnName = field.getName().toLowerCase();\n         }\n      }\n\n      Transient transientAnnotation = field.getAnnotation(Transient.class);\n      if (transientAnnotation == null) {\n         columnToField.put(fcInfo.columnName, fcInfo);\n      }\n   }",
        "fixed_function": "   private void processColumnAnnotation(FieldColumnInfo fcInfo)\n   {\n      Field field = fcInfo.field;\n\n      Column columnAnnotation = field.getAnnotation(Column.class);\n      if (columnAnnotation != null) {\n         String columnName = columnAnnotation.name();\n         fcInfo.columnName = columnName.isEmpty()\n            ? field.getName() // as per documentation, empty name in Column \"defaults to the property or field name\"\n            : toColumnName(columnName);\n\n         String columnTableName = columnAnnotation.table();\n         if (!columnTableName.isEmpty()) {\n            fcInfo.columnTableName = toColumnName(columnTableName);\n         }\n\n         fcInfo.insertable = columnAnnotation.insertable();\n         fcInfo.updatable = columnAnnotation.updatable();\n      }\n      else {\n         // If there is no Column annotation, is there a JoinColumn annotation?\n         JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class);\n         if (joinColumnAnnotation != null) {\n            // Is the JoinColumn a self-join?\n            if (field.getType() == clazz) {\n               fcInfo.columnName = toColumnName(joinColumnAnnotation.name());\n               selfJoinFCInfo = fcInfo;\n            }\n            else {\n               throw new RuntimeException(\"JoinColumn annotations can only be self-referencing: \" + field.getType().getCanonicalName() + \" != \"\n                     + clazz.getCanonicalName());\n            }\n         }\n         else {\n            fcInfo.columnName = field.getName().toLowerCase();\n         }\n      }\n\n      Transient transientAnnotation = field.getAnnotation(Transient.class);\n      if (transientAnnotation == null) {\n         String keyName = !(fcInfo.columnName.startsWith(\"\\\"\") && fcInfo.columnName.endsWith(\"\\\"\")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1);\n         columnToField.put(keyName, fcInfo);\n         delimitedColumnToField.put(fcInfo.columnName, fcInfo);\n      }\n   }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/OrmBase.java",
        "start_loc": 98,
        "end_loc": 122,
        "buggy_function": "   public static <T> String getColumnsCsvExclude(Class<T> clazz, String... excludeColumns)\n   {\n      Set<String> excludes = new HashSet<>(Arrays.asList(excludeColumns));\n\n      Introspected introspected = Introspector.getIntrospected(clazz);\n      StringBuilder sb = new StringBuilder();\n      String[] delimitedColumnNames = introspected.getColumnNames();\n      String[] columnTableNames = introspected.getColumnTableNames();\n      for (int i = 0; i < delimitedColumnNames.length; i++) {\n         String delimitedColumn = delimitedColumnNames[i];\n         if (excludes.contains(delimitedColumn)) {\n            continue;\n         }\n\n         String columnTableName = columnTableNames[i];\n\n         if (columnTableName != null) {\n            sb.append(columnTableName).append('.');\n         }\n\n         sb.append(delimitedColumn).append(',');\n      }\n\n      return sb.deleteCharAt(sb.length() - 1).toString();\n   }",
        "fixed_function": "   public static <T> String getColumnsCsvExclude(Class<T> clazz, String... excludeColumns)\n   {\n      Set<String> excludes = new HashSet<>(Arrays.asList(excludeColumns));\n\n      Introspected introspected = Introspector.getIntrospected(clazz);\n      StringBuilder sb = new StringBuilder();\n      String[] delimitedColumnNames = introspected.getColumnNames();\n      String[] columnTableNames = introspected.getColumnTableNames();\n      for (int i = 0; i < delimitedColumnNames.length; i++) {\n         String delimitedColumn = delimitedColumnNames[i];\n         boolean isDelimited = delimitedColumn.startsWith(\"\\\"\") && delimitedColumn.endsWith(\"\\\"\");\n         String column = !isDelimited  ? delimitedColumn\n                                       : delimitedColumn.substring(1, delimitedColumn.length() - 1);\n         if (excludes.contains(column)) {\n            continue;\n         }\n\n         String columnTableName = columnTableNames[i];\n\n         if (columnTableName != null) {\n            sb.append(columnTableName).append('.');\n         }\n\n         sb.append(delimitedColumn).append(',');\n      }\n\n      return sb.deleteCharAt(sb.length() - 1).toString();\n   }",
        "comment": "/**\n    *\n    * @param excludeColumns In case of delimited column names provide name without delimiters.\n    * @return comma separated column names. In case of delimited column names the column names are surrounded by delimiters.\n    */"
      },
      {
        "path": "src/main/java/com/zaxxer/sansorm/internal/OrmWriter.java",
        "start_loc": 161,
        "end_loc": 175,
        "buggy_function": "   public static <T> int deleteObjectById(Connection connection, Class<T> clazz, Object... args) throws SQLException\n   {\n      Introspected introspected = Introspector.getIntrospected(clazz);\n\n      StringBuilder sql = new StringBuilder();\n      sql.append(\"DELETE FROM \").append(introspected.getTableName()).append(\" WHERE \");\n\n      String[] idColumnNames = introspected.getIdColumnNames();\n      for (String idColumn : idColumnNames) {\n         sql.append(idColumn).append(\"=? AND \");\n      }\n      sql.setLength(sql.length() - 5);\n\n      return executeUpdate(connection, sql.toString(), args);\n   }",
        "fixed_function": "   public static <T> int deleteObjectById(Connection connection, Class<T> clazz, Object... args) throws SQLException\n   {\n      Introspected introspected = Introspector.getIntrospected(clazz);\n\n      StringBuilder sql = new StringBuilder();\n      sql.append(\"DELETE FROM \").append(introspected.getTableName()).append(\" WHERE \");\n\n      String[] idColumnNames = introspected.getIdColumnNames();\n      if (idColumnNames.length == 0) {\n         throw new RuntimeException(\"No id columns provided in: \" + clazz.getName());\n      }\n      for (String idColumn : idColumnNames) {\n         sql.append(idColumn).append(\"=? AND \");\n      }\n      sql.setLength(sql.length() - 5);\n\n      return executeUpdate(connection, sql.toString(), args);\n   }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumnsGeneratedId": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getInsertableColumnsGeneratedId",
        "src": "@Test\n   public void getInsertableColumnsGeneratedId() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id @GeneratedValue @Column\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getInsertableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumnsGeneratedId --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumnsWithTableName": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getInsertableColumnsWithTableName",
        "src": "@Test\n   public void getInsertableColumnsWithTableName() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\", table = \"DEFAULT_TABLE_NAME\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\", table=\"\\\"DELIMITED_TABLE_NAME\\\"\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getInsertableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumnsWithTableName --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::joinColumnsNameElementInQuotes": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "joinColumnsNameElementInQuotes",
        "src": "@Test\n   public void joinColumnsNameElementInQuotes() {\n      class TestClass {\n         @JoinColumn(name = \"\\\"JOIN_COLUMN_NAME\\\"\")\n         TestClass joinColumnName;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      String colName = introspected.getColumnNameForProperty(\"joinColumnName\");\n      assertEquals(\"\\\"JOIN_COLUMN_NAME\\\"\", colName);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::joinColumnsNameElementInQuotes --> junit.framework.AssertionFailedError: expected:<[JOIN_COLUMN_NAME]> but was:<[join_column_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[JOIN_COLUMN_NAME]> but was:<[join_column_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumns": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getInsertableColumns",
        "src": "@Test\n   public void getInsertableColumns() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getInsertableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumns --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::deleteObjectNoIdProvided": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "deleteObjectNoIdProvided",
        "src": "@Test\n   public void deleteObjectNoIdProvided() throws SQLException {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName = delimitedFieldValue;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase = defaultCaseValue;\n      }\n      final String[] fetchedSql = new String[1];\n      DummyConnection con = new DummyConnection() {\n         @Override\n         public PreparedStatement prepareStatement(String sql) {\n            fetchedSql[0] = sql;\n            return new DummyStatement() {\n               @Override\n               public ParameterMetaData getParameterMetaData() {\n                  return new DummyParameterMetaData() {\n                     @Override\n                     public int getParameterCount() {\n                        return CaseSensitiveDatabasesTest.this.getParameterCount(fetchedSql[0]);\n                     }\n                     @Override\n                     public int getParameterType(int param) {\n                        return Types.VARCHAR;\n                     }\n                  };\n               }\n            };\n         }\n      };\n      thrown.expectMessage(\"No id columns provided\");\n      OrmWriter.deleteObject(con, new TestClass());\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::deleteObjectNoIdProvided --> junit.framework.AssertionFailedError: Expected test to throw exception with message a string containing No id columns provided",
        "clean_error_msg": "junit.framework.AssertionFailedError: Expected test to throw exception with message a string containing No id columns provided"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::columnsTableNameElementInQuotes": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "columnsTableNameElementInQuotes",
        "src": "@Test\n   public void columnsTableNameElementInQuotes() {\n      class TestClass {\n         @Column(table = \"\\\"TABLE_NAME\\\"\")\n         String columnName;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      String[] columnTableNames = introspected.getColumnTableNames();\n      assertEquals(\"\\\"TABLE_NAME\\\"\", columnTableNames[0]);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::columnsTableNameElementInQuotes --> junit.framework.AssertionFailedError: expected:<[TABLE_NAME]> but was:<[table_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[TABLE_NAME]> but was:<[table_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::statementToObject": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "statementToObject",
        "src": "@Test\n   public void statementToObject() throws SQLException {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      String idValue = \"id value\";\n\n      final String[] fetchedSql = new String[1];\n\n      DummyConnection con = new DummyConnection() {\n         @Override\n         public PreparedStatement prepareStatement(String sql) {\n            fetchedSql[0] = sql;\n            return new DummyStatement() {\n               @Override\n               public ParameterMetaData getParameterMetaData() {\n                  return new DummyParameterMetaData() {\n                     @Override\n                     public int getParameterCount() {\n                        return CaseSensitiveDatabasesTest.this.getParameterCount(fetchedSql[0]);\n                     }\n                     @Override\n                     public int getParameterType(int param) {\n                        return Types.VARCHAR;\n                     }\n                  };\n               }\n               @Override\n               public ResultSet executeQuery() {\n                  return new DummyResultSet() {\n                     @Override\n                     public boolean next() {\n                        return true;\n                     }\n\n                     @Override\n                     public ResultSetMetaData getMetaData() {\n                        return new DummyResultSetMetaData() {\n                           @Override\n                           public int getColumnCount() {\n                              return 3;\n                           }\n\n                           @Override\n                           public String getColumnName(int column) {\n                              return   column == 1 ? \"DELIMITED_FIELD_NAME\" :\n                                       column == 2 ? \"default_case\" :\n                                       column == 3 ? \"id\"\n                                                   : null;\n                           }\n                        };\n                     }\n\n                     @Override\n                     public Object getObject(int columnIndex) {\n                        return   columnIndex == 1 ? delimitedFieldValue :\n                                 columnIndex == 2 ? defaultCaseValue :\n                                 columnIndex == 3 ? idValue\n                                                  : null;\n                     }\n                  };\n               }\n            };\n         }\n      };\n      PreparedStatement pstmnt = con.prepareStatement(\"select * from TEST_CLASS where id = ?\");\n      CaseSensitiveDatabasesClass obj = OrmElf.statementToObject(pstmnt, CaseSensitiveDatabasesClass.class, \"xyz\");\n      assertEquals(delimitedFieldValue, obj.getDelimitedFieldName());\n      assertEquals(defaultCaseValue, obj.getDefaultCase());\n      assertEquals(idValue, obj.getId());\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::statementToObject --> java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesClass",
        "clean_error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesClass"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsvExclude": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getColumnsCsvExclude",
        "src": "@Test\n   public void getColumnsCsvExclude() {\n      String cols = OrmBase.getColumnsCsvExclude(CaseSensitiveDatabasesClass.class, \"DELIMITED_FIELD_NAME\");\n      assertEquals(\"default_case,id\", cols);\n      cols = OrmBase.getColumnsCsvExclude(CaseSensitiveDatabasesClass.class, \"default_case\");\n      assertEquals(\"\\\"DELIMITED_FIELD_NAME\\\",id\", cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsvExclude --> junit.framework.AssertionFailedError: expected:<[]default_case,id> but was:<[delimited_field_name,]default_case,id>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[]default_case,id> but was:<[delimited_field_name,]default_case,id>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::isInsertableColumn": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "isInsertableColumn",
        "src": "@Test\n   public void isInsertableColumn() {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName = delimitedFieldValue;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase = defaultCaseValue;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      assertTrue(introspected.isInsertableColumn(\"default_case\"));\n      assertTrue(introspected.isInsertableColumn(\"DELIMITED_FIELD_NAME\"));\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::isInsertableColumn --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::updateObject": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "updateObject",
        "src": "@Test\n   public void updateObject() throws SQLException {\n      String upperCaseValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName = upperCaseValue;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase = defaultCaseValue;\n      }\n      final String[] fetchedSql = new String[1];\n      DummyConnection con = new DummyConnection() {\n         @Override\n         public PreparedStatement prepareStatement(String sql) {\n            fetchedSql[0] = sql;\n            return new DummyStatement() {\n               @Override\n               public ParameterMetaData getParameterMetaData() {\n                  return new DummyParameterMetaData() {\n                     @Override\n                     public int getParameterCount() {\n                        return CaseSensitiveDatabasesTest.this.getParameterCount(fetchedSql[0]);\n                     }\n                     @Override\n                     public int getParameterType(int param) {\n                        return Types.VARCHAR;\n                     }\n                  };\n               }\n            };\n         }\n      };\n      TestClass obj = OrmWriter.updateObject(con, new TestClass());\n      assertEquals(\"UPDATE TEST_CLASS SET default_case=?,\\\"DELIMITED_FIELD_NAME\\\"=?\", fetchedSql[0]);\n      assertEquals(defaultCaseValue, obj.defaultCase);\n      assertEquals(upperCaseValue, obj.delimitedFieldName);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::updateObject --> junit.framework.AssertionFailedError: expected:<...DATE TEST_CLASS SET [default_case=?,DELIMITED_FIELD_NAME]=?> but was:<...DATE TEST_CLASS SET [delimited_field_name=?,default_case]=?>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...DATE TEST_CLASS SET [default_case=?,DELIMITED_FIELD_NAME]=?> but was:<...DATE TEST_CLASS SET [delimited_field_name=?,default_case]=?>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getIdColumnNames": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getIdColumnNames",
        "src": "@Test\n   public void getIdColumnNames() {\n      class TestClass {\n         @Id\n         @Column(name = \"\\\"ID\\\"\")\n         String id;\n         @Id\n         String Id2;\n         @Id @Column\n         String Id3;\n         @Id @Column(name = \"Id4\")\n         String Id4;\n         @Id @Column(name = \"\")\n         String Id5;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      String[] idColumnNames = introspected.getIdColumnNames();\n      assertTrue(idColumnNames.length == 5);\n      assertEquals(\"\\\"ID\\\"\", idColumnNames[0]);\n      assertEquals(\"id2\", idColumnNames[1]);\n      assertEquals(\"Id3\", idColumnNames[2]);\n      assertEquals(\"id4\", idColumnNames[3]);\n      assertEquals(\"Id5\", idColumnNames[4]);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getIdColumnNames --> junit.framework.AssertionFailedError: expected:<[ID]> but was:<[id]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[ID]> but was:<[id]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::isUpdatableColumn": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "isUpdatableColumn",
        "src": "@Test\n   public void isUpdatableColumn() {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName = delimitedFieldValue;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase = defaultCaseValue;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      assertTrue(introspected.isUpdatableColumn(\"default_case\"));\n      assertTrue(introspected.isUpdatableColumn(\"DELIMITED_FIELD_NAME\"));\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::isUpdatableColumn --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumns2": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getInsertableColumns2",
        "src": "@Test\n   public void getInsertableColumns2() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id @Column\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getInsertableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\", \"id\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getInsertableColumns2 --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::insertObject": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "insertObject",
        "src": "@Test\n   public void insertObject() throws SQLException {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName = delimitedFieldValue;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase = defaultCaseValue;\n      }\n      final String[] fetchedSql = new String[1];\n      DummyConnection con = new DummyConnection() {\n         @Override\n         public PreparedStatement prepareStatement(String sql) {\n            fetchedSql[0] = sql;\n            return new DummyStatement() {\n               @Override\n               public ParameterMetaData getParameterMetaData() {\n                  return new DummyParameterMetaData() {\n                     @Override\n                     public int getParameterCount() {\n                        return CaseSensitiveDatabasesTest.this.getParameterCount(fetchedSql[0]);\n                     }\n                     @Override\n                     public int getParameterType(int param) {\n                        return Types.VARCHAR;\n                     }\n                  };\n               }\n            };\n         }\n      };\n      TestClass obj = OrmWriter.insertObject(con, new TestClass());\n      assertEquals(\"INSERT INTO TEST_CLASS(default_case,\\\"DELIMITED_FIELD_NAME\\\") VALUES (?,?)\", fetchedSql[0]);\n      assertEquals(defaultCaseValue, obj.defaultCase);\n      assertEquals(delimitedFieldValue, obj.delimitedFieldName);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::insertObject --> junit.framework.AssertionFailedError: expected:<...ERT INTO TEST_CLASS([default_case,DELIMITED_FIELD_NAME]) VALUES (?,?)> but was:<...ERT INTO TEST_CLASS([delimited_field_name,default_case]) VALUES (?,?)>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...ERT INTO TEST_CLASS([default_case,DELIMITED_FIELD_NAME]) VALUES (?,?)> but was:<...ERT INTO TEST_CLASS([delimited_field_name,default_case]) VALUES (?,?)>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::columnsNameElementInQuotes": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "columnsNameElementInQuotes",
        "src": "@Test\n   public void columnsNameElementInQuotes() {\n      class TestClass {\n         @Column(name = \"\\\"COLUMN_NAME\\\"\")\n         String columnName;\n      }\n      Introspected introspected = new Introspected(TestClass.class);\n      String colName = introspected.getColumnNameForProperty(\"columnName\");\n      assertEquals(\"\\\"COLUMN_NAME\\\"\", colName);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::columnsNameElementInQuotes --> junit.framework.AssertionFailedError: expected:<[COLUMN_NAME]> but was:<[column_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[COLUMN_NAME]> but was:<[column_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnNameForProperty": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getColumnNameForProperty",
        "src": "@Test\n   public void getColumnNameForProperty() {\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      assertEquals(\"\\\"DELIMITED_FIELD_NAME\\\"\", introspected.getColumnNameForProperty(\"delimitedFieldName\"));\n      assertEquals(\"default_case\", introspected.getColumnNameForProperty(\"defaultCase\"));\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnNameForProperty --> junit.framework.AssertionFailedError: expected:<[DELIMITED_FIELD_NAME]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[DELIMITED_FIELD_NAME]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getUpdatableColumns": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getUpdatableColumns",
        "src": "@Test\n   public void getUpdatableColumns() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id @Column\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getUpdatableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\", \"id\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getUpdatableColumns --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getUpdatableColumnsGenratedId": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getUpdatableColumnsGenratedId",
        "src": "@Test\n   public void getUpdatableColumnsGenratedId() {\n      @Table(name = \"TEST_CLASS\")\n      class TestClass {\n         @Id @GeneratedValue @Column\n         String id;\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      Introspected introspected = Introspector.getIntrospected(TestClass.class);\n      String[] cols = introspected.getUpdatableColumns();\n      assertArrayEquals(new String[]{\"default_case\", \"\\\"DELIMITED_FIELD_NAME\\\"\"}, cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getUpdatableColumnsGenratedId --> junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<[default_case]> but was:<[delimited_field_name]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::objectById": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "objectById",
        "src": "@Test\n   public void objectById() throws SQLException {\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default_case value\";\n      String idValue = \"id value\";\n      final String[] fetchedSql = new String[1];\n      DummyConnection con = new DummyConnection() {\n         @Override\n         public PreparedStatement prepareStatement(String sql) {\n            fetchedSql[0] = sql;\n            return new DummyStatement() {\n               @Override\n               public ParameterMetaData getParameterMetaData() {\n                  return new DummyParameterMetaData() {\n                     @Override\n                     public int getParameterCount() {\n                        return CaseSensitiveDatabasesTest.this.getParameterCount(fetchedSql[0]);\n                     }\n                     @Override\n                     public int getParameterType(int param) {\n                        return Types.VARCHAR;\n                     }\n                  };\n               }\n               @Override\n               public ResultSet executeQuery() {\n                  return new DummyResultSet() {\n                     @Override\n                     public boolean next() {\n                        return true;\n                     }\n\n                     @Override\n                     public ResultSetMetaData getMetaData() {\n                        return new DummyResultSetMetaData() {\n                           @Override\n                           public int getColumnCount() {\n                              return 3;\n                           }\n\n                           @Override\n                           public String getColumnName(int column) {\n                              return   column == 1 ? \"DELIMITED_FIELD_NAME\" :\n                                       column == 2 ? \"default_case\" :\n                                       column == 3 ? \"id\"\n                                                   : null;\n                           }\n                        };\n                     }\n\n                     @Override\n                     public Object getObject(int columnIndex) {\n                        return   columnIndex == 1 ? delimitedFieldValue :\n                                 columnIndex == 2 ? defaultCaseValue :\n                                 columnIndex == 3 ? idValue\n                                                  : null;\n                     }\n                  };\n               }\n            };\n         }\n      };\n      CaseSensitiveDatabasesClass obj = OrmReader.objectById(con, CaseSensitiveDatabasesClass.class, \"xyz\");\n      assertEquals(\"SELECT TEST_CLASS.default_case,TEST_CLASS.\\\"DELIMITED_FIELD_NAME\\\",TEST_CLASS.id FROM TEST_CLASS TEST_CLASS WHERE  id=?\", fetchedSql[0]);\n      assertEquals(idValue, obj.getId());\n      assertEquals(defaultCaseValue, obj.getDefaultCase());\n      assertEquals(delimitedFieldValue, obj.getDelimitedFieldName());\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::objectById --> java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesClass",
        "clean_error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesClass"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsvExcludeWithTableName": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getColumnsCsvExcludeWithTableName",
        "src": "@Test\n   public void getColumnsCsvExcludeWithTableName() {\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\", table = \"DEFAULT_TABLE_NAME\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\", table = \"\\\"DELIMITED_TABLE_NAME\\\"\")\n         String defaultCase;\n         @Column\n         String excluded;\n      }\n      String cols = OrmBase.getColumnsCsvExclude(TestClass.class, \"excluded\");\n      assertEquals(\"\\\"DELIMITED_TABLE_NAME\\\".default_case,default_table_name.\\\"DELIMITED_FIELD_NAME\\\"\", cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsvExcludeWithTableName --> junit.framework.AssertionFailedError: expected:<[DELIMITED_TABLE_NAME.default_case,default_table_name.DELIMITED_FIELD_NAME]> but was:<[default_table_name.delimited_field_name,delimited_table_name.default_case]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[DELIMITED_TABLE_NAME.default_case,default_table_name.DELIMITED_FIELD_NAME]> but was:<[default_table_name.delimited_field_name,delimited_table_name.default_case]>"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::insertObjectH2": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "insertObjectH2",
        "src": "@Test\n   public void insertObjectH2() {\n\n      SansOrm.initializeTxNone(TestUtils.makeH2DataSource());\n      SqlClosureElf.executeUpdate(\"CREATE TABLE \\\"test_class\\\" (\"\n         + \"id INTEGER NOT NULL IDENTITY PRIMARY KEY, \"\n         + \"\\\"delimited_field_name\\\" VARCHAR(128), \"\n         + \"DEFAULT_CASE VARCHAR(128) \"\n         + \")\");\n\n      String delimitedFieldValue = \"delimited field value\";\n      String defaultCaseValue = \"default case value\";\n      InsertObjectH2 obj = SqlClosureElf.insertObject(new InsertObjectH2());\n      assertEquals(1, obj.id);\n      obj = SqlClosureElf.getObjectById(InsertObjectH2.class, obj.id);\n      assertNotNull(obj);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::insertObjectH2 --> java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest.InsertObjectH2",
        "clean_error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: Cannot find field mapped to column delimited_field_name on type com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest.InsertObjectH2"
      },
      "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsv": {
        "path": "com/zaxxer/sansorm/internal/CaseSensitiveDatabasesTest.java",
        "function_name": "getColumnsCsv",
        "src": "@Test\n   public void getColumnsCsv() {\n      class TestClass {\n         @Column(name = \"\\\"DELIMITED_FIELD_NAME\\\"\")\n         String delimitedFieldName;\n         @Column(name = \"DEFAULT_CASE\")\n         String defaultCase;\n      }\n      String cols = OrmReader.getColumnsCsv(TestClass.class);\n      assertEquals(\"default_case,\\\"DELIMITED_FIELD_NAME\\\"\", cols);\n   }",
        "error_msg": "com.zaxxer.sansorm.internal.CaseSensitiveDatabasesTest::getColumnsCsv --> junit.framework.AssertionFailedError: expected:<[default_case,DELIMITED_FIELD_NAME]> but was:<[delimited_field_name,default_case]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<[default_case,DELIMITED_FIELD_NAME]> but was:<[delimited_field_name,default_case]>"
      }
    }
  },
  "Transmittable_thread_local-1": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/com/alibaba/mtc/MtContextCallable.java",
        "start_loc": 81,
        "end_loc": 90,
        "buggy_function": "    public static <T> MtContextCallable<T> get(Callable<T> callable, boolean releaseMtContextAfterCall) {\n        if (null == callable) {\n            return null;\n        }\n\n        if (callable instanceof MtContextCallable) { // avoid redundant decoration, and ensure idempotency\n            return (MtContextCallable<T>) callable;\n        }\n        return new MtContextCallable<T>(callable, releaseMtContextAfterCall);\n    }",
        "fixed_function": "    public static <T> MtContextCallable<T> get(Callable<T> callable, boolean releaseMtContextAfterCall) {\n        if (null == callable) {\n            return null;\n        }\n\n        if (callable instanceof MtContextCallable) { // avoid redundant decoration, and ensure idempotency\n            throw new IllegalStateException(\"Already MtContextCallable!\");\n        }\n        return new MtContextCallable<T>(callable, releaseMtContextAfterCall);\n    }",
        "comment": "/**\n     * Factory method, wrapper input {@link Callable} to {@link MtContextCallable}.\n     * <p/>\n     * This method is idempotent.\n     *\n     * @param callable                  input {@link Callable}\n     * @param releaseMtContextAfterCall release MtContext after run, avoid memory leak even if {@link MtContextRunnable} is referred.\n     * @return Wrapped {@link Callable}\n     */"
      },
      {
        "path": "src/main/java/com/alibaba/mtc/MtContextRunnable.java",
        "start_loc": 77,
        "end_loc": 86,
        "buggy_function": "    public static MtContextRunnable get(Runnable runnable, boolean releaseMtContextAfterRun) {\n        if (null == runnable) {\n            return null;\n        }\n\n        if (runnable instanceof MtContextRunnable) { // avoid redundant decoration, and ensure idempotency\n            return (MtContextRunnable) runnable;\n        }\n        return new MtContextRunnable(runnable, releaseMtContextAfterRun);\n    }",
        "fixed_function": "    public static MtContextRunnable get(Runnable runnable, boolean releaseMtContextAfterRun) {\n        if (null == runnable) {\n            return null;\n        }\n\n        if (runnable instanceof MtContextRunnable) { // avoid redundant decoration, and ensure idempotency\n            throw new IllegalStateException(\"Already MtContextRunnable!\");\n        }\n        return new MtContextRunnable(runnable, releaseMtContextAfterRun);\n    }",
        "comment": "/**\n     * Factory method, wrapper input {@link Runnable} to {@link MtContextRunnable}.\n     * <p/>\n     * This method is idempotent.\n     *\n     * @param runnable                 input {@link Runnable}\n     * @param releaseMtContextAfterRun release MtContext after run, avoid memory leak even if {@link MtContextRunnable} is referred.\n     * @return Wrapped {@link Runnable}\n     */"
      },
      {
        "path": "src/main/java/com/alibaba/mtc/MtContextTimerTask.java",
        "start_loc": 64,
        "end_loc": 73,
        "buggy_function": "    public static MtContextTimerTask get(TimerTask timerTask) {\n        if (null == timerTask) {\n            return null;\n        }\n\n        if (timerTask instanceof MtContextTimerTask) { // avoid redundant decoration, and ensure idempotency\n            return (MtContextTimerTask) timerTask;\n        }\n        return new MtContextTimerTask(timerTask);\n    }",
        "fixed_function": "    public static MtContextTimerTask get(TimerTask timerTask) {\n        if (null == timerTask) {\n            return null;\n        }\n\n        if (timerTask instanceof MtContextTimerTask) { // avoid redundant decoration, and ensure idempotency\n            throw new IllegalStateException(\"Already MtContextTimerTask!\");\n        }\n        return new MtContextTimerTask(timerTask);\n    }",
        "comment": "/**\n     * Factory method, wrapper input {@link Runnable} to {@link MtContextTimerTask}.\n     * <p/>\n     * This method is idempotent.\n     *\n     * @param timerTask input {@link TimerTask}\n     * @return Wrapped {@link TimerTask}\n     */"
      },
      {
        "path": "src/main/java/com/alibaba/mtc/threadpool/agent/MtContextTransformer.java",
        "start_loc": 45,
        "end_loc": 78,
        "buggy_function": "    @Override\n    public byte[] transform(ClassLoader loader, String classFile, Class<?> classBeingRedefined,\n                            ProtectionDomain protectionDomain, byte[] classFileBuffer) throws IllegalClassFormatException {\n        try {\n            final String className = toClassName(classFile);\n            if (THREAD_POOL_CLASS_FILE.equals(classFile) || SCHEDULER_CLASS_FILE.equals(classFile)) {\n                logger.info(\"Transforming class \" + className);\n                CtClass clazz = getCtClass(classFileBuffer, loader);\n\n                for (CtMethod method : clazz.getDeclaredMethods()) {\n                    updateMethod(method);\n                }\n                return clazz.toBytecode();\n            } else if (TIMER_TASK_CLASS_FILE.equals(classFile)) {\n                CtClass clazz = getCtClass(classFileBuffer, loader);\n                while (true) {\n                    String name = clazz.getSuperclass().getName();\n                    if (Object.class.getName().equals(name)) {\n                        break;\n                    }\n                    if (TIMER_TASK_CLASS_FILE.equals(name)) {\n                        logger.info(\"Transforming class \" + className);\n                        // FIXME add code here\n                        return null;\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            String msg = \"Fail to transform class \" + classFile + \", cause: \" + t.getMessage();\n            logger.severe(msg);\n            throw new IllegalStateException(msg, t);\n        }\n        return null;\n    }",
        "fixed_function": "    @Override\n    public byte[] transform(ClassLoader loader, String classFile, Class<?> classBeingRedefined,\n                            ProtectionDomain protectionDomain, byte[] classFileBuffer) throws IllegalClassFormatException {\n        try {\n            final String className = toClassName(classFile);\n            if (THREAD_POOL_CLASS_FILE.equals(classFile) || SCHEDULER_CLASS_FILE.equals(classFile)) {\n                logger.info(\"Transforming class \" + className);\n                CtClass clazz = getCtClass(classFileBuffer, loader);\n\n                for (CtMethod method : clazz.getDeclaredMethods()) {\n                    updateMethod(clazz, method);\n                }\n                return clazz.toBytecode();\n            } else if (TIMER_TASK_CLASS_FILE.equals(classFile)) {\n                CtClass clazz = getCtClass(classFileBuffer, loader);\n                while (true) {\n                    String name = clazz.getSuperclass().getName();\n                    if (Object.class.getName().equals(name)) {\n                        break;\n                    }\n                    if (TIMER_TASK_CLASS_FILE.equals(name)) {\n                        logger.info(\"Transforming class \" + className);\n                        // FIXME add code here\n                        return null;\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            String msg = \"Fail to transform class \" + classFile + \", cause: \" + t.getMessage();\n            logger.severe(msg);\n            throw new IllegalStateException(msg, t);\n        }\n        return null;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/alibaba/mtc/threadpool/agent/MtContextTransformer.java",
        "start_loc": 101,
        "end_loc": 127,
        "buggy_function": "    static void updateMethod(CtMethod method) throws NotFoundException, CannotCompileException {\n        if (!updateMethodNames.contains(method.getName())) {\n            return;\n        }\n        final int modifiers = method.getModifiers();\n        if (!Modifier.isPublic(modifiers) || Modifier.isStatic(modifiers)) {\n            return;\n        }\n\n        CtClass[] parameterTypes = method.getParameterTypes();\n        StringBuilder insertCode = new StringBuilder();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            CtClass paraType = parameterTypes[i];\n            if (RUNNABLE_CLASS_NAME.equals(paraType.getName())) {\n                String code = String.format(\"$%d = %s.get($%d);\", i + 1, MT_CONTEXT_RUNNABLE_CLASS_NAME, i + 1);\n                logger.info(\"insert code before method \" + method + \" of class \" + method.getDeclaringClass().getName() + \": \" + code);\n                insertCode.append(code);\n            } else if (CALLABLE_CLASS_NAME.equals(paraType.getName())) {\n                String code = String.format(\"$%d = %s.get($%d);\", i + 1, MT_CONTEXT_CALLABLE_CLASS_NAME, i + 1);\n                logger.info(\"insert code before method \" + method + \" of class \" + method.getDeclaringClass().getName() + \": \" + code);\n                insertCode.append(code);\n            }\n        }\n        if (insertCode.length() > 0) {\n            method.insertBefore(insertCode.toString());\n        }\n    }",
        "fixed_function": "    static void updateMethod(CtClass clazz, CtMethod method) throws NotFoundException, CannotCompileException {\n        if (!updateMethodNames.contains(method.getName())) {\n            return;\n        }\n        if (method.getDeclaringClass() != clazz) {\n            return;\n        }\n        final int modifiers = method.getModifiers();\n        if (!Modifier.isPublic(modifiers) || Modifier.isStatic(modifiers)) {\n            return;\n        }\n\n        CtClass[] parameterTypes = method.getParameterTypes();\n        StringBuilder insertCode = new StringBuilder();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            CtClass paraType = parameterTypes[i];\n            if (RUNNABLE_CLASS_NAME.equals(paraType.getName())) {\n                String code = String.format(\"$%d = %s.get($%d);\", i + 1, MT_CONTEXT_RUNNABLE_CLASS_NAME, i + 1);\n                logger.info(\"insert code before method \" + method + \" of class \" + method.getDeclaringClass().getName() + \": \" + code);\n                insertCode.append(code);\n            } else if (CALLABLE_CLASS_NAME.equals(paraType.getName())) {\n                String code = String.format(\"$%d = %s.get($%d);\", i + 1, MT_CONTEXT_CALLABLE_CLASS_NAME, i + 1);\n                logger.info(\"insert code before method \" + method + \" of class \" + method.getDeclaringClass().getName() + \": \" + code);\n                insertCode.append(code);\n            }\n        }\n        if (insertCode.length() > 0) {\n            method.insertBefore(insertCode.toString());\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.alibaba.mtc.MtContextCallableTest::test_get_idempotent": {
        "path": "com/alibaba/mtc/MtContextCallableTest.java",
        "function_name": "test_get_idempotent",
        "src": "@Test\n    public void test_get_idempotent() throws Exception {\n        MtContextCallable<String> call = MtContextCallable.get(new Call(\"1\", null));\n        try {\n            MtContextCallable.get(call);\n            fail();\n        } catch (IllegalStateException e) {\n            assertThat(e.getMessage(), containsString(\"Already MtContextCallable\"));\n        }\n    }",
        "error_msg": "com.alibaba.mtc.MtContextCallableTest::test_get_idempotent --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "com.alibaba.mtc.MtContextRunnableTest::test_idempotent": {
        "path": "com/alibaba/mtc/MtContextRunnableTest.java",
        "function_name": "test_idempotent",
        "src": "@Test\n    public void test_idempotent() throws Exception {\n        MtContextRunnable task = MtContextRunnable.get(new Task(\"1\", null));\n        try {\n            MtContextRunnable.get(task);\n            fail();\n        } catch (IllegalStateException e) {\n            assertThat(e.getMessage(), containsString(\"Already MtContextRunnable\"));\n        }\n    }",
        "error_msg": "com.alibaba.mtc.MtContextRunnableTest::test_idempotent --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Xades4j-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/xades4j/production/SignerBES.java",
        "start_loc": 89,
        "end_loc": 122,
        "buggy_function": "    @Inject\n    protected SignerBES(\n            KeyingDataProvider keyingProvider,\n            AlgorithmsProviderEx algorithmsProvider,\n            BasicSignatureOptions basicSignatureOptions,\n            SignedDataObjectsProcessor dataObjectDescsProcessor,\n            SignaturePropertiesProvider signaturePropsProvider,\n            DataObjectPropertiesProvider dataObjPropsProvider,\n            PropertiesDataObjectsGenerator propsDataObjectsGenerator,\n            SignedPropertiesMarshaller signedPropsMarshaller,\n            UnsignedPropertiesMarshaller unsignedPropsMarshaller,\n            AlgorithmsParametersMarshallingProvider algorithmsParametersMarshaller,\n            X500NameStyleProvider x500NameStyleProvider)\n    {\n        if (ObjectUtils.anyNull(\n                keyingProvider, algorithmsProvider, basicSignatureOptions,\n                signaturePropsProvider, dataObjPropsProvider, propsDataObjectsGenerator,\n                signedPropsMarshaller, unsignedPropsMarshaller, algorithmsParametersMarshaller,\n                x500NameStyleProvider))\n        {\n            throw new NullPointerException(\"One or more arguments are null\");\n        }\n\n        this.keyingProvider = keyingProvider;\n        this.algorithmsProvider = algorithmsProvider;\n        this.propsDataObjectsGenerator = propsDataObjectsGenerator;\n        this.signedPropsMarshaller = signedPropsMarshaller;\n        this.unsignedPropsMarshaller = unsignedPropsMarshaller;\n        this.algorithmsParametersMarshaller = algorithmsParametersMarshaller;\n        this.x500NameStyleProvider = x500NameStyleProvider;\n        this.dataObjectDescsProcessor = dataObjectDescsProcessor;\n        this.keyInfoBuilder = new KeyInfoBuilder(basicSignatureOptions, algorithmsProvider, algorithmsParametersMarshaller, x500NameStyleProvider);\n        this.qualifPropsProcessor = new QualifyingPropertiesProcessor(signaturePropsProvider, dataObjPropsProvider);\n    }",
        "fixed_function": "    @Inject\n    protected SignerBES(\n            KeyingDataProvider keyingProvider,\n            AlgorithmsProviderEx algorithmsProvider,\n            BasicSignatureOptions basicSignatureOptions,\n            SignedDataObjectsProcessor dataObjectDescsProcessor,\n            SignaturePropertiesProvider signaturePropsProvider,\n            DataObjectPropertiesProvider dataObjPropsProvider,\n            PropertiesDataObjectsGenerator propsDataObjectsGenerator,\n            SignedPropertiesMarshaller signedPropsMarshaller,\n            UnsignedPropertiesMarshaller unsignedPropsMarshaller,\n            AlgorithmsParametersMarshallingProvider algorithmsParametersMarshaller,\n            X500NameStyleProvider x500NameStyleProvider)\n    {\n        if (ObjectUtils.anyNull(\n                keyingProvider, algorithmsProvider, basicSignatureOptions,\n                signaturePropsProvider, dataObjPropsProvider, propsDataObjectsGenerator,\n                signedPropsMarshaller, unsignedPropsMarshaller, algorithmsParametersMarshaller,\n                x500NameStyleProvider))\n        {\n            throw new NullPointerException(\"One or more arguments are null\");\n        }\n\n        this.keyingProvider = keyingProvider;\n        this.algorithmsProvider = algorithmsProvider;\n        this.propsDataObjectsGenerator = propsDataObjectsGenerator;\n        this.signedPropsMarshaller = signedPropsMarshaller;\n        this.unsignedPropsMarshaller = unsignedPropsMarshaller;\n        this.algorithmsParametersMarshaller = algorithmsParametersMarshaller;\n        this.dataObjectDescsProcessor = dataObjectDescsProcessor;\n        this.keyInfoBuilder = new KeyInfoBuilder(basicSignatureOptions, algorithmsProvider, algorithmsParametersMarshaller, x500NameStyleProvider);\n        this.qualifPropsProcessor = new QualifyingPropertiesProcessor(signaturePropsProvider, dataObjPropsProvider);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/xades4j/verification/XadesVerifierImpl.java",
        "start_loc": 115,
        "end_loc": 233,
        "buggy_function": "    @Override\n    public XAdESVerificationResult verify(Element signatureElem, SignatureSpecificVerificationOptions verificationOptions) throws XAdES4jException\n    {\n        if (null == signatureElem)\n        {\n            throw new NullPointerException(\"Signature node not specified\");\n        }\n\n        if (null == verificationOptions)\n        {\n            verificationOptions = SignatureSpecificVerificationOptions.empty;\n        }\n\n        /* Unmarshal the signature */\n\n        XMLSignature signature;\n        try\n        {\n            signature = new XMLSignature(signatureElem, verificationOptions.getBaseUri(), this.secureValidation);\n        } catch (XMLSecurityException ex)\n        {\n            throw new UnmarshalException(\"Bad XML signature\", ex);\n        }\n\n        String signatureId = signature.getId();\n        if (null == signatureId)\n        {\n            throw new UnmarshalException(\"XML signature doesn't have an Id\");\n        }\n\n        ReferencesRes referencesRes = SignatureUtils.processReferences(signature);\n\n        /* Apply early verifiers */\n\n        RawSignatureVerifierContext rawCtx = new RawSignatureVerifierContext(signature);\n        for (RawSignatureVerifier rawSignatureVerifier : this.rawSigVerifiers)\n        {\n            rawSignatureVerifier.verify(rawCtx);\n        }\n\n        /* Get and check the QualifyingProperties element */\n\n        Element qualifyingPropsElem = SignatureUtils.getQualifyingPropertiesElement(signature);\n        SignatureUtils.checkSignedPropertiesIncorporation(qualifyingPropsElem, referencesRes.signedPropsReference);\n\n        // Check the QualifyingProperties 'Target' attribute.\n        Node targetAttr = qualifyingPropsElem.getAttributeNodeNS(null, QualifyingProperty.TARGET_ATTR);\n        if (null == targetAttr)\n        {\n            targetAttr = qualifyingPropsElem.getAttributeNodeNS(QualifyingProperty.XADES_XMLNS, QualifyingProperty.TARGET_ATTR);\n            if (null == targetAttr)\n            {\n                throw new QualifyingPropertiesIncorporationException(\"QualifyingProperties Target attribute not present\");\n            }\n        }\n        String targetValue = targetAttr.getNodeValue();\n        if (null == targetValue\n                || !targetValue.startsWith(\"#\")\n                || !targetValue.substring(1).equals(signatureId))\n        {\n            throw new QualifyingPropertiesIncorporationException(\"QualifyingProperties target doesn't match the signature's Id\");\n        }\n\n        /* Unmarshal the qualifying properties */\n\n        QualifPropsDataCollectorImpl propsDataCollector = new QualifPropsDataCollectorImpl();\n        qualifPropsUnmarshaller.unmarshalProperties(qualifyingPropsElem, propsDataCollector);\n        Collection<PropertyDataObject> qualifPropsData = propsDataCollector.getPropertiesData();\n\n        /* Certification path */\n\n        KeyInfoRes keyInfoRes = SignatureUtils.processKeyInfo(signature.getKeyInfo(), this.x500NameStyleProvider);\n        Date validationDate = getValidationDate(qualifPropsData, signature, verificationOptions);\n        ValidationData certValidationRes = this.certificateValidator.validate(\n                keyInfoRes.certSelector,\n                validationDate,\n                keyInfoRes.keyInfoCerts);\n        if (null == certValidationRes || certValidationRes.getCerts().isEmpty())\n        {\n            throw new NullPointerException(\"Certificate validator returned null or empty data\");\n        }\n        X509Certificate validationCert = certValidationRes.getCerts().get(0);\n\n        /* Signature verification */\n\n        // Core XML-DSIG verification.\n        doCoreVerification(signature, verificationOptions, validationCert);\n\n        // Create the properties verification context.\n        QualifyingPropertyVerificationContext qPropsCtx = new QualifyingPropertyVerificationContext(\n                signature,\n                new QualifyingPropertyVerificationContext.CertificationChainData(\n                certValidationRes.getCerts(),\n                certValidationRes.getCrls(),\n                keyInfoRes.issuerSerial,\n                this.x500NameStyleProvider),\n                /**/\n                new QualifyingPropertyVerificationContext.SignedObjectsData(\n                referencesRes.dataObjsReferences,\n                signature));\n\n        // Verify the properties. Data structure verification is included.\n        Collection<PropertyInfo> props = this.qualifyingPropertiesVerifier.verifyProperties(qualifPropsData, qPropsCtx);\n\n        XAdESVerificationResult res = new XAdESVerificationResult(\n                XAdESFormChecker.checkForm(props),\n                signature,\n                certValidationRes,\n                props,\n                referencesRes.dataObjsReferences);\n\n        // Apply the custom signature verifiers.\n        for (CustomSignatureVerifier customVer : this.customSigVerifiers)\n        {\n            customVer.verify(res, qPropsCtx);\n        }\n\n        return res;\n    }",
        "fixed_function": "    @Override\n    public XAdESVerificationResult verify(Element signatureElem, SignatureSpecificVerificationOptions verificationOptions) throws XAdES4jException\n    {\n        if (null == signatureElem)\n        {\n            throw new NullPointerException(\"Signature node not specified\");\n        }\n\n        if (null == verificationOptions)\n        {\n            verificationOptions = SignatureSpecificVerificationOptions.empty;\n        }\n\n        /* Unmarshal the signature */\n\n        XMLSignature signature;\n        try\n        {\n            signature = new XMLSignature(signatureElem, verificationOptions.getBaseUri(), this.secureValidation);\n        } catch (XMLSecurityException ex)\n        {\n            throw new UnmarshalException(\"Bad XML signature\", ex);\n        }\n\n        String signatureId = signature.getId();\n        if (null == signatureId)\n        {\n            throw new UnmarshalException(\"XML signature doesn't have an Id\");\n        }\n\n        ReferencesRes referencesRes = SignatureUtils.processReferences(signature);\n\n        /* Apply early verifiers */\n\n        RawSignatureVerifierContext rawCtx = new RawSignatureVerifierContext(signature);\n        for (RawSignatureVerifier rawSignatureVerifier : this.rawSigVerifiers)\n        {\n            rawSignatureVerifier.verify(rawCtx);\n        }\n\n        /* Get and check the QualifyingProperties element */\n\n        Element qualifyingPropsElem = SignatureUtils.getQualifyingPropertiesElement(signature);\n        SignatureUtils.checkSignedPropertiesIncorporation(qualifyingPropsElem, referencesRes.signedPropsReference);\n\n        // Check the QualifyingProperties 'Target' attribute.\n        Node targetAttr = qualifyingPropsElem.getAttributeNodeNS(null, QualifyingProperty.TARGET_ATTR);\n        if (null == targetAttr)\n        {\n            targetAttr = qualifyingPropsElem.getAttributeNodeNS(QualifyingProperty.XADES_XMLNS, QualifyingProperty.TARGET_ATTR);\n            if (null == targetAttr)\n            {\n                throw new QualifyingPropertiesIncorporationException(\"QualifyingProperties Target attribute not present\");\n            }\n        }\n        String targetValue = targetAttr.getNodeValue();\n        if (null == targetValue\n                || !targetValue.startsWith(\"#\")\n                || !targetValue.substring(1).equals(signatureId))\n        {\n            throw new QualifyingPropertiesIncorporationException(\"QualifyingProperties target doesn't match the signature's Id\");\n        }\n\n        /* Unmarshal the qualifying properties */\n\n        QualifPropsDataCollectorImpl propsDataCollector = new QualifPropsDataCollectorImpl();\n        qualifPropsUnmarshaller.unmarshalProperties(qualifyingPropsElem, propsDataCollector);\n        Collection<PropertyDataObject> qualifPropsData = propsDataCollector.getPropertiesData();\n\n        /* Certification path */\n\n        Date validationDate = getValidationDate(qualifPropsData, signature, verificationOptions);\n        CertRef signingCertRefAttempt = tryGetSigningCertificateRef(qualifPropsData);\n        KeyInfoRes keyInfoRes = KeyInfoProcessor.process(signature.getKeyInfo(), signingCertRefAttempt, this.x500NameStyleProvider);\n        ValidationData certValidationRes = this.certificateValidator.validate(\n                keyInfoRes.certSelector,\n                validationDate,\n                keyInfoRes.keyInfoCerts);\n        if (null == certValidationRes || certValidationRes.getCerts().isEmpty())\n        {\n            throw new NullPointerException(\"Certificate validator returned null or empty data\");\n        }\n        X509Certificate validationCert = certValidationRes.getCerts().get(0);\n\n        /* Signature verification */\n\n        // Core XML-DSIG verification.\n        doCoreVerification(signature, verificationOptions, validationCert);\n\n        // Create the properties verification context.\n        QualifyingPropertyVerificationContext qPropsCtx = new QualifyingPropertyVerificationContext(\n                signature,\n                new QualifyingPropertyVerificationContext.CertificationChainData(\n                certValidationRes.getCerts(),\n                certValidationRes.getCrls(),\n                keyInfoRes.issuerSerial,\n                this.x500NameStyleProvider),\n                /**/\n                new QualifyingPropertyVerificationContext.SignedObjectsData(\n                referencesRes.dataObjsReferences,\n                signature));\n\n        // Verify the properties. Data structure verification is included.\n        Collection<PropertyInfo> props = this.qualifyingPropertiesVerifier.verifyProperties(qualifPropsData, qPropsCtx);\n\n        XAdESVerificationResult res = new XAdESVerificationResult(\n                XAdESFormChecker.checkForm(props),\n                signature,\n                certValidationRes,\n                props,\n                referencesRes.dataObjsReferences);\n\n        // Apply the custom signature verifiers.\n        for (CustomSignatureVerifier customVer : this.customSigVerifiers)\n        {\n            customVer.verify(res, qPropsCtx);\n        }\n\n        return res;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "xades4j.verification.XadesVerifierImplTest::testVerifyBESWithoutKeyInfo": {
        "path": "xades4j/verification/XadesVerifierImplTest.java",
        "function_name": "testVerifyBESWithoutKeyInfo",
        "src": "@Test\n    public void testVerifyBESWithoutKeyInfo() throws Exception\n    {\n        System.out.println(\"verifyBES\");\n        XAdESForm f = verifySignature(\"document.signed.bes.no-ki.xml\");\n        assertEquals(XAdESForm.BES, f);\n    }",
        "error_msg": "xades4j.verification.XadesVerifierImplTest::testVerifyBESWithoutKeyInfo --> xades4j.verification.InvalidKeyInfoDataException: No X509Data to identify the leaf certificate",
        "clean_error_msg": "xades4j.verification.InvalidKeyInfoDataException: No X509Data to identify the leaf certificate"
      }
    }
  },
  "Spatial4j-3": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/spatial4j/io/GeoJSONReader.java",
        "start_loc": 226,
        "end_loc": 301,
        "buggy_function": "  protected Shape readShape(JSONParser parser) throws IOException, ParseException {\n    String type = null;\n\n    String key = null;\n    int evt = parser.nextEvent();\n    while (evt != JSONParser.EOF) {\n      switch (evt) {\n        case JSONParser.STRING:\n          if (parser.wasKey()) {\n            key = parser.getString();\n          } else {\n            if (\"type\".equals(key)) {\n              type = parser.getString();\n            } else {\n              throw new ParseException(\"Unexpected String Value for key: \" + key,\n                      (int) parser.getPosition());\n            }\n          }\n          break;\n\n        case JSONParser.ARRAY_START:\n          if (\"coordinates\".equals(key)) {\n            Shape shape = readShapeFromCoordinates(type, parser);\n            readUntilEvent(parser, JSONParser.OBJECT_END);\n            return shape;\n          } else if (\"geometries\".equals(key)) {\n            List<Shape> shapes = new ArrayList<Shape>();\n            int sub = parser.nextEvent();\n            while (sub != JSONParser.EOF) {\n              if (sub == JSONParser.OBJECT_START) {\n                Shape s = readShape(parser);\n                if (s != null) {\n                  shapes.add(s);\n                }\n              } else if (sub == JSONParser.OBJECT_END) {\n                break;\n              }\n              sub = parser.nextEvent();\n            }\n            if (shapes.isEmpty()) {\n              throw new ParseException(\"Shape Collection with no geometries!\",\n                  (int) parser.getPosition());\n            }\n            return ctx.makeCollection(shapes);\n          }\n          else {\n            throw new ParseException(\"Unknown type: \"+type,\n                (int) parser.getPosition());\n          }\n\n        case JSONParser.ARRAY_END:\n          break;\n\n        case JSONParser.OBJECT_START:\n          if (key != null) {\n           // System.out.println(\"Unexpected object: \" + key);\n          }\n          break;\n\n        case JSONParser.LONG:\n        case JSONParser.NUMBER:\n        case JSONParser.BIGNUMBER:\n        case JSONParser.BOOLEAN:\n        case JSONParser.NULL:\n        case JSONParser.OBJECT_END:\n         // System.out.println(\">>>>>\" + JSONParser.getEventString(evt) + \" :: \" + key);\n          break;\n\n        default:\n          throw new ParseException(\"Unexpected \" + JSONParser.getEventString(evt),\n              (int) parser.getPosition());\n      }\n      evt = parser.nextEvent();\n    }\n    throw new RuntimeException(\"unable to parse shape\");\n  }",
        "fixed_function": "  protected Shape readShape(JSONParser parser) throws IOException, ParseException {\n    String type = null;\n\n    String key = null;\n    int evt = parser.nextEvent();\n    while (evt != JSONParser.EOF) {\n      switch (evt) {\n        case JSONParser.STRING:\n          if (parser.wasKey()) {\n            key = parser.getString();\n          } else {\n            if (\"type\".equals(key)) {\n              type = parser.getString();\n            } else {\n              throw new ParseException(\"Unexpected String Value for key: \" + key,\n                      (int) parser.getPosition());\n            }\n          }\n          break;\n\n        case JSONParser.ARRAY_START:\n          if (\"coordinates\".equals(key)) {\n            Shape shape = readShapeFromCoordinates(type, parser);\n            readUntilEvent(parser, JSONParser.OBJECT_END);\n            return shape;\n          } else if (\"geometries\".equals(key)) {\n            List<Shape> shapes = new ArrayList<Shape>();\n            int sub = parser.nextEvent();\n            while (sub != JSONParser.EOF) {\n              if (sub == JSONParser.OBJECT_START) {\n                Shape s = readShape(parser);\n                if (s != null) {\n                  shapes.add(s);\n                }\n              } else if (sub == JSONParser.OBJECT_END) {\n                break;\n              }\n              sub = parser.nextEvent();\n            }\n            return ctx.makeCollection(shapes);\n          }\n          else {\n            throw new ParseException(\"Unknown type: \"+type,\n                (int) parser.getPosition());\n          }\n\n        case JSONParser.ARRAY_END:\n          break;\n\n        case JSONParser.OBJECT_START:\n          if (key != null) {\n           // System.out.println(\"Unexpected object: \" + key);\n          }\n          break;\n\n        case JSONParser.LONG:\n        case JSONParser.NUMBER:\n        case JSONParser.BIGNUMBER:\n        case JSONParser.BOOLEAN:\n        case JSONParser.NULL:\n        case JSONParser.OBJECT_END:\n         // System.out.println(\">>>>>\" + JSONParser.getEventString(evt) + \" :: \" + key);\n          break;\n\n        default:\n          throw new ParseException(\"Unexpected \" + JSONParser.getEventString(evt),\n              (int) parser.getPosition());\n      }\n      evt = parser.nextEvent();\n    }\n    throw new RuntimeException(\"unable to parse shape\");\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/spatial4j/io/GeoJSONWriter.java",
        "start_loc": 39,
        "end_loc": 48,
        "buggy_function": "  protected void write(Writer output, NumberFormat nf, double... coords) throws IOException {\n    output.write('[');\n    for (int i = 0; i < coords.length; i++) {\n      if (i > 0) {\n        output.append(',');\n      }\n      output.append(nf.format(coords[i]));\n    }\n    output.write(']');\n  }",
        "fixed_function": "  protected void write(Writer output, NumberFormat nf, double... coords) throws IOException {\n    output.write('[');\n    for (int i = 0; i < coords.length; i++) {\n      if (Double.isNaN(coords[i])) {\n        break; // empty point or no more coordinates\n      }\n      if (i > 0) {\n        output.append(',');\n      }\n      output.append(nf.format(coords[i]));\n    }\n    output.write(']');\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/spatial4j/io/WKTWriter.java",
        "start_loc": 44,
        "end_loc": 126,
        "buggy_function": "  @Override\n  public String toString(Shape shape) {\n    NumberFormat nf = getNumberFormat();\n    if (shape instanceof Point) {\n\n      StringBuilder buffer = new StringBuilder();\n      return append(buffer.append(\"POINT (\"),(Point)shape,nf).append(\")\").toString();\n    }\n    if (shape instanceof Rectangle) {\n      NumberFormat nfMIN = nf;\n      NumberFormat nfMAX = LegacyShapeWriter.makeNumberFormat(6);\n\n      nfMIN.setRoundingMode( RoundingMode.FLOOR );\n      nfMAX.setRoundingMode( RoundingMode.CEILING );\n      \n      Rectangle rect = (Rectangle)shape;\n      return \"ENVELOPE (\" +\n          // '(' x1 ',' x2 ',' y2 ',' y1 ')'\n        nfMIN.format(rect.getMinX()) + \", \" + nfMAX.format(rect.getMaxX()) + \", \"+\n        nfMAX.format(rect.getMaxY()) + \", \" + nfMIN.format(rect.getMinY()) + \")\";\n//      \n//      return \"POLYGON(( \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMinY()) + \", \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMaxY()) + \", \"+\n//         nf.format(rect.getMaxX()) + \" \" + nf.format(rect.getMaxY()) + \", \"+\n//         nf.format(rect.getMaxX()) + \" \" + nf.format(rect.getMinY()) + \", \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMinY()) + \"))\";\n    }\n    if (shape instanceof Circle) {\n      Circle c = (Circle) shape;\n\n      StringBuilder str = new StringBuilder();\n      str.append(\"BUFFER (POINT (\")\n        .append(nf.format(c.getCenter().getX())).append(\" \")\n        .append(nf.format(c.getCenter().getY()))\n        .append(\"), \")\n        .append(nf.format(c.getRadius()))\n        .append(\")\");\n      return str.toString();\n    }\n    if (shape instanceof BufferedLineString) {\n      BufferedLineString line = (BufferedLineString) shape;\n      StringBuilder str = new StringBuilder();\n\n      double buf = line.getBuf();\n      if (buf > 0d) {\n        str.append(\"BUFFER (\");\n      }\n\n      str.append(\"LINESTRING (\");\n      Iterator<BufferedLine> iter = line.getSegments().iterator();\n      while(iter.hasNext()) {\n        BufferedLine seg = iter.next();\n        append(str,seg.getA(),nf).append(\", \");\n        if(!iter.hasNext()) {\n          append(str,seg.getB(),nf);\n        }\n      }\n      str.append(\")\");\n\n      if (buf > 0d) {\n        str.append(\", \").append(nf.format(buf)).append(\")\");\n      }\n      return str.toString();\n    }\n    if(shape instanceof ShapeCollection) {\n\n\n      StringBuilder buffer = new StringBuilder();\n      buffer.append(\"GEOMETRYCOLLECTION (\");\n      boolean first = true;\n      for(Shape sub : ((ShapeCollection<? extends Shape>)shape).getShapes()) {\n        if(!first) {\n          buffer.append(\",\");\n        }\n        buffer.append(toString(sub));\n        first = false;\n      }\n      buffer.append(\")\");\n      return buffer.toString();\n    }\n    return LegacyShapeWriter.writeShape(shape, nf);\n  }",
        "fixed_function": "  @Override\n  public String toString(Shape shape) {\n    NumberFormat nf = getNumberFormat();\n    if (shape instanceof Point) {\n      Point point = (Point)shape;\n      if (point.isEmpty()) {\n        return \"POINT EMPTY\";\n      }\n\n      StringBuilder buffer = new StringBuilder();\n      return append(buffer.append(\"POINT (\"), point, nf).append(\")\").toString();\n    }\n    if (shape instanceof Rectangle) {\n      NumberFormat nfMIN = nf;\n      NumberFormat nfMAX = LegacyShapeWriter.makeNumberFormat(6);\n\n      nfMIN.setRoundingMode( RoundingMode.FLOOR );\n      nfMAX.setRoundingMode( RoundingMode.CEILING );\n      \n      Rectangle rect = (Rectangle)shape;\n      return \"ENVELOPE (\" +\n          // '(' x1 ',' x2 ',' y2 ',' y1 ')'\n        nfMIN.format(rect.getMinX()) + \", \" + nfMAX.format(rect.getMaxX()) + \", \"+\n        nfMAX.format(rect.getMaxY()) + \", \" + nfMIN.format(rect.getMinY()) + \")\";\n//      \n//      return \"POLYGON(( \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMinY()) + \", \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMaxY()) + \", \"+\n//         nf.format(rect.getMaxX()) + \" \" + nf.format(rect.getMaxY()) + \", \"+\n//         nf.format(rect.getMaxX()) + \" \" + nf.format(rect.getMinY()) + \", \"+\n//         nf.format(rect.getMinX()) + \" \" + nf.format(rect.getMinY()) + \"))\";\n    }\n    if (shape instanceof Circle) {\n      Circle c = (Circle) shape;\n\n      StringBuilder str = new StringBuilder();\n      str.append(\"BUFFER (POINT (\")\n        .append(nf.format(c.getCenter().getX())).append(\" \")\n        .append(nf.format(c.getCenter().getY()))\n        .append(\"), \")\n        .append(nf.format(c.getRadius()))\n        .append(\")\");\n      return str.toString();\n    }\n    if (shape instanceof BufferedLineString) {\n      BufferedLineString line = (BufferedLineString) shape;\n      StringBuilder str = new StringBuilder();\n\n      double buf = line.getBuf();\n      if (buf > 0d) {\n        str.append(\"BUFFER (\");\n      }\n\n      str.append(\"LINESTRING (\");\n      Iterator<BufferedLine> iter = line.getSegments().iterator();\n      while(iter.hasNext()) {\n        BufferedLine seg = iter.next();\n        append(str,seg.getA(),nf).append(\", \");\n        if(!iter.hasNext()) {\n          append(str,seg.getB(),nf);\n        }\n      }\n      str.append(\")\");\n\n      if (buf > 0d) {\n        str.append(\", \").append(nf.format(buf)).append(\")\");\n      }\n      return str.toString();\n    }\n    if(shape instanceof ShapeCollection) {\n      @SuppressWarnings(\"unchecked\")\n      ShapeCollection<? extends Shape> collection = (ShapeCollection<? extends Shape>) shape;\n\n      if (collection.isEmpty()) {\n        return \"GEOMETRYCOLLECTION EMPTY\";\n      }\n\n      StringBuilder buffer = new StringBuilder();\n      buffer.append(\"GEOMETRYCOLLECTION (\");\n      boolean first = true;\n      for (Shape sub : collection.getShapes()) {\n        if(!first) {\n          buffer.append(\",\");\n        }\n        buffer.append(toString(sub));\n        first = false;\n      }\n      buffer.append(\")\");\n      return buffer.toString();\n    }\n    return LegacyShapeWriter.writeShape(shape, nf);\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/spatial4j/io/jackson/ShapeAsGeoJSONSerializer.java",
        "start_loc": 38,
        "end_loc": 44,
        "buggy_function": "  protected void write(JsonGenerator gen, double... coords) throws IOException {\n    gen.writeStartArray();\n    for (int i = 0; i < coords.length; i++) {\n      gen.writeNumber(coords[i]);\n    }\n    gen.writeEndArray();\n  }",
        "fixed_function": "  protected void write(JsonGenerator gen, double... coords) throws IOException {\n    gen.writeStartArray();\n    for (double coord : coords) {\n      if (Double.isNaN(coord)) {\n        break; // empty\n      }\n      gen.writeNumber(coord);\n    }\n    gen.writeEndArray();\n  }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/spatial4j/io/jackson/ShapeDeserializer.java",
        "start_loc": 40,
        "end_loc": 48,
        "buggy_function": "  public Point readPoint(ArrayNode arr, ShapeFactory factory) {\n    double x = arr.get(0).asDouble();\n    double y = arr.get(1).asDouble();\n    if(arr.size()==3) {\n      double z = arr.get(3).asDouble();\n      return factory.pointXYZ(x, y, z);\n    }\n    return factory.pointXY(x, y);\n  }",
        "fixed_function": "  public Point readPoint(ArrayNode arr, ShapeFactory factory) {\n    if(arr.size()==0) {\n      return factory.pointXY(Double.NaN, Double.NaN);\n    }\n    double x = arr.get(0).asDouble();\n    double y = arr.get(1).asDouble();\n    if(arr.size()==3) {\n      double z = arr.get(3).asDouble();\n      return factory.pointXYZ(x, y, z);\n    }\n    return factory.pointXY(x, y);\n  }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.locationtech.spatial4j.io.GeneralGeoJSONTest::testEmptyPoint": {
        "path": "org/locationtech/spatial4j/io/GeneralGeoJSONTest.java",
        "function_name": "testEmptyPoint",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.GeneralGeoJSONTest::testEmptyPoint --> org.noggit.JSONParser$ParseException: JSON Parse Error: char=\ufffd,position=31 AFTER='{type:Point,coordinates:[\ufffd' BEFORE=',\ufffd]}'",
        "clean_error_msg": "org.noggit.JSONParser$ParseException: JSON Parse Error: char=\ufffd,position=31 AFTER='{type:Point,coordinates:[\ufffd' BEFORE=',\ufffd]}'"
      },
      "org.locationtech.spatial4j.io.GeneralGeoJSONTest::testEmptyGeometryCollection": {
        "path": "org/locationtech/spatial4j/io/GeneralGeoJSONTest.java",
        "function_name": "testEmptyGeometryCollection",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.GeneralGeoJSONTest::testEmptyGeometryCollection --> java.text.ParseException: Shape Collection with no geometries!",
        "clean_error_msg": "java.text.ParseException: Shape Collection with no geometries!"
      },
      "org.locationtech.spatial4j.io.GeneralWktTest::testEmptyPoint": {
        "path": "org/locationtech/spatial4j/io/GeneralWktTest.java",
        "function_name": "testEmptyPoint",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.GeneralWktTest::testEmptyPoint --> java.text.ParseException: Expected a number",
        "clean_error_msg": "java.text.ParseException: Expected a number"
      },
      "org.locationtech.spatial4j.io.GeneralWktTest::testEmptyGeometryCollection": {
        "path": "org/locationtech/spatial4j/io/GeneralWktTest.java",
        "function_name": "testEmptyGeometryCollection",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.GeneralWktTest::testEmptyGeometryCollection --> java.text.ParseException: Word expected",
        "clean_error_msg": "java.text.ParseException: Word expected"
      },
      "org.locationtech.spatial4j.io.WKTWriterTest::testToStringOnEmptyShapeCollection": {
        "path": "org/locationtech/spatial4j/io/WKTWriterTest.java",
        "function_name": "testToStringOnEmptyShapeCollection",
        "src": "@Test\n  public void testToStringOnEmptyShapeCollection() throws Exception {\n    ShapeWriter writer = ctx.getFormats().getWktWriter();\n    ShapeCollection<Point> emptyCollection = ctx.makeCollection(new ArrayList<Point>());\n\n    assertEquals(\"GEOMETRYCOLLECTION EMPTY\", writer.toString(emptyCollection));\n  }",
        "error_msg": "org.locationtech.spatial4j.io.WKTWriterTest::testToStringOnEmptyShapeCollection --> junit.framework.AssertionFailedError: expected:<GEOMETRYCOLLECTION [EMPTY]> but was:<GEOMETRYCOLLECTION [()]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<GEOMETRYCOLLECTION [EMPTY]> but was:<GEOMETRYCOLLECTION [()]>"
      },
      "org.locationtech.spatial4j.io.WKTWriterTest::testToStringOnEmptyPoint": {
        "path": "org/locationtech/spatial4j/io/WKTWriterTest.java",
        "function_name": "testToStringOnEmptyPoint",
        "src": "@Test\n  public void testToStringOnEmptyPoint() throws Exception {\n    ShapeWriter writer = ctx.getFormats().getWktWriter();\n    Point emptyPoint = ctx.makePoint(Double.NaN, Double.NaN);\n\n    assertEquals(\"POINT EMPTY\", writer.toString(emptyPoint));\n  }",
        "error_msg": "org.locationtech.spatial4j.io.WKTWriterTest::testToStringOnEmptyPoint --> junit.framework.AssertionFailedError: expected:<POINT [EMPTY]> but was:<POINT [(\ufffd \ufffd)]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<POINT [EMPTY]> but was:<POINT [(\ufffd \ufffd)]>"
      },
      "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONReaderTest::testEmptyPoint": {
        "path": "org/locationtech/spatial4j/io/jackson/JacksonGeoJSONReaderTest.java",
        "function_name": "testEmptyPoint",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONReaderTest::testEmptyPoint --> com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\ufffd' (code 65533 / 0xfffd)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')",
        "clean_error_msg": "com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\ufffd' (code 65533 / 0xfffd)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')"
      },
      "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONWriterTest::testEmptyGeometryCollection": {
        "path": "org/locationtech/spatial4j/io/jackson/JacksonGeoJSONWriterTest.java",
        "function_name": "testEmptyGeometryCollection",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONWriterTest::testEmptyGeometryCollection --> java.text.ParseException: Shape Collection with no geometries!",
        "clean_error_msg": "java.text.ParseException: Shape Collection with no geometries!"
      },
      "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONWriterTest::testEmptyPoint": {
        "path": "org/locationtech/spatial4j/io/jackson/JacksonGeoJSONWriterTest.java",
        "function_name": "testEmptyPoint",
        "src": "",
        "error_msg": "org.locationtech.spatial4j.io.jackson.JacksonGeoJSONWriterTest::testEmptyPoint --> java.text.ParseException: Unexpected STRING",
        "clean_error_msg": "java.text.ParseException: Unexpected STRING"
      }
    }
  },
  "Spatial4j-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/spatial4j/shape/jts/JtsGeometry.java",
        "start_loc": 570,
        "end_loc": 591,
        "buggy_function": "  private static Geometry cutUnwrappedGeomInto360(Geometry geom) {\n    Envelope geomEnv = geom.getEnvelopeInternal();\n    if (geomEnv.getMinX() >= -180 && geomEnv.getMaxX() <= 180)\n      return geom;\n    assert geom.isValid() : \"geom\";\n\n    List<Geometry> geomList = new ArrayList<Geometry>();\n    //page 0 is the standard -180 to 180 range\n    for (int page = 0; true; page++) {\n      double minX = -180 + page * 360;\n      if (geomEnv.getMaxX() <= minX)\n        break;\n      Geometry rect = geom.getFactory().toGeometry(new Envelope(minX, minX + 360, -90, 90));\n      assert rect.isValid() : \"rect\";\n      Geometry pageGeom = rect.intersection(geom);//JTS is doing some hard work\n      assert pageGeom.isValid() : \"pageGeom\";\n\n        shiftGeomByX(pageGeom, page * -360);\n      geomList.add(pageGeom);\n    }\n    return UnaryUnionOp.union(geomList);\n  }",
        "fixed_function": "  private static Geometry cutUnwrappedGeomInto360(Geometry geom) {\n    Envelope geomEnv = geom.getEnvelopeInternal();\n    if (geomEnv.getMinX() >= -180 && geomEnv.getMaxX() <= 180)\n      return geom;\n    assert geom.isValid() : \"geom\";\n\n    List<Geometry> geomList = new ArrayList<Geometry>();\n    //page 0 is the standard -180 to 180 range\n    int startPage = (int) Math.floor((geomEnv.getMinX() + 180) / 360);\n    for (int page = startPage; true; page++) {\n      double minX = -180 + page * 360;\n      if (geomEnv.getMaxX() <= minX)\n        break;\n      Geometry rect = geom.getFactory().toGeometry(new Envelope(minX, minX + 360, -90, 90));\n      assert rect.isValid() : \"rect\";\n      Geometry pageGeom = rect.intersection(geom);//JTS is doing some hard work\n      assert pageGeom.isValid() : \"pageGeom\";\n\n      if (page != 0) {\n        pageGeom = pageGeom.copy(); // because shiftGeomByX modifies the underlying coordinates shared by geom.\n        shiftGeomByX(pageGeom, page * -360);\n      }\n      geomList.add(pageGeom);\n    }\n    return UnaryUnionOp.union(geomList);\n  }",
        "comment": "/**\n   * This \"pages\" through standard geo boundaries offset by multiples of 360\n   * longitudinally that intersect geom, and the intersecting results of a page\n   * and the geom are shifted into the standard -180 to +180 and added to a new\n   * geometry that is returned.\n   */"
      },
      {
        "path": "src/main/java/org/locationtech/spatial4j/shape/jts/JtsShapeFactory.java",
        "start_loc": 131,
        "end_loc": 173,
        "buggy_function": "  public Geometry getGeometryFrom(Shape shape) {\n    if (shape instanceof JtsGeometry) {\n      return ((JtsGeometry)shape).getGeom();\n    }\n    if (shape instanceof JtsPoint) {\n      return ((JtsPoint) shape).getGeom();\n    }\n    if (shape instanceof Point) {\n      Point point = (Point) shape;\n      return geometryFactory.createPoint(new Coordinate(point.getX(),point.getY()));\n    }\n    if (shape instanceof Rectangle) {\n      Rectangle r = (Rectangle)shape;\n      if (r.getCrossesDateLine()) {\n        Collection<Geometry> pair = new ArrayList<>(2);\n        pair.add(geometryFactory.toGeometry(new Envelope(\n                r.getMinX(), ctx.getWorldBounds().getMaxX(), r.getMinY(), r.getMaxY())));\n        pair.add(geometryFactory.toGeometry(new Envelope(\n                ctx.getWorldBounds().getMinX(), r.getMaxX(), r.getMinY(), r.getMaxY())));\n        return geometryFactory.buildGeometry(pair);//a MultiPolygon or MultiLineString\n      } else {\n        return geometryFactory.toGeometry(new Envelope(r.getMinX(), r.getMaxX(), r.getMinY(), r.getMaxY()));\n      }\n    }\n    if (shape instanceof Circle) {\n      // FYI Some interesting code for this is here:\n      //  http://docs.codehaus.org/display/GEOTDOC/01+How+to+Create+a+Geometry#01HowtoCreateaGeometry-CreatingaCircle\n      //TODO This should ideally have a geodetic version\n      Circle circle = (Circle)shape;\n      if (circle.getBoundingBox().getCrossesDateLine())\n        throw new IllegalArgumentException(\"Doesn't support dateline cross yet: \"+circle);//TODO\n      GeometricShapeFactory gsf = new GeometricShapeFactory(geometryFactory);\n      gsf.setWidth(circle.getBoundingBox().getWidth());\n      gsf.setHeight(circle.getBoundingBox().getHeight());\n      gsf.setNumPoints(4*25);//multiple of 4 is best\n      gsf.setCentre(new Coordinate(circle.getCenter().getX(), circle.getCenter().getY()));\n      Geometry geom = gsf.createCircle();\n        // wrap the geometry in a JtsGeometry to handle date line wrapping\n      return geom;\n    }\n    //TODO add BufferedLineString\n    throw new InvalidShapeException(\"can't make Geometry from: \" + shape);\n  }",
        "fixed_function": "  public Geometry getGeometryFrom(Shape shape) {\n    if (shape instanceof JtsGeometry) {\n      return ((JtsGeometry)shape).getGeom();\n    }\n    if (shape instanceof JtsPoint) {\n      return ((JtsPoint) shape).getGeom();\n    }\n    if (shape instanceof Point) {\n      Point point = (Point) shape;\n      return geometryFactory.createPoint(new Coordinate(point.getX(),point.getY()));\n    }\n    if (shape instanceof Rectangle) {\n      Rectangle r = (Rectangle)shape;\n      if (r.getCrossesDateLine()) {\n        Collection<Geometry> pair = new ArrayList<>(2);\n        pair.add(geometryFactory.toGeometry(new Envelope(\n                r.getMinX(), ctx.getWorldBounds().getMaxX(), r.getMinY(), r.getMaxY())));\n        pair.add(geometryFactory.toGeometry(new Envelope(\n                ctx.getWorldBounds().getMinX(), r.getMaxX(), r.getMinY(), r.getMaxY())));\n        return geometryFactory.buildGeometry(pair);//a MultiPolygon or MultiLineString\n      } else {\n        return geometryFactory.toGeometry(new Envelope(r.getMinX(), r.getMaxX(), r.getMinY(), r.getMaxY()));\n      }\n    }\n    if (shape instanceof Circle) {\n      // FYI Some interesting code for this is here:\n      //  http://docs.codehaus.org/display/GEOTDOC/01+How+to+Create+a+Geometry#01HowtoCreateaGeometry-CreatingaCircle\n      //TODO This should ideally have a geodetic version\n      Circle circle = (Circle)shape;\n      GeometricShapeFactory gsf = new GeometricShapeFactory(geometryFactory);\n      gsf.setWidth(circle.getBoundingBox().getWidth());\n      gsf.setHeight(circle.getBoundingBox().getHeight());\n      gsf.setNumPoints(4*25);//multiple of 4 is best\n      gsf.setCentre(new Coordinate(circle.getCenter().getX(), circle.getCenter().getY()));\n      Geometry geom = gsf.createCircle();\n      if (circle.getBoundingBox().getCrossesDateLine())\n        // wrap the geometry in a JtsGeometry to handle date line wrapping\n        geom = new JtsGeometry(geom, (JtsSpatialContext) getSpatialContext(),false, false).getGeom();\n      return geom;\n    }\n    //TODO add BufferedLineString\n    throw new InvalidShapeException(\"can't make Geometry from: \" + shape);\n  }",
        "comment": "/**\n   * Gets a JTS {@link Geometry} for the given {@link Shape}. Some shapes hold a\n   * JTS geometry whereas new ones must be created for the rest.\n   * @param shape Not null\n   * @return Not null\n   */"
      }
    ],
    "trigger_test": {
      "org.locationtech.spatial4j.context.jts.JtsSpatialContextTest::testMultiDatelineWrap": {
        "path": "org/locationtech/spatial4j/context/jts/JtsSpatialContextTest.java",
        "function_name": "testMultiDatelineWrap",
        "src": "@Test\n    public void testMultiDatelineWrap() {\n        // polygon crosses the dateline twice\n        Polygon polygon = Geom.build().points(-179, 45, 179, 44, 1, 35, -179, 25, 179, 24, 179, 19, -179, 20, 1, 30, 179, 39, -179, 40).toPolygon();\n\n        JtsSpatialContextFactory factory = new JtsSpatialContextFactory();\n        factory.datelineRule = DatelineRule.width180;\n        JtsSpatialContext ctx = factory.newSpatialContext();\n        JtsShapeFactory shapeFactory = ctx.getShapeFactory();\n        JtsGeometry jtsGeometry = shapeFactory.makeShape(polygon);\n        Geometry geometry = jtsGeometry.getGeom();\n\n        assertTrue(geometry.isValid());\n        assertTrue(geometry instanceof MultiPolygon);\n    }",
        "error_msg": "org.locationtech.spatial4j.context.jts.JtsSpatialContextTest::testMultiDatelineWrap --> org.locationtech.jts.geom.TopologyException: found non-noded intersection between LINESTRING ( -179 25, 179 24 ) and LINESTRING ( -179 20, 1 30 ) [ (-93.30851063829788, 24.76063829787234, NaN) ]",
        "clean_error_msg": "org.locationtech.jts.geom.TopologyException: found non-noded intersection between LINESTRING ( -179 25, 179 24 ) and LINESTRING ( -179 20, 1 30 ) [ (-93.30851063829788, 24.76063829787234, NaN) ]"
      },
      "org.locationtech.spatial4j.shape.jts.JtsShapeFactoryTest::testCircleDateLineWrapping": {
        "path": "org/locationtech/spatial4j/shape/jts/JtsShapeFactoryTest.java",
        "function_name": "testCircleDateLineWrapping",
        "src": "@Test\n  public void testCircleDateLineWrapping() {\n    // left wrapping (-180)\n    circleGeometryConversionDateLineTest(-179.99, 51.22, 5);\n    // right wrapping (+180)\n    circleGeometryConversionDateLineTest(179.99, -35.6, 10);\n  }",
        "error_msg": "org.locationtech.spatial4j.shape.jts.JtsShapeFactoryTest::testCircleDateLineWrapping --> java.lang.IllegalArgumentException: Doesn't support dateline cross yet: Circle(Pt(x=-179.99,y=51.22), d=0.0\u00b0 5.00km)",
        "clean_error_msg": "java.lang.IllegalArgumentException: Doesn't support dateline cross yet: Circle(Pt(x=-179.99,y=51.22), d=0.0\u00b0 5.00km)"
      }
    }
  },
  "Jmimemagic-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/net/sf/jmimemagic/MagicMatch.java",
        "start_loc": 390,
        "end_loc": 422,
        "buggy_function": "    protected Object clone()\n        throws CloneNotSupportedException\n    {\n        MagicMatch clone = new MagicMatch();\n        clone.setBitmask(Long.toString(bitmask, 8));\n        clone.setComparator(\"\" + comparator);\n        clone.setDescription(description);\n        clone.setExtension(extension);\n        clone.setLength(length);\n        clone.setMimeType(mimeType);\n        clone.setOffset(offset);\n\n        // these properties should only be String types, so we shouldn't have to clone them\n\t        HashMap m = new HashMap();\n\t        m.putAll(properties);\n\t        clone.setProperties(m);\n\n        Iterator i = subMatches.iterator();\n        ArrayList a = new ArrayList();\n\n        while (i.hasNext()) {\n            MagicMatch mm = (MagicMatch) i.next();\n            a.add(mm);\n        }\n\n        clone.setSubMatches(a);\n\n        clone.setTest(test);\n        clone.setType(type);\n\n        // TODO Auto-generated method stub\n        return clone;\n    }",
        "fixed_function": "    protected Object clone()\n        throws CloneNotSupportedException\n    {\n        MagicMatch clone = new MagicMatch();\n        clone.setBitmask(Long.toString(bitmask, 8));\n        clone.setComparator(\"\" + comparator);\n        clone.setDescription(description);\n        clone.setExtension(extension);\n        clone.setLength(length);\n        clone.setMimeType(mimeType);\n        clone.setOffset(offset);\n\n        // these properties should only be String types, so we shouldn't have to clone them\n        if(properties!= null) {\n\t        HashMap m = new HashMap();\n\t        m.putAll(properties);\n\t        clone.setProperties(m);\n        }\n\n        Iterator i = subMatches.iterator();\n        ArrayList a = new ArrayList();\n\n        while (i.hasNext()) {\n            MagicMatch mm = (MagicMatch) i.next();\n            a.add(mm);\n        }\n\n        clone.setSubMatches(a);\n\n        clone.setTest(test);\n        clone.setType(type);\n\n        // TODO Auto-generated method stub\n        return clone;\n    }",
        "comment": "/**\n     * DOCUMENT ME!\n     *\n     * @return DOCUMENT ME!\n     *\n     * @throws CloneNotSupportedException DOCUMENT ME!\n     */"
      },
      {
        "path": "src/main/java/net/sf/jmimemagic/MagicMatcher.java",
        "start_loc": 158,
        "end_loc": 275,
        "buggy_function": "    public MagicMatch test(File f, boolean onlyMimeMatch)\n        throws IOException, UnsupportedTypeException\n    {\n        log.debug(\"test(File)\");\n\n        int offset = match.getOffset();\n        String description = match.getDescription();\n        String type = match.getType();\n        String mimeType = match.getMimeType();\n\n        log.debug(\"test(File): testing '\" + f.getName() + \"' for '\" + description + \"'\");\n\n        log.debug(\"test(File): \\n=== BEGIN MATCH INFO ==\");\n        log.debug(match.print());\n        log.debug(\"test(File): \\n=== END MATCH INFO ====\\n\");\n\n        RandomAccessFile file = null;\n        file = new RandomAccessFile(f, \"r\");\n\n        try {\n            int length = 0;\n\n            if (type.equals(\"byte\")) {\n                length = 1;\n            } else if (type.equals(\"short\") || type.equals(\"leshort\") || type.equals(\"beshort\")) {\n                length = 4;\n            } else if (type.equals(\"long\") || type.equals(\"lelong\") || type.equals(\"belong\")) {\n                length = 8;\n            } else if (type.equals(\"string\")) {\n                length = match.getTest().capacity();\n            } else if (type.equals(\"regex\")) {\n                \n                \n                final int matchLength = match.getLength();\n                length = (matchLength == 0) ? (int) file.length() - offset : matchLength;\n\n                if (length < 0) {\n                    length = 0;\n                }\n            } else if (type.equals(\"detector\")) {\n                length = (int) file.length() - offset;\n\n                if (length < 0) {\n                    length = 0;\n                }\n            } else {\n                throw new UnsupportedTypeException(\"unsupported test type '\" + type + \"'\");\n            }\n\n            // we know this match won't work since there isn't enough data for the test\n            if (length > (file.length() - offset)) {\n                return null;\n            }\n\n            byte[] buf = new byte[length];\n            file.seek(offset);\n\n            int bytesRead = 0;\n            int size = 0;\n            boolean gotAllBytes = false;\n            boolean done = false;\n\n            while (!done) {\n                size = file.read(buf, 0, length - bytesRead);\n\n                if (size == -1) {\n                    throw new IOException(\"reached end of file before all bytes were read\");\n                }\n\n                bytesRead += size;\n\n                if (bytesRead == length) {\n                    gotAllBytes = true;\n                    done = true;\n                }\n            }\n\n            log.debug(\"test(File): stream size is '\" + buf.length + \"'\");\n\n            MagicMatch match = null;\n            MagicMatch submatch = null;\n\n            if (testInternal(buf)) {\n                // set the top level match to this one\n                    match = getMatch();\n                    // noop\n\n                log.debug(\"test(File): testing matched '\" + description + \"'\");\n\n                // set the data on this match\n                if ((onlyMimeMatch == false) && (subMatchers != null) && (subMatchers.size() > 0)) {\n                    log.debug(\"test(File): testing \" + subMatchers.size() + \" submatches for '\" +\n                        description + \"'\");\n\n                    for (int i = 0; i < subMatchers.size(); i++) {\n                        log.debug(\"test(File): testing submatch \" + i);\n\n                        MagicMatcher m = (MagicMatcher) subMatchers.get(i);\n\n                        if ((submatch = m.test(f, false)) != null) {\n                            log.debug(\"test(File): submatch \" + i + \" matched with '\" +\n                                submatch.getDescription() + \"'\");\n                            match.addSubMatch(submatch);\n                        } else {\n                            log.debug(\"test(File): submatch \" + i + \" doesn't match\");\n                        }\n                    }\n                }\n            }\n\n            return match;\n        } finally {\n            try {\n                file.close();\n            } catch (Exception fce) {\n            }\n        }\n    }",
        "fixed_function": "    public MagicMatch test(File f, boolean onlyMimeMatch)\n        throws IOException, UnsupportedTypeException\n    {\n        log.debug(\"test(File)\");\n\n        int offset = match.getOffset();\n        String description = match.getDescription();\n        String type = match.getType();\n        String mimeType = match.getMimeType();\n\n        log.debug(\"test(File): testing '\" + f.getName() + \"' for '\" + description + \"'\");\n\n        log.debug(\"test(File): \\n=== BEGIN MATCH INFO ==\");\n        log.debug(match.print());\n        log.debug(\"test(File): \\n=== END MATCH INFO ====\\n\");\n\n        RandomAccessFile file = null;\n        file = new RandomAccessFile(f, \"r\");\n\n        try {\n            int length = 0;\n\n            if (type.equals(\"byte\")) {\n                length = 1;\n            } else if (type.equals(\"short\") || type.equals(\"leshort\") || type.equals(\"beshort\")) {\n                length = 4;\n            } else if (type.equals(\"long\") || type.equals(\"lelong\") || type.equals(\"belong\")) {\n                length = 8;\n            } else if (type.equals(\"string\")) {\n                length = match.getTest().capacity();\n            } else if (type.equals(\"regex\")) {\n                \n                \n                final int matchLength = match.getLength();\n                length = (matchLength == 0) ? (int) file.length() - offset : matchLength;\n\n                if (length < 0) {\n                    length = 0;\n                }\n            } else if (type.equals(\"detector\")) {\n                length = (int) file.length() - offset;\n\n                if (length < 0) {\n                    length = 0;\n                }\n            } else {\n                throw new UnsupportedTypeException(\"unsupported test type '\" + type + \"'\");\n            }\n\n            // we know this match won't work since there isn't enough data for the test\n            if (length > (file.length() - offset)) {\n                return null;\n            }\n\n            byte[] buf = new byte[length];\n            file.seek(offset);\n\n            int bytesRead = 0;\n            int size = 0;\n            boolean gotAllBytes = false;\n            boolean done = false;\n\n            while (!done) {\n                size = file.read(buf, 0, length - bytesRead);\n\n                if (size == -1) {\n                    throw new IOException(\"reached end of file before all bytes were read\");\n                }\n\n                bytesRead += size;\n\n                if (bytesRead == length) {\n                    gotAllBytes = true;\n                    done = true;\n                }\n            }\n\n            log.debug(\"test(File): stream size is '\" + buf.length + \"'\");\n\n            MagicMatch match = null;\n            MagicMatch submatch = null;\n\n            if (testInternal(buf)) {\n                // set the top level match to this one\n                try {\n                    match = getMatch() != null ? (MagicMatch) getMatch()\n                            .clone() : null;\n                } catch (CloneNotSupportedException e) {\n                    // noop\n                }\n\n                log.debug(\"test(File): testing matched '\" + description + \"'\");\n\n                // set the data on this match\n                if ((onlyMimeMatch == false) && (subMatchers != null) && (subMatchers.size() > 0)) {\n                    log.debug(\"test(File): testing \" + subMatchers.size() + \" submatches for '\" +\n                        description + \"'\");\n\n                    for (int i = 0; i < subMatchers.size(); i++) {\n                        log.debug(\"test(File): testing submatch \" + i);\n\n                        MagicMatcher m = (MagicMatcher) subMatchers.get(i);\n\n                        if ((submatch = m.test(f, false)) != null) {\n                            log.debug(\"test(File): submatch \" + i + \" matched with '\" +\n                                submatch.getDescription() + \"'\");\n                            match.addSubMatch(submatch);\n                        } else {\n                            log.debug(\"test(File): submatch \" + i + \" doesn't match\");\n                        }\n                    }\n                }\n            }\n\n            return match;\n        } finally {\n            try {\n                file.close();\n            } catch (Exception fce) {\n            }\n        }\n    }",
        "comment": "/**\n     * test to see if this match or any submatches match\n     *\n     * @param f the file that should be used to test the match\n     * @param onlyMimeMatch DOCUMENT ME!\n     *\n     * @return the deepest magic match object that matched\n     *\n     * @throws IOException DOCUMENT ME!\n     * @throws UnsupportedTypeException DOCUMENT ME!\n     */"
      },
      {
        "path": "src/main/java/net/sf/jmimemagic/MagicMatcher.java",
        "start_loc": 288,
        "end_loc": 377,
        "buggy_function": "    public MagicMatch test(byte[] data, boolean onlyMimeMatch)\n        throws IOException, UnsupportedTypeException\n    {\n        log.debug(\"test(byte[])\");\n\n        int offset = match.getOffset();\n        String description = match.getDescription();\n        String type = match.getType();\n        String test = new String(match.getTest().array());\n        String mimeType = match.getMimeType();\n\n        log.debug(\"test(byte[]): testing byte[] data for '\" + description + \"'\");\n\n        log.debug(\"test(byte[]): \\n=== BEGIN MATCH INFO ==\");\n        log.debug(match.print());\n        log.debug(\"test(byte[]): \\n=== END MATCH INFO ====\\n\");\n\n        int length = 0;\n\n        if (type.equals(\"byte\")) {\n            length = 1;\n        } else if (type.equals(\"short\") || type.equals(\"leshort\") || type.equals(\"beshort\")) {\n            length = 4;\n        } else if (type.equals(\"long\") || type.equals(\"lelong\") || type.equals(\"belong\")) {\n            length = 8;\n        } else if (type.equals(\"string\")) {\n            length = match.getTest().capacity();\n        } else if (type.equals(\"regex\")) {\n            // FIXME - something wrong here, shouldn't have to subtract 1???\n            length = data.length - offset - 1;\n\n            if (length < 0) {\n                length = 0;\n            }\n        } else if (type.equals(\"detector\")) {\n            // FIXME - something wrong here, shouldn't have to subtract 1???\n            length = data.length - offset - 1;\n\n            if (length < 0) {\n                length = 0;\n            }\n        } else {\n            throw new UnsupportedTypeException(\"unsupported test type \" + type);\n        }\n\n        byte[] buf = new byte[length];\n        log.debug(\"test(byte[]): offset=\" + offset + \",length=\" + length + \",data length=\" +\n            data.length);\n\n        if ((offset + length) < data.length) {\n            System.arraycopy(data, offset, buf, 0, length);\n\n            log.debug(\"test(byte[]): stream size is '\" + buf.length + \"'\");\n\n            MagicMatch match = null;\n            MagicMatch submatch = null;\n\n            if (testInternal(buf)) {\n                // set the top level match to this one\n                    match = getMatch();\n                    // noop\n\n                log.debug(\"test(byte[]): testing matched '\" + description + \"'\");\n\n                // set the data on this match\n                if ((onlyMimeMatch == false) && (subMatchers != null) && (subMatchers.size() > 0)) {\n                    log.debug(\"test(byte[]): testing \" + subMatchers.size() + \" submatches for '\" +\n                        description + \"'\");\n\n                    for (int i = 0; i < subMatchers.size(); i++) {\n                        log.debug(\"test(byte[]): testing submatch \" + i);\n\n                        MagicMatcher m = (MagicMatcher) subMatchers.get(i);\n\n                        if ((submatch = m.test(data, false)) != null) {\n                            log.debug(\"test(byte[]): submatch \" + i + \" matched with '\" +\n                                submatch.getDescription() + \"'\");\n                            match.addSubMatch(submatch);\n                        } else {\n                            log.debug(\"test(byte[]): submatch \" + i + \" doesn't match\");\n                        }\n                    }\n                }\n            }\n\n            return match;\n        } else {\n            return null;\n        }\n    }",
        "fixed_function": "    public MagicMatch test(byte[] data, boolean onlyMimeMatch)\n        throws IOException, UnsupportedTypeException\n    {\n        log.debug(\"test(byte[])\");\n\n        int offset = match.getOffset();\n        String description = match.getDescription();\n        String type = match.getType();\n        String test = new String(match.getTest().array());\n        String mimeType = match.getMimeType();\n\n        log.debug(\"test(byte[]): testing byte[] data for '\" + description + \"'\");\n\n        log.debug(\"test(byte[]): \\n=== BEGIN MATCH INFO ==\");\n        log.debug(match.print());\n        log.debug(\"test(byte[]): \\n=== END MATCH INFO ====\\n\");\n\n        int length = 0;\n\n        if (type.equals(\"byte\")) {\n            length = 1;\n        } else if (type.equals(\"short\") || type.equals(\"leshort\") || type.equals(\"beshort\")) {\n            length = 4;\n        } else if (type.equals(\"long\") || type.equals(\"lelong\") || type.equals(\"belong\")) {\n            length = 8;\n        } else if (type.equals(\"string\")) {\n            length = match.getTest().capacity();\n        } else if (type.equals(\"regex\")) {\n            // FIXME - something wrong here, shouldn't have to subtract 1???\n            length = data.length - offset - 1;\n\n            if (length < 0) {\n                length = 0;\n            }\n        } else if (type.equals(\"detector\")) {\n            // FIXME - something wrong here, shouldn't have to subtract 1???\n            length = data.length - offset - 1;\n\n            if (length < 0) {\n                length = 0;\n            }\n        } else {\n            throw new UnsupportedTypeException(\"unsupported test type \" + type);\n        }\n\n        byte[] buf = new byte[length];\n        log.debug(\"test(byte[]): offset=\" + offset + \",length=\" + length + \",data length=\" +\n            data.length);\n\n        if ((offset + length) < data.length) {\n            System.arraycopy(data, offset, buf, 0, length);\n\n            log.debug(\"test(byte[]): stream size is '\" + buf.length + \"'\");\n\n            MagicMatch match = null;\n            MagicMatch submatch = null;\n\n            if (testInternal(buf)) {\n                // set the top level match to this one\n                try {\n                    match = getMatch() != null ? (MagicMatch) getMatch()\n                            .clone() : null;\n                } catch (CloneNotSupportedException e) {\n                    // noop\n                }\n\n                log.debug(\"test(byte[]): testing matched '\" + description + \"'\");\n\n                // set the data on this match\n                if ((onlyMimeMatch == false) && (subMatchers != null) && (subMatchers.size() > 0)) {\n                    log.debug(\"test(byte[]): testing \" + subMatchers.size() + \" submatches for '\" +\n                        description + \"'\");\n\n                    for (int i = 0; i < subMatchers.size(); i++) {\n                        log.debug(\"test(byte[]): testing submatch \" + i);\n\n                        MagicMatcher m = (MagicMatcher) subMatchers.get(i);\n\n                        if ((submatch = m.test(data, false)) != null) {\n                            log.debug(\"test(byte[]): submatch \" + i + \" matched with '\" +\n                                submatch.getDescription() + \"'\");\n                            match.addSubMatch(submatch);\n                        } else {\n                            log.debug(\"test(byte[]): submatch \" + i + \" doesn't match\");\n                        }\n                    }\n                }\n            }\n\n            return match;\n        } else {\n            return null;\n        }\n    }",
        "comment": "/**\n     * test to see if this match or any submatches match\n     *\n     * @param data the data that should be used to test the match\n     * @param onlyMimeMatch DOCUMENT ME!\n     *\n     * @return the deepest magic match object that matched\n     *\n     * @throws IOException DOCUMENT ME!\n     * @throws UnsupportedTypeException DOCUMENT ME!\n     */"
      }
    ],
    "trigger_test": {
      "net.sf.jmimemagic.MagicTest::testSubMatches": {
        "path": "net/sf/jmimemagic/MagicTest.java",
        "function_name": "testSubMatches",
        "src": "public void testSubMatches(){\n        System.out.print(\"\\ntesting Submatches...\");\n        try {\n            MagicMatch match = Magic.getMagicMatch(new File(gifFile), true, false);\n            Assert.assertEquals(3, match.getSubMatches().size());\n            match = Magic.getMagicMatch(new File(gifFile), true, false);\n            Assert.assertEquals(3, match.getSubMatches().size());           \n            System.out.print(\"ok\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"exception in testSubMatches(). message: \" + e);\n        } catch (Error e) {\n            e.printStackTrace();\n            fail(\"error in testSubMatches(). message: \" + e.getMessage());\n        }\n        \n    }",
        "error_msg": "net.sf.jmimemagic.MagicTest::testSubMatches --> junit.framework.AssertionFailedError: error in testSubMatches(). message: expected:<3> but was:<6>",
        "clean_error_msg": "junit.framework.AssertionFailedError: error in testSubMatches(). message: expected:<3> but was:<6>"
      }
    }
  },
  "Markedj-3": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Lexer.java",
        "start_loc": 40,
        "end_loc": 327,
        "buggy_function": "    protected void token(String src, boolean top, boolean bq, LexerContext context){\n        while(src.length() > 0){\n            // newline\n            {\n                List<String> cap = rules.get(\"newline\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(0).length() > 1){\n                        context.pushToken(new SpaceToken());\n                    }\n                }\n            }\n\n            // code\n            {\n                List<String> cap = rules.get(\"code\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    String code = cap.get(0).replaceAll(\"(?m)^ {4}\", \"\");\n                    if(!options.isPedantic()){\n                        context.pushToken(new CodeToken(code.replaceAll(\"\\\\n+$\", \"\"), null, false));\n                    } else {\n                        context.pushToken(new CodeToken(code, null, false));\n                    }\n                    continue;\n                }\n            }\n\n            // fences (gfm)\n            {\n                List<String> cap = rules.get(\"fences\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new CodeToken(cap.get(3), cap.get(2), false));\n                    continue;\n                }\n            }\n\n            // heading\n            {\n                List<String> cap = rules.get(\"heading\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2)));\n                    continue;\n                }\n            }\n\n            // table no leading pipe (gfm)\n            if(top){\n                List<String> cap = rules.get(\"nptable\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n\n                    String[] headers = cap.get(1).replaceAll(\"^ *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] aligns  = cap.get(2).replaceAll(\"^ *|\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] rows    = cap.get(3).replaceAll(\"\\n$\", \"\").split(\"\\n\");\n\n                    List<String> headerList = array2list(headers);\n\n                    List<String> alignList = new ArrayList<>();\n                    for (String s : aligns) {\n                        if(s.matches(\"^ *-+: *$\")){\n                            alignList.add(\"right\");\n                        } else if(s.matches(\"^ *:-+: *$\")){\n                            alignList.add(\"center\");\n                        } else if(s.matches(\"^ *:-+ *$\")){\n                            alignList.add(\"left\");\n                        } else {\n                            alignList.add(null);\n                        }\n                    }\n\n                    int maxColumns = Math.max(headers.length, aligns.length);\n\n                    List<List<String>> rowList = new ArrayList<>();\n                    for (String row : rows) {\n                        String[] columns = row.split(\" *\\\\| *\");\n                        rowList.add(array2list(columns));\n                    }\n\n                    fillList(headerList, maxColumns, \"\");\n                    fillList(alignList, maxColumns, null);\n                    for(List<String> row: rowList){\n                        fillList(row, maxColumns, \"\");\n                    }\n\n                    context.pushToken(new TableToken(headerList, alignList, rowList));\n                    continue;\n                }\n            }\n\n            // lheading\n            {\n                List<String> cap = rules.get(\"lheading\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(2).equals(\"=\")){\n                        context.pushToken(new HeadingToken(1, cap.get(1)));\n                    } else {\n                        context.pushToken(new HeadingToken(2, cap.get(1)));\n                    }\n                    continue;\n                }\n            }\n\n            // hr\n            {\n                List<String> cap = rules.get(\"hr\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new HrToken());\n                    continue;\n                }\n            }\n\n            // blockquote\n            {\n                List<String> cap = rules.get(\"blockquote\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new BlockquoteStartToken());\n                    token(cap.get(0).replaceAll(\"(?m) *> ?\", \"\"), top, true, context);\n                    context.pushToken(new BlockquoteEndToken());\n                    continue;\n                }\n            }\n\n            // list\n            {\n                List<String> cap = rules.get(\"list\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    String bull = cap.get(2);\n\n                    context.pushToken(new ListStartToken(bull.matches(\"^[0-9]+\\\\.$\")));\n                    boolean next = false;\n\n                    // Get each top-level item.\n                    cap = rules.get(\"item\").exec(cap.get(0));\n                    if(!cap.isEmpty()){\n                        for(int i = 0; i < cap.size(); i++){\n                            String item = cap.get(i);\n\n                            // Remove the list item's bullet\n                            // so it is seen as the nextToken token.\n                            int space = item.length();\n                            item = item.replaceAll(\"^ *([*+-]|\\\\d+\\\\.) +\", \"\");\n\n                            // Outdent whatever the\n                            // list item contains. Hacky.\n                            if(item.indexOf(\"\\n \") > 0){\n                                space = space - item.length();\n                                if(!options.isPedantic()){\n                                    item = item.replaceAll(\"(?m)^ {1,\" + space + \"}\", \"\");\n                                } else {\n                                    item = item.replaceAll(\"(?m)^ {1,4}\", \"\");\n                                }\n                            }\n\n//                            // Determine whether the nextToken list item belongs here.\n//                            // Backpedal if it does not belong in this list.\n//                            if(options.isSmartLists() && i != cap.size() - 1){\n//                                Pattern p = Pattern.compile(Grammer.BULLET);\n//                                if(p.matcher(cap.get(i + 1)).find()){\n//                                    src = String.join(\"\\n\", cap.subList(i + 1, cap.size())) + src;\n//                                    i = i - 1;\n//                                }\n//                            }\n\n                            // Determine whether item is loose or not.\n                            // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n                            // for discount behavior.\n                            boolean loose = next || item.matches(\"\\\\n\\\\n(?!\\\\s*$)\");\n                            if(i != cap.size() - 1){\n                                next = !item.isEmpty() && item.charAt(item.length() - 1) == '\\n';\n                                if(!loose) {\n                                    loose = next;\n                                }\n                            }\n\n                            if(loose){\n                                context.pushToken(new LooseItemStartToken());\n                            } else {\n                                context.pushToken(new ListItemStartToken());\n                            }\n\n                            token(item, false, bq, context);\n                            context.pushToken(new ListItemEndToken());\n                        }\n                    }\n                    context.pushToken(new ListEndToken());\n                    continue;\n                }\n            }\n\n            // html\n            {\n                List<String> cap = rules.get(\"html\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(options.isSanitize()){\n                        context.pushToken(new ParagraphToken(cap.get(0)));\n                    } else {\n                        context.pushToken(new HtmlToken(cap.get(0),\n                                !options.isSanitize() && (cap.get(0).equals(\"pre\") || cap.get(0).equals(\"script\") || cap.get(0).equals(\"style\"))));\n                    }\n                    continue;\n                }\n            }\n\n            // def\n            if(!bq && top){\n                List<String> cap = rules.get(\"def\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3)));\n                    continue;\n                }\n            }\n\n            // table (gfm)\n            if(top){\n                List<String> cap = rules.get(\"table\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n\n                    String[] headers = cap.get(1).replaceAll(\"^ *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] aligns  = cap.get(2).replaceAll(\"^ *|\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] rows    = cap.get(3).replaceAll(\"(?: *\\\\| *)?\\\\n$\", \"\").split(\"\\\\n\");\n\n                    List<String> headerList = array2list(headers);\n\n                    List<String> alignList = new ArrayList<>();\n                    for (String s : aligns) {\n                        if(s.matches(\"^ *-+: *$\")){\n                            alignList.add(\"right\");\n                        } else if(s.matches(\"^ *:-+: *$\")){\n                            alignList.add(\"center\");\n                        } else if(s.matches(\"^ *:-+ *$\")){\n                            alignList.add(\"left\");\n                        } else {\n                            alignList.add(null);\n                        }\n                    }\n\n                    int maxColumns = Math.max(headers.length, aligns.length);\n\n                    List<List<String>> rowList = new ArrayList<>();\n                    for (String row : rows) {\n                        String[] columns = row.replaceAll(\"^ *\\\\| *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                        rowList.add(array2list(columns));\n                    }\n\n\n                    context.pushToken(new TableToken(headerList, alignList, rowList));\n                    continue;\n                }\n            }\n\n            // top-level paragraph\n            if(top){\n                List<String> cap = rules.get(\"paragraph\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(1).charAt(cap.get(1).length() - 1) == '\\n'){\n                        context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1)));\n                    } else {\n                        context.pushToken(new ParagraphToken(cap.get(1)));\n                    }\n                    continue;\n                }\n            }\n\n            // text\n            {\n                List<String> cap = rules.get(\"text\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new TextToken((cap.get(0))));\n                    continue;\n                }\n            }\n\n            // TODO Error\n            //println(\"Infinite loop on byte: \" + source.charAt(0).toByte)\n        }\n    }",
        "fixed_function": "    protected void token(String src, boolean top, boolean bq, LexerContext context){\n        while(src.length() > 0){\n            // newline\n            {\n                List<String> cap = rules.get(\"newline\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(0).length() > 1){\n                        context.pushToken(new SpaceToken());\n                    }\n                }\n            }\n\n            // code\n            {\n                List<String> cap = rules.get(\"code\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    String code = cap.get(0).replaceAll(\"(?m)^ {4}\", \"\");\n                    if(!options.isPedantic()){\n                        context.pushToken(new CodeToken(code.replaceAll(\"\\\\n+$\", \"\"), null, false));\n                    } else {\n                        context.pushToken(new CodeToken(code, null, false));\n                    }\n                    continue;\n                }\n            }\n\n            // fences (gfm)\n            {\n                List<String> cap = rules.get(\"fences\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new CodeToken(cap.get(3), cap.get(2), false));\n                    continue;\n                }\n            }\n\n            // heading\n            {\n                List<String> cap = rules.get(\"heading\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2)));\n                    continue;\n                }\n            }\n\n            // table no leading pipe (gfm)\n            if(top){\n                List<String> cap = rules.get(\"nptable\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n\n                    String[] headers = cap.get(1).replaceAll(\"^ *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] aligns  = cap.get(2).replaceAll(\"^ *|\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] rows    = cap.get(3).replaceAll(\"\\n$\", \"\").split(\"\\n\");\n\n                    List<String> headerList = array2list(headers);\n\n                    List<String> alignList = new ArrayList<>();\n                    for (String s : aligns) {\n                        if(s.matches(\"^ *-+: *$\")){\n                            alignList.add(\"right\");\n                        } else if(s.matches(\"^ *:-+: *$\")){\n                            alignList.add(\"center\");\n                        } else if(s.matches(\"^ *:-+ *$\")){\n                            alignList.add(\"left\");\n                        } else {\n                            alignList.add(null);\n                        }\n                    }\n\n                    int maxColumns = Math.max(headers.length, aligns.length);\n\n                    List<List<String>> rowList = new ArrayList<>();\n                    for (String row : rows) {\n                        String[] columns = row.split(\" *\\\\| *\");\n                        if(maxColumns < columns.length){\n                            maxColumns = columns.length;\n                        }\n                        rowList.add(array2list(columns));\n                    }\n\n                    fillList(headerList, maxColumns, \"\");\n                    fillList(alignList, maxColumns, null);\n                    for(List<String> row: rowList){\n                        fillList(row, maxColumns, \"\");\n                    }\n\n                    context.pushToken(new TableToken(headerList, alignList, rowList));\n                    continue;\n                }\n            }\n\n            // lheading\n            {\n                List<String> cap = rules.get(\"lheading\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(2).equals(\"=\")){\n                        context.pushToken(new HeadingToken(1, cap.get(1)));\n                    } else {\n                        context.pushToken(new HeadingToken(2, cap.get(1)));\n                    }\n                    continue;\n                }\n            }\n\n            // hr\n            {\n                List<String> cap = rules.get(\"hr\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new HrToken());\n                    continue;\n                }\n            }\n\n            // blockquote\n            {\n                List<String> cap = rules.get(\"blockquote\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new BlockquoteStartToken());\n                    token(cap.get(0).replaceAll(\"(?m) *> ?\", \"\"), top, true, context);\n                    context.pushToken(new BlockquoteEndToken());\n                    continue;\n                }\n            }\n\n            // list\n            {\n                List<String> cap = rules.get(\"list\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    String bull = cap.get(2);\n\n                    context.pushToken(new ListStartToken(bull.matches(\"^[0-9]+\\\\.$\")));\n                    boolean next = false;\n\n                    // Get each top-level item.\n                    cap = rules.get(\"item\").exec(cap.get(0));\n                    if(!cap.isEmpty()){\n                        for(int i = 0; i < cap.size(); i++){\n                            String item = cap.get(i);\n\n                            // Remove the list item's bullet\n                            // so it is seen as the nextToken token.\n                            int space = item.length();\n                            item = item.replaceAll(\"^ *([*+-]|\\\\d+\\\\.) +\", \"\");\n\n                            // Outdent whatever the\n                            // list item contains. Hacky.\n                            if(item.indexOf(\"\\n \") > 0){\n                                space = space - item.length();\n                                if(!options.isPedantic()){\n                                    item = item.replaceAll(\"(?m)^ {1,\" + space + \"}\", \"\");\n                                } else {\n                                    item = item.replaceAll(\"(?m)^ {1,4}\", \"\");\n                                }\n                            }\n\n//                            // Determine whether the nextToken list item belongs here.\n//                            // Backpedal if it does not belong in this list.\n//                            if(options.isSmartLists() && i != cap.size() - 1){\n//                                Pattern p = Pattern.compile(Grammer.BULLET);\n//                                if(p.matcher(cap.get(i + 1)).find()){\n//                                    src = String.join(\"\\n\", cap.subList(i + 1, cap.size())) + src;\n//                                    i = i - 1;\n//                                }\n//                            }\n\n                            // Determine whether item is loose or not.\n                            // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n                            // for discount behavior.\n                            boolean loose = next || item.matches(\"\\\\n\\\\n(?!\\\\s*$)\");\n                            if(i != cap.size() - 1){\n                                next = !item.isEmpty() && item.charAt(item.length() - 1) == '\\n';\n                                if(!loose) {\n                                    loose = next;\n                                }\n                            }\n\n                            if(loose){\n                                context.pushToken(new LooseItemStartToken());\n                            } else {\n                                context.pushToken(new ListItemStartToken());\n                            }\n\n                            token(item, false, bq, context);\n                            context.pushToken(new ListItemEndToken());\n                        }\n                    }\n                    context.pushToken(new ListEndToken());\n                    continue;\n                }\n            }\n\n            // html\n            {\n                List<String> cap = rules.get(\"html\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(options.isSanitize()){\n                        context.pushToken(new ParagraphToken(cap.get(0)));\n                    } else {\n                        context.pushToken(new HtmlToken(cap.get(0),\n                                !options.isSanitize() && (cap.get(0).equals(\"pre\") || cap.get(0).equals(\"script\") || cap.get(0).equals(\"style\"))));\n                    }\n                    continue;\n                }\n            }\n\n            // def\n            if(!bq && top){\n                List<String> cap = rules.get(\"def\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3)));\n                    continue;\n                }\n            }\n\n            // table (gfm)\n            if(top){\n                List<String> cap = rules.get(\"table\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n\n                    String[] headers = cap.get(1).replaceAll(\"^ *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] aligns  = cap.get(2).replaceAll(\"^ *|\\\\| *$\", \"\").split(\" *\\\\| *\");\n                    String[] rows    = cap.get(3).replaceAll(\"(?: *\\\\| *)?\\\\n$\", \"\").split(\"\\\\n\");\n\n                    List<String> headerList = array2list(headers);\n\n                    List<String> alignList = new ArrayList<>();\n                    for (String s : aligns) {\n                        if(s.matches(\"^ *-+: *$\")){\n                            alignList.add(\"right\");\n                        } else if(s.matches(\"^ *:-+: *$\")){\n                            alignList.add(\"center\");\n                        } else if(s.matches(\"^ *:-+ *$\")){\n                            alignList.add(\"left\");\n                        } else {\n                            alignList.add(null);\n                        }\n                    }\n\n                    int maxColumns = Math.max(headers.length, aligns.length);\n\n                    List<List<String>> rowList = new ArrayList<>();\n                    for (String row : rows) {\n                        String[] columns = row.replaceAll(\"^ *\\\\| *| *\\\\| *$\", \"\").split(\" *\\\\| *\");\n                        if(maxColumns < columns.length){\n                            maxColumns = columns.length;\n                        }\n                        rowList.add(array2list(columns));\n                    }\n\n                    fillList(headerList, maxColumns, \"\");\n                    fillList(alignList, maxColumns, null);\n                    for(List<String> row: rowList){\n                        fillList(row, maxColumns, \"\");\n                    }\n\n                    context.pushToken(new TableToken(headerList, alignList, rowList));\n                    continue;\n                }\n            }\n\n            // top-level paragraph\n            if(top){\n                List<String> cap = rules.get(\"paragraph\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    if(cap.get(1).charAt(cap.get(1).length() - 1) == '\\n'){\n                        context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1)));\n                    } else {\n                        context.pushToken(new ParagraphToken(cap.get(1)));\n                    }\n                    continue;\n                }\n            }\n\n            // text\n            {\n                List<String> cap = rules.get(\"text\").exec(src);\n                if(!cap.isEmpty()){\n                    src = src.substring(cap.get(0).length());\n                    context.pushToken(new TextToken((cap.get(0))));\n                    continue;\n                }\n            }\n\n            // TODO Error\n            //println(\"Infinite loop on byte: \" + source.charAt(0).toByte)\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Parser.java",
        "start_loc": 53,
        "end_loc": 167,
        "buggy_function": "    protected String tok(ParserContext context){\n        switch(context.currentToken().getType()){\n            case \"SpaceToken\": {\n                return \"\";\n            }\n            case \"HrToken\": {\n                return renderer.hr();\n            }\n            case \"HeadingToken\": {\n                HeadingToken t = (HeadingToken) context.currentToken();\n                return renderer.heading(context.getInlineLexer().output(t.getText()), t.getDepth(), t.getText());\n            }\n            case \"CodeToken\": {\n                CodeToken t = (CodeToken) context.currentToken();\n                return renderer.code(t.getCode(), t.getLang(), t.isEscaped());\n            }\n            case \"TableToken\": {\n                TableToken t = (TableToken) context.currentToken();\n                StringBuilder outCell   = new StringBuilder();\n                StringBuilder outHeader = new StringBuilder();\n                StringBuilder outBody   = new StringBuilder();\n\n                for(int i = 0; i < t.getHeader().size(); i++){\n                    String align = null;\n                    if(t.getAlign().size() > i){\n                        align = t.getAlign().get(i);\n                    }\n                    outCell.append(renderer.tablecell(\n                            context.getInlineLexer().output(t.getHeader().get(i)), new Renderer.TableCellFlags(true, align)));\n                }\n                outHeader.append(renderer.tablerow(outCell.toString()));\n\n                for(int i = 0; i < t.getCells().size(); i++){\n                    outCell.setLength(0);\n                    for(int j = 0; j < t.getCells().get(i).size(); j++){\n                        String align = null;\n                        if(t.getAlign().size() > j){\n                            align = t.getAlign().get(j);\n                        }\n                        outCell.append(renderer.tablecell(\n                                context.getInlineLexer().output(t.getCells().get(i).get(j)), new Renderer.TableCellFlags(false, align)));\n                    }\n                    outBody.append(renderer.tablerow(outCell.toString()));\n                }\n                return renderer.table(outHeader.toString(), outBody.toString());\n            }\n            case \"BlockquoteStartToken\": {\n                StringBuilder body = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"BlockquoteEndToken\")){\n                        break;\n                    }\n                    body.append(tok(context));\n                }\n                return renderer.blockquote(body.toString());\n            }\n            case \"ListStartToken\": {\n                ListStartToken t = (ListStartToken) context.currentToken();\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListEndToken\")){\n                        break;\n                    }\n                    out.append(tok(context));\n                }\n                return renderer.list(out.toString(), t.isOrderd());\n            }\n            case \"ListItemStartToken\": {\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListItemEndToken\")){\n                        break;\n                    }\n                    if(context.currentToken().getType().equals(\"TextToken\")){\n                        out.append(parseText(context));\n                    } else {\n                        out.append(tok(context));\n                    }\n                }\n                return renderer.listitem(out.toString());\n            }\n            case \"LooseItemStartToken\": {\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListItemEndToken\")){\n                        break;\n                    }\n                    out.append(tok(context));\n                }\n                return renderer.listitem(out.toString());\n            }\n            case \"HtmlToken\": {\n                HtmlToken t = (HtmlToken) context.currentToken();\n                if(!t.isPre() && !options.isPedantic()){\n                    return renderer.html(context.getInlineLexer().output(t.getText()));\n                } else {\n                    return renderer.html(t.getText());\n                }\n            }\n            case \"ParagraphToken\": {\n                ParagraphToken t = (ParagraphToken) context.currentToken();\n                return renderer.paragraph(context.getInlineLexer().output(t.getText()));\n            }\n            case \"TextToken\": {\n                return renderer.paragraph(parseText(context));\n            }\n            default: {\n                throw new RuntimeException(\"Unexpected token: \" + context.currentToken());\n            }\n        }\n    }",
        "fixed_function": "    protected String tok(ParserContext context){\n        switch(context.currentToken().getType()){\n            case \"SpaceToken\": {\n                return \"\";\n            }\n            case \"HrToken\": {\n                return renderer.hr();\n            }\n            case \"HeadingToken\": {\n                HeadingToken t = (HeadingToken) context.currentToken();\n                return renderer.heading(context.getInlineLexer().output(t.getText()), t.getDepth(), t.getText());\n            }\n            case \"CodeToken\": {\n                CodeToken t = (CodeToken) context.currentToken();\n                return renderer.code(t.getCode(), t.getLang(), t.isEscaped());\n            }\n            case \"TableToken\": {\n                TableToken t = (TableToken) context.currentToken();\n                StringBuilder outCell   = new StringBuilder();\n                StringBuilder outHeader = new StringBuilder();\n                StringBuilder outBody   = new StringBuilder();\n\n                for(int i = 0; i < t.getHeader().size(); i++){\n                    outCell.append(renderer.tablecell(\n                            context.getInlineLexer().output(t.getHeader().get(i)), new Renderer.TableCellFlags(true, t.getAlign().get(i))));\n                }\n                outHeader.append(renderer.tablerow(outCell.toString()));\n\n                for(int i = 0; i < t.getCells().size(); i++){\n                    outCell.setLength(0);\n                    for(int j = 0; j < t.getCells().get(i).size(); j++){\n                        outCell.append(renderer.tablecell(\n                                context.getInlineLexer().output(t.getCells().get(i).get(j)), new Renderer.TableCellFlags(false, t.getAlign().get(j))));\n                    }\n                    outBody.append(renderer.tablerow(outCell.toString()));\n                }\n                return renderer.table(outHeader.toString(), outBody.toString());\n            }\n            case \"BlockquoteStartToken\": {\n                StringBuilder body = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"BlockquoteEndToken\")){\n                        break;\n                    }\n                    body.append(tok(context));\n                }\n                return renderer.blockquote(body.toString());\n            }\n            case \"ListStartToken\": {\n                ListStartToken t = (ListStartToken) context.currentToken();\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListEndToken\")){\n                        break;\n                    }\n                    out.append(tok(context));\n                }\n                return renderer.list(out.toString(), t.isOrderd());\n            }\n            case \"ListItemStartToken\": {\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListItemEndToken\")){\n                        break;\n                    }\n                    if(context.currentToken().getType().equals(\"TextToken\")){\n                        out.append(parseText(context));\n                    } else {\n                        out.append(tok(context));\n                    }\n                }\n                return renderer.listitem(out.toString());\n            }\n            case \"LooseItemStartToken\": {\n                StringBuilder out = new StringBuilder();\n                while(true){\n                    Token n = context.nextToken();\n                    if(n == null || n.getType().equals(\"ListItemEndToken\")){\n                        break;\n                    }\n                    out.append(tok(context));\n                }\n                return renderer.listitem(out.toString());\n            }\n            case \"HtmlToken\": {\n                HtmlToken t = (HtmlToken) context.currentToken();\n                if(!t.isPre() && !options.isPedantic()){\n                    return renderer.html(context.getInlineLexer().output(t.getText()));\n                } else {\n                    return renderer.html(t.getText());\n                }\n            }\n            case \"ParagraphToken\": {\n                ParagraphToken t = (ParagraphToken) context.currentToken();\n                return renderer.paragraph(context.getInlineLexer().output(t.getText()));\n            }\n            case \"TextToken\": {\n                return renderer.paragraph(parseText(context));\n            }\n            default: {\n                throw new RuntimeException(\"Unexpected token: \" + context.currentToken());\n            }\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "io.github.gitbucket.markedj.MarkedTest::testEmptyTableCell": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testEmptyTableCell",
        "src": "@Test\n    public void testEmptyTableCell() throws Exception {\n        String result = Marked.marked(\n                \"|ID|name|note|\\n\" +\n                \"|-|-|-|\\n\" +\n                \"|1|foo|This is foo|\\n\" +\n                \"|2|bar||\");\n\n\n        assertEquals(\n                \"<table>\\n\" +\n                        \"<thead>\\n\" +\n                        \"<tr>\\n\" +\n                        \"<th>ID</th>\\n\" +\n                        \"<th>name</th>\\n\" +\n                        \"<th>note</th>\\n\" +\n                        \"</tr>\\n\" +\n                        \"</thead>\\n\" +\n                        \"<tbody>\\n\" +\n                        \"<tr>\\n\" +\n                        \"<td>1</td>\\n\" +\n                        \"<td>foo</td>\\n\" +\n                        \"<td>This is foo</td>\\n\" +\n                        \"</tr>\\n\" +\n                        \"<tr>\\n\" +\n                        \"<td>2</td>\\n\" +\n                        \"<td>bar</td>\\n\" +\n                        \"<td></td>\\n\" +\n                        \"</tr>\\n\" +\n                        \"</tbody>\\n\" +\n                        \"</table>\\n\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testEmptyTableCell --> junit.framework.AssertionFailedError: expected:<...</td>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...</td>"
      },
      "io.github.gitbucket.markedj.MarkedTest::testInvalidColumnTable": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testInvalidColumnTable",
        "src": "@Test\n    public void testInvalidColumnTable() throws Exception {\n        {\n            String result = Marked.marked(loadResourceAsString(\"table.md\"), new Options());\n            assertEquals(loadResourceAsString(\"table.html\"), result);\n        }\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testInvalidColumnTable --> junit.framework.AssertionFailedError: expected:<...a</th>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...a</th>"
      }
    }
  },
  "Markedj-5": {
    "function_num": 7,
    "functions": [
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Marked.java",
        "start_loc": 17,
        "end_loc": 25,
        "buggy_function": "    public static String marked(String src, Options options, Renderer renderer){\n        Lexer lexer = new Lexer(options);\n        Lexer.LexerResult result = lexer.lex(src);\n        Parser parser = new Parser(options, renderer);\n        String html = parser.parse(result.getTokens(), result.getLinks());\n\n\n            return html;\n    }",
        "fixed_function": "    public static String marked(String src, Options options, Renderer renderer){\n        Lexer lexer = new Lexer(options);\n        Lexer.LexerResult result = lexer.lex(src);\n        Parser parser = new Parser(options, renderer);\n        String html = parser.parse(result.getTokens(), result.getLinks());\n\n        Whitelist whitelist = options.getWhitelist();\n\n        if(whitelist != null) {\n            return Jsoup.clean(html, whitelist);\n        } else {\n            return html;\n        }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Options.java",
        "start_loc": 39,
        "end_loc": 41,
        "buggy_function": "    public void setXhtml(boolean xhtml) {\n        this.xhtml = xhtml;\n    }",
        "fixed_function": "    public void setWhitelist(Whitelist whitelist){\n        this.whitelist = whitelist;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Options.java",
        "start_loc": 67,
        "end_loc": 69,
        "buggy_function": "    public boolean isXhtml() {\n        return xhtml;\n    }",
        "fixed_function": "    public Whitelist getWhitelist(){\n        return whitelist;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Renderer.java",
        "start_loc": 50,
        "end_loc": 56,
        "buggy_function": "    public String hr() {\n        if (options.isXhtml()){\n            return \"<hr/>\\n\";\n        } else {\n        return \"<hr>\\n\";\n        }\n    }",
        "fixed_function": "    public String hr() {\n        return \"<hr>\\n\";\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Renderer.java",
        "start_loc": 112,
        "end_loc": 118,
        "buggy_function": "    public String br(){\n        if(options.isXhtml()){\n            return \"<br/>\";\n        } else {\n        return \"<br>\";\n        }\n    }",
        "fixed_function": "    public String br(){\n        return \"<br>\";\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Renderer.java",
        "start_loc": 124,
        "end_loc": 133,
        "buggy_function": "    public String link(String href, String title, String text){\n        if(options.isSanitize()){\n        }\n        String titleAttr = \"\";\n        if(title != null){\n            titleAttr = \" title=\\\"\" + title + \"\\\"\";\n        }\n\n        return \"<a href=\\\"\" + href + \"\\\"\" + titleAttr + \">\" + text + \"</a>\";\n    }",
        "fixed_function": "    public String link(String href, String title, String text){\n        String titleAttr = \"\";\n        if(title != null){\n            titleAttr = \" title=\\\"\" + title + \"\\\"\";\n        }\n\n        return \"<a href=\\\"\" + href + \"\\\"\" + titleAttr + \">\" + text + \"</a>\";\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/io/github/gitbucket/markedj/Renderer.java",
        "start_loc": 135,
        "end_loc": 146,
        "buggy_function": "    public String image(String href, String title, String text){\n        String titleAttr = \"\";\n        if(title != null){\n            titleAttr = \" title=\\\"\" + title + \"\\\"\";\n        }\n\n        if(options.isXhtml()){\n            return \"<img src=\\\"\" + href + \"\\\" alt=\\\"\" + text + \"\\\"\" + titleAttr + \"/>\";\n        } else {\n        return \"<img src=\\\"\" + href + \"\\\" alt=\\\"\" + text + \"\\\"\" + titleAttr + \">\";\n        }\n    }",
        "fixed_function": "    public String image(String href, String title, String text){\n        String titleAttr = \"\";\n        if(title != null){\n            titleAttr = \" title=\\\"\" + title + \"\\\"\";\n        }\n\n        return \"<img src=\\\"\" + href + \"\\\" alt=\\\"\" + text + \"\\\"\" + titleAttr + \">\";\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "io.github.gitbucket.markedj.MarkedTest::testAutolink": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testAutolink",
        "src": "@Test\n    public void testAutolink() throws Exception {\n        String result = Marked.marked(\"<takezoe@gmail.com>\", new Options());\n        assertEquals(\"<p><a href=\\\"mailto:takezoe@gmail.com\\\">takezoe@gmail.com</a></p>\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testAutolink --> junit.framework.AssertionFailedError: expected:<...oe@gmail.com</a></p>[]> but was:<...oe@gmail.com</a></p>[",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...oe@gmail.com</a></p>[]> but was:<...oe@gmail.com</a></p>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testSanitize": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testSanitize",
        "src": "@Test\n    public void testSanitize() throws Exception {\n        {\n            Options options = new Options();\n            options.setSanitize(true);\n            String result = Marked.marked(\"<b>bold</b><script>alert('test!');</script>\", options);\n            assertEquals(\"<p>&lt;b&gt;bold&lt;/b&gt;&lt;script&gt;alert('test!');&lt;/script&gt;</p>\", result);\n        }\n        {\n            Options options = new Options();\n            options.setSanitize(false);\n            String result = Marked.marked(\"<b>bold</b><script>alert('test!');</script>\", options);\n            assertEquals(\"<p><b>bold</b></p>\", result);\n        }\n        {\n            Options options = new Options();\n            options.setSanitize(false);\n            String result = Marked.marked(\"- <b>test\", options);\n            // It's not clean but tag is closed at least.\n            assertEquals(\"<ul> \\n\" +\n                    \" <li><b>test</b></li>\\n\" +\n                    \" <b> </b>\\n\" +\n                    \"</ul>\\n\" +\n                    \"<b> </b>\", result);\n        }\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testSanitize --> junit.framework.AssertionFailedError: expected:<...&lt;script&gt;alert(['test!');&lt;/script&gt;</p>]> but was:<...&lt;script&gt;alert([&#39;test!&#39;);&lt;/script&gt;</p>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...&lt;script&gt;alert(['test!');&lt;/script&gt;</p>]> but was:<...&lt;script&gt;alert([&#39;test!&#39;);&lt;/script&gt;</p>"
      },
      "io.github.gitbucket.markedj.MarkedTest::testEmptyTableCell": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testEmptyTableCell",
        "src": "@Test\n    public void testEmptyTableCell() throws Exception {\n        String result = Marked.marked(\n                \"|ID|name|note|\\n\" +\n                \"|-|-|-|\\n\" +\n                \"|1|foo|This is foo|\\n\" +\n                \"|2|bar||\");\n\n\n        assertEquals(\n                \"<table> \\n\" +\n                        \" <thead> \\n\" +\n                        \"  <tr> \\n\" +\n                        \"   <th>ID</th> \\n\" +\n                        \"   <th>name</th> \\n\" +\n                        \"   <th>note</th> \\n\" +\n                        \"  </tr> \\n\" +\n                        \" </thead> \\n\" +\n                        \" <tbody> \\n\" +\n                        \"  <tr> \\n\" +\n                        \"   <td>1</td> \\n\" +\n                        \"   <td>foo</td> \\n\" +\n                        \"   <td>This is foo</td> \\n\" +\n                        \"  </tr> \\n\" +\n                        \"  <tr> \\n\" +\n                        \"   <td>2</td> \\n\" +\n                        \"   <td>bar</td> \\n\" +\n                        \"   <td></td> \\n\" +\n                        \"  </tr> \\n\" +\n                        \" </tbody> \\n\" +\n                        \"</table>\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testEmptyTableCell --> junit.framework.AssertionFailedError: expected:<<table>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<table>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testEmptyItemOfList": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testEmptyItemOfList",
        "src": "@Test\n    public void testEmptyItemOfList() throws Exception {\n        String result = Marked.marked(loadResourceAsString(\"empty_item_of_list.md\"), new Options());\n        assertEquals(loadResourceAsString(\"empty_item_of_list.html\"), result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testEmptyItemOfList --> junit.framework.AssertionFailedError: expected:<<ul>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<ul>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testQuote": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testQuote",
        "src": "@Test\n    public void testQuote() throws Exception {\n        String md = loadResourceAsString(\"quote.md\");\n        String result = Marked.marked(md, new Options());\n        String expect = loadResourceAsString(\"quote.html\");\n        assertEquals(expect, result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testQuote --> junit.framework.AssertionFailedError: expected:<<blockquote>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<blockquote>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testNestedContentOfList": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testNestedContentOfList",
        "src": "@Test\n    public void testNestedContentOfList() throws Exception {\n        String result = Marked.marked(loadResourceAsString(\"nested_content_of_list.md\"), new Options());\n        assertEquals(loadResourceAsString(\"nested_content_of_list.html\"), result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testNestedContentOfList --> junit.framework.AssertionFailedError: expected:<<ul>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<ul>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testEm": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testEm",
        "src": "@Test\n    public void testEm() throws Exception {\n        {\n            String result = Marked.marked(\"_aa__a__aa_\", new Options());\n            assertEquals(\"<p><em>aa<strong>a</strong>aa</em></p>\", result);\n        }\n        {\n            String result = Marked.marked(\"*aa*o*aa*\", new Options());\n            assertEquals(\"<p><em>aa</em>o<em>aa</em></p>\", result);\n        }\n        {\n            String result = Marked.marked(\"_aa__aa_\", new Options());\n            assertEquals(\"<p><em>aa__aa</em></p>\", result);\n        }\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testEm --> junit.framework.AssertionFailedError: expected:<...</strong>aa</em></p>[]> but was:<...</strong>aa</em></p>[",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...</strong>aa</em></p>[]> but was:<...</strong>aa</em></p>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testCodeBlock": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testCodeBlock",
        "src": "@Test\n    public void testCodeBlock() throws Exception {\n        String result = Marked.marked(\n                \"    public class HelloWorld {\\n\" +\n                \"    }\", new Options());\n        assertEquals(\n                \"<pre><code>public class HelloWorld {\\n\" +\n                \"}\\n\" +\n                \"</code></pre>\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testCodeBlock --> junit.framework.AssertionFailedError: expected:<...ld {",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...ld {"
      },
      "io.github.gitbucket.markedj.MarkedTest::testMarked2": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testMarked2",
        "src": "@Test\n    public void testMarked2() throws Exception {\n        String md = loadResourceAsString(\"gitbucket.md\");\n        String result = Marked.marked(md, new Options());\n        String expect = loadResourceAsString(\"gitbucket.html\");\n        assertEquals(expect, result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testMarked2 --> junit.framework.AssertionFailedError: expected:<...ld Status></a></h1>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...ld Status></a></h1>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testMarked3": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testMarked3",
        "src": "@Test\n    public void testMarked3() throws Exception {\n        String md = loadResourceAsString(\"wikilink.md\");\n        String result = Marked.marked(md, new Options());\n        String expect = loadResourceAsString(\"wikilink.html\");\n        assertEquals(expect, result);\n//        Files.write(Paths.get(\"wikilink.html\"), result.getBytes(\"UTF-8\"));\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testMarked3 --> junit.framework.AssertionFailedError: expected:<...GitBucket wiki!</h1>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...GitBucket wiki!</h1>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testReflink": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testReflink",
        "src": "@Test\n    public void testReflink() throws Exception {\n      String result = Marked.marked(\"[FOO], [bar][Foo], [Bar]\\n\\n[Foo]: http://example.com\");\n      assertEquals(\"<p><a href=\\\"http://example.com\\\">FOO</a>, <a href=\\\"http://example.com\\\">bar</a>, [Bar]</p>\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testReflink --> junit.framework.AssertionFailedError: expected:<...>bar</a>, [Bar]</p>[]> but was:<...>bar</a>, [Bar]</p>[",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<...>bar</a>, [Bar]</p>[]> but was:<...>bar</a>, [Bar]</p>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testInvalidColumnTable": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testInvalidColumnTable",
        "src": "@Test\n    public void testInvalidColumnTable() throws Exception {\n        {\n            String result = Marked.marked(loadResourceAsString(\"table.md\"), new Options());\n            assertEquals(loadResourceAsString(\"table.html\"), result);\n        }\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testInvalidColumnTable --> junit.framework.AssertionFailedError: expected:<<table>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<table>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testBreaks": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testBreaks",
        "src": "@Test\n    public void testBreaks() throws Exception {\n        {\n            String md = \"first line\\nsecond line\";\n            Options options = new Options();\n            //options.setBreaks(false); // default is false\n            //options.setGfm(true);     // default is true\n            String result = Marked.marked(md, options);\n\n            assertEquals(\"<p>first line second line</p>\", result);\n        }\n        {\n            String md = \"first line\\nsecond line\";\n            Options options = new Options();\n            options.setBreaks(true);\n            //options.setGfm(true); // default is true\n            String result = Marked.marked(md, options);\n\n            assertEquals(\"<p>first line<br>second line</p>\", result);\n        }\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testBreaks --> junit.framework.AssertionFailedError: expected:<<p>first line[ second line</p>]> but was:<<p>first line[",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p>first line[ second line</p>]> but was:<<p>first line["
      },
      "io.github.gitbucket.markedj.MarkedTest::testMarked": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testMarked",
        "src": "@Test\n    public void testMarked() throws Exception {\n        String md = loadResourceAsString(\"ldap_settings.md\");\n        String result = Marked.marked(md, new Options());\n        String expect = loadResourceAsString(\"ldap_settings.html\");\n        assertEquals(expect, result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testMarked --> junit.framework.AssertionFailedError: expected:<... in the version 1.5.[ This Wiki page describes how to configure and troubleshoot it.</p> ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<... in the version 1.5.[ This Wiki page describes how to configure and troubleshoot it.</p>"
      },
      "io.github.gitbucket.markedj.MarkedTest::testParagraphSeparation": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testParagraphSeparation",
        "src": "@Test\n    public void testParagraphSeparation() throws Exception {\n        String result = Marked.marked(\n                \"Message A\\n\" +\n                \"- List A\\n\" +\n                \"- List B\", new Options());\n\n        assertEquals(\n                \"<p>Message A</p> \\n\" +\n                \"<ul> \\n\" +\n                \" <li>List A</li> \\n\" +\n                \" <li>List B</li> \\n\" +\n                \"</ul>\", result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testParagraphSeparation --> junit.framework.AssertionFailedError: expected:<<p>Message A</p>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p>Message A</p>["
      },
      "io.github.gitbucket.markedj.MarkedTest::testNptable": {
        "path": "io/github/gitbucket/markedj/MarkedTest.java",
        "function_name": "testNptable",
        "src": "@Test\n    public void testNptable() throws Exception {\n        String result = Marked.marked(loadResourceAsString(\"nptable.md\"), new Options());\n        String expect = loadResourceAsString(\"nptable.html\");\n        assertEquals(expect, result);\n    }",
        "error_msg": "io.github.gitbucket.markedj.MarkedTest::testNptable --> junit.framework.AssertionFailedError: expected:<<table>[ ",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<table>["
      }
    }
  },
  "Sonartsplugin-3": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java",
        "start_loc": 19,
        "end_loc": 39,
        "buggy_function": "    private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) {\n        Command command =\n                Command\n                .create(\"node\")\n                .addArgument('\"' + pathToTsLint + '\"')\n                .addArgument(\"--format\")\n                .addArgument(\"json\");\n\n        if (rulesDir != null && rulesDir.length() > 0) {\n            command\n                .addArgument(\"--rules-dir\")\n                .addArgument('\"' + rulesDir + '\"');\n        }\n\n        command\n            .addArgument(\"--config\")\n            .addArgument('\"' + configFile + '\"')\n            .setNewShell(false);\n\n        return command;\n    }",
        "fixed_function": "    private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) {\n        Command command =\n                Command\n                .create(\"node\")\n                .addArgument(pathToTsLint)\n                .addArgument(\"--format\")\n                .addArgument(\"json\");\n\n        if (rulesDir != null && rulesDir.length() > 0) {\n            command\n                .addArgument(\"--rules-dir\")\n                .addArgument(rulesDir);\n        }\n\n        command\n            .addArgument(\"--config\")\n            .addArgument(configFile)\n            .setNewShell(false);\n\n        return command;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java",
        "start_loc": 41,
        "end_loc": 105,
        "buggy_function": "    public String execute(String pathToTsLint, String configFile, String rulesDir, List<String> files, Integer timeoutMs) {\n        // New up a command that's everything we need except the files to process\n        // We'll use this as our reference for chunking up files\n        int baseCommandLength = getBaseCommand(pathToTsLint, configFile, rulesDir).toCommandLine().length();\n        int availableForBatching = MAX_COMMAND_LENGTH - baseCommandLength;\n\n        List<List<String>> batches = new ArrayList<List<String>>();\n        List<String> currentBatch = new ArrayList<String>();\n        batches.add(currentBatch);\n\n        int currentBatchLength = 0;\n        for (int i = 0; i < files.size(); i++) {\n            String nextPath = '\"' + files.get(i).trim() + '\"';\n\n            // +1 for the space we'll be adding between filenames\n            if (currentBatchLength + nextPath.length() + 1 > availableForBatching) {\n                // Too long to add to this batch, create new\n                currentBatch = new ArrayList<String>();\n                currentBatchLength = 0;\n                batches.add(currentBatch);\n            }\n\n            currentBatch.add(nextPath);\n            currentBatchLength += nextPath.length() + 1;\n        }\n\n        LOG.debug(\"Split \" + files.size() + \" files into \" + batches.size() + \" batches for processing\");\n\n        this.stdOut = new StringBuilder();\n        this.stdErr = new StringBuilder();\n\n        StreamConsumer stdOutConsumer = new StreamConsumer() {\n            public void consumeLine(String line) {\n                stdOut.append(line);\n            }\n        };\n\n        StreamConsumer stdErrConsumer = new StreamConsumer() {\n            public void consumeLine(String line) {\n                LOG.error(\"TsLint Err: \" + line);\n                stdErr.append(line + \"\\n\");\n            }\n        };\n\n        for (int i = 0; i < batches.size(); i++) {\n            List<String> thisBatch = batches.get(i);\n            Command thisCommand = getBaseCommand(pathToTsLint, configFile, rulesDir);\n\n            for (int fileIndex = 0; fileIndex < thisBatch.size(); fileIndex++) {\n                thisCommand.addArgument(thisBatch.get(fileIndex));\n            }\n\n            LOG.debug(\"Executing TsLint with command: \" + thisCommand.toCommandLine());\n\n            // Timeout is specified per file, not per batch (which can vary a lot)\n            // so multiply it up\n            this.createExecutor().execute(thisCommand, stdOutConsumer, stdErrConsumer, timeoutMs * thisBatch.size());\n        }\n\n        String rawOutput = stdOut.toString();\n\n        // TsLint returns nonsense for its JSON output when faced with multiple files\n        // so we need to fix it up before we do anything else\n        return \"[\" + rawOutput.replaceAll(\"\\\\]\\\\[\", \"],[\") + \"]\";\n    }",
        "fixed_function": "    public String execute(String pathToTsLint, String configFile, String rulesDir, List<String> files, Integer timeoutMs) {\n        // New up a command that's everything we need except the files to process\n        // We'll use this as our reference for chunking up files\n        int baseCommandLength = getBaseCommand(pathToTsLint, configFile, rulesDir).toCommandLine().length();\n        int availableForBatching = MAX_COMMAND_LENGTH - baseCommandLength;\n\n        List<List<String>> batches = new ArrayList<List<String>>();\n        List<String> currentBatch = new ArrayList<String>();\n        batches.add(currentBatch);\n\n        int currentBatchLength = 0;\n        for (int i = 0; i < files.size(); i++) {\n            String nextPath = files.get(i).trim();\n\n            // +1 for the space we'll be adding between filenames\n            if (currentBatchLength + nextPath.length() + 1 > availableForBatching) {\n                // Too long to add to this batch, create new\n                currentBatch = new ArrayList<String>();\n                currentBatchLength = 0;\n                batches.add(currentBatch);\n            }\n\n            currentBatch.add(nextPath);\n            currentBatchLength += nextPath.length() + 1;\n        }\n\n        LOG.debug(\"Split \" + files.size() + \" files into \" + batches.size() + \" batches for processing\");\n\n        this.stdOut = new StringBuilder();\n        this.stdErr = new StringBuilder();\n\n        StreamConsumer stdOutConsumer = new StreamConsumer() {\n            public void consumeLine(String line) {\n                LOG.trace(\"TsLint Out: \" + line);\n                stdOut.append(line);\n            }\n        };\n\n        StreamConsumer stdErrConsumer = new StreamConsumer() {\n            public void consumeLine(String line) {\n                LOG.error(\"TsLint Err: \" + line);\n                stdErr.append(line + \"\\n\");\n            }\n        };\n\n        for (int i = 0; i < batches.size(); i++) {\n            List<String> thisBatch = batches.get(i);\n            Command thisCommand = getBaseCommand(pathToTsLint, configFile, rulesDir);\n\n            for (int fileIndex = 0; fileIndex < thisBatch.size(); fileIndex++) {\n                thisCommand.addArgument(thisBatch.get(fileIndex));\n            }\n\n            LOG.debug(\"Executing TsLint with command: \" + thisCommand.toCommandLine());\n\n            // Timeout is specified per file, not per batch (which can vary a lot)\n            // so multiply it up\n            this.createExecutor().execute(thisCommand, stdOutConsumer, stdErrConsumer, timeoutMs * thisBatch.size());\n        }\n\n        String rawOutput = stdOut.toString();\n\n        // TsLint returns nonsense for its JSON output when faced with multiple files\n        // so we need to fix it up before we do anything else\n        return \"[\" + rawOutput.replaceAll(\"\\\\]\\\\[\", \"],[\") + \"]\";\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintSensor.java",
        "start_loc": 51,
        "end_loc": 65,
        "buggy_function": "    private String getPath(String settingKey, String defaultValue) {\n        // Prefer the specified path\n        String toReturn = settings.getString(settingKey);\n                \n        // Fall back to a file system search if null or doesn't exist\n        if (toReturn == null || toReturn.isEmpty()) {\n            LOG.debug(\"Path \" + settingKey + \" not specified, falling back to \" + defaultValue);\n            toReturn = defaultValue;\n        }\n        else {\n            LOG.debug(\"Found \" + settingKey + \" Lint path to be '\" + toReturn + \"'\");\n        }\n        \n        return getAbsolutePath(toReturn);\n    }",
        "fixed_function": "    protected String getTsLintPath() {\n        // Prefer the specified path\n        String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH);\n                \n        // Fall back to a file system search if null or doesn't exist\n        if (toReturn == null || toReturn.isEmpty()) {\n            LOG.debug(\"Path to TsLint not specified, falling back to node_modules\");\n            toReturn = TSLINT_FALLBACK_PATH;\n        }\n        else {\n            LOG.debug(\"Found TsLint path to be '\" + toReturn + \"'\");\n        }\n        \n        File candidateFile = new java.io.File(toReturn);\n        if (!candidateFile.isAbsolute()) {\n            candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn);\n        }\n        \n        if (!doesFileExist(candidateFile)) {\n            LOG.warn(\"Could not find tslint at path '\" + toReturn + \"' - skipping tslint analysis\");\n            toReturn = null;\n        }\n        \n        return toReturn;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintSensor.java",
        "start_loc": 66,
        "end_loc": 80,
        "buggy_function": "    protected String getAbsolutePath(String toReturn) {\n        if (toReturn != null) {\n            File candidateFile = new java.io.File(toReturn);\n        if (!candidateFile.isAbsolute()) {\n            candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn);\n            }\n            if (!doesFileExist(candidateFile)) {\n                return null;\n            }\n            return candidateFile.getAbsolutePath();\n        }\n        \n        return null;\n        \n    }",
        "fixed_function": "    public void analyse(Project project, SensorContext context) {\n        String pathToTsLint = getTsLintPath();\n        String pathToTsLintConfig = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH);\n        String rulesDir = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_RULES_DIR);\n        Integer tsLintTimeoutMs = Math.max(5000, settings.getInt(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT));\n\n        if (pathToTsLint == null) {\n            return;\n        }\n        else if (pathToTsLintConfig == null) {\n            LOG.warn(\"Path to tslint.json configuration file (\" + TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH + \") is not defined. Skipping tslint analysis.\");\n            return;\n        }\n\n        TsLintExecutor executor = this.getTsLintExecutor();\n        TsLintParser parser = this.getTsLintParser();\n\n        boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);\n\n        RuleQuery ruleQuery = RuleQuery.create().withRepositoryKey(TsRulesDefinition.REPOSITORY_NAME);\n        Collection<Rule> allRules = this.ruleFinder.findAll(ruleQuery);\n        HashSet<String> ruleNames = new HashSet<>();\n        for (Rule rule : allRules) {\n            ruleNames.add(rule.getKey());\n        }\n\n        List<String> paths = new ArrayList<String>();\n        HashMap<String, File> fileMap = new HashMap<String, File>();\n\n        for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) {\n            if (skipTypeDefFiles && file.getName().toLowerCase().endsWith(\".\" + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) {\n                continue;\n            }\n\n            String pathAdjusted = file.getAbsolutePath().replace('\\\\', '/');\n            paths.add(pathAdjusted);\n            fileMap.put(pathAdjusted, file);\n        }\n\n        String jsonResult = executor.execute(pathToTsLint, pathToTsLintConfig, rulesDir, paths, tsLintTimeoutMs);\n\n        TsLintIssue[][] issues = parser.parse(jsonResult);\n\n        if (issues == null) {\n            LOG.warn(\"TsLint returned no result at all\");\n            return;\n        }\n\n        // Each issue bucket will contain info about a single file\n        for (TsLintIssue[] batchIssues : issues) {\n            if (batchIssues == null || batchIssues.length == 0) {\n                continue;\n            }\n\n            String filePath = batchIssues[0].getName();\n\n            if (!fileMap.containsKey(filePath)) {\n                LOG.warn(\"TsLint reported issues against a file that wasn't sent to it - will be ignored: \" + filePath);\n                continue;\n            }\n\n            File file = fileMap.get(filePath);\n            Resource resource = this.getFileFromIOFile(file, project);\n            Issuable issuable = perspectives.as(Issuable.class, resource);\n\n            for (TsLintIssue issue : batchIssues) {\n                // Make sure the rule we're violating is one we recognise - if not, we'll\n                // fall back to the generic 'tslint-issue' rule\n                String ruleName = issue.getRuleName();\n                if (!ruleNames.contains(ruleName)) {\n                    ruleName = TsRulesDefinition.TSLINT_UNKNOWN_RULE.key;\n                }\n\n                issuable.addIssue\n                (\n                        issuable\n                        .newIssueBuilder()\n                        .line(issue.getStartPosition().getLine() + 1)\n                        .message(issue.getFailure())\n                        .ruleKey(RuleKey.of(TsRulesDefinition.REPOSITORY_NAME, ruleName))\n                        .build()\n                        );\n            }\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.pablissimo.sonar.TsLintExecutorImplTest::executesCommandWithCorrectArgumentsAndTimeouts": {
        "path": "com/pablissimo/sonar/TsLintExecutorImplTest.java",
        "function_name": "executesCommandWithCorrectArgumentsAndTimeouts",
        "src": "@Test\n    public void executesCommandWithCorrectArgumentsAndTimeouts() {\n        final ArrayList<Command> capturedCommands = new ArrayList<Command>();\n        final ArrayList<Long> capturedTimeouts = new ArrayList<Long>();\n        \n        Answer<Integer> captureCommand = new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock invocation) throws Throwable {\n                capturedCommands.add((Command) invocation.getArguments()[0]);\n                capturedTimeouts.add((long) invocation.getArguments()[3]);\n                return 0;\n            }\n        };\n        \n        when(this.commandExecutor.execute(any(Command.class), any(StreamConsumer.class), any(StreamConsumer.class), any(long.class))).then(captureCommand);\n        this.executorImpl.execute(\"path/to/tslint\", \"path/to/config\", \"path/to/rules\", Arrays.asList(new String[] { \"path/to/file\", \"path/to/another\" }), 40000);\n        \n        assertEquals(1, capturedCommands.size());\n        \n        Command theCommand = capturedCommands.get(0);\n        long theTimeout = capturedTimeouts.get(0);\n        \n        assertEquals(\"node path/to/tslint --format json --rules-dir path/to/rules --config path/to/config path/to/file path/to/another\", theCommand.toCommandLine());\n        // Expect one timeout period per file processed\n        assertEquals(2 * 40000, theTimeout);        \n    }",
        "error_msg": "com.pablissimo.sonar.TsLintExecutorImplTest::executesCommandWithCorrectArgumentsAndTimeouts --> junit.framework.AssertionFailedError: expected:<node [path/to/tslint --format json --rules-dir path/to/rules --config path/to/config path/to/file path/to/another]> but was:<node [path/to/tslint --format json --rules-dir path/to/rules --config path/to/config path/to/file path/to/another]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<node [path/to/tslint --format json --rules-dir path/to/rules --config path/to/config path/to/file path/to/another]> but was:<node [path/to/tslint --format json --rules-dir path/to/rules --config path/to/config path/to/file path/to/another]>"
      },
      "com.pablissimo.sonar.TsLintExecutorImplTest::BatchesExecutions_IfTooManyFilesForCommandLine": {
        "path": "com/pablissimo/sonar/TsLintExecutorImplTest.java",
        "function_name": "BatchesExecutions_IfTooManyFilesForCommandLine",
        "src": "@Test\n    public void BatchesExecutions_IfTooManyFilesForCommandLine() {\n        List<String> filenames = new ArrayList<String>();\n        int currentLength = 0;\n        int standardCmdLength = \"node path/to/tslint --format json --rules-dir path/to/rules --config path/to/config\".length();\n        \n        String firstBatch = \"first batch\";\n        while (currentLength + 12 < TsLintExecutorImpl.MAX_COMMAND_LENGTH - standardCmdLength) {\n            filenames.add(firstBatch);\n            currentLength += firstBatch.length() + 1;\n        }\n        filenames.add(\"second batch\");\n        \n        final ArrayList<Command> capturedCommands = new ArrayList<Command>();\n        final ArrayList<Long> capturedTimeouts = new ArrayList<Long>();\n        \n        Answer<Integer> captureCommand = new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock invocation) throws Throwable {\n                capturedCommands.add((Command) invocation.getArguments()[0]);\n                capturedTimeouts.add((long) invocation.getArguments()[3]);\n                return 0;\n            }\n        };\n        \n        when(this.commandExecutor.execute(any(Command.class), any(StreamConsumer.class), any(StreamConsumer.class), any(long.class))).then(captureCommand);\n        this.executorImpl.execute(\"path/to/tslint\", \"path/to/config\", \"path/to/rules\", filenames, 40000);\n        \n        assertEquals(2, capturedCommands.size());\n        \n        Command theSecondCommand = capturedCommands.get(1);\n        \n        assertFalse(theSecondCommand.toCommandLine().contains(\"first batch\"));\n        assertTrue(theSecondCommand.toCommandLine().contains(\"second batch\"));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintExecutorImplTest::BatchesExecutions_IfTooManyFilesForCommandLine --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "com.pablissimo.sonar.TsLintSensorTest::analyse_fallsBackToDefaultTsLintPath_whenNoServerConfiguration": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyse_fallsBackToDefaultTsLintPath_whenNoServerConfiguration",
        "src": "@Test\n    public void analyse_fallsBackToDefaultTsLintPath_whenNoServerConfiguration() {\n        when(this.settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH)).thenReturn(null);\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n        \n        verify(this.executor).execute(eq(TsLintSensor.TSLINT_FALLBACK_PATH), any(String.class), any(String.class), any(List.class), any(Integer.class));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyse_fallsBackToDefaultTsLintPath_whenNoServerConfiguration --> Argument(s) are different! Wanted:",
        "clean_error_msg": "Argument(s) are different! Wanted:"
      },
      "com.pablissimo.sonar.TsLintSensorTest::analyse_fallsBackToDefaultTsLintPath_whenServerConfigurationNonNullButEmpty": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyse_fallsBackToDefaultTsLintPath_whenServerConfigurationNonNullButEmpty",
        "src": "@Test\n    public void analyse_fallsBackToDefaultTsLintPath_whenServerConfigurationNonNullButEmpty() {\n        when(this.settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH)).thenReturn(\"\");\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n        \n        verify(this.executor).execute(eq(TsLintSensor.TSLINT_FALLBACK_PATH), any(String.class), any(String.class), any(List.class), any(Integer.class));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyse_fallsBackToDefaultTsLintPath_whenServerConfigurationNonNullButEmpty --> Argument(s) are different! Wanted:",
        "clean_error_msg": "Argument(s) are different! Wanted:"
      }
    }
  },
  "Sonartsplugin-4": {
    "function_num": 2,
    "functions": [
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintSensor.java",
        "start_loc": 50,
        "end_loc": 68,
        "buggy_function": "    protected String getTsLintPath() {\n        String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH);\n        if (toReturn == null || toReturn.isEmpty()) {\n            LOG.debug(\"Path to TsLint not specified, falling back to node_modules\");\n            toReturn = TSLINT_FALLBACK_PATH;\n        }\n        else {\n            LOG.debug(\"Found TsLint path to be '\" + toReturn + \"'\");\n        }\n        File candidateFile = new java.io.File(toReturn);\n        if (!candidateFile.isAbsolute()) {\n            candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn);\n        }\n        if (!doesFileExist(candidateFile)) {\n            LOG.warn(\"Could not find tslint at path '\" + toReturn + \"' - skipping tslint analysis\");\n            toReturn = null;\n        }\n        return toReturn;\n    }",
        "fixed_function": "    private boolean hasFilesToAnalyze() {\n        return fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_KEY)).iterator().hasNext();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/pablissimo/sonar/TsLintSensor.java",
        "start_loc": 69,
        "end_loc": 71,
        "buggy_function": "    protected boolean doesFileExist(File f) {\n        return f.exists();\n    }",
        "fixed_function": "    public void analyse(Project project, SensorContext context) {\n        String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH);\n        String pathToTsLintConfig = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH);\n        String rulesDir = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_RULES_DIR);\n        Integer tsLintTimeoutMs = Math.max(5000, settings.getInt(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT));\n\n        if (pathToTsLint == null) {\n            LOG.warn(\"Path to tslint (\" + TypeScriptPlugin.SETTING_TS_LINT_PATH + \") is not defined. Skipping tslint analysis.\");\n            return;\n        }\n        else if (pathToTsLintConfig == null) {\n            LOG.warn(\"Path to tslint.json configuration file (\" + TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH + \") is not defined. Skipping tslint analysis.\");\n            return;\n        }\n\n        TsLintExecutor executor = this.getTsLintExecutor();\n        TsLintParser parser = this.getTsLintParser();\n\n        boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);\n\n        RuleQuery ruleQuery = RuleQuery.create().withRepositoryKey(TsRulesDefinition.REPOSITORY_NAME);\n        Collection<Rule> allRules = this.ruleFinder.findAll(ruleQuery);\n        HashSet<String> ruleNames = new HashSet<>();\n        for (Rule rule : allRules) {\n            ruleNames.add(rule.getKey());\n        }\n\n        List<String> paths = new ArrayList<String>();\n        HashMap<String, File> fileMap = new HashMap<String, File>();\n\n        for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) {\n            if (skipTypeDefFiles && file.getName().toLowerCase().endsWith(\".\" + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) {\n                continue;\n            }\n\n            String pathAdjusted = file.getAbsolutePath().replace('\\\\', '/');\n            paths.add(pathAdjusted);\n            fileMap.put(pathAdjusted, file);\n        }\n\n        String jsonResult = executor.execute(pathToTsLint, pathToTsLintConfig, rulesDir, paths, tsLintTimeoutMs);\n\n        TsLintIssue[][] issues = parser.parse(jsonResult);\n\n        if (issues == null) {\n            LOG.warn(\"TsLint returned no result at all\");\n            return;\n        }\n\n        // Each issue bucket will contain info about a single file\n        for (TsLintIssue[] batchIssues : issues) {\n            if (batchIssues == null || batchIssues.length == 0) {\n                continue;\n            }\n\n            String filePath = batchIssues[0].getName();\n\n            if (!fileMap.containsKey(filePath)) {\n                LOG.warn(\"TsLint reported issues against a file that wasn't sent to it - will be ignored: \" + filePath);\n                continue;\n            }\n\n            File file = fileMap.get(filePath);\n            Resource resource = this.getFileFromIOFile(file, project);\n            Issuable issuable = perspectives.as(Issuable.class, resource);\n\n            for (TsLintIssue issue : batchIssues) {\n                // Make sure the rule we're violating is one we recognise - if not, we'll\n                // fall back to the generic 'tslint-issue' rule\n                String ruleName = issue.getRuleName();\n                if (!ruleNames.contains(ruleName)) {\n                    ruleName = TsRulesDefinition.TSLINT_UNKNOWN_RULE.key;\n                }\n\n                issuable.addIssue\n                (\n                        issuable\n                        .newIssueBuilder()\n                        .line(issue.getStartPosition().getLine() + 1)\n                        .message(issue.getFailure())\n                        .ruleKey(RuleKey.of(TsRulesDefinition.REPOSITORY_NAME, ruleName))\n                        .build()\n                        );\n            }\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.pablissimo.sonar.TsLintSensorTest::analyse_addsIssues": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyse_addsIssues",
        "src": "@Test\n    public void analyse_addsIssues() {\n        TsLintIssue issue = new TsLintIssue();\n        issue.setFailure(\"failure\");\n        issue.setRuleName(\"rule name\");\n        issue.setName(\"/path/to/file\");\n\n        TsLintPosition startPosition = new TsLintPosition();\n        startPosition.setLine(1);\n\n        issue.setStartPosition(startPosition);\n\n        TsLintIssue[][] issues = new TsLintIssue[][] {\n                new TsLintIssue[] { issue }\n        };\n\n        final List<Issue> capturedIssues = new ArrayList<Issue>();\n        Answer<Void> captureIssue = new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                capturedIssues.add((Issue) invocation.getArguments()[0]);\n                return null;\n            }\n        };\n\n        when(this.issuable.addIssue(any(Issue.class))).then(captureIssue);\n        when(parser.parse(any(String.class))).thenReturn(issues);\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n\n        assertEquals(1, capturedIssues.size());\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyse_addsIssues --> junit.framework.AssertionFailedError: expected:<1> but was:<0>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1> but was:<0>"
      },
      "com.pablissimo.sonar.TsLintSensorTest::analyse_doesNothingWhenNotConfigured": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyse_doesNothingWhenNotConfigured",
        "src": "@Test\n    public void analyse_doesNothingWhenNotConfigured() throws IOException {\n        when(this.settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH)).thenReturn(null);\n\n        when(this.fileSystem.files(any(FilePredicate.class))).thenReturn(new ArrayList<File>());\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n\n        verify(this.issuable, never()).addIssue(any(Issue.class));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyse_doesNothingWhenNotConfigured --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.pablissimo.sonar.TsLintSensorTest::analyse_callsExecutorWithSuppliedTimeout": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyse_callsExecutorWithSuppliedTimeout",
        "src": "@Test\n    public void analyse_callsExecutorWithSuppliedTimeout() throws IOException {\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n\n        verify(this.executor, times(1)).execute(any(String.class), any(String.class), any(String.class), any(List.class), eq(45000));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyse_callsExecutorWithSuppliedTimeout --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.pablissimo.sonar.TsLintSensorTest::analyze_callsExecutorWithAtLeast5000msTimeout": {
        "path": "com/pablissimo/sonar/TsLintSensorTest.java",
        "function_name": "analyze_callsExecutorWithAtLeast5000msTimeout",
        "src": "@Test\n    public void analyze_callsExecutorWithAtLeast5000msTimeout() throws IOException {\n        when(this.settings.getInt(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT)).thenReturn(-500);\n\n        this.sensor.analyse(mock(Project.class), mock(SensorContext.class));\n\n        verify(this.executor, times(1)).execute(any(String.class), any(String.class), any(String.class), any(List.class), eq(5000));\n    }",
        "error_msg": "com.pablissimo.sonar.TsLintSensorTest::analyze_callsExecutorWithAtLeast5000msTimeout --> junit.framework.AssertionFailedError: ",
        "clean_error_msg": "junit.framework.AssertionFailedError:"
      },
      "com.pablissimo.sonar.TypeScriptPluginTest::tsLintPathSetting_definedAppropriately": {
        "path": "com/pablissimo/sonar/TypeScriptPluginTest.java",
        "function_name": "tsLintPathSetting_definedAppropriately",
        "src": "@Test\n    public void tsLintPathSetting_definedAppropriately() {\n        Property property = findPropertyByName(TypeScriptPlugin.SETTING_TS_LINT_PATH);\n\n        assertEquals(PropertyType.STRING, property.type());\n        assertEquals(\"\", property.defaultValue());\n        assertEquals(false, property.project());\n        assertEquals(true, property.global());\n    }",
        "error_msg": "com.pablissimo.sonar.TypeScriptPluginTest::tsLintPathSetting_definedAppropriately --> junit.framework.AssertionFailedError: expected:<false> but was:<true>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<false> but was:<true>"
      }
    }
  },
  "Proj4J-2": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/proj4j/parser/Proj4Keyword.java",
        "start_loc": 75,
        "end_loc": 121,
        "buggy_function": "    public static synchronized Set supportedParameters() {\n        if (supportedParams == null) {\n            supportedParams = new TreeSet<String>();\n\n            supportedParams.add(a);\n            supportedParams.add(rf);\n            supportedParams.add(f);\n            supportedParams.add(alpha);\n            supportedParams.add(es);\n            supportedParams.add(b);\n            supportedParams.add(datum);\n            supportedParams.add(ellps);\n            supportedParams.add(h);\n\n            supportedParams.add(R_A);\n\n            supportedParams.add(k);\n            supportedParams.add(k_0);\n            supportedParams.add(lat_ts);\n            supportedParams.add(lat_0);\n            supportedParams.add(lat_1);\n            supportedParams.add(lat_2);\n            supportedParams.add(lon_0);\n            supportedParams.add(lonc);\n\n            supportedParams.add(x_0);\n            supportedParams.add(y_0);\n\n            supportedParams.add(proj);\n            supportedParams.add(south);\n            supportedParams.add(towgs84);\n            supportedParams.add(to_meter);\n            supportedParams.add(units);\n            supportedParams.add(nadgrids);\n            supportedParams.add(pm);\n            supportedParams.add(axis);\n\n            supportedParams.add(gamma);       // Just for Oblique Mercator projection\n            supportedParams.add(zone);        // Just for Transverse Mercator projection\n\n            supportedParams.add(title);       // no-op\n            supportedParams.add(no_defs);     // no-op\n            supportedParams.add(wktext);      // no-op\n            supportedParams.add(no_uoff);     // no-op\n        }\n        return supportedParams;\n    }",
        "fixed_function": "    public static synchronized Set supportedParameters() {\n        if (supportedParams == null) {\n            supportedParams = new TreeSet<String>();\n\n            supportedParams.add(a);\n            supportedParams.add(rf);\n            supportedParams.add(f);\n            supportedParams.add(alpha);\n            supportedParams.add(es);\n            supportedParams.add(b);\n            supportedParams.add(datum);\n            supportedParams.add(ellps);\n            supportedParams.add(h);\n\n            supportedParams.add(R);\n            supportedParams.add(R_A);\n\n            supportedParams.add(k);\n            supportedParams.add(k_0);\n            supportedParams.add(lat_ts);\n            supportedParams.add(lat_0);\n            supportedParams.add(lat_1);\n            supportedParams.add(lat_2);\n            supportedParams.add(lon_0);\n            supportedParams.add(lonc);\n\n            supportedParams.add(x_0);\n            supportedParams.add(y_0);\n\n            supportedParams.add(proj);\n            supportedParams.add(south);\n            supportedParams.add(towgs84);\n            supportedParams.add(to_meter);\n            supportedParams.add(units);\n            supportedParams.add(nadgrids);\n            supportedParams.add(pm);\n            supportedParams.add(axis);\n\n            supportedParams.add(gamma);       // Just for Oblique Mercator projection\n            supportedParams.add(zone);        // Just for Transverse Mercator projection\n\n            supportedParams.add(title);       // no-op\n            supportedParams.add(no_defs);     // no-op\n            supportedParams.add(wktext);      // no-op\n            supportedParams.add(no_uoff);     // no-op\n        }\n        return supportedParams;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/parser/Proj4Parser.java",
        "start_loc": 65,
        "end_loc": 180,
        "buggy_function": "    private Projection parseProjection(Map params, Ellipsoid ellipsoid) {\n        Projection projection = null;\n\n        String s;\n        s = (String) params.get(Proj4Keyword.proj);\n        if (s != null) {\n            projection = registry.getProjection(s);\n            if (projection == null)\n                throw new InvalidValueException(\"Unknown projection: \" + s);\n        }\n\t\telse {\n\t\t\tthrow new InvalidValueException(\"Keyword '\" + Proj4Keyword.proj + \"' is a required parameter\");\n        }\n        projection.setEllipsoid(ellipsoid);\n\n        //TODO: better error handling for things like bad number syntax.\n        // Should be able to report the original param string in the error message\n        // Should the exception be lib-specific?  (e.g. ParseException)\n\n        s = (String) params.get(Proj4Keyword.alpha);\n        if (s != null)\n            projection.setAlphaDegrees(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.lonc);\n        if (s != null)\n            projection.setLonCDegrees(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.lat_0);\n        if (s != null)\n            projection.setProjectionLatitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lon_0);\n        if (s != null)\n            projection.setProjectionLongitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_1);\n        if (s != null)\n            projection.setProjectionLatitude1Degrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_2);\n        if (s != null)\n            projection.setProjectionLatitude2Degrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_ts);\n        if (s != null)\n            projection.setTrueScaleLatitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.x_0);\n        if (s != null)\n            projection.setFalseEasting(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.y_0);\n        if (s != null)\n            projection.setFalseNorthing(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.k_0);\n        if (s == null)\n            s = (String) params.get(Proj4Keyword.k);\n        if (s != null)\n            projection.setScaleFactor(Double.parseDouble(s));\n        s = (String) params.get(Proj4Keyword.gamma);\n        if (s != null)\n            projection.setGamma(Double.parseDouble(s) * ProjectionMath.DTR);\n\n        s = (String) params.get(Proj4Keyword.units);\n        if (s != null) {\n            Unit unit = Units.findUnits(s);\n            // TODO: report unknown units name as error\n            if (unit != null) {\n                projection.setFromMetres(1.0 / unit.value);\n                projection.setUnits(unit);\n            }\n        }\n\n        s = (String) params.get(Proj4Keyword.to_meter);\n        if (s != null)\n            projection.setFromMetres(1.0 / Double.parseDouble(s));\n        \n        s = (String) params.get(Proj4Keyword.h);\n        if (s != null) {\n            projection.setHeightOfOrbit(Double.parseDouble(s));\n        }\n\n        if (params.containsKey(Proj4Keyword.south))\n            projection.setSouthernHemisphere(true);\n\n        s = (String) params.get(Proj4Keyword.pm);\n        if (s != null)\n            projection.setPrimeMeridian(s);\n\n        s = (String) params.get(Proj4Keyword.axis);\n        if (s != null)\n            projection.setAxisOrder(s);\n\n        /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */\n\n        //TODO: implement some of these parameters ?\n\n        // this must be done last, since behaviour depends on other params being set (eg +south)\n        if (projection instanceof TransverseMercatorProjection) {\n            s = (String) params.get(Proj4Keyword.zone);\n            if (s != null)\n                ((TransverseMercatorProjection) projection).setUTMZone(Integer\n                        .parseInt(s));\n        }\n        if (projection instanceof ExtendedTransverseMercatorProjection) {\n            s = (String) params.get(Proj4Keyword.zone);\n            if (s != null)\n                ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer\n                        .parseInt(s));\n        }\n\n        projection.initialize();\n\n        return projection;\n    }",
        "fixed_function": "    private Projection parseProjection(Map params, Ellipsoid ellipsoid) {\n        Projection projection = null;\n\n        String s;\n        s = (String) params.get(Proj4Keyword.proj);\n        if (s != null) {\n            projection = registry.getProjection(s);\n            if (projection == null)\n                throw new InvalidValueException(\"Unknown projection: \" + s);\n        }\n\t\telse {\n\t\t\tthrow new InvalidValueException(\"Keyword '\" + Proj4Keyword.proj + \"' is a required parameter\");\n        }\n        projection.setEllipsoid(ellipsoid);\n\n        //TODO: better error handling for things like bad number syntax.\n        // Should be able to report the original param string in the error message\n        // Should the exception be lib-specific?  (e.g. ParseException)\n\n        s = (String) params.get(Proj4Keyword.alpha);\n        if (s != null)\n            projection.setAlphaDegrees(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.lonc);\n        if (s != null)\n            projection.setLonCDegrees(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.lat_0);\n        if (s != null)\n            projection.setProjectionLatitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lon_0);\n        if (s != null)\n            projection.setProjectionLongitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_1);\n        if (s != null)\n            projection.setProjectionLatitude1Degrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_2);\n        if (s != null)\n            projection.setProjectionLatitude2Degrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.lat_ts);\n        if (s != null)\n            projection.setTrueScaleLatitudeDegrees(parseAngle(s));\n\n        s = (String) params.get(Proj4Keyword.x_0);\n        if (s != null)\n            projection.setFalseEasting(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.y_0);\n        if (s != null)\n            projection.setFalseNorthing(Double.parseDouble(s));\n\n        s = (String) params.get(Proj4Keyword.k_0);\n        if (s == null)\n            s = (String) params.get(Proj4Keyword.k);\n        if (s != null)\n            projection.setScaleFactor(Double.parseDouble(s));\n        s = (String) params.get(Proj4Keyword.gamma);\n        if (s != null)\n            projection.setGamma(Double.parseDouble(s) * ProjectionMath.DTR);\n\n        s = (String) params.get(Proj4Keyword.units);\n        if (s != null) {\n            Unit unit = Units.findUnits(s);\n            // TODO: report unknown units name as error\n            if (unit != null) {\n                projection.setFromMetres(1.0 / unit.value);\n                projection.setUnits(unit);\n            }\n        }\n\n        s = (String) params.get(Proj4Keyword.to_meter);\n        if (s != null)\n            projection.setFromMetres(1.0 / Double.parseDouble(s));\n        \n        s = (String) params.get(Proj4Keyword.h);\n        if (s != null) {\n            projection.setHeightOfOrbit(Double.parseDouble(s));\n        }\n\n        if (params.containsKey(Proj4Keyword.south))\n            projection.setSouthernHemisphere(true);\n\n        s = (String) params.get(Proj4Keyword.pm);\n        if (s != null)\n            projection.setPrimeMeridian(s);\n\n        s = (String) params.get(Proj4Keyword.axis);\n        if (s != null)\n            projection.setAxisOrder(s);\n\n        /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */\n        s = (String) params.get(Proj4Keyword.R);\n        if (s != null)\n            projection.setRadius(Double.parseDouble(s));\n\n        //TODO: implement some of these parameters ?\n\n        // this must be done last, since behaviour depends on other params being set (eg +south)\n        if (projection instanceof TransverseMercatorProjection) {\n            s = (String) params.get(Proj4Keyword.zone);\n            if (s != null)\n                ((TransverseMercatorProjection) projection).setUTMZone(Integer\n                        .parseInt(s));\n        }\n        if (projection instanceof ExtendedTransverseMercatorProjection) {\n            s = (String) params.get(Proj4Keyword.zone);\n            if (s != null)\n                ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer\n                        .parseInt(s));\n        }\n\n        projection.initialize();\n\n        return projection;\n    }",
        "comment": "/**\n     * Creates a {@link Projection}\n     * initialized from a PROJ.4 argument list.\n     */"
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 746,
        "end_loc": 748,
        "buggy_function": "    public Ellipsoid getEllipsoid() {\n        return ellipsoid;\n    }",
        "fixed_function": "    public void setRadius(double radius) {\n        a = radius;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.locationtech.proj4j.CoordinateTransformTest::testRadius": {
        "path": "org/locationtech/proj4j/CoordinateTransformTest.java",
        "function_name": "testRadius",
        "src": "@Test\n    public void testRadius() {\n        checkTransformToWGS84(\"+title=long/lat:WGS84 +proj=eqc +R=57295779.5130823209\", 1000000.0, 1000000.0, 1.0, 1.0, 0.01);\n    }",
        "error_msg": "org.locationtech.proj4j.CoordinateTransformTest::testRadius --> org.locationtech.proj4j.UnsupportedParameterException: R parameter is not supported",
        "clean_error_msg": "org.locationtech.proj4j.UnsupportedParameterException: R parameter is not supported"
      }
    }
  },
  "Proj4J-3": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/NewZealandMapGridProjection.java",
        "start_loc": 59,
        "end_loc": 72,
        "buggy_function": "    @Override\n\tpublic ProjCoordinate project(double lplam, double lpphi, ProjCoordinate out) {\n        Complex p = new Complex(0, 0);\n\n        lpphi = (lpphi - projectionLatitude) * RAD_TO_SECS;\n        for (int i = tpsi.length - 1; i >= 0; --i) \n            p.r = tpsi[i] + lpphi * p.r;\n        p.r *= lpphi;\n        p.i = lplam;\n        zpoly1(p, bf);\n        out.x = p.i;\n        out.y = p.r;\n        return out;\n    }",
        "fixed_function": "    @Override\n\tpublic ProjCoordinate project(double lplam, double lpphi, ProjCoordinate out) {\n        Complex p = new Complex(0, 0);\n\n        lpphi = (lpphi - projectionLatitude) * RAD_TO_SECS;\n        for (int i = tpsi.length - 1; i >= 0; --i) \n            p.r = tpsi[i] + lpphi * p.r;\n        p.r *= lpphi;\n        p.i = lplam;\n        p = zpoly1(p, bf);\n        out.x = p.i;\n        out.y = p.r;\n        return out;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/NewZealandMapGridProjection.java",
        "start_loc": 74,
        "end_loc": 101,
        "buggy_function": "    @Override\n    protected ProjCoordinate projectInverse(double x, double y, ProjCoordinate dst) {\n        int nn, i;\n        Complex p = new Complex(y, x), f, fp = new Complex(0,0), dp = new Complex(0,0);\n        double den;\n        double[] C;\n\n        for (nn = 20; nn > 0 ;--nn) {\n            f = zpoly1d(p, bf, fp);\n            f.r -= y;\n            f.i -= x;\n            den = fp.r * fp.r + fp.i * fp.i;\n            p.r += dp.r = -(f.r * fp.r + f.i * fp.i) / den;\n            p.i += dp.i = -(f.i * fp.r - f.r * fp.i) / den;\n            if ((abs(dp.r) + abs(dp.i)) <= EPS10)\n                break;\n        }\n        if (nn > 0) {\n            dst.x = p.i;\n            dst.y = tphi[tphi.length - 1];\n            for (i = tphi.length - 1; i > 0; i--) {\n                dst.y = tphi[i] + p.r * dst.y;\n            }\n            dst.y = projectionLongitude + p.r * dst.x * SECS_TO_RAD;\n        } else\n            dst.y = dst.x = Double.NaN;\n        return dst;\n    }",
        "fixed_function": "    @Override\n    protected ProjCoordinate projectInverse(double x, double y, ProjCoordinate dst) {\n        int nn, i;\n        Complex p = new Complex(y, x), f, fp = new Complex(0,0), dp = new Complex(0,0);\n        double den;\n        double[] C;\n\n        for (nn = 20; nn > 0 ;--nn) {\n            f = zpoly1d(p, bf, fp);\n            f.r -= y;\n            f.i -= x;\n            den = fp.r * fp.r + fp.i * fp.i;\n            p.r += dp.r = -(f.r * fp.r + f.i * fp.i) / den;\n            p.i += dp.i = -(f.i * fp.r - f.r * fp.i) / den;\n            if ((abs(dp.r) + abs(dp.i)) <= EPS10)\n                break;\n        }\n        if (nn > 0) {\n            dst.x = p.i;\n            dst.y = tphi[tphi.length - 1];\n            for (i = tphi.length - 1; i > 0; i--) {\n                dst.y = tphi[i-1] + p.r * dst.y;\n            }\n            dst.y = projectionLatitude + p.r * dst.y * SECS_TO_RAD;\n        } else\n            dst.y = dst.x = Double.NaN;\n        return dst;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/util/ProjectionMath.java",
        "start_loc": 500,
        "end_loc": 526,
        "buggy_function": "    public static Complex zpoly1d(Complex z, Complex[] C, Complex der) {\n        Complex a, b;\n        double t;\n        boolean first = true;\n\n        a = new Complex(C[C.length - 1]);\n        b = new Complex(a);\n        for (int i = C.length - 1; i > 0; i--) {\n            if (first) {\n                first = false;\n            } else {\n                b.r = a.r + z.r * (t = b.r) - z.i * b.i;\n                b.i = a.i + z.r * b.i + z.i * t;\n            }\n            Complex c = C[i];\n            a.r = c.r + z.r * (t = a.r) - z.i * a.i;\n            a.i = c.i + z.r * a.i + z.i * t;\n        }\n\n        b.r = a.r + z.r * (t = b.r) - z.i * b.i;\n        b.i = a.i + z.r * b.i + z.i * t;\n        a.r = z.r * (t = a.r) - z.i * a.i;\n        a.i = z.r * a.i + z.i * t;\n        der.i = b.i;\n        der.r = b.r;\n        return a;\n    }",
        "fixed_function": "    public static Complex zpoly1d(Complex z, Complex[] C, Complex der) {\n        Complex a, b;\n        double t;\n        boolean first = true;\n\n        a = new Complex(C[C.length - 1]);\n        b = new Complex(a);\n        for (int i = C.length - 1; i > 0; i--) {\n            if (first) {\n                first = false;\n            } else {\n                b.r = a.r + z.r * (t = b.r) - z.i * b.i;\n                b.i = a.i + z.r * b.i + z.i * t;\n            }\n            Complex c = C[i-1];\n            a.r = c.r + z.r * (t = a.r) - z.i * a.i;\n            a.i = c.i + z.r * a.i + z.i * t;\n        }\n\n        b.r = a.r + z.r * (t = b.r) - z.i * b.i;\n        b.i = a.i + z.r * b.i + z.i * t;\n        a.r = z.r * (t = a.r) - z.i * a.i;\n        a.i = z.r * a.i + z.i * t;\n        der.i = b.i;\n        der.r = b.r;\n        return a;\n    }",
        "comment": "/**\n     * Evaluate a complex polynomial and its derivative\n     */"
      }
    ],
    "trigger_test": {
      "org.locationtech.proj4j.Proj4JSTest::testGood": {
        "path": "org/locationtech/proj4j/Proj4JSTest.java",
        "function_name": "testGood",
        "src": "@Test\n    public void testGood() {\n        checkTransformFromGeo(\"EPSG:23030\", -6.77432123185356, 37.88456231505968, 168035.13, 4199884.83, 100);\n        checkTransformFromGeo(\"EPSG:2403\", 81.0, 37.92, 2.75E7, 4198690.08, 3);\n        checkTransformFromGeo(\"EPSG:29100\", -53.0, 5.0, 5110899.06, 1.055297181E7, 4000);\n        checkTransformFromGeo(\"EPSG:3031\", -57.65625, -79.21875, -992481.633786, 628482.06328, 0.1);\n        checkTransformFromGeo(\"EPSG:3035\", 11.0, 53.0, 4388138.6, 3321736.46, 0.1);\n        checkTransformFromGeo(\"EPSG:3153\", -127.0, 52.11, 931625.91, 789252.65, 0.1);\n        checkTransformFromGeo(\"EPSG:32612\", -113.109375, 60.28125, 383357.429537, 6684599.06392, 0.1);\n        checkTransformFromGeo(\"EPSG:32615\", -93.0, 42.0, 500000.0, 4649776.22482, 0.1);\n        checkTransformFromGeo(\"EPSG:3411\", -32.0, 48.0, 1070076.44, -4635010.27, 2);\n        checkTransformFromGeo(\"EPSG:3573\", 9.84375, 61.875, 2923052.02009, 1054885.46559, 0.1);\n        checkTransformToGeo(\"EPSG:27200\",2464770.343667, 6056137.861919,172.465,-40.7,0.1);\n        checkTransformFromGeo(\"EPSG:27200\",172.465,-40.7, 2464780.81,6056330.22,0.1);\n    }",
        "error_msg": "org.locationtech.proj4j.Proj4JSTest::testGood --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Proj4J-5": {
    "function_num": 5,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 699,
        "end_loc": 701,
        "buggy_function": "    public void setSouthernHemisphere(boolean isSouth) {\n        this.isSouth = isSouth;\n    }",
        "fixed_function": "    public void setSouthernHemisphere(boolean isSouth) {\n        throw new NoSuchElementException();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 703,
        "end_loc": 703,
        "buggy_function": "    public boolean getSouthernHemisphere() { return isSouth; }",
        "fixed_function": "    public boolean getSouthernHemisphere() {\n        throw new NoSuchElementException();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 769,
        "end_loc": 771,
        "buggy_function": "    public double getHeightOfOrbit(){\n        return this.heightOfOrbit;\n    }",
        "fixed_function": "    public double getHeightOfOrbit(){\n        throw new NoSuchElementException();\n    }",
        "comment": "/**\n     * Get height of orbit - Geostationary satellite projection\n     * @return Height of orbit\n     */"
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 777,
        "end_loc": 779,
        "buggy_function": "    public void setHeightOfOrbit(double h){\n        this.heightOfOrbit = h;\n    }",
        "fixed_function": "    public void setHeightOfOrbit(double h){\n        throw new NoSuchElementException();\n    }",
        "comment": "/**\n     * Set height of orbit - Geostationary satellite projection\n     * @param h Height of orbit\n     */"
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/Projection.java",
        "start_loc": 819,
        "end_loc": 821,
        "buggy_function": "    public Boolean isGeographic() {\n        return false;\n    }",
        "fixed_function": "    @Override\n    public boolean equals(Object that) {\n        if (this == that) {\n            return true;\n        }\n        if (that instanceof Projection) {\n            Projection p = (Projection) that;\n            // Using Double.compare when values can be NaN and should still be equal\n            return (\n                // class represents implementation of project method\n                this.getClass().equals(that.getClass()) &&\n                ellipsoid.isEqual(p.ellipsoid) &&\n                falseNorthing == p.falseNorthing &&\n                falseEasting == p.falseEasting &&\n                scaleFactor == p.scaleFactor &&\n                fromMetres == p.fromMetres &&\n                trueScaleLatitude == p.trueScaleLatitude &&\n                projectionLatitude == p.projectionLatitude &&\n                projectionLongitude == p.projectionLongitude &&\n                projectionLatitude1 == p.projectionLatitude1 &&\n                projectionLatitude2 == p.projectionLatitude2 &&\n                minLatitude == p.minLatitude &&\n                maxLatitude == p.maxLatitude &&\n                minLongitude == p.minLongitude &&\n                maxLongitude == p.maxLongitude &&\n                axes.equals(p.axes) &&\n                unit.equals(p.unit) &&\n                primeMeridian.equals(p.primeMeridian));\n        }\n        return false;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.locationtech.proj4j.proj.ProjectionEqualityTest::utmEquality": {
        "path": "org/locationtech/proj4j/proj/ProjectionEqualityTest.java",
        "function_name": "utmEquality",
        "src": "@Test\n\tpublic void utmEquality() {\n\n    CoordinateReferenceSystem cs1 = csFactory.createFromName(\"EPSG:26710\");\n    CoordinateReferenceSystem cs2 = csFactory.createFromParameters(null, \"+proj=utm +zone=10 +datum=NAD27 +units=m +no_defs\");\n    assertEquals(cs1, cs2);\n\n    CoordinateReferenceSystem cs3 = csFactory.createFromName(\"EPSG:26711\");\n    assertNotEquals(cs1, cs3);\n  }",
        "error_msg": "org.locationtech.proj4j.proj.ProjectionEqualityTest::utmEquality --> junit.framework.AssertionFailedError: expected:<EPSG:26710> but was:<utm-CS>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<EPSG:26710> but was:<utm-CS>"
      }
    }
  },
  "Proj4J-6": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/proj4j/Registry.java",
        "start_loc": 158,
        "end_loc": 291,
        "buggy_function": "    private synchronized void initialize() {\n        // guard against race condition\n        if (projRegistry != null)\n            return;\n        projRegistry = new HashMap();\n        register(\"aea\", AlbersProjection.class, \"Albers Equal Area\");\n        register(\"aeqd\", EquidistantAzimuthalProjection.class, \"Azimuthal Equidistant\");\n        register(\"airy\", AiryProjection.class, \"Airy\");\n        register(\"aitoff\", AitoffProjection.class, \"Aitoff\");\n        register(\"alsk\", Projection.class, \"Mod. Stereographics of Alaska\");\n        register(\"apian\", Projection.class, \"Apian Globular I\");\n        register(\"august\", AugustProjection.class, \"August Epicycloidal\");\n        register(\"bacon\", Projection.class, \"Bacon Globular\");\n        register(\"bipc\", BipolarProjection.class, \"Bipolar conic of western hemisphere\");\n        register(\"boggs\", BoggsProjection.class, \"Boggs Eumorphic\");\n        register(\"bonne\", BonneProjection.class, \"Bonne (Werner lat_1=90)\");\n        register(\"cass\", CassiniProjection.class, \"Cassini\");\n        register(\"cc\", CentralCylindricalProjection.class, \"Central Cylindrical\");\n        register(\"cea\", CylindricalEqualAreaProjection.class, \"Equal Area Cylindrical\");\n        // register( \"chamb\", Projection.class, \"Chamberlin Trimetric\" );\n        register(\"collg\", CollignonProjection.class, \"Collignon\");\n        register(\"crast\", CrasterProjection.class, \"Craster Parabolic (Putnins P4)\");\n        register(\"denoy\", DenoyerProjection.class, \"Denoyer Semi-Elliptical\");\n        register(\"eck1\", Eckert1Projection.class, \"Eckert I\");\n        register(\"eck2\", Eckert2Projection.class, \"Eckert II\");\n        // register( \"eck3\", Eckert3Projection.class, \"Eckert III\" );\n        register(\"eck4\", Eckert4Projection.class, \"Eckert IV\");\n        register(\"eck5\", Eckert5Projection.class, \"Eckert V\");\n        register(\"eck6\", Eckert6Projection.class, \"Eckert VI\");\n        register(\"eqc\", PlateCarreeProjection.class, \"Equidistant Cylindrical (Plate Caree)\");\n        register(\"eqdc\", EquidistantConicProjection.class, \"Equidistant Conic\");\n        register(\"euler\", EulerProjection.class, \"Euler\");\n        register(\"fahey\", FaheyProjection.class, \"Fahey\");\n        register(\"fouc\", FoucautProjection.class, \"Foucaut\");\n        register(\"fouc_s\", FoucautSinusoidalProjection.class, \"Foucaut Sinusoidal\");\n        register(\"gall\", GallProjection.class, \"Gall (Gall Stereographic)\");\n        register(\"geocent\", GeocentProjection.class, \"Geocentric\");\n        register(\"geos\", GeostationarySatelliteProjection.class, \"Geostationary Satellite\");\n        // register( \"gins8\", Projection.class, \"Ginsburg VIII (TsNIIGAiK)\" );\n        // register( \"gn_sinu\", Projection.class, \"General Sinusoidal Series\" );\n        register(\"gnom\", GnomonicAzimuthalProjection.class, \"Gnomonic\");\n        register(\"goode\", GoodeProjection.class, \"Goode Homolosine\");\n        // register( \"gs48\", Projection.class, \"Mod. Stererographics of 48 U.S.\" );\n        // register( \"gs50\", Projection.class, \"Mod. Stererographics of 50 U.S.\" );\n        register(\"hammer\", HammerProjection.class, \"Hammer & Eckert-Greifendorff\");\n        register(\"hatano\", HatanoProjection.class, \"Hatano Asymmetrical Equal Area\");\n        // register( \"imw_p\", Projection.class, \"Internation Map of the World Polyconic\" );\n        register(\"kav5\", KavraiskyVProjection.class, \"Kavraisky V\");\n        // register( \"kav7\", Projection.class, \"Kavraisky VII\" );\n        register(\"krovak\", KrovakProjection.class, \"Krovak\");\n        // register( \"labrd\", Projection.class, \"Laborde\" );\n        register(\"laea\", LambertAzimuthalEqualAreaProjection.class, \"Lambert Azimuthal Equal Area\");\n        register(\"lagrng\", LagrangeProjection.class, \"Lagrange\");\n        register(\"larr\", LarriveeProjection.class, \"Larrivee\");\n        register(\"lask\", LaskowskiProjection.class, \"Laskowski\");\n        register(\"latlong\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"longlat\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"latlon\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"lonlat\", LongLatProjection.class, \"Lat/Long (Geodetic)\");\n        register(\"lcc\", LambertConformalConicProjection.class, \"Lambert Conformal Conic\");\n        register(\"leac\", LambertEqualAreaConicProjection.class, \"Lambert Equal Area Conic\");\n        // register( \"lee_os\", Projection.class, \"Lee Oblated Stereographic\" );\n        register(\"loxim\", LoximuthalProjection.class, \"Loximuthal\");\n        register(\"lsat\", LandsatProjection.class, \"Space oblique for LANDSAT\");\n        // register( \"mbt_s\", Projection.class, \"McBryde-Thomas Flat-Polar Sine\" );\n        register(\"mbt_fps\", McBrydeThomasFlatPolarSine2Projection.class, \"McBryde-Thomas Flat-Pole Sine (No. 2)\");\n        register(\"mbtfpp\", McBrydeThomasFlatPolarParabolicProjection.class, \"McBride-Thomas Flat-Polar Parabolic\");\n        register(\"mbtfpq\", McBrydeThomasFlatPolarQuarticProjection.class, \"McBryde-Thomas Flat-Polar Quartic\");\n        // register( \"mbtfps\", Projection.class, \"McBryde-Thomas Flat-Polar Sinusoidal\" );\n        register(\"merc\", MercatorProjection.class, \"Mercator\");\n        // register( \"mil_os\", Projection.class, \"Miller Oblated Stereographic\" );\n        register(\"mill\", MillerProjection.class, \"Miller Cylindrical\");\n        // register( \"mpoly\", Projection.class, \"Modified Polyconic\" );\n        register(\"moll\", MolleweideProjection.class, \"Mollweide\");\n        register(\"murd1\", Murdoch1Projection.class, \"Murdoch I\");\n        register(\"murd2\", Murdoch2Projection.class, \"Murdoch II\");\n        register(\"murd3\", Murdoch3Projection.class, \"Murdoch III\");\n        register(\"nell\", NellProjection.class, \"Nell\");\n        // register( \"nell_h\", Projection.class, \"Nell-Hammer\" );\n        register(\"nicol\", NicolosiProjection.class, \"Nicolosi Globular\");\n        register(\"nsper\", PerspectiveProjection.class, \"Near-sided perspective\");\n        register(\"nzmg\", NewZealandMapGridProjection.class, \"New Zealand Map Grid\");\n        // register( \"ob_tran\", Projection.class, \"General Oblique Transformation\" );\n        // register( \"ocea\", Projection.class, \"Oblique Cylindrical Equal Area\" );\n        // register( \"oea\", Projection.class, \"Oblated Equal Area\" );\n        register(\"omerc\", ObliqueMercatorProjection.class, \"Oblique Mercator\");\n        // register( \"ortel\", Projection.class, \"Ortelius Oval\" );\n        register(\"ortho\", OrthographicAzimuthalProjection.class, \"Orthographic\");\n        register(\"pconic\", PerspectiveConicProjection.class, \"Perspective Conic\");\n        register(\"poly\", PolyconicProjection.class, \"Polyconic (American)\");\n        // register( \"putp1\", Projection.class, \"Putnins P1\" );\n        register(\"putp2\", PutninsP2Projection.class, \"Putnins P2\");\n        // register( \"putp3\", Projection.class, \"Putnins P3\" );\n        // register( \"putp3p\", Projection.class, \"Putnins P3'\" );\n        register(\"putp4p\", PutninsP4Projection.class, \"Putnins P4'\");\n        register(\"putp5\", PutninsP5Projection.class, \"Putnins P5\");\n        register(\"putp5p\", PutninsP5PProjection.class, \"Putnins P5'\");\n        // register( \"putp6\", Projection.class, \"Putnins P6\" );\n        // register( \"putp6p\", Projection.class, \"Putnins P6'\" );\n        register(\"qua_aut\", QuarticAuthalicProjection.class, \"Quartic Authalic\");\n        register(\"robin\", RobinsonProjection.class, \"Robinson\");\n        register(\"rpoly\", RectangularPolyconicProjection.class, \"Rectangular Polyconic\");\n        register(\"sinu\", SinusoidalProjection.class, \"Sinusoidal (Sanson-Flamsteed)\");\n        register(\"somerc\", SwissObliqueMercatorProjection.class, \"Swiss Oblique Mercator\");\n        register(\"stere\", StereographicAzimuthalProjection.class, \"Stereographic\");\n        register(\"sterea\", ObliqueStereographicAlternativeProjection.class, \"Oblique Stereographic Alternative\");\n        register(\"tcc\", TranverseCentralCylindricalProjection.class, \"Transverse Central Cylindrical\");\n        register(\"tcea\", TransverseCylindricalEqualArea.class, \"Transverse Cylindrical Equal Area\");\n        // register( \"tissot\", TissotProjection.class, \"Tissot Conic\" );\n        register(\"tmerc\", TransverseMercatorProjection.class, \"Transverse Mercator\");\n        register(\"etmerc\", ExtendedTransverseMercatorProjection.class, \"Extended Transverse Mercator\");\n        // register( \"tpeqd\", Projection.class, \"Two Point Equidistant\" );\n        // register( \"tpers\", Projection.class, \"Tilted perspective\" );\n        // register( \"ups\", Projection.class, \"Universal Polar Stereographic\" );\n        // register( \"urm5\", Projection.class, \"Urmaev V\" );\n        register(\"urmfps\", UrmaevFlatPolarSinusoidalProjection.class, \"Urmaev Flat-Polar Sinusoidal\");\n        register(\"utm\", TransverseMercatorProjection.class, \"Universal Transverse Mercator (UTM)\");\n        register(\"vandg\", VanDerGrintenProjection.class, \"van der Grinten (I)\");\n        // register( \"vandg2\", Projection.class, \"van der Grinten II\" );\n        // register( \"vandg3\", Projection.class, \"van der Grinten III\" );\n        // register( \"vandg4\", Projection.class, \"van der Grinten IV\" );\n        register(\"vitk1\", VitkovskyProjection.class, \"Vitkovsky I\");\n        register(\"wag1\", Wagner1Projection.class, \"Wagner I (Kavraisky VI)\");\n        register(\"wag2\", Wagner2Projection.class, \"Wagner II\");\n        register(\"wag3\", Wagner3Projection.class, \"Wagner III\");\n        register(\"wag4\", Wagner4Projection.class, \"Wagner IV\");\n        register(\"wag5\", Wagner5Projection.class, \"Wagner V\");\n        // register( \"wag6\", Projection.class, \"Wagner VI\" );\n        register(\"wag7\", Wagner7Projection.class, \"Wagner VII\");\n        register(\"weren\", WerenskioldProjection.class, \"Werenskiold I\");\n        // register( \"wink1\", Projection.class, \"Winkel I\" );\n        // register( \"wink2\", Projection.class, \"Winkel II\" );\n        register(\"wintri\", WinkelTripelProjection.class, \"Winkel Tripel\");\n    }",
        "fixed_function": "    private synchronized void initialize() {\n        // guard against race condition\n        if (projRegistry != null)\n            return;\n        projRegistry = new HashMap();\n        register(\"aea\", AlbersProjection.class, \"Albers Equal Area\");\n        register(\"aeqd\", EquidistantAzimuthalProjection.class, \"Azimuthal Equidistant\");\n        register(\"airy\", AiryProjection.class, \"Airy\");\n        register(\"aitoff\", AitoffProjection.class, \"Aitoff\");\n        register(\"alsk\", Projection.class, \"Mod. Stereographics of Alaska\");\n        register(\"apian\", Projection.class, \"Apian Globular I\");\n        register(\"august\", AugustProjection.class, \"August Epicycloidal\");\n        register(\"bacon\", Projection.class, \"Bacon Globular\");\n        register(\"bipc\", BipolarProjection.class, \"Bipolar conic of western hemisphere\");\n        register(\"boggs\", BoggsProjection.class, \"Boggs Eumorphic\");\n        register(\"bonne\", BonneProjection.class, \"Bonne (Werner lat_1=90)\");\n        register(\"cass\", CassiniProjection.class, \"Cassini\");\n        register(\"cc\", CentralCylindricalProjection.class, \"Central Cylindrical\");\n        register(\"cea\", CylindricalEqualAreaProjection.class, \"Equal Area Cylindrical\");\n        // register( \"chamb\", Projection.class, \"Chamberlin Trimetric\" );\n        register(\"collg\", CollignonProjection.class, \"Collignon\");\n        register(\"crast\", CrasterProjection.class, \"Craster Parabolic (Putnins P4)\");\n        register(\"denoy\", DenoyerProjection.class, \"Denoyer Semi-Elliptical\");\n        register(\"eck1\", Eckert1Projection.class, \"Eckert I\");\n        register(\"eck2\", Eckert2Projection.class, \"Eckert II\");\n        // register( \"eck3\", Eckert3Projection.class, \"Eckert III\" );\n        register(\"eck4\", Eckert4Projection.class, \"Eckert IV\");\n        register(\"eck5\", Eckert5Projection.class, \"Eckert V\");\n        register(\"eck6\", Eckert6Projection.class, \"Eckert VI\");\n        register(\"eqc\", PlateCarreeProjection.class, \"Equidistant Cylindrical (Plate Caree)\");\n        register(\"eqdc\", EquidistantConicProjection.class, \"Equidistant Conic\");\n        register(\"euler\", EulerProjection.class, \"Euler\");\n        register(\"fahey\", FaheyProjection.class, \"Fahey\");\n        register(\"fouc\", FoucautProjection.class, \"Foucaut\");\n        register(\"fouc_s\", FoucautSinusoidalProjection.class, \"Foucaut Sinusoidal\");\n        register(\"gall\", GallProjection.class, \"Gall (Gall Stereographic)\");\n        register(\"geocent\", GeocentProjection.class, \"Geocentric\");\n        register(\"geos\", GeostationarySatelliteProjection.class, \"Geostationary Satellite\");\n        // register( \"gins8\", Projection.class, \"Ginsburg VIII (TsNIIGAiK)\" );\n        // register( \"gn_sinu\", Projection.class, \"General Sinusoidal Series\" );\n        register(\"gnom\", GnomonicAzimuthalProjection.class, \"Gnomonic\");\n        register(\"goode\", GoodeProjection.class, \"Goode Homolosine\");\n        // register( \"gs48\", Projection.class, \"Mod. Stererographics of 48 U.S.\" );\n        // register( \"gs50\", Projection.class, \"Mod. Stererographics of 50 U.S.\" );\n        register(\"hammer\", HammerProjection.class, \"Hammer & Eckert-Greifendorff\");\n        register(\"hatano\", HatanoProjection.class, \"Hatano Asymmetrical Equal Area\");\n        // register( \"imw_p\", Projection.class, \"Internation Map of the World Polyconic\" );\n        register(\"kav5\", KavraiskyVProjection.class, \"Kavraisky V\");\n        // register( \"kav7\", Projection.class, \"Kavraisky VII\" );\n        register(\"krovak\", KrovakProjection.class, \"Krovak\");\n        // register( \"labrd\", Projection.class, \"Laborde\" );\n        register(\"laea\", LambertAzimuthalEqualAreaProjection.class, \"Lambert Azimuthal Equal Area\");\n        register(\"lagrng\", LagrangeProjection.class, \"Lagrange\");\n        register(\"larr\", LarriveeProjection.class, \"Larrivee\");\n        register(\"lask\", LaskowskiProjection.class, \"Laskowski\");\n        register(\"latlong\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"longlat\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"latlon\", LongLatProjection.class, \"Lat/Long (Geodetic alias)\");\n        register(\"lonlat\", LongLatProjection.class, \"Lat/Long (Geodetic)\");\n        register(\"lcc\", LambertConformalConicProjection.class, \"Lambert Conformal Conic\");\n        register(\"leac\", LambertEqualAreaConicProjection.class, \"Lambert Equal Area Conic\");\n        // register( \"lee_os\", Projection.class, \"Lee Oblated Stereographic\" );\n        register(\"loxim\", LoximuthalProjection.class, \"Loximuthal\");\n        register(\"lsat\", LandsatProjection.class, \"Space oblique for LANDSAT\");\n        // register( \"mbt_s\", Projection.class, \"McBryde-Thomas Flat-Polar Sine\" );\n        register(\"mbt_fps\", McBrydeThomasFlatPolarSine2Projection.class, \"McBryde-Thomas Flat-Pole Sine (No. 2)\");\n        register(\"mbtfpp\", McBrydeThomasFlatPolarParabolicProjection.class, \"McBride-Thomas Flat-Polar Parabolic\");\n        register(\"mbtfpq\", McBrydeThomasFlatPolarQuarticProjection.class, \"McBryde-Thomas Flat-Polar Quartic\");\n        // register( \"mbtfps\", Projection.class, \"McBryde-Thomas Flat-Polar Sinusoidal\" );\n        register(\"merc\", MercatorProjection.class, \"Mercator\");\n        // register( \"mil_os\", Projection.class, \"Miller Oblated Stereographic\" );\n        register(\"mill\", MillerProjection.class, \"Miller Cylindrical\");\n        // register( \"mpoly\", Projection.class, \"Modified Polyconic\" );\n        register(\"moll\", MolleweideProjection.class, \"Mollweide\");\n        register(\"murd1\", Murdoch1Projection.class, \"Murdoch I\");\n        register(\"murd2\", Murdoch2Projection.class, \"Murdoch II\");\n        register(\"murd3\", Murdoch3Projection.class, \"Murdoch III\");\n        register(\"nell\", NellProjection.class, \"Nell\");\n        // register( \"nell_h\", Projection.class, \"Nell-Hammer\" );\n        register(\"nicol\", NicolosiProjection.class, \"Nicolosi Globular\");\n        register(\"nsper\", PerspectiveProjection.class, \"Near-sided perspective\");\n        register(\"nzmg\", NewZealandMapGridProjection.class, \"New Zealand Map Grid\");\n        // register( \"ob_tran\", Projection.class, \"General Oblique Transformation\" );\n        // register( \"ocea\", Projection.class, \"Oblique Cylindrical Equal Area\" );\n        // register( \"oea\", Projection.class, \"Oblated Equal Area\" );\n        register(\"omerc\", ObliqueMercatorProjection.class, \"Oblique Mercator\");\n        // register( \"ortel\", Projection.class, \"Ortelius Oval\" );\n        register(\"ortho\", OrthographicAzimuthalProjection.class, \"Orthographic\");\n        register(\"pconic\", PerspectiveConicProjection.class, \"Perspective Conic\");\n        register(\"poly\", PolyconicProjection.class, \"Polyconic (American)\");\n        // register( \"putp1\", Projection.class, \"Putnins P1\" );\n        register(\"putp2\", PutninsP2Projection.class, \"Putnins P2\");\n        // register( \"putp3\", Projection.class, \"Putnins P3\" );\n        // register( \"putp3p\", Projection.class, \"Putnins P3'\" );\n        register(\"putp4p\", PutninsP4Projection.class, \"Putnins P4'\");\n        register(\"putp5\", PutninsP5Projection.class, \"Putnins P5\");\n        register(\"putp5p\", PutninsP5PProjection.class, \"Putnins P5'\");\n        // register( \"putp6\", Projection.class, \"Putnins P6\" );\n        // register( \"putp6p\", Projection.class, \"Putnins P6'\" );\n        register(\"qua_aut\", QuarticAuthalicProjection.class, \"Quartic Authalic\");\n        register(\"robin\", RobinsonProjection.class, \"Robinson\");\n        register(\"rpoly\", RectangularPolyconicProjection.class, \"Rectangular Polyconic\");\n        register(\"sinu\", SinusoidalProjection.class, \"Sinusoidal (Sanson-Flamsteed)\");\n        register(\"somerc\", SwissObliqueMercatorProjection.class, \"Swiss Oblique Mercator\");\n        register(\"stere\", StereographicAzimuthalProjection.class, \"Stereographic\");\n        register(\"sterea\", ObliqueStereographicAlternativeProjection.class, \"Oblique Stereographic Alternative\");\n        register(\"tcc\", TranverseCentralCylindricalProjection.class, \"Transverse Central Cylindrical\");\n        register(\"tcea\", TransverseCylindricalEqualArea.class, \"Transverse Cylindrical Equal Area\");\n        // register( \"tissot\", TissotProjection.class, \"Tissot Conic\" );\n        register(\"tmerc\", TransverseMercatorProjection.class, \"Transverse Mercator\");\n        register(\"etmerc\", ExtendedTransverseMercatorProjection.class, \"Extended Transverse Mercator\");\n        // register( \"tpeqd\", Projection.class, \"Two Point Equidistant\" );\n        // register( \"tpers\", Projection.class, \"Tilted perspective\" );\n        // register( \"ups\", Projection.class, \"Universal Polar Stereographic\" );\n        // register( \"urm5\", Projection.class, \"Urmaev V\" );\n        register(\"urmfps\", UrmaevFlatPolarSinusoidalProjection.class, \"Urmaev Flat-Polar Sinusoidal\");\n        register(\"utm\", ExtendedTransverseMercatorProjection.class, \"Universal Transverse Mercator (UTM)\");\n        register(\"vandg\", VanDerGrintenProjection.class, \"van der Grinten (I)\");\n        // register( \"vandg2\", Projection.class, \"van der Grinten II\" );\n        // register( \"vandg3\", Projection.class, \"van der Grinten III\" );\n        // register( \"vandg4\", Projection.class, \"van der Grinten IV\" );\n        register(\"vitk1\", VitkovskyProjection.class, \"Vitkovsky I\");\n        register(\"wag1\", Wagner1Projection.class, \"Wagner I (Kavraisky VI)\");\n        register(\"wag2\", Wagner2Projection.class, \"Wagner II\");\n        register(\"wag3\", Wagner3Projection.class, \"Wagner III\");\n        register(\"wag4\", Wagner4Projection.class, \"Wagner IV\");\n        register(\"wag5\", Wagner5Projection.class, \"Wagner V\");\n        // register( \"wag6\", Projection.class, \"Wagner VI\" );\n        register(\"wag7\", Wagner7Projection.class, \"Wagner VII\");\n        register(\"weren\", WerenskioldProjection.class, \"Werenskiold I\");\n        // register( \"wink1\", Projection.class, \"Winkel I\" );\n        // register( \"wink2\", Projection.class, \"Winkel II\" );\n        register(\"wintri\", WinkelTripelProjection.class, \"Winkel Tripel\");\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/LambertConformalConicProjection.java",
        "start_loc": 30,
        "end_loc": 40,
        "buggy_function": "\tpublic LambertConformalConicProjection() {\n\t\tminLatitude = Math.toRadians(0);\n\t\tmaxLatitude = Math.toRadians(80.0);\n\t\t// an incorrect init, LCC is sensitive to input parameters\n\t\t// init should happen only after the LCC projection parsing\n\t\t// projectionLatitude = ProjectionMath.QUARTERPI;\n\t\tprojectionLatitude = ProjectionMath.QUARTERPI;\n\t\tprojectionLatitude1 = 0;\n\t\tprojectionLatitude2 = 0;\n\t\tinitialize();\n\t}",
        "fixed_function": "\tpublic LambertConformalConicProjection() {\n\t\tminLatitude = Math.toRadians(0);\n\t\tmaxLatitude = Math.toRadians(80.0);\n\t\t// an incorrect init, LCC is sensitive to input parameters\n\t\t// init should happen only after the LCC projection parsing\n\t\t// projectionLatitude = ProjectionMath.QUARTERPI;\n\t\tprojectionLatitude1 = 0;\n\t\tprojectionLatitude2 = 0;\n\t\t// initialize();\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/LambertConformalConicProjection.java",
        "start_loc": 93,
        "end_loc": 138,
        "buggy_function": "\tpublic void initialize() {\n\t\tsuper.initialize();\n\t\tdouble cosphi, sinphi;\n\t\tboolean secant;\n\n\t\t// Old code:\n\t\t// if ( projectionLatitude1 == 0 )\n\t\t\t// projectionLatitude1 = projectionLatitude2 = projectionLatitude;\n\n\t\t// https://github.com/OSGeo/PROJ/blob/e3d7e18f988230973ced5163fa2581b6671c8755/src/projections/lcc.cpp#L89-L96\n\t\t// if there is no lat2 set it to lat1\n\t\tif ( projectionLatitude1 == 0) {\n\t\t\tprojectionLatitude1 = projectionLatitude2 = projectionLatitude;\n\t\t\t// if there is no lat0, set it to lat1\n\t\t}\n\n\n\t\tif (Math.abs(projectionLatitude1 + projectionLatitude2) < 1e-10)\n\t\t\tthrow new ProjectionException();\n\t\tn = sinphi = Math.sin(projectionLatitude1);\n\t\tcosphi = Math.cos(projectionLatitude1);\n\t\tsecant = Math.abs(projectionLatitude1 - projectionLatitude2) >= 1e-10;\n\t\tspherical = (es == 0.0);\n\t\tif (!spherical) {\n\t\t\tdouble ml1, m1;\n\n\t\t\tm1 = ProjectionMath.msfn(sinphi, cosphi, es);\n\t\t\tml1 = ProjectionMath.tsfn(projectionLatitude1, sinphi, e);\n\t\t\tif (secant) {\n\t\t\t\tn = Math.log(m1 /\n\t\t\t\t   ProjectionMath.msfn(sinphi = Math.sin(projectionLatitude2), Math.cos(projectionLatitude2), es));\n\t\t\t\tn /= Math.log(ml1 / ProjectionMath.tsfn(projectionLatitude2, sinphi, e));\n\t\t\t}\n\t\t\tc = (rho0 = m1 * Math.pow(ml1, -n) / n);\n\t\t\trho0 *= (Math.abs(Math.abs(projectionLatitude) - ProjectionMath.HALFPI) < 1e-10) ? 0. :\n\t\t\t\tMath.pow(ProjectionMath.tsfn(projectionLatitude, Math.sin(projectionLatitude), e), n);\n\t\t} else {\n\t\t\tif (secant)\n\t\t\t\tn = Math.log(cosphi / Math.cos(projectionLatitude2)) /\n\t\t\t\t   Math.log(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude2) /\n\t\t\t\t   Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude1));\n\t\t\tc = cosphi * Math.pow(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude1), n) / n;\n\t\t\trho0 = (Math.abs(Math.abs(projectionLatitude) - ProjectionMath.HALFPI) < 1e-10) ? 0. :\n\t\t\t\tc * Math.pow(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude), -n);\n\t\t}\n\t}",
        "fixed_function": "\tpublic void initialize() {\n\t\tsuper.initialize();\n\t\tdouble cosphi, sinphi;\n\t\tboolean secant;\n\n\t\t// Old code:\n\t\t// if ( projectionLatitude1 == 0 )\n\t\t\t// projectionLatitude1 = projectionLatitude2 = projectionLatitude;\n\n\t\t// https://github.com/OSGeo/PROJ/blob/e3d7e18f988230973ced5163fa2581b6671c8755/src/projections/lcc.cpp#L89-L96\n\t\t// if there is no lat2 set it to lat1\n\t\tif (projectionLatitude2 == 0) {\n\t\t\tprojectionLatitude2 = projectionLatitude1;\n\t\t\t// if there is no lat0, set it to lat1\n\t\t\tif(projectionLatitude == 0)\n\t\t\t\tprojectionLatitude = projectionLatitude1;\n\t\t}\n\n\n\t\tif (Math.abs(projectionLatitude1 + projectionLatitude2) < 1e-10)\n\t\t\tthrow new ProjectionException();\n\t\tn = sinphi = Math.sin(projectionLatitude1);\n\t\tcosphi = Math.cos(projectionLatitude1);\n\t\tsecant = Math.abs(projectionLatitude1 - projectionLatitude2) >= 1e-10;\n\t\tspherical = (es == 0.0);\n\t\tif (!spherical) {\n\t\t\tdouble ml1, m1;\n\n\t\t\tm1 = ProjectionMath.msfn(sinphi, cosphi, es);\n\t\t\tml1 = ProjectionMath.tsfn(projectionLatitude1, sinphi, e);\n\t\t\tif (secant) {\n\t\t\t\tn = Math.log(m1 /\n\t\t\t\t   ProjectionMath.msfn(sinphi = Math.sin(projectionLatitude2), Math.cos(projectionLatitude2), es));\n\t\t\t\tn /= Math.log(ml1 / ProjectionMath.tsfn(projectionLatitude2, sinphi, e));\n\t\t\t}\n\t\t\tc = (rho0 = m1 * Math.pow(ml1, -n) / n);\n\t\t\trho0 *= (Math.abs(Math.abs(projectionLatitude) - ProjectionMath.HALFPI) < 1e-10) ? 0. :\n\t\t\t\tMath.pow(ProjectionMath.tsfn(projectionLatitude, Math.sin(projectionLatitude), e), n);\n\t\t} else {\n\t\t\tif (secant)\n\t\t\t\tn = Math.log(cosphi / Math.cos(projectionLatitude2)) /\n\t\t\t\t   Math.log(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude2) /\n\t\t\t\t   Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude1));\n\t\t\tc = cosphi * Math.pow(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude1), n) / n;\n\t\t\trho0 = (Math.abs(Math.abs(projectionLatitude) - ProjectionMath.HALFPI) < 1e-10) ? 0. :\n\t\t\t\tc * Math.pow(Math.tan(ProjectionMath.QUARTERPI + .5 * projectionLatitude), -n);\n\t\t}\n\t}",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/proj/StereographicAzimuthalProjection.java",
        "start_loc": 105,
        "end_loc": 169,
        "buggy_function": "\tpublic ProjCoordinate project(double lam, double phi, ProjCoordinate xy) {\n\t\tdouble coslam = Math.cos(lam);\n\t\tdouble sinlam = Math.sin(lam);\n\t\tdouble sinphi = Math.sin(phi);\n\n\t\tif (spherical) {\n\t\t\tdouble cosphi = Math.cos(phi);\n\n\t\t\tswitch (mode) {\n\t\t\tcase EQUATOR:\n\t\t\t\txy.y = 1. + cosphi * coslam;\n\t\t\t\tif (xy.y <= EPS10)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = (xy.y = akm1 / xy.y) * cosphi * sinlam;\n\t\t\t\txy.y *= sinphi;\n\t\t\t\tbreak;\n\t\t\tcase OBLIQUE:\n\t\t\t\txy.y = 1. + sinphi0 * sinphi + cosphi0 * cosphi * coslam;\n\t\t\t\tif (xy.y <= EPS10)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = (xy.y = akm1 / xy.y) * cosphi * sinlam;\n\t\t\t\txy.y *= cosphi0 * sinphi - sinphi0 * cosphi * coslam;\n\t\t\t\tbreak;\n\t\t\tcase NORTH_POLE:\n\t\t\t\tcoslam = - coslam;\n\t\t\t\tphi = - phi;\n\t\t\tcase SOUTH_POLE:\n\t\t\t\tif (Math.abs(phi - ProjectionMath.HALFPI) < TOL)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = sinlam * ( xy.y = akm1 * Math.tan(ProjectionMath.QUARTERPI + .5 * phi) );\n\t\t\t\txy.y *= coslam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdouble sinX = 0, cosX = 0, X, A;\n\n\t\t\tif (mode == OBLIQUE || mode == EQUATOR) {\n\t\t\t\tsinX = Math.sin(X = 2. * Math.atan(ssfn(phi, sinphi, e)) - ProjectionMath.HALFPI);\n\t\t\t\tcosX = Math.cos(X);\n\t\t\t}\n\t\t\tswitch (mode) {\n\t\t\tcase OBLIQUE:\n\t\t\t\tA = akm1 / (cosphi0 * (1. + sinphi0 * sinX + cosphi0 * cosX * coslam));\n\t\t\t\txy.y = A * (cosphi0 * sinX - sinphi0 * cosX * coslam);\n\t\t\t\txy.x = A * cosX;\n\t\t\t\tbreak;\n\t\t\tcase EQUATOR:\n\t\t\t\t// https://github.com/OSGeo/PROJ/blob/8.0.0/src/projections/stere.cpp#L77\n\t\t\t\tA = 2. * akm1 / (1. + cosX * coslam);\n\t\t\t\txy.y = A * sinX;\n\t\t\t\txy.x = A * cosX;\n\t\t\t\tbreak;\n\t\t\tcase SOUTH_POLE:\n\t\t\t\tphi = -phi;\n\t\t\t\tcoslam = -coslam;\n\t\t\t\tsinphi = -sinphi;\n\t\t\tcase NORTH_POLE:\n\t\t\t\txy.x = akm1 * ProjectionMath.tsfn(phi, sinphi, e);\n\t\t\t\txy.y = - xy.x * coslam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txy.x = xy.x * sinlam;\n\t\t}\n\t\treturn xy;\n\t}",
        "fixed_function": "\tpublic ProjCoordinate project(double lam, double phi, ProjCoordinate xy) {\n\t\tdouble coslam = Math.cos(lam);\n\t\tdouble sinlam = Math.sin(lam);\n\t\tdouble sinphi = Math.sin(phi);\n\n\t\tif (spherical) {\n\t\t\tdouble cosphi = Math.cos(phi);\n\n\t\t\tswitch (mode) {\n\t\t\tcase EQUATOR:\n\t\t\t\txy.y = 1. + cosphi * coslam;\n\t\t\t\tif (xy.y <= EPS10)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = (xy.y = akm1 / xy.y) * cosphi * sinlam;\n\t\t\t\txy.y *= sinphi;\n\t\t\t\tbreak;\n\t\t\tcase OBLIQUE:\n\t\t\t\txy.y = 1. + sinphi0 * sinphi + cosphi0 * cosphi * coslam;\n\t\t\t\tif (xy.y <= EPS10)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = (xy.y = akm1 / xy.y) * cosphi * sinlam;\n\t\t\t\txy.y *= cosphi0 * sinphi - sinphi0 * cosphi * coslam;\n\t\t\t\tbreak;\n\t\t\tcase NORTH_POLE:\n\t\t\t\tcoslam = - coslam;\n\t\t\t\tphi = - phi;\n\t\t\tcase SOUTH_POLE:\n\t\t\t\tif (Math.abs(phi - ProjectionMath.HALFPI) < TOL)\n\t\t\t\t\tthrow new ProjectionException();\n\t\t\t\txy.x = sinlam * ( xy.y = akm1 * Math.tan(ProjectionMath.QUARTERPI + .5 * phi) );\n\t\t\t\txy.y *= coslam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdouble sinX = 0, cosX = 0, X, A;\n\n\t\t\tif (mode == OBLIQUE || mode == EQUATOR) {\n\t\t\t\tsinX = Math.sin(X = 2. * Math.atan(ssfn(phi, sinphi, e)) - ProjectionMath.HALFPI);\n\t\t\t\tcosX = Math.cos(X);\n\t\t\t}\n\t\t\tswitch (mode) {\n\t\t\tcase OBLIQUE:\n\t\t\t\tA = akm1 / (cosphi0 * (1. + sinphi0 * sinX + cosphi0 * cosX * coslam));\n\t\t\t\txy.y = A * (cosphi0 * sinX - sinphi0 * cosX * coslam);\n\t\t\t\txy.x = A * cosX;\n\t\t\t\tbreak;\n\t\t\tcase EQUATOR:\n\t\t\t\t// https://github.com/OSGeo/PROJ/blob/8.0.0/src/projections/stere.cpp#L77\n\t\t\t\tA = akm1 / (1. + cosX * coslam);\n\t\t\t\txy.y = A * sinX;\n\t\t\t\txy.x = A * cosX;\n\t\t\t\tbreak;\n\t\t\tcase SOUTH_POLE:\n\t\t\t\tphi = -phi;\n\t\t\t\tcoslam = -coslam;\n\t\t\t\tsinphi = -sinphi;\n\t\t\tcase NORTH_POLE:\n\t\t\t\txy.x = akm1 * ProjectionMath.tsfn(phi, sinphi, e);\n\t\t\t\txy.y = - xy.x * coslam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txy.x = xy.x * sinlam;\n\t\t}\n\t\treturn xy;\n\t}",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.locationtech.proj4j.CoordinateTransformTest::testEPSG_4326": {
        "path": "org/locationtech/proj4j/CoordinateTransformTest.java",
        "function_name": "testEPSG_4326",
        "src": "@Test\n    public void testEPSG_4326() {\n        // this test is asjusted to match proj4s behavior\n        checkTransformAndInverse(\n                \"EPSG:4326\", -126.54, 54.15,\n                \"EPSG:3005\", 964813.103719, 1016486.305862,\n                0.0001, 0.2 * APPROX_METRE_IN_DEGREES);\n\n        checkTransformAndInverse(\n                \"EPSG:32633\", 249032.839239894, 7183612.30572229,\n                \"EPSG:4326\", 9.735465995870696, 64.68347938261206,\n                0.000001, 0.3 * APPROX_METRE_IN_DEGREES);\n\n        checkTransformAndInverse(\n                \"EPSG:32636\", 500000, 4649776.224819178,\n                \"EPSG:4326\", 33, 42,\n                0.000001, 20 * APPROX_METRE_IN_DEGREES);\n    }",
        "error_msg": "org.locationtech.proj4j.CoordinateTransformTest::testEPSG_4326 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.locationtech.proj4j.ExampleTest::latLonToStereBidirectionalTransform": {
        "path": "org/locationtech/proj4j/ExampleTest.java",
        "function_name": "latLonToStereBidirectionalTransform",
        "src": "@Test\n    public void latLonToStereBidirectionalTransform() {\n        CRSFactory csFactory = new CRSFactory();\n        CoordinateReferenceSystem STERE0 = csFactory.createFromParameters(\"STERE\", \"+proj=stere +lat_0=0.0 +lon_0=0.0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs\");\n        CoordinateReferenceSystem STERE1 = csFactory.createFromParameters(\"STERE\", \"+proj=stere +lat_0=0.000001 +lon_0=0.0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs\");\n        CoordinateReferenceSystem WGS84 = csFactory.createFromParameters(\"WGS84\", \"+proj=latlong +datum=WGS84 +ellps=WGS84 +no_defs\");\n        CoordinateTransform transformer0 = new CoordinateTransformFactory().createTransform(WGS84, STERE0);\n        CoordinateTransform transformer1 = new CoordinateTransformFactory().createTransform(WGS84, STERE1);\n\n        ProjCoordinate pc = new ProjCoordinate(1, 1);\n        ProjCoordinate result0 = new ProjCoordinate();\n        ProjCoordinate result1 = new ProjCoordinate();\n\n        transformer0.transform(pc, result0);\n        transformer1.transform(pc, result1);\n\n        assertTrue(isInTolerance(result0, 111313.95106842462, 110585.61615828621, 0.000001));\n        assertTrue(isInTolerance(result1, 111313.95105169504, 110585.50558411982, 0.000001));\n    }",
        "error_msg": "org.locationtech.proj4j.ExampleTest::latLonToStereBidirectionalTransform --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.locationtech.proj4j.ExampleTest::lccToUtmBidirectionalTransform": {
        "path": "org/locationtech/proj4j/ExampleTest.java",
        "function_name": "lccToUtmBidirectionalTransform",
        "src": "@Test\n    public void lccToUtmBidirectionalTransform() {\n\n        String sourceProjection = \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\";\n        String targetProjection = \"+proj=utm +zone=13 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\";\n\n        CoordinateTransformFactory ctFactory = new CoordinateTransformFactory();\n        CRSFactory csFactory = new CRSFactory();\n        /*\n         * Create {@link CoordinateReferenceSystem} & CoordinateTransformation.\n         * Normally this would be carried out once and reused for all transformations\n         */\n        CoordinateReferenceSystem sourceCRS = csFactory.createFromParameters(null, sourceProjection);\n        CoordinateReferenceSystem targetCRS = csFactory.createFromParameters(null, targetProjection);\n\n        CoordinateTransform trans = ctFactory.createTransform(sourceCRS, targetCRS);\n        CoordinateTransform inverse = ctFactory.createTransform(targetCRS, sourceCRS);\n\n        /*\n         * Create input and output points.\n         * These can be constructed once per thread and reused.\n         */\n        ProjCoordinate p1 = new ProjCoordinate();\n        ProjCoordinate p2 = new ProjCoordinate();\n\n        p1.x = -2328478.0;\n        p1.y = -732244.0;\n        p2.x = 2641142.0;\n        p2.y = 3898488.0;\n\n        ProjCoordinate p1t = new ProjCoordinate();\n        ProjCoordinate p2t = new ProjCoordinate();\n\n        ProjCoordinate p1i = new ProjCoordinate();\n        ProjCoordinate p2i = new ProjCoordinate();\n\n        /*\n         * Transform point\n         */\n        trans.transform(p1, p1t);\n        trans.transform(p2, p2t);\n\n        inverse.transform(p1t, p1i);\n        inverse.transform(p2t, p2i);\n\n        // TransverseMercator: -898112.8947364385 4366397.986532097\n        // proj4js, ExtendedTransverseMercator: -898112.6757444271, 4366397.955450379\n        assertTrue(isInTolerance(p1t, -898112.6757444271, 4366397.955450379, 0.000001));\n        // TransverseMercator: 3168615.043479321 10060133.986247078\n        // proj4js, ExtendedTransverseMercator: 3196914.503779556, 10104027.377988787\n        assertTrue(isInTolerance(p2t, 3196914.503779556, 10104027.377988787, 0.000001));\n\n        // TransverseMercator: -2328476.414958664 -732244.6234315771\n        // proj4js, ExtendedTransverseMercator: -2328478.000000011, -732244.0000000233\n        assertTrue(isInTolerance(p1i, p1.x, p1.y, 0.000001));\n        // TransverseMercator: 0 4654175.264342441\n        // proj4js, ExtendedTransverseMercator: 2641142.000000019, 3898487.999999993\n        assertTrue(isInTolerance(p2i, p2.x, p2.y, 0.000001));\n    }",
        "error_msg": "org.locationtech.proj4j.ExampleTest::lccToUtmBidirectionalTransform --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.locationtech.proj4j.ExampleTest::latLonToLccBidirectionalTransform": {
        "path": "org/locationtech/proj4j/ExampleTest.java",
        "function_name": "latLonToLccBidirectionalTransform",
        "src": "@Test\n    public void latLonToLccBidirectionalTransform() {\n        String sourceProjection = \"+proj=longlat +datum=WGS84 +no_defs\";\n        String targetProjection = \"+proj=lcc +lat_1=10.16666666666667 +lat_0=10.16666666666667 +lon_0=-71.60561777777777 +k_0=1 +x_0=0 +y_0=-52684.972 +ellps=intl +units=m +no_defs\";\n\n        CoordinateTransformFactory ctFactory = new CoordinateTransformFactory();\n        CRSFactory csFactory = new CRSFactory();\n        /*\n         * Create {@link CoordinateReferenceSystem} & CoordinateTransformation.\n         * Normally this would be carried out once and reused for all transformations\n         */\n        CoordinateReferenceSystem sourceCRS = csFactory.createFromParameters(null, sourceProjection);\n        CoordinateReferenceSystem targetCRS = csFactory.createFromParameters(null, targetProjection);\n\n        CoordinateTransform trans = ctFactory.createTransform(sourceCRS, targetCRS);\n        CoordinateTransform inverse = ctFactory.createTransform(targetCRS, sourceCRS);\n\n        /*\n         * Create input and output points.\n         * These can be constructed once per thread and reused.\n         */\n        ProjCoordinate p = new ProjCoordinate();\n\n        p.x = 1;\n        p.y = -1;\n\n        ProjCoordinate pt = new ProjCoordinate();\n\n        ProjCoordinate pi = new ProjCoordinate();\n\n        /*\n         * Transform point\n         */\n        trans.transform(p, pt);\n        inverse.transform(pt, pi);\n\n        assertTrue(isInTolerance(pt, 8166119.317682125, -378218.6293696874, 0.000001));\n        assertTrue(isInTolerance(pi, p.x, p.y, 0.000001));\n    }",
        "error_msg": "org.locationtech.proj4j.ExampleTest::latLonToLccBidirectionalTransform --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      },
      "org.locationtech.proj4j.MetaCRSTest::testPROJ4_Empirical": {
        "path": "org/locationtech/proj4j/MetaCRSTest.java",
        "function_name": "testPROJ4_Empirical",
        "src": "@Test\n    public void testPROJ4_Empirical() throws IOException {\n        File file = getFile(\"proj4-epsg.csv\");\n        MetaCRSTestFileReader reader = new MetaCRSTestFileReader(file);\n        List<MetaCRSTestCase> tests = reader.readTests();\n        for (MetaCRSTestCase test : tests) {\n            boolean testResult = runTest(test);\n            String testMethod = test.getTestMethod();\n\n            if (testMethod.equals(MetaCRSTestCase.PASSING)) {\n                Assert.assertTrue(testResult);\n            } else {\n                Assert.assertFalse(testResult);\n            }\n        }\n    }",
        "error_msg": "org.locationtech.proj4j.MetaCRSTest::testPROJ4_Empirical --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Proj4J-9": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/org/locationtech/proj4j/BasicCoordinateTransform.java",
        "start_loc": 69,
        "end_loc": 112,
        "buggy_function": "    public BasicCoordinateTransform(CoordinateReferenceSystem srcCRS,\n                                    CoordinateReferenceSystem tgtCRS) {\n        this.srcCRS = srcCRS;\n        this.tgtCRS = tgtCRS;\n\n        // compute strategy for transformation at initialization time, to make transformation more efficient\n        // this may include precomputing sets of parameters\n\n        doInverseProjection = (srcCRS != CoordinateReferenceSystem.CS_GEO);\n        doForwardProjection = (tgtCRS != CoordinateReferenceSystem.CS_GEO);\n        doDatumTransform = doInverseProjection && doForwardProjection\n                && srcCRS.getDatum() != tgtCRS.getDatum();\n\n        boolean geocentric = false;\n\n        if (doDatumTransform) {\n\n            boolean isEllipsoidEqual = srcCRS.getDatum().getEllipsoid().isEqual(tgtCRS.getDatum().getEllipsoid());\n            transformViaGeocentric = ! isEllipsoidEqual || srcCRS.getDatum().hasTransformToWGS84()\n                    || tgtCRS.getDatum().hasTransformToWGS84();\n\n            if (transformViaGeocentric) {\n                srcGeoConv = new GeocentricConverter(srcCRS.getDatum().getEllipsoid());\n                tgtGeoConv = new GeocentricConverter(tgtCRS.getDatum().getEllipsoid());\n\n\n\n\n                if (srcCRS.getDatum().getTransformType() == Datum.TYPE_GRIDSHIFT) {\n                    srcGeoConv.overrideWithWGS84Params();\n                }\n\n\t                // After WGS84 params override, check if geocentric transform is still required\n\t                // https://github.com/OSGeo/PROJ/blob/5.2.0/src/pj_transform.c#L892\n                if (tgtCRS.getDatum().getTransformType() == Datum.TYPE_GRIDSHIFT) {\n                    tgtGeoConv.overrideWithWGS84Params();\n                }\n            }\n\n        } else {\n        \ttransformViaGeocentric=false;\n        }\n\n    }",
        "fixed_function": "    public BasicCoordinateTransform(CoordinateReferenceSystem srcCRS,\n                                    CoordinateReferenceSystem tgtCRS) {\n        this.srcCRS = srcCRS;\n        this.tgtCRS = tgtCRS;\n\n        // compute strategy for transformation at initialization time, to make transformation more efficient\n        // this may include precomputing sets of parameters\n\n        doInverseProjection = (srcCRS != CoordinateReferenceSystem.CS_GEO);\n        doForwardProjection = (tgtCRS != CoordinateReferenceSystem.CS_GEO);\n        doDatumTransform = doInverseProjection && doForwardProjection\n                && srcCRS.getDatum() != tgtCRS.getDatum();\n\n        boolean geocentric = false;\n\n        if (doDatumTransform) {\n\n            boolean isEllipsoidEqual = srcCRS.getDatum().getEllipsoid().isEqual(tgtCRS.getDatum().getEllipsoid());\n            geocentric = ! isEllipsoidEqual || srcCRS.getDatum().hasTransformToWGS84()\n                    || tgtCRS.getDatum().hasTransformToWGS84();\n\n            if (geocentric) {\n                srcGeoConv = new GeocentricConverter(srcCRS.getDatum().getEllipsoid());\n                tgtGeoConv = new GeocentricConverter(tgtCRS.getDatum().getEllipsoid());\n\n                int srcTransformType = srcCRS.getDatum().getTransformType();\n                int tgtTransformType = tgtCRS.getDatum().getTransformType();\n\n                if (srcTransformType == Datum.TYPE_GRIDSHIFT || tgtTransformType == Datum.TYPE_GRIDSHIFT) {\n\n\t                if (srcTransformType == Datum.TYPE_GRIDSHIFT) {\n\t                    srcGeoConv.overrideWithWGS84Params();\n\t                }\n\n\t                if (tgtTransformType == Datum.TYPE_GRIDSHIFT) {\n\t                    tgtGeoConv.overrideWithWGS84Params();\n\t                }\n\n\t                // After WGS84 params override, check if geocentric transform is still required\n\t                // https://github.com/OSGeo/PROJ/blob/5.2.0/src/pj_transform.c#L892\n\t                if(srcGeoConv.isEqual(tgtGeoConv)) {\n\t                    geocentric = false;\n\t                    srcGeoConv = null;\n\t                    tgtGeoConv = null;\n\t                }\n\n                }\n            }\n\n        }\n\n        transformViaGeocentric = geocentric;\n    }",
        "comment": "/**\n     * Creates a transformation from a source {@link CoordinateReferenceSystem}\n     * to a target one.\n     *\n     * @param srcCRS the source CRS to transform from\n     * @param tgtCRS the target CRS to transform to\n     */"
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/datum/GeocentricConverter.java",
        "start_loc": 62,
        "end_loc": 65,
        "buggy_function": "    public GeocentricConverter(Ellipsoid ellipsoid) {\n        // Preserve the ellipsoid value precisions\n        this(ellipsoid.getA(), ellipsoid.getB());\n    }",
        "fixed_function": "    public GeocentricConverter(Ellipsoid ellipsoid) {\n        // Preserve the ellipsoid value precisions\n        this(ellipsoid.getA(), ellipsoid.getB(), ellipsoid.getEccentricitySquared());\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/datum/GeocentricConverter.java",
        "start_loc": 67,
        "end_loc": 74,
        "buggy_function": "    public GeocentricConverter(double a, double b) {\n        this.a = a;\n        this.b = b;\n        a2 = a * a;\n        b2 = b * b;\n        e2 = (a2 - b2) / a2;\n        ep2 = (a2 - b2) / b2;\n    }",
        "fixed_function": "    public GeocentricConverter(double a, double b, double e2) {\n        this.a = a;\n        this.b = b;\n        a2 = a * a;\n        b2 = b * b;\n        this.e2 = e2;\n        ep2 = (a2 - b2) / b2;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/org/locationtech/proj4j/datum/Grid.java",
        "start_loc": 314,
        "end_loc": 329,
        "buggy_function": "    public static List<Grid> fromNadGrids(String grids) throws IOException {\n        List<Grid> gridlist = new ArrayList<Grid>();\n        synchronized (Grid.class) {\n            for (String gridName : grids.split(\",\")) {\n                boolean optional = gridName.startsWith(\"@\");\n                if (optional) gridName = gridName.substring(1);\n                if (gridName.equals(\"null\")) return null;\n                try {\n                    mergeGridFile(gridName, gridlist);\n                } catch (IOException e) {\n                    if (!optional) throw e;\n                }\n            }\n        }\n        return gridlist;\n    }",
        "fixed_function": "    public static List<Grid> fromNadGrids(String grids) throws IOException {\n        List<Grid> gridlist = new ArrayList<Grid>();\n        synchronized (Grid.class) {\n            for (String gridName : grids.split(\",\")) {\n                boolean optional = gridName.startsWith(\"@\");\n                if (optional) gridName = gridName.substring(1);\n                try {\n                    mergeGridFile(gridName, gridlist);\n                } catch (IOException e) {\n                    if (!optional) throw e;\n                }\n            }\n        }\n        return gridlist;\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.locationtech.proj4j.CoordinateTransformTest::testPROJ4": {
        "path": "org/locationtech/proj4j/CoordinateTransformTest.java",
        "function_name": "testPROJ4",
        "src": "@Test\n    public void testPROJ4_SPCS_NAD27() {\n        // AK 2\n        checkTransform(\"+proj=longlat +datum=NAD27 +to_meter=0.3048006096012192\", -142.0, 56.50833333333333, \"ESRI:26732\", 500000.000, 916085.508, 0.001);\n\n        /*\n         * EPSG:4267 is the CRS for NAD27 Geographics.\n         * Even though ESRI:26732 is also NAD27,\n         * the transform fails, because EPSG:4267 specifies datum transform params.\n         * This causes a datum transformation to be attempted,\n         * which fails because the target does not specify datum transform params\n         * A more sophisticated check for datum equivalence might prevent this failure\n         */\n        //    checkTransform(\"EPSG:4267\", -142.0, 56.50833333333333,    \"ESRI:26732\", 500000.000,    916085.508, 0.1 );\n    }",
        "error_msg": "org.locationtech.proj4j.CoordinateTransformTest::testPROJ4 --> junit.framework.AssertionFailedError",
        "clean_error_msg": "junit.framework.AssertionFailedError"
      }
    }
  },
  "Dagger_core-2": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 220,
        "end_loc": 225,
        "buggy_function": "  public <T> T get(Class<T> type) {\n    String key = Keys.get(type);\n    @SuppressWarnings(\"unchecked\") // The linker matches keys to bindings by their type.\n    Binding<T> binding = (Binding<T>) getEntryPointBinding(key, key);\n    return binding.get();\n  }",
        "fixed_function": "  public <T> T get(Class<T> type) {\n    String key = Keys.get(type);\n    String entryPointKey = Keys.getMembersKey(type);\n    @SuppressWarnings(\"unchecked\") // The linker matches keys to bindings by their type.\n    Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);\n    return binding.get();\n  }",
        "comment": "/**\n   * Returns an instance of {@code type}.\n   *\n   * @throws IllegalArgumentException if {@code type} is not one of this object\n   *     graph's entry point types.\n   */"
      },
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 234,
        "end_loc": 240,
        "buggy_function": "  public void inject(Object instance) {\n    String entryPointKey = Keys.get(instance.getClass());\n    String membersKey = Keys.getMembersKey(instance.getClass());\n    @SuppressWarnings(\"unchecked\") // The linker matches keys to bindings by their type.\n    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(entryPointKey, membersKey);\n    binding.injectMembers(instance);\n  }",
        "fixed_function": "  public void inject(Object instance) {\n    String membersKey = Keys.getMembersKey(instance.getClass());\n    @SuppressWarnings(\"unchecked\") // The linker matches keys to bindings by their type.\n    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);\n    binding.injectMembers(instance);\n  }",
        "comment": "/**\n   * Injects the members of {@code instance}, including injectable members\n   * inherited from its supertypes.\n   *\n   * @throws IllegalArgumentException if the runtime type of {@code instance} is\n   *     not one of this object graph's entry point types.\n   */"
      }
    ],
    "trigger_test": {
      "dagger.InjectionTest::entryPointNeedsNoInjectAnnotation": {
        "path": "dagger/InjectionTest.java",
        "function_name": "entryPointNeedsNoInjectAnnotation",
        "src": "@Test public void entryPointNeedsNoInjectAnnotation() {\n    @Module(entryPoints = NoInjections.class)\n    class TestModule {\n    }\n\n    ObjectGraph.create(new TestModule()).validate();\n  }",
        "error_msg": "dagger.InjectionTest::entryPointNeedsNoInjectAnnotation --> java.lang.IllegalStateException: Errors creating object graph:",
        "clean_error_msg": "java.lang.IllegalStateException: Errors creating object graph:"
      }
    }
  },
  "Dagger_core-13": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 165,
        "end_loc": 169,
        "buggy_function": "  private void linkEntryPoints() {\n    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {\n      linker.requestEntryPoint(entry.getKey(), entry.getValue());\n    }\n  }",
        "fixed_function": "  private void linkEntryPoints() {\n    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {\n      linker.requestBinding(entry.getKey(), entry.getValue(), false);\n    }\n  }",
        "comment": ""
      },
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 248,
        "end_loc": 267,
        "buggy_function": "  private Binding<?> getEntryPointBinding(String entryPointKey, String key) {\n    Class<?> moduleClass = null;\n    for (ObjectGraph graph = this; graph != null; graph = graph.base) {\n      moduleClass = graph.entryPoints.get(entryPointKey);\n      if (moduleClass != null) break;\n    }\n    if (moduleClass == null) {\n      throw new IllegalArgumentException(\"No entry point for \" + entryPointKey\n          + \". You must explicitly add an entry point to one of your modules.\");\n    }\n\n    synchronized (linker) {\n      Binding<?> binding = linker.requestBinding(key, moduleClass);\n      if (binding == null || !binding.isLinked()) {\n        linker.linkRequested();\n        binding = linker.requestBinding(key, moduleClass);\n      }\n      return binding;\n    }\n  }",
        "fixed_function": "  private Binding<?> getEntryPointBinding(String entryPointKey, String key) {\n    Class<?> moduleClass = null;\n    for (ObjectGraph graph = this; graph != null; graph = graph.base) {\n      moduleClass = graph.entryPoints.get(entryPointKey);\n      if (moduleClass != null) break;\n    }\n    if (moduleClass == null) {\n      throw new IllegalArgumentException(\"No entry point for \" + entryPointKey\n          + \". You must explicitly add an entry point to one of your modules.\");\n    }\n\n    synchronized (linker) {\n      Binding<?> binding = linker.requestBinding(key, moduleClass, false);\n      if (binding == null || !binding.isLinked()) {\n        linker.linkRequested();\n        binding = linker.requestBinding(key, moduleClass, false);\n      }\n      return binding;\n    }\n  }",
        "comment": "/**\n   * @param entryPointKey the key used to store the entry point. This is always\n   *     a regular (provider) key.\n   * @param key the key to use when retrieving the binding. This may be a\n   *     regular (provider) key or a members key.\n   */"
      }
    ],
    "trigger_test": {
      "dagger.InjectionTest::uninjectableSupertypes": {
        "path": "dagger/InjectionTest.java",
        "function_name": "uninjectableSupertypes",
        "src": "@Test public void uninjectableSupertypes() {\n    class TestEntryPoint {\n      @Inject T t;\n    }\n\n    @Module(entryPoints = TestEntryPoint.class)\n    class TestModule {\n    }\n\n    TestEntryPoint entryPoint = new TestEntryPoint();\n    ObjectGraph.create(new TestModule()).inject(entryPoint);\n    assertThat(entryPoint.t).isNotNull();\n  }",
        "error_msg": "dagger.InjectionTest::uninjectableSupertypes --> java.lang.IllegalStateException: Errors creating object graph:",
        "clean_error_msg": "java.lang.IllegalStateException: Errors creating object graph:"
      }
    }
  },
  "Dagger_core-19": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 159,
        "end_loc": 185,
        "buggy_function": "    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {\n      Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();\n      Map<Class<?>, StaticInjection> staticInjections\n          = new LinkedHashMap<Class<?>, StaticInjection>();\n\n      // Extract bindings in the 'base' and 'overrides' set. Within each set no\n      // duplicates are permitted.\n      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();\n      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();\n      for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {\n        for (String key : moduleAdapter.injectableTypes) {\n          injectableTypes.put(key, moduleAdapter.getModule().getClass());\n        }\n        for (Class<?> c : moduleAdapter.staticInjections) {\n          staticInjections.put(c, null);\n        }\n        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;\n        moduleAdapter.getBindings(addTo);\n      }\n\n      // Create a linker and install all of the user's bindings\n      Linker linker = new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());\n      linker.installBindings(baseBindings);\n      linker.installBindings(overrideBindings);\n\n      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);\n    }",
        "fixed_function": "    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {\n      Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();\n      Map<Class<?>, StaticInjection> staticInjections\n          = new LinkedHashMap<Class<?>, StaticInjection>();\n\n      // Extract bindings in the 'base' and 'overrides' set. Within each set no\n      // duplicates are permitted.\n      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {\n        @Override public Binding<?> put(String key, Binding<?> value) {\n          return super.put(key, (value instanceof SetBinding)\n              ? new SetBinding<Object>((SetBinding<Object>) value) : value);\n        }\n      };\n      if (base != null) {\n        baseBindings.putAll(base.linkEverything()); // Add parent bindings\n      }\n      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {\n        @Override public Binding<?> put(String key, Binding<?> value) {\n          if (value instanceof SetBinding) {\n            throw new IllegalArgumentException(\"Module overrides cannot contribute set bindings.\");\n          }\n          return super.put(key, value);\n        }\n      };\n      for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {\n        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {\n          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());\n        }\n        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {\n          staticInjections.put(moduleAdapter.staticInjections[i], null);\n        }\n        try {\n          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);\n        } catch (IllegalArgumentException e) {\n          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()\n              + \" is an overriding module and cannot contribute set bindings.\");\n        }\n      }\n\n      // Create a linker and install all of the user's bindings\n      Linker linker = new Linker(plugin, new ThrowingErrorHandler());\n      linker.installBindings(baseBindings);\n      linker.installBindings(overrideBindings);\n\n      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/dagger/ObjectGraph.java",
        "start_loc": 187,
        "end_loc": 190,
        "buggy_function": "    @Override public ObjectGraph plus(Object... modules) {\n      linkEverything();\n      return makeGraph(this, plugin, modules);\n    }",
        "fixed_function": "    @Override public ObjectGraph plus(Object... modules) {\n      return makeGraph(this, plugin, modules);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "dagger.ExtensionWithSetBindingsTest::basicInjectionWithExtensionAndOverrides": {
        "path": "dagger/ExtensionWithSetBindingsTest.java",
        "function_name": "basicInjectionWithExtensionAndOverrides",
        "src": "@Test public void basicInjectionWithExtensionAndOverrides() {\n    try {\n      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());\n      fail(\"Should throw exception.\");\n    } catch (IllegalArgumentException e) {\n      assertEquals(\"TestModule is an overriding module and cannot contribute set bindings.\",\n          e.getMessage());\n    }\n  }",
        "error_msg": "dagger.ExtensionWithSetBindingsTest::basicInjectionWithExtensionAndOverrides --> junit.framework.AssertionFailedError: Should throw exception.",
        "clean_error_msg": "junit.framework.AssertionFailedError: Should throw exception."
      },
      "dagger.ExtensionWithSetBindingsTest::basicInjectionWithExtension": {
        "path": "dagger/ExtensionWithSetBindingsTest.java",
        "function_name": "basicInjectionWithExtension",
        "src": "@Test public void basicInjectionWithExtension() {\n    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());\n    RealSingleton rs = root.get(RealSingleton.class);\n    assertThat(rs.ints).containsOnly(0, 1);\n\n    ObjectGraph extension = root.plus(new ExtensionModule());\n    Main main = extension.get(Main.class);\n    assertThat(main.ints).containsOnly(0, 1, 2, 3);\n\n    // Second time around.\n    ObjectGraph extension2 = root.plus(new ExtensionModule());\n    Main main2 = extension2.get(Main.class);\n    assertThat(main2.ints).containsOnly(0, 1, 4, 5);\n  }",
        "error_msg": "dagger.ExtensionWithSetBindingsTest::basicInjectionWithExtension --> junit.framework.AssertionFailedError: <[2, 3]> does not contain element(s):<[0, 1]>",
        "clean_error_msg": "junit.framework.AssertionFailedError: <[2, 3]> does not contain element(s):<[0, 1]>"
      }
    }
  },
  "Jcabi_aether-1": {
    "function_num": 3,
    "functions": [
      {
        "path": "src/main/java/com/jcabi/aether/Aether.java",
        "start_loc": 130,
        "end_loc": 139,
        "buggy_function": "    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    public Aether(@NotNull final Collection<RemoteRepository> repos,\n        @NotNull final File repo) {\n        final Collection<Repository> rlist = new LinkedList<Repository>();\n        for (final RemoteRepository remote : this.mrepos(repos)) {\n            rlist.add(new Repository(remote));\n        }\n        this.remotes = rlist.toArray(new Repository[repos.size()]);\n        this.lrepo = repo.getAbsolutePath();\n    }",
        "fixed_function": "    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    public Aether(@NotNull final Collection<RemoteRepository> repos,\n        @NotNull final File repo) {\n        final Collection<Repository> rlist = new LinkedList<Repository>();\n        for (final RemoteRepository remote : this.prepos(this.mrepos(repos))) {\n            rlist.add(new Repository(remote));\n        }\n        this.remotes = rlist.toArray(new Repository[repos.size()]);\n        this.lrepo = repo.getAbsolutePath();\n    }",
        "comment": "/**\n     * Public ctor, requires information about all remote repositories and one\n     * lrepo.\n     * @param repos Collection of remote repositories\n     * @param repo Local repository location (directory path)\n     * @since 0.8\n     */"
      },
      {
        "path": "src/main/java/com/jcabi/aether/Aether.java",
        "start_loc": 190,
        "end_loc": 218,
        "buggy_function": "    private Collection<RemoteRepository> mrepos(\n        final Collection<RemoteRepository> repos) {\n        final DefaultMirrorSelector selector = this.mirror(this.settings());\n        org.apache.maven.settings.Proxy activeProxy = this.settings().getActiveProxy();\n        final DefaultProxySelector proxySelector = new DefaultProxySelector().add(\n            new Proxy(activeProxy.getProtocol(), activeProxy.getHost(), activeProxy.getPort(), null), null\n        );\n        final Collection<RemoteRepository> mrepos =\n            new ArrayList<RemoteRepository>(repos.size());\n        for (final RemoteRepository repo : repos) {\n            final RemoteRepository mrepo = selector.getMirror(repo);\n            RemoteRepository nrepo = repo;\n            if (mrepo != null) {\n                nrepo = mrepo;\n            }\n\n    /**\n     * Build repositories with proxy if it is available.\n     * @param repos List of repositories\n     * @return List of repositories with proxy\n     */\n            final Proxy proxy = proxySelector.getProxy(nrepo);\n            if (proxy != null) {\n                nrepo.setProxy(proxy);\n            }\n            mrepos.add(nrepo);\n        }\n        return mrepos;\n    }",
        "fixed_function": "    private Collection<RemoteRepository> mrepos(\n        final Collection<RemoteRepository> repos) {\n        final DefaultMirrorSelector selector = this.mirror(this.settings());\n        final Collection<RemoteRepository> mrepos =\n            new ArrayList<RemoteRepository>(repos.size());\n        for (final RemoteRepository repo : repos) {\n            final RemoteRepository mrepo = selector.getMirror(repo);\n            if (mrepo == null) {\n                mrepos.add(repo);\n            } else {\n                mrepos.add(mrepo);\n            }\n        }\n        return mrepos;\n    }",
        "comment": "/**\n     * Build repositories taking mirrors into consideration.\n     * @param repos Initial list of repositories.\n     * @return List of repositories with mirrored ones.\n     */"
      },
      {
        "path": "src/main/java/com/jcabi/aether/RepositoryAuthentication.java",
        "start_loc": 70,
        "end_loc": 78,
        "buggy_function": "    @SuppressWarnings(\"PMD.ConfusingTernary\")\n    public RepositoryAuthentication(final Authentication auth) {\n        this.username = auth.getUsername();\n        // @checkstyle AvoidInlineConditionalsCheck (2 lines)\n        this.password = auth.getPassword().toCharArray();\n        this.privatekeyfile = auth.getPrivateKeyFile();\n        // @checkstyle AvoidInlineConditionalsCheck (2 lines)\n        this.passphrase = auth.getPassphrase().toCharArray();\n    }",
        "fixed_function": "    @SuppressWarnings(\"PMD.ConfusingTernary\")\n    public RepositoryAuthentication(final Authentication auth) {\n        this.username = auth.getUsername();\n        // @checkstyle AvoidInlineConditionalsCheck (2 lines)\n        this.password = auth.getPassword() != null\n            ? auth.getPassword().toCharArray() : null;\n        this.privatekeyfile = auth.getPrivateKeyFile();\n        // @checkstyle AvoidInlineConditionalsCheck (2 lines)\n        this.passphrase = auth.getPassphrase() != null\n            ? auth.getPassphrase().toCharArray() : null;\n    }",
        "comment": "/**\n     * Creates a new authentication with the specified properties.\n     * @param auth The authentication object.\n     */"
      }
    ],
    "trigger_test": {
      "com.jcabi.aether.AetherTest::throwsWhenArtifactNotFound": {
        "path": "com/jcabi/aether/AetherTest.java",
        "function_name": "throwsWhenArtifactNotFound",
        "src": "@Test(expected = DependencyResolutionException.class)\n    public void throwsWhenArtifactNotFound() throws Exception {\n        new Aether(this.project(), this.temp.newFolder()).resolve(\n            new DefaultArtifact(\"com.jcabi:jcabi-log:jar:0.0.0\"),\n            JavaScopes.COMPILE\n        );\n    }",
        "error_msg": "com.jcabi.aether.AetherTest::throwsWhenArtifactNotFound --> java.lang.Exception: Unexpected exception, expected<org.sonatype.aether.resolution.DependencyResolutionException> but was<java.lang.NullPointerException>",
        "clean_error_msg": "java.lang.Exception: Unexpected exception, expected<org.sonatype.aether.resolution.DependencyResolutionException> but was<java.lang.NullPointerException>"
      },
      "com.jcabi.aether.AetherTest::resolvesArtifactsInParallelThreads": {
        "path": "com/jcabi/aether/AetherTest.java",
        "function_name": "resolvesArtifactsInParallelThreads",
        "src": "@Test\n    public void resolvesArtifactsInParallelThreads() throws Exception {\n        final File local = this.temp.newFolder();\n        final Aether aether = new Aether(this.project(), local);\n        final int threads = Runtime.getRuntime().availableProcessors() * 5;\n        final Artifact artifact = new DefaultArtifact(\n            \"com.jcabi:jcabi-assembly:pom:0.1.10\"\n        );\n        final CountDownLatch start = new CountDownLatch(1);\n        final CountDownLatch latch = new CountDownLatch(threads);\n        final Runnable task = new VerboseRunnable(\n            new Callable<Void>() {\n                @Override\n                public Void call() throws Exception {\n                    start.await();\n                    MatcherAssert.assertThat(\n                        aether.resolve(artifact, JavaScopes.RUNTIME),\n                        Matchers.not(Matchers.<Artifact>empty())\n                    );\n                    latch.countDown();\n                    return null;\n                }\n            },\n            true\n        );\n        final ExecutorService svc =\n            Executors.newFixedThreadPool(threads, new VerboseThreads());\n        for (int thread = 0; thread < threads; ++thread) {\n            svc.submit(task);\n        }\n        start.countDown();\n        MatcherAssert.assertThat(\n            latch.await(2, TimeUnit.MINUTES),\n            Matchers.is(true)\n        );\n        svc.shutdown();\n    }",
        "error_msg": "com.jcabi.aether.AetherTest::resolvesArtifactsInParallelThreads --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.jcabi.aether.AetherTest::recoversAfterFailure": {
        "path": "com/jcabi/aether/AetherTest.java",
        "function_name": "recoversAfterFailure",
        "src": "@Test\n    public void recoversAfterFailure() throws Exception {\n        final Aether aether = new Aether(\n            this.project(),\n            this.temp.newFolder()\n        );\n        try {\n            aether.resolve(\n                new DefaultArtifact(\"com.jcabi:jcabi-x:jar:0.0.0\"),\n                JavaScopes.TEST\n            );\n            Assert.fail(\"expection expected here\");\n        } catch (final DependencyResolutionException ex) {\n            MatcherAssert.assertThat(\n                Logger.format(\"%[exception]s\", ex),\n                Matchers.allOf(\n                    Matchers.containsString(\"oss.sonatype.org\"),\n                    Matchers.containsString(\"repo1.maven.org\"),\n                    Matchers.containsString(\"without authentication\")\n                )\n            );\n            if (AetherTest.AWS_KEY != null) {\n                MatcherAssert.assertThat(\n                    Logger.format(\"%[exception]s \", ex),\n                    Matchers.allOf(\n                        Matchers.containsString(\"aether-test.jcabi.com\"),\n                        Matchers.containsString(AetherTest.AWS_KEY),\n                        Matchers.not(\n                            Matchers.containsString(AetherTest.AWS_SECRET)\n                        )\n                    )\n                );\n            }\n        }\n        MatcherAssert.assertThat(\n            aether.resolve(\n                new DefaultArtifact(\"com.jcabi:jcabi-log:jar:0.1.8\"),\n                JavaScopes.RUNTIME\n            ),\n            Matchers.not(Matchers.<Artifact>empty())\n        );\n    }",
        "error_msg": "com.jcabi.aether.AetherTest::recoversAfterFailure --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.jcabi.aether.AetherTest::findsAndLoadsArtifacts": {
        "path": "com/jcabi/aether/AetherTest.java",
        "function_name": "findsAndLoadsArtifacts",
        "src": "@Test\n    public void findsAndLoadsArtifacts() throws Exception {\n        final File local = this.temp.newFolder();\n        final Aether aether = new Aether(this.project(), local);\n        final Collection<DefaultArtifact> artifacts =\n            new LinkedList<DefaultArtifact>(\n                Arrays.asList(\n                    new DefaultArtifact(\"com.jcabi:jcabi-log:pom:1.0-SNAPSHOT\"),\n                    new DefaultArtifact(\"log4j:log4j:jar:1.2.16\")\n                )\n            );\n        if (AetherTest.AWS_KEY != null) {\n            artifacts.add(\n                new DefaultArtifact(\n                    \"com.jcabi.aether-test:parent:pom:1.0\"\n                )\n            );\n        }\n        final Matcher<?> matcher = new CustomMatcher<String>(\"file exists\") {\n            @Override\n            public boolean matches(final Object file) {\n                return File.class.cast(file).exists();\n            }\n        };\n        for (final Artifact artifact : artifacts) {\n            MatcherAssert.assertThat(\n                aether.resolve(artifact, JavaScopes.RUNTIME),\n                Matchers.<Artifact>everyItem(\n                    Matchers.<Artifact>hasProperty(\"file\", matcher)\n                )\n            );\n        }\n    }",
        "error_msg": "com.jcabi.aether.AetherTest::findsAndLoadsArtifacts --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.jcabi.aether.ClasspathTest::comparesToAnotherClasspath": {
        "path": "com/jcabi/aether/ClasspathTest.java",
        "function_name": "comparesToAnotherClasspath",
        "src": "@Test\n    public void comparesToAnotherClasspath() throws Exception {\n        final Dependency dep = new Dependency();\n        dep.setGroupId(\"org.apache.commons\");\n        dep.setArtifactId(\"commons-lang3-absent\");\n        dep.setVersion(\"3.0\");\n        dep.setScope(JavaScopes.COMPILE);\n        final Classpath classpath = new Classpath(\n            this.project(dep), this.temp.newFolder(), JavaScopes.TEST\n        );\n        MatcherAssert.assertThat(classpath, Matchers.equalTo(classpath));\n        MatcherAssert.assertThat(\n            classpath.canEqual(classpath),\n            Matchers.is(true)\n        );\n    }",
        "error_msg": "com.jcabi.aether.ClasspathTest::comparesToAnotherClasspath --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.jcabi.aether.ClasspathTest::hasToStringWithBrokenDependency": {
        "path": "com/jcabi/aether/ClasspathTest.java",
        "function_name": "hasToStringWithBrokenDependency",
        "src": "@Test\n    public void hasToStringWithBrokenDependency() throws Exception {\n        final Dependency dep = new Dependency();\n        dep.setGroupId(\"junit-broken\");\n        dep.setArtifactId(\"junit-absent\");\n        dep.setVersion(\"1.0\");\n        dep.setScope(JavaScopes.TEST);\n        final Classpath classpath = new Classpath(\n            this.project(dep), this.temp.newFolder(), JavaScopes.TEST\n        );\n        MatcherAssert.assertThat(\n            classpath.toString(),\n            Matchers.containsString(\n                \"failed to load 'junit-broken:junit-absent:jar:1.0 (compile)'\"\n            )\n        );\n    }",
        "error_msg": "com.jcabi.aether.ClasspathTest::hasToStringWithBrokenDependency --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      },
      "com.jcabi.aether.RootArtifactTest::gracefullyResolvesBrokenRootArtifact": {
        "path": "com/jcabi/aether/RootArtifactTest.java",
        "function_name": "gracefullyResolvesBrokenRootArtifact",
        "src": "@Test\n    public void gracefullyResolvesBrokenRootArtifact() throws Exception {\n        final RootArtifact root = new RootArtifact(\n            this.aether(),\n            new DefaultArtifact(\"junit-broken\", \"junit-absent\", \"\", \"\", \"1.0\"),\n            new ArrayList<Exclusion>(0)\n        );\n        MatcherAssert.assertThat(\n            root,\n            Matchers.hasToString(\n                Matchers.containsString(\"failed to load 'junit-broken:\")\n            )\n        );\n    }",
        "error_msg": "com.jcabi.aether.RootArtifactTest::gracefullyResolvesBrokenRootArtifact --> java.lang.NullPointerException",
        "clean_error_msg": "java.lang.NullPointerException"
      }
    }
  },
  "Jcabi_email-1": {
    "function_num": 4,
    "functions": [
      {
        "path": "src/main/java/com/jcabi/email/stamp/StBCC.java",
        "start_loc": 75,
        "end_loc": 81,
        "buggy_function": "    public StBCC(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(name, addr, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "fixed_function": "    public StBCC(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(addr, name, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "comment": "/**\n     * Ctor.\n     * @param name Name of the recipient\n     * @param addr His email\n     * @since 1.1\n     */"
      },
      {
        "path": "src/main/java/com/jcabi/email/stamp/StCC.java",
        "start_loc": 75,
        "end_loc": 81,
        "buggy_function": "    public StCC(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(name, addr, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "fixed_function": "    public StCC(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(addr, name, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "comment": "/**\n     * Ctor.\n     * @param name Name of the recipient\n     * @param addr His email\n     * @since 1.1\n     */"
      },
      {
        "path": "src/main/java/com/jcabi/email/stamp/StRecipient.java",
        "start_loc": 75,
        "end_loc": 81,
        "buggy_function": "    public StRecipient(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(name, addr, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "fixed_function": "    public StRecipient(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(addr, name, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "comment": "/**\n     * Ctor.\n     * @param name Name of the recipient\n     * @param addr His email\n     * @since 1.1\n     */"
      },
      {
        "path": "src/main/java/com/jcabi/email/stamp/StSender.java",
        "start_loc": 75,
        "end_loc": 81,
        "buggy_function": "    public StSender(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(name, addr, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "fixed_function": "    public StSender(final String name, final String addr) {\n        try {\n            this.email = new InternetAddress(addr, name, \"UTF-8\").toString();\n        } catch (final UnsupportedEncodingException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }",
        "comment": "/**\n     * Ctor.\n     * @param name Name of the recipient\n     * @param addr His email\n     * @since 1.1\n     */"
      }
    ],
    "trigger_test": {
      "com.jcabi.email.stamp.StBCCTest::addsCopyToMessage": {
        "path": "com/jcabi/email/stamp/StBCCTest.java",
        "function_name": "addsCopyToMessage",
        "src": "@Test\n    public void addsCopyToMessage() throws Exception {\n        final Message msg = new MimeMessage(\n            Session.getDefaultInstance(new Properties())\n        );\n        new StBCC(\"Jeff Lebowski\", \"jeff@gmail.com\").attach(msg);\n        MatcherAssert.assertThat(\n            msg.getRecipients(Message.RecipientType.BCC)[0].toString(),\n            Matchers.equalTo(\"Jeff Lebowski <jeff@gmail.com>\")\n        );\n    }",
        "error_msg": "com.jcabi.email.stamp.StBCCTest::addsCopyToMessage --> javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''",
        "clean_error_msg": "javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''"
      },
      "com.jcabi.email.stamp.StCCTest::addsCopyToMessage": {
        "path": "com/jcabi/email/stamp/StCCTest.java",
        "function_name": "addsCopyToMessage",
        "src": "@Test\n    public void addsCopyToMessage() throws Exception {\n        final Message msg = new MimeMessage(\n            Session.getDefaultInstance(new Properties())\n        );\n        new StCC(\"Jeff Lebowski\", \"jeff@gmail.com\").attach(msg);\n        MatcherAssert.assertThat(\n            msg.getRecipients(Message.RecipientType.CC)[0].toString(),\n            Matchers.equalTo(\"Jeff Lebowski <jeff@gmail.com>\")\n        );\n    }",
        "error_msg": "com.jcabi.email.stamp.StCCTest::addsCopyToMessage --> javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''",
        "clean_error_msg": "javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''"
      },
      "com.jcabi.email.stamp.StRecipientTest::addsRecipientToMessage": {
        "path": "com/jcabi/email/stamp/StRecipientTest.java",
        "function_name": "addsRecipientToMessage",
        "src": "@Test\n    public void addsRecipientToMessage() throws Exception {\n        final Message msg = new MimeMessage(\n            Session.getDefaultInstance(new Properties())\n        );\n        new StRecipient(\"Jeff Lebowski\", \"jeff@gmail.com\").attach(msg);\n        MatcherAssert.assertThat(\n            msg.getRecipients(Message.RecipientType.TO)[0].toString(),\n            Matchers.equalTo(\"Jeff Lebowski <jeff@gmail.com>\")\n        );\n    }",
        "error_msg": "com.jcabi.email.stamp.StRecipientTest::addsRecipientToMessage --> javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''",
        "clean_error_msg": "javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''"
      },
      "com.jcabi.email.stamp.StSenderTest::addsSenderToMessage": {
        "path": "com/jcabi/email/stamp/StSenderTest.java",
        "function_name": "addsSenderToMessage",
        "src": "@Test\n    public void addsSenderToMessage() throws Exception {\n        final Message msg = new MimeMessage(\n            Session.getDefaultInstance(new Properties())\n        );\n        new StSender(\"Jeff Lebowski\", \"jeff@gmail.com\").attach(msg);\n        MatcherAssert.assertThat(\n            msg.getFrom()[0].toString(),\n            Matchers.equalTo(\"Jeff Lebowski <jeff@gmail.com>\")\n        );\n    }",
        "error_msg": "com.jcabi.email.stamp.StSenderTest::addsSenderToMessage --> javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''",
        "clean_error_msg": "javax.mail.internet.AddressException: Local address contains control or whitespace in string ``Jeff Lebowski''"
      }
    }
  },
  "Leshan_core-8": {
    "function_num": 2,
    "functions": [
      {
        "path": "/src/main/java/org/eclipse/leshan/core/node/codec/DefaultLwM2mNodeEncoder.java",
        "start_loc": 78,
        "end_loc": 112,
        "buggy_function": "    @Override\n    public byte[] encode(LwM2mNode node, ContentFormat format, LwM2mPath path, LwM2mModel model) throws CodecException {\n        Validate.notNull(node);\n\n        if (format == null) {\n            throw new CodecException(\"Content format is mandatory. [%s]\", path);\n        }\n\n        if (!isSupported(format)) {\n            throw new CodecException(\"Content format %s is not supported [%s]\", format, path);\n        }\n\n        LOG.trace(\"Encoding node {} for path {} and format\u00a0{}\", node, path, format);\n        byte[] encoded;\n        switch (format.getCode()) {\n        case ContentFormat.TLV_CODE:\n        case ContentFormat.OLD_TLV_CODE:\n            encoded = LwM2mNodeTlvEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.TEXT_CODE:\n            encoded = LwM2mNodeTextEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.OPAQUE_CODE:\n            encoded = LwM2mNodeOpaqueEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.JSON_CODE:\n        case ContentFormat.OLD_JSON_CODE:\n            encoded = LwM2mNodeJsonEncoder.encode(node, path, model, converter);\n            break;\n        default:\n            throw new CodecException(\"Content format %s is not supported [%s]\", format, path);\n        }\n        LOG.trace(\"Encoded node {}: {}\", node, encoded);\n        return encoded;\n    }",
        "fixed_function": "    @Override\n    public byte[] encode(LwM2mNode node, ContentFormat format, LwM2mPath path, LwM2mModel model) throws CodecException {\n        Validate.notNull(node);\n\n        if (format == null) {\n            throw new CodecException(\"Content format is mandatory. [%s]\", path);\n        }\n\n        if (!isSupported(format)) {\n            throw new CodecException(\"Content format %s is not supported [%s]\", format, path);\n        }\n\n        LOG.trace(\"Encoding node {} for path {} and format\u00a0{}\", node, path, format);\n        byte[] encoded;\n        switch (format.getCode()) {\n        case ContentFormat.TLV_CODE:\n        case ContentFormat.OLD_TLV_CODE:\n            encoded = LwM2mNodeTlvEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.TEXT_CODE:\n            encoded = LwM2mNodeTextEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.OPAQUE_CODE:\n            encoded = LwM2mNodeOpaqueEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.JSON_CODE:\n        case ContentFormat.OLD_JSON_CODE:\n            encoded = LwM2mNodeJsonEncoder.encode(node, path, model, converter);\n            break;\n        case ContentFormat.SENML_JSON_CODE:\n            encoded = LwM2mNodeSenMLJsonEncoder.encode(node, path, model, converter);\n            break;\n        default:\n            throw new CodecException(\"Content format %s is not supported [%s]\", format, path);\n        }\n        LOG.trace(\"Encoded node {}: {}\", node, encoded);\n        return encoded;\n    }",
        "comment": ""
      },
      {
        "path": "/src/main/java/org/eclipse/leshan/core/node/codec/DefaultLwM2mNodeEncoder.java",
        "start_loc": 141,
        "end_loc": 155,
        "buggy_function": "    @Override\n    public boolean isSupported(ContentFormat format) {\n        switch (format.getCode()) {\n        case ContentFormat.TEXT_CODE:\n        case ContentFormat.TLV_CODE:\n        case ContentFormat.OPAQUE_CODE:\n        case ContentFormat.JSON_CODE:\n            return true;\n        case ContentFormat.OLD_TLV_CODE:\n        case ContentFormat.OLD_JSON_CODE:\n            return supportDeprecatedContentFormat;\n        default:\n            return false;\n        }\n    }",
        "fixed_function": "    @Override\n    public boolean isSupported(ContentFormat format) {\n        switch (format.getCode()) {\n        case ContentFormat.TEXT_CODE:\n        case ContentFormat.TLV_CODE:\n        case ContentFormat.OPAQUE_CODE:\n        case ContentFormat.JSON_CODE:\n        case ContentFormat.SENML_JSON_CODE:\n            return true;\n        case ContentFormat.OLD_TLV_CODE:\n        case ContentFormat.OLD_JSON_CODE:\n            return supportDeprecatedContentFormat;\n        default:\n            return false;\n        }\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_multiple_resource": {
        "path": "org/eclipse/leshan/core/node/codec/LwM2mNodeEncoderTest.java",
        "function_name": "senml_json_encode_multiple_resource",
        "src": "@Test\n    public void senml_json_encode_multiple_resource() {\n        Map<Integer, Long> values = new HashMap<>();\n        values.put(0, 3800L);\n        values.put(1, 5000L);\n        LwM2mResource oResource = LwM2mMultipleResource.newIntegerResource(7, values);\n        byte[] encoded = encoder.encode(oResource, ContentFormat.SENML_JSON, new LwM2mPath(\"/3/0/7\"), model);\n\n        String expected = \"[{\\\"bn\\\":\\\"/3/0/7/\\\",\\\"n\\\":\\\"0\\\",\\\"v\\\":3800},{\\\"n\\\":\\\"1\\\",\\\"v\\\":5000}]\";\n        Assert.assertEquals(expected, new String(encoded));\n    }",
        "error_msg": "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_multiple_resource --> org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0/7]",
        "clean_error_msg": "org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0/7]"
      },
      "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_device_object_instance": {
        "path": "org/eclipse/leshan/core/node/codec/LwM2mNodeEncoderTest.java",
        "function_name": "senml_json_encode_device_object_instance",
        "src": "@Test\n    public void senml_json_encode_device_object_instance() {\n        LwM2mObjectInstance oInstance = new LwM2mObjectInstance(0, getDeviceResources());\n        byte[] encoded = encoder.encode(oInstance, ContentFormat.SENML_JSON, new LwM2mPath(\"/3/0\"), model);\n\n        StringBuilder b = new StringBuilder();\n        b.append(\"[{\\\"bn\\\":\\\"/3/0/\\\",\\\"n\\\":\\\"0\\\",\\\"vs\\\":\\\"Open Mobile Alliance\\\"},\");\n        b.append(\"{\\\"n\\\":\\\"1\\\",\\\"vs\\\":\\\"Lightweight M2M Client\\\"},\");\n        b.append(\"{\\\"n\\\":\\\"2\\\",\\\"vs\\\":\\\"345000123\\\"},\");\n        b.append(\"{\\\"n\\\":\\\"3\\\",\\\"vs\\\":\\\"1.0\\\"},\");\n        b.append(\"{\\\"n\\\":\\\"6/0\\\",\\\"v\\\":1},\");\n        b.append(\"{\\\"n\\\":\\\"6/1\\\",\\\"v\\\":5},\");\n        b.append(\"{\\\"n\\\":\\\"7/0\\\",\\\"v\\\":3800},\");\n        b.append(\"{\\\"n\\\":\\\"7/1\\\",\\\"v\\\":5000},\");\n        b.append(\"{\\\"n\\\":\\\"8/0\\\",\\\"v\\\":125},\");\n        b.append(\"{\\\"n\\\":\\\"8/1\\\",\\\"v\\\":900},\");\n        b.append(\"{\\\"n\\\":\\\"9\\\",\\\"v\\\":100},\");\n        b.append(\"{\\\"n\\\":\\\"10\\\",\\\"v\\\":15},\");\n        b.append(\"{\\\"n\\\":\\\"11/0\\\",\\\"v\\\":0},\");\n        b.append(\"{\\\"n\\\":\\\"13\\\",\\\"v\\\":1.3674912E9},\");\n        b.append(\"{\\\"n\\\":\\\"14\\\",\\\"vs\\\":\\\"+02:00\\\"},\");\n        b.append(\"{\\\"n\\\":\\\"16\\\",\\\"vs\\\":\\\"U\\\"}]\");\n\n        String expected = b.toString();\n        Assert.assertEquals(expected, new String(encoded));\n    }",
        "error_msg": "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_device_object_instance --> org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0]",
        "clean_error_msg": "org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0]"
      },
      "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_single_resource": {
        "path": "org/eclipse/leshan/core/node/codec/LwM2mNodeEncoderTest.java",
        "function_name": "senml_json_encode_single_resource",
        "src": "@Test\n    public void senml_json_encode_single_resource() {\n        LwM2mResource oResource = LwM2mSingleResource.newStringResource(0, \"Open Mobile Alliance\");\n        byte[] encoded = encoder.encode(oResource, ContentFormat.SENML_JSON, new LwM2mPath(\"/3/0/0\"), model);\n\n        String expected = \"[{\\\"bn\\\":\\\"/3/0/0\\\",\\\"vs\\\":\\\"Open Mobile Alliance\\\"}]\";\n        Assert.assertEquals(expected, new String(encoded));\n    }",
        "error_msg": "org.eclipse.leshan.core.node.codec.LwM2mNodeEncoderTest::senml_json_encode_single_resource --> org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0/0]",
        "clean_error_msg": "org.eclipse.leshan.core.node.codec.CodecException: Content format ContentFormat [name=SENML_JSON, code=110] is not supported [/3/0/0]"
      }
    }
  },
  "Rtree2-6": {
    "function_num": 16,
    "functions": [
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 10,
        "end_loc": 12,
        "buggy_function": "    private Point(float x, float y) {\n        this.mbr = RectangleImpl.create(x, y, x, y);\n    }",
        "fixed_function": "    private Point(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 22,
        "end_loc": 25,
        "buggy_function": "    @Override\n    public Rectangle mbr() {\n        return mbr;\n    }",
        "fixed_function": "    @Override\n    public Rectangle mbr() {\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 27,
        "end_loc": 30,
        "buggy_function": "    @Override\n    public double distance(Rectangle r) {\n        return mbr.distance(r);\n    }",
        "fixed_function": "    @Override\n    public double distance(Rectangle r) {\n        return RectangleImpl.distance(x, y, x, y, r.x1(), r.y1(), r.x2(), r.y2());\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 36,
        "end_loc": 40,
        "buggy_function": "    public double distanceSquared(Point p) {\n        float dx = mbr().x1() - p.mbr().x1();\n        float dy = mbr().y1() - p.mbr().y1();\n        return dx * dx + dy * dy;\n    }",
        "fixed_function": "    public double distanceSquared(Point p) {\n        float dx = x - p.x;\n        float dy = y - p.y;\n        return dx * dx + dy * dy;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 42,
        "end_loc": 45,
        "buggy_function": "    @Override\n    public boolean intersects(Rectangle r) {\n        return mbr.intersects(r);\n    }",
        "fixed_function": "    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x1() <= x && x <= r.x2() && r.y1() <= y && y <= r.y2();\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 47,
        "end_loc": 49,
        "buggy_function": "    public float x() {\n        return mbr.x1();\n    }",
        "fixed_function": "    public float x() {\n        return x;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 51,
        "end_loc": 53,
        "buggy_function": "    public float y() {\n        return mbr.y1();\n    }",
        "fixed_function": "    public float y() {\n        return y;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 55,
        "end_loc": 58,
        "buggy_function": "    @Override\n    public int hashCode() {\n        return Objects.hashCode(mbr);\n    }",
        "fixed_function": "    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Float.floatToIntBits(x);\n        result = prime * result + Float.floatToIntBits(y);\n        return result;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 60,
        "end_loc": 67,
        "buggy_function": "    @Override\n    public boolean equals(Object obj) {\n        Optional<Point> other = ObjectsHelper.asClass(obj, Point.class);\n        if (other.isPresent()) {\n            return Objects.equal(mbr, other.get().mbr());\n        } else\n            return false;\n    }",
        "fixed_function": "    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Point other = (Point) obj;\n        if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))\n            return false;\n        if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))\n            return false;\n        return true;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/Point.java",
        "start_loc": 69,
        "end_loc": 72,
        "buggy_function": "    @Override\n    public String toString() {\n        return \"Point [x=\" + x() + \", y=\" + y() + \"]\";\n    }",
        "fixed_function": "    @Override\n    public Geometry geometry() {\n        return this;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 20,
        "end_loc": 22,
        "buggy_function": "    static RectangleImpl create(double x1, double y1, double x2, double y2) {\n        return new RectangleImpl((float) x1, (float) y1, (float) x2, (float) y2);\n    }",
        "fixed_function": "    static Rectangle create(double x1, double y1, double x2, double y2) {\n        return new RectangleImpl((float) x1, (float) y1, (float) x2, (float) y2);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 24,
        "end_loc": 26,
        "buggy_function": "    static RectangleImpl create(float x1, float y1, float x2, float y2) {\n        return new RectangleImpl(x1, y1, x2, y2);\n    }",
        "fixed_function": "    static Rectangle create(float x1, float y1, float x2, float y2) {\n        return new RectangleImpl(x1, y1, x2, y2);\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 85,
        "end_loc": 89,
        "buggy_function": "    @Override\n    public RectangleImpl add(Rectangle r) {\n        return new RectangleImpl(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }",
        "fixed_function": "    @Override\n    public Rectangle add(Rectangle r) {\n        return new RectangleImpl(min(x1, r.x1()), min(y1, r.y1()), max(x2, r.x2()),\n                max(y2, r.y2()));\n    }",
        "comment": "/*\n     * (non-Javadoc)\n     * \n     * @see\n     * com.github.davidmoten.rtree.geometry.RectangleI#add(com.github.davidmoten\n     * .rtree.geometry.Rectangle)\n     */"
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 102,
        "end_loc": 106,
        "buggy_function": "    @Override\n    public boolean intersects(Rectangle r) {\n        return r.x2() >= x1 && r.x1() <= x2 && r.y2() >= y1 && r.y1() <= y2;\n        // return r.x2() >= x1 && r.x1() <= x2 && r.y2() >= y1 && r.y1() <= y2;\n    }",
        "fixed_function": "    @Override\n    public boolean intersects(Rectangle r) {\n        return intersects(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        // return r.x2() >= x1 && r.x1() <= x2 && r.y2() >= y1 && r.y1() <= y2;\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 108,
        "end_loc": 145,
        "buggy_function": "    @Override\n    public double distance(Rectangle r) {\n        if (intersects(r))\n        // if (intersects(r))\n        // return 0;\n        // else {\n        // Rectangle mostLeft = x1 < r.x1() ? this : r;\n        // Rectangle mostRight = x1 > r.x1() ? this : r;\n        // double xDifference = max(0,\n        // mostLeft.x1() == mostRight.x1() ? 0 : mostRight.x1() -\n        // mostLeft.x2());\n        //\n        // Rectangle upper = y1 < r.y1() ? this : r;\n        // Rectangle lower = y1 > r.y1() ? this : r;\n        //\n        // double yDifference = max(0, upper.y1() == lower.y1() ? 0 : lower.y1()\n        // - upper.y2());\n        //\n        // return Math.sqrt(xDifference * xDifference + yDifference *\n        // yDifference);\n        // }\n\n            return 0;\n        else {\n            Rectangle mostLeft = x1 < r.x1() ? this : r;\n            Rectangle mostRight = x1 > r.x1() ? this : r;\n            double xDifference = max(0,\n                    mostLeft.x1() == mostRight.x1() ? 0 : mostRight.x1() - mostLeft.x2());\n\n            Rectangle upper = y1 < r.y1() ? this : r;\n            Rectangle lower = y1 > r.y1() ? this : r;\n\n            double yDifference = max(0, upper.y1() == lower.y1() ? 0 : lower.y1() - upper.y2());\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }\n\n    }",
        "fixed_function": "    @Override\n    public double distance(Rectangle r) {\n        return distance(x1, y1, x2, y2, r.x1(), r.y1(), r.x2(), r.y2());\n        // if (intersects(r))\n        // return 0;\n        // else {\n        // Rectangle mostLeft = x1 < r.x1() ? this : r;\n        // Rectangle mostRight = x1 > r.x1() ? this : r;\n        // double xDifference = max(0,\n        // mostLeft.x1() == mostRight.x1() ? 0 : mostRight.x1() -\n        // mostLeft.x2());\n        //\n        // Rectangle upper = y1 < r.y1() ? this : r;\n        // Rectangle lower = y1 > r.y1() ? this : r;\n        //\n        // double yDifference = max(0, upper.y1() == lower.y1() ? 0 : lower.y1()\n        // - upper.y2());\n        //\n        // return Math.sqrt(xDifference * xDifference + yDifference *\n        // yDifference);\n        // }\n    }",
        "comment": ""
      },
      {
        "path": "src/main/java/com/github/davidmoten/rtree/geometry/RectangleImpl.java",
        "start_loc": 147,
        "end_loc": 150,
        "buggy_function": "    @Override\n    public RectangleImpl mbr() {\n        return this;\n    }",
        "fixed_function": "    public static double distance(float x1, float y1, float x2, float y2, float a1, float b1,\n            float a2, float b2) {\n        if (intersects(x1, y1, x2, y2, a1, b1, a2, b2)) {\n            return 0;\n        }\n        boolean xyMostLeft = x1 < a1;\n        float mostLeftX1 = xyMostLeft ? x1 : a1;\n        float mostRightX1 = xyMostLeft ? a1 : x1;\n        float mostLeftX2 = xyMostLeft ? x2 : a2;\n        double xDifference = max(0, mostLeftX1 == mostRightX1 ? 0 : mostRightX1 - mostLeftX2);\n\n        boolean xyMostDown = y1 < b1;\n        float mostDownY1 = xyMostDown ? y1 : b1;\n        float mostUpY1 = xyMostDown ? b1 : y1;\n        float mostDownY2 = xyMostDown ? y2 : b2;\n\n        double yDifference = max(0, mostDownY1 == mostUpY1 ? 0 : mostUpY1 - mostDownY2);\n\n        return Math.sqrt(xDifference * xDifference + yDifference * yDifference);\n    }",
        "comment": ""
      }
    ],
    "trigger_test": {
      "com.github.davidmoten.rtree.geometry.PointTest::testHashCode": {
        "path": "com/github/davidmoten/rtree/geometry/PointTest.java",
        "function_name": "testHashCode",
        "src": "@Test\n    public void testHashCode() {\n        Point p = Geometries.point(1, 2);\n        assertEquals(-260045887, p.hashCode());\n    }",
        "error_msg": "com.github.davidmoten.rtree.geometry.PointTest::testHashCode --> junit.framework.AssertionFailedError: expected:<-260045887> but was:<-1056041056>",
        "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-260045887> but was:<-1056041056>"
      }
    }
  }
}